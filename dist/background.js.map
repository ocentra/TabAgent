{"version":3,"file":"background.js","sources":["../src/background.js"],"sourcesContent":["const OFFSCREEN_DOCUMENT_PATH = 'offscreen.html';\n\n\nlet detachedPopups = {};\nlet popupIdToTabId = {};\n\nconst DNR_RULE_ID_1 = 1;\nconst DNR_RULE_PRIORITY_1 = 1;\n\nasync function updateDeclarativeNetRequestRules() {\n    const currentRules = await chrome.declarativeNetRequest.getDynamicRules();\n    const currentRuleIds = currentRules.map(rule => rule.id);\n\n    const rulesToAdd = [\n        {\n            id: DNR_RULE_ID_1,\n            priority: DNR_RULE_PRIORITY_1,\n            action: {\n                type: 'modifyHeaders',\n                responseHeaders: [\n                    { header: 'x-frame-options', operation: 'remove' },\n                    { header: 'X-Frame-Options', operation: 'remove' },\n                    { header: 'content-security-policy', operation: 'remove' },\n                    { header: 'Content-Security-Policy', operation: 'remove' }\n                ]\n            },\n            condition: {\n                resourceTypes: ['main_frame'],\n                urlFilter: '|http*://*/*|'\n            }\n        }\n    ];\n\n    const rulesToRemove = currentRuleIds.filter(id => id === DNR_RULE_ID_1);\n\n    try {\n        await chrome.declarativeNetRequest.updateDynamicRules({\n            removeRuleIds: rulesToRemove,\n            addRules: rulesToAdd\n        });\n        console.log(\"Declarative Net Request rules updated successfully.\");\n    } catch (error) {\n        console.error(\"Error updating Declarative Net Request rules:\", error);\n    }\n}\n\nupdateDeclarativeNetRequestRules();\n\nasync function hasOffscreenDocument(path) {\n    const filename = path.split('/').pop();\n    const targetUrl = chrome.runtime.getURL(filename);\n    console.log(`[Debug] hasOffscreenDocument: Checking for URL: ${targetUrl}`);\n    const existingContexts = await chrome.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    console.log(`[Debug] hasOffscreenDocument: Found ${existingContexts.length} matching contexts.`);\n    return existingContexts.length > 0;\n}\n\nasync function setupOffscreenDocument(path, reasons, justification) {\n    if (await hasOffscreenDocument(path)) {\n        console.log(`Background: Offscreen document at ${path} already exists.`);\n        return;\n    }\n    const filename = path.split('/').pop();\n    console.log(`Background: Creating offscreen document using filename: ${filename}...`);\n    await chrome.offscreen.createDocument({\n        url: filename,\n        reasons: reasons,\n        justification: justification,\n    });\n    console.log(`Background: Offscreen document created successfully using ${filename}.`);\n}\n\nasync function scrapeUrlWithOffscreenIframe(url) {\n    console.log(`[Stage 2] Attempting Offscreen + iframe: ${url}`);\n    const DYNAMIC_SCRIPT_ID_PREFIX = 'offscreen-scrape-';\n    const DYNAMIC_SCRIPT_MESSAGE_TYPE = 'offscreenIframeResult';\n    const IFRAME_LOAD_TIMEOUT = 30000;\n    let dynamicScripterId = null;\n\n    const cleanup = async (scriptIdBase) => {\n        console.log(`[Stage 2 Cleanup] Starting cleanup for script ID base: ${scriptIdBase}`);\n        if (scriptIdBase) {\n             try {\n                 await chrome.scripting.unregisterContentScripts({ ids: [scriptIdBase] });\n                 console.log(`[Stage 2 Cleanup] Unregistered script: ${scriptIdBase}`);\n             } catch (error) {\n                 console.warn(`[Stage 2 Cleanup] Failed to unregister script ${scriptIdBase}:`, error);\n             }\n        }\n        try {\n            await chrome.runtime.sendMessage({ type: 'removeIframe', target: 'offscreen' });\n            console.log('[Stage 2 Cleanup] Sent removeIframe request to offscreen.');\n        } catch (error) {\n            console.warn('[Stage 2 Cleanup] Failed to send removeIframe request: ', error);\n        }\n    };\n\n    try {\n        await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH, ['DOM_PARSER', 'IFRAME_SCRIPTING'], 'Parse HTML content and manage scraping iframes');\n        console.log('[Stage 2] Sending createIframe request to offscreen...');\n        const createResponse = await chrome.runtime.sendMessage({\n            type: 'createIframe',\n            target: 'offscreen',\n            url: url\n        });\n        if (!createResponse?.success) {\n            throw new Error(`Failed to create iframe in offscreen: ${createResponse?.error || 'Unknown error'}`);\n        }\n        console.log('[Stage 2] Iframe creation request successful. Waiting for load and script...');\n        dynamicScripterId = `${DYNAMIC_SCRIPT_ID_PREFIX}${Date.now()}`;\n        await chrome.scripting.registerContentScripts([{\n            id: dynamicScripterId,\n            js: ['PageExtractor.js', 'stage2-helper.js'],\n            matches: [url],\n            runAt: 'document_idle',\n            world: 'ISOLATED',\n            allFrames: true,\n            persistAcrossSessions: false\n        }]);\n        console.log(`[Stage 2] Registered dynamic script(s): ${dynamicScripterId} (files: PageExtractor.js, stage2-helper.js)`);\n        let messageListener = null;\n        const scriptResponsePromise = new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                console.warn(`[Stage 2] Timeout (${IFRAME_LOAD_TIMEOUT / 1000}s) waiting for response from dynamic script.`);\n                if (messageListener) {\n                    chrome.runtime.onMessage.removeListener(messageListener);\n                }\n                reject(new Error('Timeout waiting for dynamic script response.'));\n            }, IFRAME_LOAD_TIMEOUT);\n\n            messageListener = (message, sender, sendResponse) => {\n                if (message?.type === DYNAMIC_SCRIPT_MESSAGE_TYPE) {\n                    console.log('[Stage 2] Received response from dynamic script:', message.payload);\n                    clearTimeout(timeoutId);\n                    chrome.runtime.onMessage.removeListener(messageListener);\n                    if (message.payload?.success) {\n                        resolve(message.payload);\n                    } else {\n                        reject(new Error(message.payload?.error || 'Dynamic script reported failure.'));\n                    }\n                    return false;\n                }\n                return false;\n            };\n            chrome.runtime.onMessage.addListener(messageListener);\n            console.log('[Stage 2] Listener added for dynamic script response.');\n        });\n        const resultPayload = await scriptResponsePromise;\n        await cleanup(dynamicScripterId);\n        return resultPayload;\n    } catch (error) {\n        console.error(`[Stage 2] Error during Offscreen + iframe process:`, error);\n        await cleanup(dynamicScripterId);\n        throw new Error(`Stage 2 (Offscreen + iframe) failed: ${error.message}`);\n    }\n}\n\nasync function scrapeUrlWithTempTabExecuteScript(url) {\n    console.log(`[Stage 3] Attempting Temp Tab + executeScript (using window.scraper.extract): ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            console.warn(`[Stage 3] Cleanup: ${errorMsg}`);\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 3] Error removing tab ${tempTabId}: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n            const tab = await chrome.tabs.create({ url: url, active: false });\n            tempTabId = tab.id;\n            if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n            console.log(`[Stage 3] Created temp tab ${tempTabId} for executeScript.`);\n        } catch (error) {\n            return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    console.log(`[Stage 3] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    chrome.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            chrome.tabs.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                chrome.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load.`));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch (error) {\n            return cleanupAndReject(`Load failed or timed out: ${error.message}`);\n        }\n        console.log(`[Stage 3] Injecting PageExtractor.js and calling window.scraper.extract() in tab ${tempTabId}`);\n        try {\n            await chrome.scripting.executeScript({\n                target: { tabId: tempTabId },\n                files: ['PageExtractor.js']\n            });\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tempTabId },\n                func: () => window.scraper.extract(),\n            });\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 3] Error removing tab ${tempTabId} post-execute: ${err.message}`));\n                tempTabId = null;\n            }\n            if (results && results.length > 0 && results[0].result) {\n                const scriptResult = results[0].result;\n                if (scriptResult && typeof scriptResult === 'object') {\n                    console.log('[Stage 3] window.scraper.extract() succeeded.');\n                    resolve(scriptResult);\n                } else {\n                    reject(new Error(scriptResult?.error || 'window.scraper.extract() failed or returned null.'));\n                }\n            } else {\n                 const lastError = chrome.runtime.lastError ? chrome.runtime.lastError.message : 'No result returned';\n                 reject(new Error(`executeScript failed: ${lastError}`));\n            }\n        } catch (error) {\n            cleanupAndReject(`executeScript call failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlWithTempTab_ContentScript(url) {\n    console.log(`[Stage 4] Attempting Temp Tab + Content Script: ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 4] Error removing tab ${tempTabId} during cleanup: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n             const tab = await chrome.tabs.create({ url: url, active: false });\n             tempTabId = tab.id;\n             if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n             console.log(`[Stage 4] Created temp tab ${tempTabId}`);\n        } catch(error) {\n             return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    console.log(`[Stage 4] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    chrome.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            chrome.tabs.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                chrome.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error('Timeout waiting for page load.'));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch(error) {\n            return cleanupAndReject(error.message);\n        }\n        console.log(`[Stage 4] Sending SCRAPE_PAGE to content script in tab ${tempTabId}`);\n        try {\n            const response = await chrome.tabs.sendMessage(tempTabId, { type: 'SCRAPE_PAGE' });\n            if (tempTabId) chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 4] Error removing tab ${tempTabId} post-message: ${err.message}`));\n            tempTabId = null;\n            if (response?.success) {\n                console.log(`[Stage 4] Success from content script.`);\n                resolve(response);\n            } else {\n                reject(new Error(response?.error || 'Content script failed or gave invalid response.'));\n            }\n        } catch (error) {\n             cleanupAndReject(`Messaging content script failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlMultiStage(url, chatId, messageId) {\n    console.log(`Scraping Orchestrator: Starting for ${url}. ChatID: ${chatId}, MessageID: ${messageId}`);\n    const sendStageResult = (stageResult) => {\n        console.log(`[Orchestrator] Sending STAGE_SCRAPE_RESULT for Stage ${stageResult.stage}, ChatID: ${chatId}, Success: ${stageResult.success}`);\n        chrome.runtime.sendMessage({\n            type: 'STAGE_SCRAPE_RESULT',\n            payload: stageResult\n        }).catch(e => console.warn(`[Orchestrator] Failed to send result for Stage ${stageResult.stage}:`, e));\n    };\n\n    // --- Outer try block to ensure finally always runs --- \n    try { \n        try {\n            const iframeResult = await scrapeUrlWithOffscreenIframe(url);\n            console.log(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Succeeded for ${url}.`);\n            const stage2SuccessPayload = {\n                stage: 2, success: true, chatId: chatId, messageId: messageId,\n                method: 'offscreenIframe', url: url,\n                length: iframeResult?.text?.length || 0,\n                ...iframeResult\n            };\n            sendStageResult(stage2SuccessPayload);\n            return; // <<< Return early on success\n        } catch (stage2Error) {\n            console.warn(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Failed for ${url}: ${stage2Error.message}`);\n            sendStageResult({ stage: 2, success: false, chatId: chatId, messageId: messageId, error: stage2Error.message });\n        }\n\n        // --- If Stage 2 failed, try Stage 3 --- \n        try {\n             const executeScriptResult = await scrapeUrlWithTempTabExecuteScript(url);\n             console.log(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Succeeded for ${url}.`);\n             const stage3SuccessPayload = {\n                stage: 3, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabExecuteScript', url: url,\n                length: executeScriptResult?.text?.length || 0,\n                ...executeScriptResult\n             };\n             sendStageResult(stage3SuccessPayload);\n             return; // <<< Return early on success\n        } catch (stage3Error) {\n             console.warn(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Failed for ${url}: ${stage3Error.message}`);\n             sendStageResult({ stage: 3, success: false, chatId: chatId, messageId: messageId, error: stage3Error.message });\n        }\n\n        // --- If Stage 3 failed, try Stage 4 --- \n        try {\n            const tempTabResult = await scrapeUrlWithTempTab_ContentScript(url);\n            console.log(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Succeeded for ${url}.`);\n            const stage4SuccessPayload = {\n                stage: 4, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabContentScript', url: url,\n                length: tempTabResult?.text?.length || 0,\n                ...tempTabResult\n            };\n            console.log(\"[Orchestrator Log] Stage 4 Payload being sent:\", stage4SuccessPayload);\n            sendStageResult(stage4SuccessPayload);\n            return; // <<< Return early on success\n        } catch (stage4Error) {\n             console.warn(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Failed for ${url}: ${stage4Error.message}`);\n             sendStageResult({ stage: 4, success: false, chatId: chatId, messageId: messageId, error: stage4Error.message });\n        }\n\n        // --- If we reach here, all stages failed --- \n        console.log(\"[Orchestrator Log] All stages failed.\");\n\n    // --- ADDED Finally block for cleanup --- \n    } finally { \n        console.log(\"[Orchestrator Cleanup] Attempting to close offscreen document after multi-stage scrape.\");\n        try {\n            if (await hasOffscreenDocument(OFFSCREEN_DOCUMENT_PATH)) {\n                await chrome.offscreen.closeDocument();\n                console.log(\"[Orchestrator Cleanup] Offscreen document closed successfully.\");\n            } else {\n                 console.log(\"[Orchestrator Cleanup] No offscreen document found to close.\");\n            }\n        } catch (error) {\n            console.warn(\"[Orchestrator Cleanup] Error closing offscreen document:\", error);\n        }\n    }\n    // --- END Finally block ---\n}\n\nchrome.runtime.onInstalled.addListener(() => {\n    chrome.sidePanel\n        .setPanelBehavior({ openPanelOnActionClick: true })\n        .catch((error) => console.error('Error setting side panel behavior:', error));\n    console.log(\"Tab Agent background: Side panel behavior set (default open on click).\");\n    chrome.storage.local.get(null, (items) => {\n        const keysToRemove = Object.keys(items).filter(key => key.startsWith('detachedState_'));\n        if (keysToRemove.length > 0) {\n            chrome.storage.local.remove(keysToRemove, () => {\n                console.log(\"Cleaned up old detached states on install/update.\");\n            });\n        }\n    });\n});\n\nchrome.action.onClicked.addListener(async (tab) => {\n    if (!tab.id) {\n        console.error(\"Action Clicked: Missing tab ID.\");\n        return;\n    }\n    const tabId = tab.id;\n    console.log(`Action clicked for tab ${tabId}`);\n    const existingPopupId = detachedPopups[tabId];\n    if (existingPopupId) {\n        console.log(`Popup ${existingPopupId} exists for tab ${tabId}. Attempting to close popup.`);\n        try {\n            await chrome.windows.remove(existingPopupId);\n            console.log(`Closed popup window ${existingPopupId} via action click.`);\n        } catch (error) {\n            console.warn(`Failed to close popup ${existingPopupId} via action click, maybe already closed?`, error);\n            if (popupIdToTabId[existingPopupId]) {\n                 console.log(`Force cleaning maps and storage for tab ${tabId} after failed close.`);\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[existingPopupId];\n                try {\n                     await chrome.storage.local.remove(`detachedState_${tabId}`);\n                     await chrome.sidePanel.setOptions({ tabId: tabId, enabled: true });\n                } catch (cleanupError) {\n                     console.error(\"Error during defensive cleanup:\", cleanupError);\n                }\n            }\n        }\n    } else {\n        console.log(`No popup exists for tab ${tabId}. Default side panel opening behavior should trigger.`);\n    }\n});\n\nchrome.windows.onRemoved.addListener(async (windowId) => {\n    console.log(`Window removed: ${windowId}`);\n    const tabId = popupIdToTabId[windowId];\n    if (tabId) {\n        console.log(`Popup window ${windowId} for tab ${tabId} was closed.`);\n        delete detachedPopups[tabId];\n        delete popupIdToTabId[windowId];\n        try {\n            await chrome.storage.local.remove(`detachedState_${tabId}`);\n            console.log(`Removed detached state from storage for tab ${tabId}`);\n            await chrome.sidePanel.setOptions({ tabId: tabId, enabled: true });\n            console.log(`Re-enabled side panel for tab ${tabId} after popup closed.`);\n        } catch (error) {\n             console.error(`Error cleaning up storage or re-enabling side panel for tab ${tabId} on popup close:`, error);\n        }\n    } else {\n         console.log(`Window ${windowId} closed, but it wasn't a tracked popup.`);\n    }\n});\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log(\"Background: Received message:\", message, \"from sender:\", sender);\n    if (message.type === 'query') {\n        const { text, model, tabId, chatId, messageId } = message;\n        if (!chatId || !messageId) {\n            console.error(\"Background: Received query without chatId or messageId.\", message);\n            if (messageId) {\n                chrome.runtime.sendMessage({\n                    type: 'error',\n                    chatId: chatId || 'unknown',\n                    messageId: messageId,\n                    error: \"Missing chat/message ID in query request\"\n                }).catch(e => console.warn(\"BG: Error sending missing ID error back:\", e));\n            }\n            sendResponse({ success: false, error: \"Missing chat/message ID in query\" });\n            return false;\n        }\n        console.log(`Background: Processing query \"${text}\" for model \"${model}\". ChatID: ${chatId}, MessageID: ${messageId}`);\n        const isUrl = text && (text.startsWith('http://') || text.startsWith('https://'));\n        if (isUrl) {\n            console.log(`Background: Query is a URL, initiating scrape for ${text}`);\n             (async () => {\n                 await scrapeUrlMultiStage(text, chatId, messageId);\n             })();\n             sendResponse({ success: true, message: \"URL query received, initiating scrape...\" });\n             return false;\n        } else {\n            console.log(`Background: Query is not a URL, using placeholder logic for \"${text}\"`);\n            const placeholderResponse = `(Tab ${tabId || 'N/A'}) Background received non-URL: \"${text}\". Agent logic for ${model} not implemented.`;\n            \n            try {\n                console.log(`Background: Sending immediate response for ${messageId}.`);\n                chrome.runtime.sendMessage({ \n                    type: 'response',\n                    chatId: chatId,\n                    messageId: messageId,\n                    text: placeholderResponse\n                }).catch(e => console.warn(`BG: Could not send response for ${messageId}, context likely closed.`, e));\n                console.log(`Background: Sent placeholder response for ${messageId}.`);\n            } catch (error) {\n                console.warn(`Background: Error sending placeholder response for ${messageId}`, error);\n                 chrome.runtime.sendMessage({ \n                     type: 'error',\n                     chatId: chatId,\n                     messageId: messageId,\n                     error: `Failed to send response: ${error.message}`\n                 }).catch(e => console.warn(`BG: Could not send error message for ${messageId} after initial failure.`, e));\n            }\n            \n            sendResponse({ success: true, message: \"Non-URL query received, processing...\" });\n            return true;\n        }\n    } else if (message.type === 'getTabId') {\n        if (sender.tab && sender.tab.id) {\n            try {\n                sendResponse({ type: 'tabIdResponse', tabId: sender.tab.id });\n            } catch(e) { console.warn(\"BG: Could not send tabId response\"); }\n            return false;\n        } else {\n            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n                if (tabs && tabs.length > 0) {\n                    try {\n                        sendResponse({ type: 'tabIdResponse', tabId: tabs[0].id });\n                    } catch(e) { console.warn(\"BG: Could not send tabId response (fallback)\"); }\n                } else {\n                    console.warn(\"Background: 'getTabId' fallback could not find active tab.\");\n                    try {\n                        sendResponse({ type: 'error', error: 'Could not determine sender tab ID (no active tab).' });\n                    } catch(e) { console.warn(\"BG: Could not send tabId error response (fallback)\"); }\n                }\n            });\n            return true;\n        }\n    } else if (message.type === 'popupCreated') {\n         if (message.popupId && message.tabId) {\n             detachedPopups[message.tabId] = message.popupId;\n             popupIdToTabId[message.popupId] = message.tabId;\n             console.log(`Background: Tracked popup ${message.popupId} for tab ${message.tabId}`);\n         } else {\n             console.error(\"Background: Invalid 'popupCreated' message:\", message);\n         }\n         return false;\n    } else if (message.type === 'getPopupForTab') {\n        const popupId = detachedPopups[message.tabId];\n        if (popupId) {\n            sendResponse({ popupId });\n        } else {\n            sendResponse({ popupId: null });\n        }\n        return false;\n    } else if (message.type === 'TEMP_SCRAPE_URL') {\n        const urlToScrape = message.url;\n        const { chatId, messageId } = message;\n        const requesterTabId = message.tabId || (sender.tab ? sender.tab.id : null);\n        if (!chatId || !messageId) {\n             console.error(\"Background: Received TEMP_SCRAPE_URL without chatId or messageId.\", message);\n             return false;\n        }\n        console.log(`Background: Received TEMP_SCRAPE_URL for: ${urlToScrape}. ChatID: ${chatId}, MessageID: ${messageId}. Starting multi-stage scrape.`);\n        (async () => {\n            await scrapeUrlMultiStage(urlToScrape, chatId, messageId);\n        })();\n        sendResponse({ success: true, message: \"Scrape request received.\" });\n        return false;\n    } else if (message.type === 'getDriveFileList') {\n        const folderId = message.folderId || 'root';\n        console.log(`Background: Received getDriveFileList for folder: ${folderId}`);\n        (async () => {\n            let files = null;\n            let errorMsg = null;\n            try {\n                const token = await getDriveToken();\n                files = await fetchDriveFileList(token, folderId);\n            } catch (error) {\n                console.error(`Background: Error handling getDriveFileList (Folder: ${folderId}):`, error);\n                errorMsg = error.message || \"Unknown error fetching file list.\";\n            }\n            chrome.runtime.sendMessage({\n                type: 'driveFileListResponse',\n                success: !errorMsg,\n                folderId: folderId,\n                files: files,\n                error: errorMsg\n            }).catch(e => console.warn(\"Background: Failed to send driveFileListResponse\", e));\n        })();\n        sendResponse({ success: true, message: \"Request received, fetching file list...\"});\n        return true;\n    } else if (message.type === 'fetchDriveFileContent') {\n        const { fileId, fileName } = message;\n        console.log(`Background: Received fetchDriveFileContent for ID: ${fileId}`);\n        if (!fileId) {\n             console.error(\"Background: fetchDriveFileContent missing fileId\");\n             return false;\n        }\n        (async () => {\n             let content = null;\n             let errorMsg = null;\n             try {\n                 const token = await getDriveToken();\n                 content = await fetchDriveFileContent(token, fileId);\n             } catch (error) {\n                 console.error(`Background: Error handling fetchDriveFileContent for ${fileId}:`, error);\n                 errorMsg = error.message || \"Unknown error fetching file content.\";\n             }\n             chrome.runtime.sendMessage({\n                 type: 'driveFileContentResponse',\n                 success: !errorMsg,\n                 fileId: fileId,\n                 fileName: fileName,\n                 content: content,\n                 error: errorMsg\n             }).catch(e => console.warn(\"Background: Failed to send driveFileContentResponse\", e));\n        })();\n         sendResponse({ success: true, message: \"Request received, fetching file content...\"});\n         return true;\n    } else if (message.target === 'offscreen' && (message.type === 'parseHTML' || message.type === 'createIframe' || message.type === 'removeIframe')){\n        console.log(`Background: Forwarding ${message.type} message to parsing offscreen document.`);\n         (async () => {\n            const parsingPath = OFFSCREEN_DOCUMENT_PATH;\n            try {\n                 await setupOffscreenDocument(\n                     parsingPath,\n                     ['DOM_PARSER', 'IFRAME_SCRIPTING'],\n                     'Parse HTML content and manage scraping iframes'\n                 );\n                 const response = await chrome.runtime.sendMessage(message);\n                 console.log(`Background: Received response from parsing offscreen for ${message.type}:`, response);\n             } catch (error) {\n                 console.error(`Background: Error ensuring/communicating with parsing offscreen document for ${message.type}:`, error);\n             }\n         })();\n         return false;\n    } else if (message.target === 'offscreen_google_drive') {\n        console.warn(\"Background: Received message explicitly targeted to 'offscreen_google_drive' outside of picker initiation flow. Ignoring.\");\n        return false;\n    } else {\n        console.log(\"Background: Received unknown message type:\", message.type);\n        try {\n            sendResponse({ type: 'error', error: 'Unknown message type received by background script.' });\n        } catch (e) {\n            console.warn(\"Background: Could not send error response for unknown message type.\");\n        }\n        return false;\n    }\n});\n\nconsole.log(\"Tab Agent background script loaded and listening for messages.\");\n\nasync function getDriveToken() {\n    return new Promise((resolve, reject) => {\n        chrome.identity.getAuthToken({ interactive: true }, (token) => {\n            if (chrome.runtime.lastError) {\n                reject(new Error(chrome.runtime.lastError.message));\n            } else {\n                resolve(token);\n            }\n        });\n    });\n}\n\nasync function fetchDriveFileList(token, folderId = 'root') {\n    const fields = \"files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)\";\n    const query = `'${folderId}' in parents and trashed=false`;\n    const pageSize = 100;\n    const orderBy = 'folder,modifiedTime desc';\n    const url = `https://www.googleapis.com/drive/v3/files?${new URLSearchParams({\n        pageSize: pageSize.toString(),\n        q: query,\n        fields: fields,\n        orderBy: orderBy\n    })}`;\n    console.log(`Background: Fetching Drive list for folder '${folderId}': ${url}`);\n    const response = await fetch(url, {\n        headers: {\n            'Authorization': `Bearer ${token}`,\n            'Accept': 'application/json'\n        }\n    });\n    if (!response.ok) {\n        const errorData = await response.text();\n        console.error(`Background: Drive API files.list error (Folder: ${folderId}):`, response.status, errorData);\n        if (response.status === 404) {\n            throw new Error(`Folder with ID '${folderId}' not found or access denied.`);\n        }\n        throw new Error(`Drive API Error ${response.status} (Folder: ${folderId}): ${errorData || response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`Background: Drive API files.list success (Folder: ${folderId}). Found ${data.files?.length || 0} items.`);\n    return data.files || [];\n}\n\nasync function fetchDriveFileContent(token, fileId) {\n    console.warn(`Background: fetchDriveFileContent not implemented yet for fileId: ${fileId}`);\n    return `(Content fetch not implemented for ${fileId})`;\n}"],"names":["OFFSCREEN_DOCUMENT_PATH","detachedPopups","popupIdToTabId","updateDeclarativeNetRequestRules","currentRuleIds","rule","rulesToAdd","rulesToRemove","id","error","hasOffscreenDocument","path","filename","targetUrl","existingContexts","setupOffscreenDocument","reasons","justification","scrapeUrlWithOffscreenIframe","url","DYNAMIC_SCRIPT_ID_PREFIX","DYNAMIC_SCRIPT_MESSAGE_TYPE","IFRAME_LOAD_TIMEOUT","dynamicScripterId","cleanup","scriptIdBase","createResponse","messageListener","resultPayload","resolve","reject","timeoutId","message","sender","sendResponse","_a","_b","scrapeUrlWithTempTabExecuteScript","tempTabId","TEMP_TAB_LOAD_TIMEOUT","cleanupAndReject","errorMsg","err","loadTimeoutId","loadPromise","resolveLoad","rejectLoad","listener","tabId","changeInfo","updatedTab","results","scriptResult","lastError","scrapeUrlWithTempTab_ContentScript","response","scrapeUrlMultiStage","chatId","messageId","_c","sendStageResult","stageResult","e","iframeResult","stage2SuccessPayload","stage2Error","executeScriptResult","stage3SuccessPayload","stage3Error","tempTabResult","stage4SuccessPayload","stage4Error","items","keysToRemove","key","tab","existingPopupId","cleanupError","windowId","text","model","placeholderResponse","tabs","popupId","urlToScrape","folderId","files","token","getDriveToken","fetchDriveFileList","fileId","fileName","content","fetchDriveFileContent","parsingPath","fields","query","pageSize","orderBy","errorData","data"],"mappings":"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"}