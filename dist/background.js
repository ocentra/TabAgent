const $="src/offscreen.html";let p={},m={};async function S(){const e=(await chrome.declarativeNetRequest.getDynamicRules()).map(c=>c.id),n=[{id:1,priority:1,action:{type:"modifyHeaders",responseHeaders:[{header:"x-frame-options",operation:"remove"},{header:"X-Frame-Options",operation:"remove"},{header:"content-security-policy",operation:"remove"},{header:"Content-Security-Policy",operation:"remove"}]},condition:{resourceTypes:["main_frame"],urlFilter:"|http*://*/*|"}}],o=e.filter(c=>c===1);try{await chrome.declarativeNetRequest.updateDynamicRules({removeRuleIds:o,addRules:n}),console.log("Declarative Net Request rules updated successfully.")}catch(c){console.error("Error updating Declarative Net Request rules:",c)}}S();async function v(r){const e=r.split("/").pop(),n=chrome.runtime.getURL(e);console.log(`[Debug] hasOffscreenDocument: Checking for URL: ${n}`);const o=await chrome.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[n]});return console.log(`[Debug] hasOffscreenDocument: Found ${o.length} matching contexts.`),o.length>0}async function I(r,e,n){if(await v(r)){console.log(`Background: Offscreen document at ${r} already exists.`);return}const o=r.split("/").pop();console.log(`Background: Creating offscreen document using filename: ${o}...`),await chrome.offscreen.createDocument({url:o,reasons:e,justification:n}),console.log(`Background: Offscreen document created successfully using ${o}.`)}async function E(r){console.log(`[Stage 2] Attempting Offscreen + iframe: ${r}`);const e="offscreen-scrape-",n="offscreenIframeResult",o=3e4;let c=null;const l=async s=>{if(console.log(`[Stage 2 Cleanup] Starting cleanup for script ID base: ${s}`),s)try{await chrome.scripting.unregisterContentScripts({ids:[s]}),console.log(`[Stage 2 Cleanup] Unregistered script: ${s}`)}catch(t){console.warn(`[Stage 2 Cleanup] Failed to unregister script ${s}:`,t)}try{await chrome.runtime.sendMessage({type:"removeIframe",target:"offscreen"}),console.log("[Stage 2 Cleanup] Sent removeIframe request to offscreen.")}catch(t){console.warn("[Stage 2 Cleanup] Failed to send removeIframe request: ",t)}};try{await I($,["DOM_PARSER","IFRAME_SCRIPTING"],"Parse HTML content and manage scraping iframes"),console.log("[Stage 2] Sending createIframe request to offscreen...");const s=await chrome.runtime.sendMessage({type:"createIframe",target:"offscreen",url:r});if(!(s!=null&&s.success))throw new Error(`Failed to create iframe in offscreen: ${(s==null?void 0:s.error)||"Unknown error"}`);console.log("[Stage 2] Iframe creation request successful. Waiting for load and script..."),c=`${e}${Date.now()}`,await chrome.scripting.registerContentScripts([{id:c,js:["PageExtractor.js","stage2-helper.js"],matches:[r],runAt:"document_idle",world:"ISOLATED",allFrames:!0,persistAcrossSessions:!1}]),console.log(`[Stage 2] Registered dynamic script(s): ${c} (files: PageExtractor.js, stage2-helper.js)`);let t=null;const i=await new Promise((d,g)=>{const f=setTimeout(()=>{console.warn(`[Stage 2] Timeout (${o/1e3}s) waiting for response from dynamic script.`),t&&chrome.runtime.onMessage.removeListener(t),g(new Error("Timeout waiting for dynamic script response."))},o);t=(u,C,P)=>{var h,w;return(u==null?void 0:u.type)===n&&(console.log("[Stage 2] Received response from dynamic script:",u.payload),clearTimeout(f),chrome.runtime.onMessage.removeListener(t),(h=u.payload)!=null&&h.success?d(u.payload):g(new Error(((w=u.payload)==null?void 0:w.error)||"Dynamic script reported failure."))),!1},chrome.runtime.onMessage.addListener(t),console.log("[Stage 2] Listener added for dynamic script response.")});return await l(c),i}catch(s){throw console.error("[Stage 2] Error during Offscreen + iframe process:",s),await l(c),new Error(`Stage 2 (Offscreen + iframe) failed: ${s.message}`)}}async function T(r){console.log(`[Stage 3] Attempting Temp Tab + executeScript (using window.scraper.extract): ${r}`);let e=null;const n=3e4;return new Promise(async(o,c)=>{const l=a=>{console.warn(`[Stage 3] Cleanup: ${a}`),e&&(chrome.tabs.remove(e).catch(i=>console.warn(`[Stage 3] Error removing tab ${e}: ${i.message}`)),e=null),c(new Error(a))};try{if(e=(await chrome.tabs.create({url:r,active:!1})).id,!e)throw new Error("Failed to get temporary tab ID.");console.log(`[Stage 3] Created temp tab ${e} for executeScript.`)}catch(a){return c(new Error(`Failed to create temp tab: ${a.message}`))}let s=null;const t=new Promise((a,i)=>{const d=(g,f,u)=>{g===e&&f.status==="complete"&&(console.log(`[Stage 3] Tab ${e} loaded.`),s&&clearTimeout(s),chrome.tabs.onUpdated.removeListener(d),a())};chrome.tabs.onUpdated.addListener(d),s=setTimeout(()=>{chrome.tabs.onUpdated.removeListener(d),i(new Error(`Timeout (${n/1e3}s) waiting for page load.`))},n)});try{await t}catch(a){return l(`Load failed or timed out: ${a.message}`)}console.log(`[Stage 3] Injecting PageExtractor.js and calling window.scraper.extract() in tab ${e}`);try{await chrome.scripting.executeScript({target:{tabId:e},files:["PageExtractor.js"]});const a=await chrome.scripting.executeScript({target:{tabId:e},func:()=>window.scraper.extract()});if(e&&(chrome.tabs.remove(e).catch(i=>console.warn(`[Stage 3] Error removing tab ${e} post-execute: ${i.message}`)),e=null),a&&a.length>0&&a[0].result){const i=a[0].result;i&&typeof i=="object"?(console.log("[Stage 3] window.scraper.extract() succeeded."),o(i)):c(new Error((i==null?void 0:i.error)||"window.scraper.extract() failed or returned null."))}else{const i=chrome.runtime.lastError?chrome.runtime.lastError.message:"No result returned";c(new Error(`executeScript failed: ${i}`))}}catch(a){l(`executeScript call failed: ${a.message}`)}})}async function R(r){console.log(`[Stage 4] Attempting Temp Tab + Content Script: ${r}`);let e=null;const n=3e4;return new Promise(async(o,c)=>{const l=a=>{e&&(chrome.tabs.remove(e).catch(i=>console.warn(`[Stage 4] Error removing tab ${e} during cleanup: ${i.message}`)),e=null),c(new Error(a))};try{if(e=(await chrome.tabs.create({url:r,active:!1})).id,!e)throw new Error("Failed to get temporary tab ID.");console.log(`[Stage 4] Created temp tab ${e}`)}catch(a){return c(new Error(`Failed to create temp tab: ${a.message}`))}let s=null;const t=new Promise((a,i)=>{const d=(g,f,u)=>{g===e&&f.status==="complete"&&(console.log(`[Stage 4] Tab ${e} loaded.`),s&&clearTimeout(s),chrome.tabs.onUpdated.removeListener(d),a())};chrome.tabs.onUpdated.addListener(d),s=setTimeout(()=>{chrome.tabs.onUpdated.removeListener(d),i(new Error("Timeout waiting for page load."))},n)});try{await t}catch(a){return l(a.message)}console.log(`[Stage 4] Sending SCRAPE_PAGE to content script in tab ${e}`);try{const a=await chrome.tabs.sendMessage(e,{type:"SCRAPE_PAGE"});e&&chrome.tabs.remove(e).catch(i=>console.warn(`[Stage 4] Error removing tab ${e} post-message: ${i.message}`)),e=null,a!=null&&a.success?(console.log("[Stage 4] Success from content script."),o(a)):c(new Error((a==null?void 0:a.error)||"Content script failed or gave invalid response."))}catch(a){l(`Messaging content script failed: ${a.message}`)}})}async function y(r,e,n){var c,l,s;console.log(`Scraping Orchestrator: Starting for ${r}. ChatID: ${e}, MessageID: ${n}`);const o=t=>{chrome.runtime.sendMessage({type:"STAGE_SCRAPE_RESULT",payload:t}).catch(a=>console.warn(`[Orchestrator] Failed to send result for Stage ${t.stage}:`,a))};try{const t=await E(r);console.log(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Succeeded for ${r}.`);const a={stage:2,success:!0,chatId:e,messageId:n,method:"offscreenIframe",url:r,length:((c=t==null?void 0:t.text)==null?void 0:c.length)||0,...t};o(a);return}catch(t){console.warn(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Failed for ${r}: ${t.message}`),o({stage:2,success:!1,chatId:e,messageId:n,error:t.message})}try{const t=await T(r);console.log(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Succeeded for ${r}.`);const a={stage:3,success:!0,chatId:e,messageId:n,method:"tempTabExecuteScript",url:r,length:((l=t==null?void 0:t.text)==null?void 0:l.length)||0,...t};o(a);return}catch(t){console.warn(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Failed for ${r}: ${t.message}`),o({stage:3,success:!1,chatId:e,messageId:n,error:t.message})}try{const t=await R(r);console.log(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Succeeded for ${r}.`);const a={stage:4,success:!0,chatId:e,messageId:n,method:"tempTabContentScript",url:r,length:((s=t==null?void 0:t.text)==null?void 0:s.length)||0,...t};console.log("[Orchestrator Log] Stage 4 Payload being sent:",a),o(a);return}catch(t){console.warn(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Failed for ${r}: ${t.message}`),o({stage:4,success:!1,chatId:e,messageId:n,error:t.message})}console.log("[Orchestrator Log] All stages failed.")}chrome.runtime.onInstalled.addListener(()=>{chrome.sidePanel.setPanelBehavior({openPanelOnActionClick:!0}).catch(r=>console.error("Error setting side panel behavior:",r)),console.log("Tab Agent background: Side panel behavior set (default open on click)."),chrome.storage.local.get(null,r=>{const e=Object.keys(r).filter(n=>n.startsWith("detachedState_"));e.length>0&&chrome.storage.local.remove(e,()=>{console.log("Cleaned up old detached states on install/update.")})})});chrome.action.onClicked.addListener(async r=>{if(!r.id){console.error("Action Clicked: Missing tab ID.");return}const e=r.id;console.log(`Action clicked for tab ${e}`);const n=p[e];if(n){console.log(`Popup ${n} exists for tab ${e}. Attempting to close popup.`);try{await chrome.windows.remove(n),console.log(`Closed popup window ${n} via action click.`)}catch(o){if(console.warn(`Failed to close popup ${n} via action click, maybe already closed?`,o),m[n]){console.log(`Force cleaning maps and storage for tab ${e} after failed close.`),delete p[e],delete m[n];try{await chrome.storage.local.remove(`detachedState_${e}`),await chrome.sidePanel.setOptions({tabId:e,enabled:!0})}catch(c){console.error("Error during defensive cleanup:",c)}}}}else console.log(`No popup exists for tab ${e}. Default side panel opening behavior should trigger.`)});chrome.windows.onRemoved.addListener(async r=>{console.log(`Window removed: ${r}`);const e=m[r];if(e){console.log(`Popup window ${r} for tab ${e} was closed.`),delete p[e],delete m[r];try{await chrome.storage.local.remove(`detachedState_${e}`),console.log(`Removed detached state from storage for tab ${e}`),await chrome.sidePanel.setOptions({tabId:e,enabled:!0}),console.log(`Re-enabled side panel for tab ${e} after popup closed.`)}catch(n){console.error(`Error cleaning up storage or re-enabling side panel for tab ${e} on popup close:`,n)}}else console.log(`Window ${r} closed, but it wasn't a tracked popup.`)});chrome.runtime.onMessage.addListener((r,e,n)=>{if(console.log("Background: Received message:",r,"from sender:",e),r.type==="query"){const{text:o,model:c,tabId:l,chatId:s,messageId:t}=r;if(!s||!t)return console.error("Background: Received query without chatId or messageId.",r),t&&chrome.runtime.sendMessage({type:"error",chatId:s||"unknown",messageId:t,error:"Missing chat/message ID in query request"}).catch(i=>console.warn("BG: Error sending missing ID error back:",i)),n({success:!1,error:"Missing chat/message ID in query"}),!1;if(console.log(`Background: Processing query "${o}" for model "${c}". ChatID: ${s}, MessageID: ${t}`),o&&(o.startsWith("http://")||o.startsWith("https://")))return console.log(`Background: Query is a URL, initiating scrape for ${o}`),(async()=>await y(o,s,t))(),n({success:!0,message:"URL query received, initiating scrape..."}),!1;{console.log(`Background: Query is not a URL, using placeholder logic for "${o}"`);const i=`(Tab ${l||"N/A"}) Background received non-URL: "${o}". Agent logic for ${c} not implemented.`;return setTimeout(()=>{try{chrome.runtime.sendMessage({type:"response",chatId:s,messageId:t,text:i}).catch(d=>console.warn(`BG: Could not send response for ${t}, context likely closed.`,d)),console.log(`Background: Sent placeholder response for ${t}.`)}catch(d){console.warn(`Background: Error sending placeholder response for ${t}`,d),chrome.runtime.sendMessage({type:"error",chatId:s,messageId:t,error:`Failed to send response: ${d.message}`}).catch(g=>console.warn(`BG: Could not send error message for ${t} after initial failure.`,g))}},500),n({success:!0,message:"Non-URL query received, processing..."}),!0}}else if(r.type==="getTabId")if(e.tab&&e.tab.id){try{n({type:"tabIdResponse",tabId:e.tab.id})}catch{console.warn("BG: Could not send tabId response")}return!1}else return chrome.tabs.query({active:!0,currentWindow:!0},o=>{if(o&&o.length>0)try{n({type:"tabIdResponse",tabId:o[0].id})}catch{console.warn("BG: Could not send tabId response (fallback)")}else{console.warn("Background: 'getTabId' fallback could not find active tab.");try{n({type:"error",error:"Could not determine sender tab ID (no active tab)."})}catch{console.warn("BG: Could not send tabId error response (fallback)")}}}),!0;else{if(r.type==="popupCreated")return r.popupId&&r.tabId?(p[r.tabId]=r.popupId,m[r.popupId]=r.tabId,console.log(`Background: Tracked popup ${r.popupId} for tab ${r.tabId}`)):console.error("Background: Invalid 'popupCreated' message:",r),!1;if(r.type==="getPopupForTab"){const o=p[r.tabId];return n(o?{popupId:o}:{popupId:null}),!1}else if(r.type==="TEMP_SCRAPE_URL"){const o=r.url,{chatId:c,messageId:l}=r;return r.tabId||e.tab&&e.tab.id,!c||!l?(console.error("Background: Received TEMP_SCRAPE_URL without chatId or messageId.",r),!1):(console.log(`Background: Received TEMP_SCRAPE_URL for: ${o}. ChatID: ${c}, MessageID: ${l}. Starting multi-stage scrape.`),(async()=>await y(o,c,l))(),n({success:!0,message:"Scrape request received."}),!1)}else if(r.type==="getDriveFileList"){const o=r.folderId||"root";return console.log(`Background: Received getDriveFileList for folder: ${o}`),(async()=>{let c=null,l=null;try{const s=await b();c=await k(s,o)}catch(s){console.error(`Background: Error handling getDriveFileList (Folder: ${o}):`,s),l=s.message||"Unknown error fetching file list."}chrome.runtime.sendMessage({type:"driveFileListResponse",success:!l,folderId:o,files:c,error:l}).catch(s=>console.warn("Background: Failed to send driveFileListResponse",s))})(),n({success:!0,message:"Request received, fetching file list..."}),!0}else if(r.type==="fetchDriveFileContent"){const{fileId:o,fileName:c}=r;return console.log(`Background: Received fetchDriveFileContent for ID: ${o}`),o?((async()=>{let l=null,s=null;try{const t=await b();l=await D(t,o)}catch(t){console.error(`Background: Error handling fetchDriveFileContent for ${o}:`,t),s=t.message||"Unknown error fetching file content."}chrome.runtime.sendMessage({type:"driveFileContentResponse",success:!s,fileId:o,fileName:c,content:l,error:s}).catch(t=>console.warn("Background: Failed to send driveFileContentResponse",t))})(),n({success:!0,message:"Request received, fetching file content..."}),!0):(console.error("Background: fetchDriveFileContent missing fileId"),!1)}else{if(r.target==="offscreen"&&(r.type==="parseHTML"||r.type==="createIframe"||r.type==="removeIframe"))return console.log(`Background: Forwarding ${r.type} message to parsing offscreen document.`),(async()=>{const o=$;try{await I(o,["DOM_PARSER","IFRAME_SCRIPTING"],"Parse HTML content and manage scraping iframes");const c=await chrome.runtime.sendMessage(r);console.log(`Background: Received response from parsing offscreen for ${r.type}:`,c)}catch(c){console.error(`Background: Error ensuring/communicating with parsing offscreen document for ${r.type}:`,c)}})(),!1;if(r.target==="offscreen_google_drive")return console.warn("Background: Received message explicitly targeted to 'offscreen_google_drive' outside of picker initiation flow. Ignoring."),!1;console.log("Background: Received unknown message type:",r.type);try{n({type:"error",error:"Unknown message type received by background script."})}catch{console.warn("Background: Could not send error response for unknown message type.")}return!1}}});console.log("Tab Agent background script loaded and listening for messages.");async function b(){return new Promise((r,e)=>{chrome.identity.getAuthToken({interactive:!0},n=>{chrome.runtime.lastError?e(new Error(chrome.runtime.lastError.message)):r(n)})})}async function k(r,e="root"){var i;const n="files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)",o=`'${e}' in parents and trashed=false`,c=100,l="folder,modifiedTime desc",s=`https://www.googleapis.com/drive/v3/files?${new URLSearchParams({pageSize:c.toString(),q:o,fields:n,orderBy:l})}`;console.log(`Background: Fetching Drive list for folder '${e}': ${s}`);const t=await fetch(s,{headers:{Authorization:`Bearer ${r}`,Accept:"application/json"}});if(!t.ok){const d=await t.text();throw console.error(`Background: Drive API files.list error (Folder: ${e}):`,t.status,d),t.status===404?new Error(`Folder with ID '${e}' not found or access denied.`):new Error(`Drive API Error ${t.status} (Folder: ${e}): ${d||t.statusText}`)}const a=await t.json();return console.log(`Background: Drive API files.list success (Folder: ${e}). Found ${((i=a.files)==null?void 0:i.length)||0} items.`),a.files||[]}async function D(r,e){return console.warn(`Background: fetchDriveFileContent not implemented yet for fileId: ${e}`),`(Content fetch not implemented for ${e})`}
