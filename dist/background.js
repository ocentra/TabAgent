const M="offscreenWorker.html";let f={},w={};let o="uninitialized",l=null,k=null,g=null,u=null,_=null,p=null;async function E(){const e=chrome.runtime.getURL(M);return(await chrome.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[e]})).length>0}async function b(){if(await E()){console.log("Background: Model worker offscreen document already exists.");return}console.log("Background: Creating model worker offscreen document..."),await chrome.offscreen.createDocument({url:M,reasons:[chrome.offscreen.Reason.WORKERS],justification:"Run model inference in a separate worker via offscreen document"}),console.log("Background: Model worker offscreen document created.")}async function $(e){if(e.type!=="init"&&e.type!=="generate"&&e.type!=="interrupt"&&e.type!=="reset")(o==="uninitialized"||!await E())&&(console.log(`Background: Ensuring model worker offscreen doc potentially exists before sending ${e==null?void 0:e.type}`),await b());else{console.log(`Background: Ensuring worker script is ready before sending ${e.type}...`);try{await m(),console.log(`Background: Worker script confirmed ready. Proceeding to send ${e.type}.`)}catch(t){throw console.error(`Background: Worker script failed to become ready. Cannot send ${e.type}. Error:`,t),o="error",new Error(`Worker script failed to initialize, cannot send ${e.type}.`)}}console.log(`Background: Sending message type '${e==null?void 0:e.type}' to model worker offscreen doc`);try{if((await chrome.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[chrome.runtime.getURL(M)]})).length>0)return chrome.runtime.sendMessage(e),console.log(`Background: Message type '${e==null?void 0:e.type}' sent to offscreen.`),{success:!0};throw console.error(`Background: Could not find target offscreen document context to send ${e==null?void 0:e.type}.`),new Error("Target offscreen document not found.")}catch(t){throw console.error(`Background: Error sending message type '${e==null?void 0:e.type}' to offscreen:`,t),o="error",e.type==="init"?(p&&p(new Error(`Failed to send init message: ${t.message}`)),u=null):g&&(o==="uninitialized"||o==="creating_worker")&&(g(new Error(`Failed to send message early: ${t.message}`)),l=null),new Error(`Failed to send message to model worker offscreen: ${t.message}`)}}function m(){if(console.log(`[ensureWorkerScriptIsReady] Current state: ${o}`),o!=="uninitialized"&&o!=="creating_worker")return o==="error"&&!l?Promise.reject(new Error("Worker script initialization previously failed.")):Promise.resolve();if(l)return l;console.log("[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise."),o="creating_worker",l=new Promise((t,n)=>{k=t,g=n,b().catch(a=>{console.error("[ensureWorkerScriptIsReady] Error setting up offscreen doc:",a),o="error",g&&g(a),l=null})});const e=3e4;return setTimeout(()=>{o==="creating_worker"&&g&&(console.error(`[ensureWorkerScriptIsReady] Timeout (${e}ms) waiting for workerScriptReady.`),g(new Error("Timeout waiting for model worker script to load.")),o="error",l=null)},e),l}async function S(e){console.log(`[loadModel] Request to load model: ${e}. Current state: ${o}`);try{await m(),console.log(`[loadModel] Worker script confirmed ready (state: ${o}). Proceeding with model load.`)}catch(n){throw console.error("[loadModel] Failed to ensure worker script readiness:",n),new Error(`Failed to ensure worker script readiness: ${n.message}`)}if(o!=="worker_script_ready"&&o!=="idle"&&o!=="error"){const n=`Cannot load model '${e}'. Worker state is '${o}', expected 'worker_script_ready', 'idle', or 'error'.`;throw console.error("[loadModel] State check failed:",n),new Error(n)}if(!e)return Promise.reject(new Error("Cannot load model: Model ID not provided."));if(console.log(`[loadModel] Request to load model: ${e}. Current state: ${o}`),o==="model_ready")return console.log(`[loadModel] Model appears ready. Assuming it's ${e}.`),Promise.resolve();if(o==="loading_model"&&u)return console.log(`[loadModel] Model is already loading. Assuming it's ${e}.`),u;if(o!=="worker_script_ready")return console.error("[loadModel] Cannot load model. Worker script is not ready. State:",o),Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${o})`));console.log(`[loadModel] Worker script ready. Initiating load for model: ${e}.`),o="loading_model",u=new Promise((n,a)=>{_=n,p=a,console.log(`[loadModel] Attempting to send 'init' message for model: ${e}`),$({type:"init",payload:{modelId:e}}).catch(r=>{console.error(`[loadModel] Failed to send 'init' message for ${e}:`,r),o="error",p&&p(r),u=null})});const t=3e5;return setTimeout(()=>{o==="loading_model"&&p&&(console.error(`[loadModel] Timeout (${t}ms) waiting for model ${e} load completion.`),p(new Error(`Timeout waiting for model ${e} to load.`)),o="error",u=null)},t),u}async function B(){const t=(await chrome.declarativeNetRequest.getDynamicRules()).map(r=>r.id),n=[{id:1,priority:1,action:{type:"modifyHeaders",responseHeaders:[{header:"x-frame-options",operation:"remove"},{header:"X-Frame-Options",operation:"remove"},{header:"content-security-policy",operation:"remove"},{header:"Content-Security-Policy",operation:"remove"}]},condition:{resourceTypes:["main_frame"],urlFilter:"|http*://*/*|"}}],a=t.filter(r=>r===1);try{await chrome.declarativeNetRequest.updateDynamicRules({removeRuleIds:a,addRules:n}),console.log("Declarative Net Request rules updated successfully.")}catch(r){console.error("Error updating Declarative Net Request rules:",r)}}B();chrome.runtime.onInstalled.addListener(e=>{console.log("Extension installed or updated:",e.reason),chrome.sidePanel.setPanelBehavior({openPanelOnActionClick:!0}).catch(t=>console.error("Error setting side panel behavior:",t)),console.log("Tab Agent background: Side panel behavior set (default open on click)."),chrome.storage.local.get(null,t=>{const n=Object.keys(t).filter(a=>a.startsWith("detachedState_"));n.length>0&&chrome.storage.local.remove(n,()=>{console.log("Cleaned up old detached states on install/update.")})}),m().catch(t=>{console.error("Initial worker script readiness check failed:",t)})});chrome.runtime.onStartup.addListener(()=>{console.log("Extension startup."),o==="uninitialized"&&m().catch(e=>{console.error("Initial worker script readiness check failed on startup:",e)})});chrome.action.onClicked.addListener(async e=>{if(!e.id){console.error("Action Clicked: Missing tab ID.");return}const t=e.id;console.log(`Action clicked for tab ${t}`);const n=f[t];if(n){console.log(`Popup ${n} exists for tab ${t}. Attempting to close popup.`);try{await chrome.windows.remove(n),console.log(`Closed popup window ${n} via action click.`)}catch(a){if(console.warn(`Failed to close popup ${n} via action click, maybe already closed?`,a),w[n]){console.log(`Force cleaning maps and storage for tab ${t} after failed close.`),delete f[t],delete w[n];try{await chrome.storage.local.remove(`detachedState_${t}`),await chrome.sidePanel.setOptions({tabId:t,enabled:!0})}catch(r){console.error("Error during defensive cleanup:",r)}}}}else console.log(`No popup exists for tab ${t}. Default side panel opening behavior should trigger.`)});chrome.windows.onRemoved.addListener(async e=>{console.log(`Window removed: ${e}`);const t=w[e];if(t){console.log(`Popup window ${e} for tab ${t} was closed.`),delete f[t],delete w[e];try{await chrome.storage.local.remove(`detachedState_${t}`),console.log(`Removed detached state from storage for tab ${t}`),await chrome.sidePanel.setOptions({tabId:t,enabled:!0}),console.log(`Re-enabled side panel for tab ${t} after popup closed.`)}catch(n){console.error(`Error cleaning up storage or re-enabling side panel for tab ${t} on popup close:`,n)}}else console.log(`Window ${e} closed, but it wasn't a tracked popup.`)});let R=-10;chrome.runtime.onMessage.addListener((e,t,n)=>{const{type:a,payload:r}=e;let i=!1;if(console.log(`[Background Listener] Received message type '${a}' from`,t.tab?`tab ${t.tab.id}`:t.url||t.id),["workerScriptReady","workerReady","loadingStatus","generationStatus","generationUpdate","generationComplete","generationError","resetComplete","error"].includes(a)){switch(console.log(`[Background Listener] Handling message from worker: ${a}`),a){case"workerScriptReady":console.log("[Background] Worker SCRIPT is ready!"),o="worker_script_ready",k&&(k(),l=null),chrome.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"script_ready"}}).catch(()=>{});break;case"workerReady":console.log("[Background] Worker MODEL is ready! Model:",r==null?void 0:r.model),o="model_ready",_&&(_(),u=null),chrome.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"model_ready",model:r==null?void 0:r.model}}).catch(()=>{}),k&&(k(),l=null);break;case"loadingStatus":if((r==null?void 0:r.status)==="progress"&&(r!=null&&r.progress)){const c=Math.floor(r.progress);c>=R+10&&(console.log("[Background] Worker loading status (progress):",r),R=c)}else console.log("[Background] Worker loading status (other):",r),R=-10;o!=="loading_model"&&(console.warn(`[Background] Received loadingStatus in unexpected state: ${o}`),o="loading_model"),chrome.runtime.sendMessage({type:"uiLoadingStatusUpdate",payload:r}).catch(c=>{c.message!=="Could not establish connection. Receiving end does not exist."&&console.warn("[Background] Error sending loading status to UI:",c.message)});break;case"generationStatus":console.log(`[Background] Generation status: ${r==null?void 0:r.status}`),(r==null?void 0:r.status)==="generating"?o="generating":(r==null?void 0:r.status)==="interrupted"&&(o="model_ready");break;case"generationUpdate":o!=="generating"&&console.warn(`[Background] Received generationUpdate in unexpected state: ${o}`),o="generating";break;case"generationComplete":console.log("[Background] Generation complete."),o="model_ready";break;case"generationError":console.error("[Background] Generation error from worker:",r),o="error";break;case"resetComplete":console.log("[Background] Worker reset complete."),o="model_ready";break;case"error":console.error("[Background] Received generic error from worker/offscreen:",r);const s=o;o="error",s==="creating_worker"&&g?(g(new Error(r||"Generic error during script init")),l=null):s==="loading_model"&&p&&(p(new Error(r||"Generic error during model load")),u=null),chrome.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"error",error:r}}).catch(()=>{});break}return C(e),!1}if(a==="loadModel"){console.log("[Background Listener] Received 'loadModel' request from sender:",t);const s=r==null?void 0:r.modelId;return console.log(`[Background] Received 'loadModel' request from UI for model: ${s}.`),s?(i=!0,S(s).then(()=>{console.log(`[Background] loadModel(${s}) promise resolved successfully.`),n({success:!0,message:`Model loading initiated or already complete for ${s}.`})}).catch(c=>{console.error(`[Background] loadModel(${s}) failed:`,c),n({success:!1,error:c.message})}),i):(console.error("[Background] 'loadModel' request missing modelId."),n({success:!1,error:"Model ID not provided in request."}),!1)}if(a==="sendChatMessage"){i=!0;const{chatId:s,messages:c,options:d,messageId:v}=r,y=v||s;return o!=="model_ready"?(console.error(`[Background] Cannot send chat message. Model state is ${o}, not 'model_ready'.`),n({success:!1,error:`Model not ready (state: ${o}). Please load a model first.`}),!1):(console.log(`[Background] Model ready, sending generate request for ${y}`),$({type:"generate",payload:{messages:c,max_new_tokens:d==null?void 0:d.max_new_tokens,temperature:d==null?void 0:d.temperature,top_k:d==null?void 0:d.top_k,correlationId:y}}).then(h=>{if(!h.success)throw new Error("Failed to send generate message initially.");console.log(`[Background] Generate request sent for ${y}. Waiting for worker responses.`),n({success:!0,message:"Generation request forwarded to worker."})}).catch(h=>{console.error(`[Background] Error processing sendChatMessage for ${y}:`,h),o==="generating"&&(o="model_ready"),n({success:!1,error:h.message})}),i)}return a==="interruptGeneration"?(console.log("[Background] Received interrupt request from UI."),m().then(()=>$({type:"interrupt"})).then(()=>n({success:!0})).catch(s=>n({success:!1,error:s.message})),i=!0,i):a==="resetWorker"?(console.log("[Background] Received reset request from UI."),m().then(()=>$({type:"reset"})).then(()=>n({success:!0})).catch(s=>n({success:!1,error:s.message})),i=!0,i):(i||console.warn(`[Background Listener] Unhandled message type: ${a}`),i)});async function C(e,t){console.log(`[Forwarder] Attempting to forward message type '${e==null?void 0:e.type}' from worker.`);for(const a in f){const r=f[a];console.log(`[Forwarder] Forwarding message to detached popup ID: ${r} (original tab: ${a})`);try{await chrome.windows.get(r),chrome.runtime.sendMessage(e)}catch(i){console.warn(`[Forwarder] Error sending to detached popup ID ${r}:`,i.message),i.message.includes("No window with id")&&(delete f[a],delete w[r])}}const n=await chrome.tabs.query({status:"complete"});for(const a of n)if(!f[a.id])try{await chrome.tabs.sendMessage(a.id,e)}catch(r){!r.message.includes("Could not establish connection")&&!r.message.includes("Receiving end does not exist")&&console.warn(`[Forwarder] Error forwarding message to tab ${a.id}:`,r.message)}}console.log("[Background-Simple] Script loaded and listening.");
//# sourceMappingURL=background.js.map
