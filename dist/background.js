/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/esm/construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _construct)
/* harmony export */ });
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js");
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");


function _construct(t, e, r) {
  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_0__["default"])()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__["default"])(p, r.prototype), p;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inheritsLoose)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, o);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _isNativeFunction)
/* harmony export */ });
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _isNativeReflectConstruct)
/* harmony export */ });
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/readOnlyError.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/readOnlyError.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _readOnlyError)
/* harmony export */ });
function _readOnlyError(r) {
  throw new TypeError('"' + r + '" is read-only');
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _wrapNativeSuper)
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ "./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js");
/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ "./node_modules/@babel/runtime/helpers/esm/construct.js");




function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__["default"])(t, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Wrapper, t);
  }, _wrapNativeSuper(t);
}


/***/ }),

/***/ "./node_modules/array-push-at-sort-position/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/array-push-at-sort-position/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pushAtSortPosition: () => (/* binding */ pushAtSortPosition)
/* harmony export */ });
/**
 * copied and adapted from npm 'binary-search-insert'
 * @link https://www.npmjs.com/package/binary-search-insert
 */
function pushAtSortPosition(array, item, compareFunction, low) {
  var length = array.length;
  var high = length - 1;
  var mid = 0;

  /**
   * Optimization shortcut.
   */
  if (length === 0) {
    array.push(item);
    return 0;
  }

  /**
   * So we do not have to get the ret[mid] doc again
   * at the last we store it here.
   */
  var lastMidDoc;
  while (low <= high) {
    // https://github.com/darkskyapp/binary-search
    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html
    mid = low + (high - low >> 1);
    lastMidDoc = array[mid];
    if (compareFunction(lastMidDoc, item) <= 0.0) {
      // searching too low
      low = mid + 1;
    } else {
      // searching too high
      high = mid - 1;
    }
  }
  if (compareFunction(lastMidDoc, item) <= 0.0) {
    mid++;
  }

  /**
   * Insert at correct position
   */
  array.splice(mid, 0, item);
  return mid;
}

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   minimalStringToSimpleBdd: () => (/* binding */ minimalStringToSimpleBdd)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/binary-decision-diagram/dist/esm/src/util.js");
/* harmony import */ var _string_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string-format.js */ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js");


function minimalStringToSimpleBdd(str) {
    const nodesById = new Map();
    // parse leaf nodes
    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
    const lastLeafNodeChar = (2 + leafNodeAmount * 2);
    const leafNodeChars = str.substring(2, lastLeafNodeChar);
    const leafNodeChunks = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.splitStringToChunks)(leafNodeChars, 2);
    for (let i = 0; i < leafNodeChunks.length; i++) {
        const chunk = leafNodeChunks[i];
        const id = chunk.charAt(0);
        const value = (0,_string_format_js__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(chunk.charAt(1));
        nodesById.set(id, value);
    }
    // parse internal nodes
    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
    const internalNodeChunks = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.splitStringToChunks)(internalNodeChars, 4);
    for (let i = 0; i < internalNodeChunks.length; i++) {
        const chunk = internalNodeChunks[i];
        const id = chunk.charAt(0);
        const idOf0Branch = chunk.charAt(1);
        const idOf1Branch = chunk.charAt(2);
        const level = (0,_string_format_js__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(chunk.charAt(3));
        if (!nodesById.has(idOf0Branch)) {
            throw new Error('missing node with id ' + idOf0Branch);
        }
        if (!nodesById.has(idOf1Branch)) {
            throw new Error('missing node with id ' + idOf1Branch);
        }
        const node0 = nodesById.get(idOf0Branch);
        const node1 = nodesById.get(idOf1Branch);
        const node = {
            l: level, // level is first for prettier json output
            0: node0,
            1: node1
        };
        nodesById.set(id, node);
    }
    // parse root node
    const last3 = str.slice(-3);
    const idOf0 = last3.charAt(0);
    const idOf1 = last3.charAt(1);
    const levelOfRoot = (0,_string_format_js__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(last3.charAt(2));
    const nodeOf0 = nodesById.get(idOf0);
    const nodeOf1 = nodesById.get(idOf1);
    const rootNode = {
        l: levelOfRoot,
        0: nodeOf0,
        1: nodeOf1,
    };
    return rootNode;
}
//# sourceMappingURL=minimal-string-to-simple-bdd.js.map

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveWithSimpleBdd: () => (/* binding */ resolveWithSimpleBdd)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/binary-decision-diagram/dist/esm/src/util.js");

function resolveWithSimpleBdd(simpleBdd, fns, input) {
    let currentNode = simpleBdd;
    let currentLevel = simpleBdd.l;
    while (true) {
        const booleanResult = fns[currentLevel](input);
        const branchKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.booleanToBooleanString)(booleanResult);
        currentNode = currentNode[branchKey];
        if (typeof currentNode === 'number' || typeof currentNode === 'string') {
            return currentNode;
        }
        else {
            currentLevel = currentNode.l;
        }
    }
}
//# sourceMappingURL=resolve-with-simple-bdd.js.map

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHAR_CODE_OFFSET: () => (/* binding */ CHAR_CODE_OFFSET),
/* harmony export */   FIRST_CHAR_CODE_FOR_ID: () => (/* binding */ FIRST_CHAR_CODE_FOR_ID),
/* harmony export */   getCharOfLevel: () => (/* binding */ getCharOfLevel),
/* harmony export */   getCharOfValue: () => (/* binding */ getCharOfValue),
/* harmony export */   getNextCharId: () => (/* binding */ getNextCharId),
/* harmony export */   getNumberOfChar: () => (/* binding */ getNumberOfChar)
/* harmony export */ });
/*
let t = 0;
while (t < 10000) {
    const char = String.fromCharCode(t);
    console.log(t + ' : ' + char);
    t++;
}
*/
/*

To have a really small string representation, we have to hack some stuff
which makes is complicated but effective.

Rules for the string:
- The string starts with a number like '23' that defines how many leaf-nodes we have
- leaf nodes consist of two chars like 'ab'
    - the first char is the id
    - the second the value is a number you can get via String.charCodeAt()
- Internal nodes have four chars like 'abcd'
    - the first char is the id
    - the second char is the id of the 0-branch
    - the third char is the id of the 1-branch
    - the last char is the id of the boolean-function (= level)
- The last 3 chars of the string is the root node like 'abc'
    - it looks like the internal-node but without the id (first char)

*/
// we use this because 39 is the quotes which causes problems
const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'
function getCharOfLevel(level) {
    const charCode = CHAR_CODE_OFFSET + level;
    return String.fromCharCode(charCode);
}
function getNumberOfChar(char) {
    const charCode = char.charCodeAt(0);
    return charCode - CHAR_CODE_OFFSET;
}
function getCharOfValue(value) {
    const charCode = CHAR_CODE_OFFSET + value;
    return String.fromCharCode(charCode);
}
const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'
function getNextCharId(lastCode) {
    // jump these codes because they look strange
    if (lastCode >= 128 && lastCode <= 160) {
        lastCode = 161;
    }
    const char = String.fromCharCode(lastCode);
    return {
        char,
        nextCode: lastCode + 1
    };
}
//# sourceMappingURL=string-format.js.map

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/esm/src/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/esm/src/util.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binaryToDecimal: () => (/* binding */ binaryToDecimal),
/* harmony export */   booleanStringToBoolean: () => (/* binding */ booleanStringToBoolean),
/* harmony export */   booleanToBooleanString: () => (/* binding */ booleanToBooleanString),
/* harmony export */   decimalToPaddedBinary: () => (/* binding */ decimalToPaddedBinary),
/* harmony export */   firstKeyOfMap: () => (/* binding */ firstKeyOfMap),
/* harmony export */   getNextStateSet: () => (/* binding */ getNextStateSet),
/* harmony export */   lastChar: () => (/* binding */ lastChar),
/* harmony export */   lastOfArray: () => (/* binding */ lastOfArray),
/* harmony export */   maxBinaryWithLength: () => (/* binding */ maxBinaryWithLength),
/* harmony export */   minBinaryWithLength: () => (/* binding */ minBinaryWithLength),
/* harmony export */   nextNodeId: () => (/* binding */ nextNodeId),
/* harmony export */   oppositeBinary: () => (/* binding */ oppositeBinary),
/* harmony export */   oppositeBoolean: () => (/* binding */ oppositeBoolean),
/* harmony export */   shuffleArray: () => (/* binding */ shuffleArray),
/* harmony export */   splitStringToChunks: () => (/* binding */ splitStringToChunks)
/* harmony export */ });
function booleanStringToBoolean(str) {
    if (str === '1') {
        return true;
    }
    else {
        return false;
    }
}
function booleanToBooleanString(b) {
    if (b) {
        return '1';
    }
    else {
        return '0';
    }
}
function oppositeBoolean(input) {
    if (input === '1') {
        return '0';
    }
    else {
        return '1';
    }
}
function lastChar(str) {
    return str.slice(-1);
}
/**
 * @link https://stackoverflow.com/a/1349426
 */
function makeid(length = 6) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
const nodeIdPrefix = makeid(4);
let lastIdGen = 0;
function nextNodeId() {
    const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;
    lastIdGen++;
    return ret;
}
/**
 * @link https://stackoverflow.com/a/16155417
 */
function decimalToPaddedBinary(decimal, padding) {
    const binary = (decimal >>> 0).toString(2);
    const padded = binary.padStart(padding, '0');
    return padded;
}
function oppositeBinary(i) {
    if (i === '1') {
        return '0';
    }
    else if (i === '0') {
        return '1';
    }
    else {
        throw new Error('non-binary given');
    }
}
function binaryToDecimal(binary) {
    return parseInt(binary, 2);
}
function minBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => '0').join('');
}
function maxBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => '1').join('');
}
function getNextStateSet(stateSet) {
    const decimal = binaryToDecimal(stateSet);
    const increase = decimal + 1;
    const binary = decimalToPaddedBinary(increase, stateSet.length);
    return binary;
}
function firstKeyOfMap(map) {
    const iterator1 = map.keys();
    return iterator1.next().value;
}
/**
 * Shuffles array in place. ES6 version
 * @link https://stackoverflow.com/a/6274381
 */
function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}
function lastOfArray(ar) {
    return ar[ar.length - 1];
}
/**
 * @link https://stackoverflow.com/a/6259536
 */
function splitStringToChunks(str, chunkSize) {
    const chunks = [];
    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {
        chunks.push(str.substring(i, i + chunkSize));
    }
    return chunks;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BroadcastChannel: () => (/* binding */ BroadcastChannel),
/* harmony export */   OPEN_BROADCAST_CHANNELS: () => (/* binding */ OPEN_BROADCAST_CHANNELS),
/* harmony export */   clearNodeFolder: () => (/* binding */ clearNodeFolder),
/* harmony export */   enforceOptions: () => (/* binding */ enforceOptions)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");
/* harmony import */ var _method_chooser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./method-chooser.js */ "./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js");
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options.js */ "./node_modules/broadcast-channel/dist/esbrowser/options.js");




/**
 * Contains all open channels,
 * used in tests to ensure everything is closed.
 */
var OPEN_BROADCAST_CHANNELS = new Set();
var lastId = 0;
var BroadcastChannel = function BroadcastChannel(name, options) {
  // identifier of the channel to debug stuff
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }
  this.options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);
  this.method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(this.options);

  // isListening
  this._iL = false;

  /**
   * _onMessageListener
   * setting onmessage twice,
   * will overwrite the first listener
   */
  this._onML = null;

  /**
   * _addEventListeners
   */
  this._addEL = {
    message: [],
    internal: []
  };

  /**
   * Unsent message promises
   * where the sending is still in progress
   * @type {Set<Promise>}
   */
  this._uMP = new Set();

  /**
   * _beforeClose
   * array of promises that will be awaited
   * before the channel is closed
   */
  this._befC = [];

  /**
   * _preparePromise
   */
  this._prepP = null;
  _prepareChannel(this);
};

// STATICS

/**
 * used to identify if someone overwrites
 * window.BroadcastChannel with this
 * See methods/native.js
 */
BroadcastChannel._pubkey = true;

/**
 * clears the tmp-folder if is node
 * @return {Promise<boolean>} true if has run, false if not node
 */
function clearNodeFolder(options) {
  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);
  var method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(options);
  if (method.type === 'node') {
    return method.clearNodeFolder().then(function () {
      return true;
    });
  } else {
    return _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_FALSE;
  }
}

/**
 * if set, this method is enforced,
 * no mather what the options are
 */
var ENFORCED_OPTIONS;
function enforceOptions(options) {
  ENFORCED_OPTIONS = options;
}

// PROTOTYPE
BroadcastChannel.prototype = {
  postMessage: function postMessage(msg) {
    if (this.closed) {
      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +
      /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, 'message', msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, 'internal', msg);
  },
  set onmessage(fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time: time,
      fn: fn
    };
    _removeListenerObject(this, 'message', this._onML);
    if (fn && typeof fn === 'function') {
      this._onML = listenObj;
      _addListenerObject(this, 'message', listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener(type, fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time: time,
      fn: fn
    };
    _addListenerObject(this, type, listenObj);
  },
  removeEventListener: function removeEventListener(type, fn) {
    var obj = this._addEL[type].find(function (obj) {
      return obj.fn === fn;
    });
    _removeListenerObject(this, type, obj);
  },
  close: function close() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare
    // wait until all current sending are processed
    .then(function () {
      return Promise.all(Array.from(_this._uMP));
    })
    // run before-close hooks
    .then(function () {
      return Promise.all(_this._befC.map(function (fn) {
        return fn();
      }));
    })
    // close the channel
    .then(function () {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};

/**
 * Post a message over the channel
 * @returns {Promise} that resolved when the message sending is done
 */
function _post(broadcastChannel, type, msg) {
  var time = broadcastChannel.method.microSeconds();
  var msgObj = {
    time: time,
    type: type,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function () {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);

    // add/remove to unsent messages list
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function () {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isPromise)(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function (s) {
      // used in tests to simulate slow runtime
      /*if (channel.options.prepareDelay) {
           await new Promise(res => setTimeout(res, this.options.prepareDelay));
      }*/
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0) return true;
  if (channel._addEL.internal.length > 0) return true;
  return false;
}
function _addListenerObject(channel, type, obj) {
  channel._addEL[type].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type, obj) {
  channel._addEL[type] = channel._addEL[type].filter(function (o) {
    return o !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    // someone is listening, start subscribing

    var listenerFn = function listenerFn(msgObj) {
      channel._addEL[msgObj.type].forEach(function (listenerObject) {
        if (msgObj.time >= listenerObject.time) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function () {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    // no one is listening, stop subscribing
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   beLeader: () => (/* binding */ beLeader),
/* harmony export */   sendLeaderMessage: () => (/* binding */ sendLeaderMessage)
/* harmony export */ });
/* harmony import */ var unload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unload */ "./node_modules/unload/dist/es/index.js");


/**
 * sends and internal message over the broadcast-channel
 */
function sendLeaderMessage(leaderElector, action) {
  var msgJson = {
    context: 'leader',
    action: action,
    token: leaderElector.token
  };
  return leaderElector.broadcastChannel.postInternal(msgJson);
}
function beLeader(leaderElector) {
  leaderElector.isLeader = true;
  leaderElector._hasLeader = true;
  var unloadFn = (0,unload__WEBPACK_IMPORTED_MODULE_0__.add)(function () {
    return leaderElector.die();
  });
  leaderElector._unl.push(unloadFn);
  var isLeaderListener = function isLeaderListener(msg) {
    if (msg.context === 'leader' && msg.action === 'apply') {
      sendLeaderMessage(leaderElector, 'tell');
    }
    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {
      /**
       * another instance is also leader!
       * This can happen on rare events
       * like when the CPU is at 100% for long time
       * or the tabs are open very long and the browser throttles them.
       * @link https://github.com/pubkey/broadcast-channel/issues/414
       * @link https://github.com/pubkey/broadcast-channel/issues/385
       */
      leaderElector._dpLC = true;
      leaderElector._dpL(); // message the lib user so the app can handle the problem
      sendLeaderMessage(leaderElector, 'tell'); // ensure other leader also knows the problem
    }
  };
  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);
  leaderElector._lstns.push(isLeaderListener);
  return sendLeaderMessage(leaderElector, 'tell');
}

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/leader-election-web-lock.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/leader-election-web-lock.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LeaderElectionWebLock: () => (/* binding */ LeaderElectionWebLock)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");
/* harmony import */ var _leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leader-election-util.js */ "./node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js");



/**
 * A faster version of the leader elector that uses the WebLock API
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
 */
var LeaderElectionWebLock = function LeaderElectionWebLock(broadcastChannel, options) {
  var _this = this;
  this.broadcastChannel = broadcastChannel;
  broadcastChannel._befC.push(function () {
    return _this.die();
  });
  this._options = options;
  this.isLeader = false;
  this.isDead = false;
  this.token = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)();
  this._lstns = [];
  this._unl = [];
  this._dpL = function () {}; // onduplicate listener
  this._dpLC = false; // true when onduplicate called

  this._wKMC = {}; // stuff for cleanup

  // lock name
  this.lN = 'pubkey-bc||' + broadcastChannel.method.type + '||' + broadcastChannel.name;
};
LeaderElectionWebLock.prototype = {
  hasLeader: function hasLeader() {
    var _this2 = this;
    return navigator.locks.query().then(function (locks) {
      var relevantLocks = locks.held ? locks.held.filter(function (lock) {
        return lock.name === _this2.lN;
      }) : [];
      if (relevantLocks && relevantLocks.length > 0) {
        return true;
      } else {
        return false;
      }
    });
  },
  awaitLeadership: function awaitLeadership() {
    var _this3 = this;
    if (!this._wLMP) {
      this._wKMC.c = new AbortController();
      var returnPromise = new Promise(function (res, rej) {
        _this3._wKMC.res = res;
        _this3._wKMC.rej = rej;
      });
      this._wLMP = new Promise(function (res) {
        navigator.locks.request(_this3.lN, {
          signal: _this3._wKMC.c.signal
        }, function () {
          // if the lock resolved, we can drop the abort controller
          _this3._wKMC.c = undefined;
          (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.beLeader)(_this3);
          res();
          return returnPromise;
        })["catch"](function () {});
      });
    }
    return this._wLMP;
  },
  set onduplicate(_fn) {
    // Do nothing because there are no duplicates in the WebLock version
  },
  die: function die() {
    var _this4 = this;
    this._lstns.forEach(function (listener) {
      return _this4.broadcastChannel.removeEventListener('internal', listener);
    });
    this._lstns = [];
    this._unl.forEach(function (uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this.isLeader = false;
    }
    this.isDead = true;
    if (this._wKMC.res) {
      this._wKMC.res();
    }
    if (this._wKMC.c) {
      this._wKMC.c.abort('LeaderElectionWebLock.die() called');
    }
    return (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.sendLeaderMessage)(this, 'death');
  }
};

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/leader-election.js":
/*!**************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/leader-election.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLeaderElection: () => (/* binding */ createLeaderElection)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");
/* harmony import */ var _leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leader-election-util.js */ "./node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js");
/* harmony import */ var _leader_election_web_lock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./leader-election-web-lock.js */ "./node_modules/broadcast-channel/dist/esbrowser/leader-election-web-lock.js");



var LeaderElection = function LeaderElection(broadcastChannel, options) {
  var _this = this;
  this.broadcastChannel = broadcastChannel;
  this._options = options;
  this.isLeader = false;
  this._hasLeader = false;
  this.isDead = false;
  this.token = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)();

  /**
   * Apply Queue,
   * used to ensure we do not run applyOnce()
   * in parallel.
   */
  this._aplQ = _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;
  // amount of unfinished applyOnce() calls
  this._aplQC = 0;

  // things to clean up
  this._unl = []; // _unloads
  this._lstns = []; // _listeners
  this._dpL = function () {}; // onduplicate listener
  this._dpLC = false; // true when onduplicate called

  /**
   * Even when the own instance is not applying,
   * we still listen to messages to ensure the hasLeader flag
   * is set correctly.
   */
  var hasLeaderListener = function hasLeaderListener(msg) {
    if (msg.context === 'leader') {
      if (msg.action === 'death') {
        _this._hasLeader = false;
      }
      if (msg.action === 'tell') {
        _this._hasLeader = true;
      }
    }
  };
  this.broadcastChannel.addEventListener('internal', hasLeaderListener);
  this._lstns.push(hasLeaderListener);
};
LeaderElection.prototype = {
  hasLeader: function hasLeader() {
    return Promise.resolve(this._hasLeader);
  },
  /**
   * Returns true if the instance is leader,
   * false if not.
   * @async
   */
  applyOnce: function applyOnce(
  // true if the applyOnce() call came from the fallbackInterval cycle
  isFromFallbackInterval) {
    var _this2 = this;
    if (this.isLeader) {
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0, true);
    }
    if (this.isDead) {
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0, false);
    }

    /**
     * Already applying more than once,
     * -> wait for the apply queue to be finished.
     */
    if (this._aplQC > 1) {
      return this._aplQ;
    }

    /**
     * Add a new apply-run
     */
    var applyRun = function applyRun() {
      /**
       * Optimization shortcuts.
       * Directly return if a previous run
       * has already elected a leader.
       */
      if (_this2.isLeader) {
        return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_TRUE;
      }
      var stopCriteria = false;
      var stopCriteriaPromiseResolve;
      /**
       * Resolves when a stop criteria is reached.
       * Uses as a performance shortcut so we do not
       * have to await the responseTime when it is already clear
       * that the election failed.
       */
      var stopCriteriaPromise = new Promise(function (res) {
        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {
          stopCriteria = true;
          res();
        };
      });
      var handleMessage = function handleMessage(msg) {
        if (msg.context === 'leader' && msg.token != _this2.token) {
          if (msg.action === 'apply') {
            // other is applying
            if (msg.token > _this2.token) {
              /**
               * other has higher token
               * -> stop applying and let other become leader.
               */
              stopCriteriaPromiseResolve();
            }
          }
          if (msg.action === 'tell') {
            // other is already leader
            stopCriteriaPromiseResolve();
            _this2._hasLeader = true;
          }
        }
      };
      _this2.broadcastChannel.addEventListener('internal', handleMessage);

      /**
       * If the applyOnce() call came from the fallbackInterval,
       * we can assume that the election runs in the background and
       * not critical process is waiting for it.
       * When this is true, we give the other instances
       * more time to answer to messages in the election cycle.
       * This makes it less likely to elect duplicate leaders.
       * But also it takes longer which is not a problem because we anyway
       * run in the background.
       */
      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;
      return (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.sendLeaderMessage)(_this2, 'apply') // send out that this one is applying
      .then(function () {
        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
          return Promise.reject(new Error());
        })]);
      })
      // send again in case another instance was just created
      .then(function () {
        return (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.sendLeaderMessage)(_this2, 'apply');
      })
      // let others time to respond
      .then(function () {
        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
          return Promise.reject(new Error());
        })]);
      })["catch"](function () {}).then(function () {
        _this2.broadcastChannel.removeEventListener('internal', handleMessage);
        if (!stopCriteria) {
          // no stop criteria -> own is leader
          return (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.beLeader)(_this2).then(function () {
            return true;
          });
        } else {
          // other is leader
          return false;
        }
      });
    };
    this._aplQC = this._aplQC + 1;
    this._aplQ = this._aplQ.then(function () {
      return applyRun();
    }).then(function () {
      _this2._aplQC = _this2._aplQC - 1;
    });
    return this._aplQ.then(function () {
      return _this2.isLeader;
    });
  },
  awaitLeadership: function awaitLeadership() {
    if (/* _awaitLeadershipPromise */
    !this._aLP) {
      this._aLP = _awaitLeadershipOnce(this);
    }
    return this._aLP;
  },
  set onduplicate(fn) {
    this._dpL = fn;
  },
  die: function die() {
    var _this3 = this;
    this._lstns.forEach(function (listener) {
      return _this3.broadcastChannel.removeEventListener('internal', listener);
    });
    this._lstns = [];
    this._unl.forEach(function (uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this._hasLeader = false;
      this.isLeader = false;
    }
    this.isDead = true;
    return (0,_leader_election_util_js__WEBPACK_IMPORTED_MODULE_1__.sendLeaderMessage)(this, 'death');
  }
};

/**
 * @param leaderElector {LeaderElector}
 */
function _awaitLeadershipOnce(leaderElector) {
  if (leaderElector.isLeader) {
    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;
  }
  return new Promise(function (res) {
    var resolved = false;
    function finish() {
      if (resolved) {
        return;
      }
      resolved = true;
      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);
      res(true);
    }

    // try once now
    leaderElector.applyOnce().then(function () {
      if (leaderElector.isLeader) {
        finish();
      }
    });

    /**
     * Try on fallbackInterval
     * @recursive
     */
    var _tryOnFallBack = function tryOnFallBack() {
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(leaderElector._options.fallbackInterval).then(function () {
        if (leaderElector.isDead || resolved) {
          return;
        }
        if (leaderElector.isLeader) {
          finish();
        } else {
          return leaderElector.applyOnce(true).then(function () {
            if (leaderElector.isLeader) {
              finish();
            } else {
              _tryOnFallBack();
            }
          });
        }
      });
    };
    _tryOnFallBack();

    // try when other leader dies
    var whenDeathListener = function whenDeathListener(msg) {
      if (msg.context === 'leader' && msg.action === 'death') {
        leaderElector._hasLeader = false;
        leaderElector.applyOnce().then(function () {
          if (leaderElector.isLeader) {
            finish();
          }
        });
      }
    };
    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);
    leaderElector._lstns.push(whenDeathListener);
  });
}
function fillOptionsWithDefaults(options, channel) {
  if (!options) options = {};
  options = JSON.parse(JSON.stringify(options));
  if (!options.fallbackInterval) {
    options.fallbackInterval = 3000;
  }
  if (!options.responseTime) {
    options.responseTime = channel.method.averageResponseTime(channel.options);
  }
  return options;
}
function createLeaderElection(channel, options) {
  if (channel._leaderElector) {
    throw new Error('BroadcastChannel already has a leader-elector');
  }
  options = fillOptionsWithDefaults(options, channel);
  var elector = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.supportsWebLockAPI)() ? new _leader_election_web_lock_js__WEBPACK_IMPORTED_MODULE_2__.LeaderElectionWebLock(channel, options) : new LeaderElection(channel, options);
  channel._befC.push(function () {
    return elector.die();
  });
  channel._leaderElector = elector;
  return elector;
}

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   chooseMethod: () => (/* binding */ chooseMethod)
/* harmony export */ });
/* harmony import */ var _methods_native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/native.js */ "./node_modules/broadcast-channel/dist/esbrowser/methods/native.js");
/* harmony import */ var _methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/indexed-db.js */ "./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js");
/* harmony import */ var _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/localstorage.js */ "./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js");
/* harmony import */ var _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/simulate.js */ "./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js");




// the line below will be removed from es5/browser builds

// order is important
var METHODS = [_methods_native_js__WEBPACK_IMPORTED_MODULE_0__.NativeMethod,
// fastest
_methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__.IndexedDBMethod, _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__.LocalstorageMethod];
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);

  // the line below will be removed from es5/browser builds

  // directly chosen
  if (options.type) {
    if (options.type === 'simulate') {
      // only use simulate-method if directly chosen
      return _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__.SimulateMethod;
    }
    var ret = chooseMethods.find(function (m) {
      return m.type === options.type;
    });
    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;
  }

  /**
   * if no webworker support is needed,
   * remove idb from the list so that localstorage will be chosen
   */
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function (m) {
      return m.type !== 'idb';
    });
  }
  var useMethod = chooseMethods.find(function (method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function (m) {
      return m.type;
    })));
  } else {
    return useMethod;
  }
}

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IndexedDBMethod: () => (/* binding */ IndexedDBMethod),
/* harmony export */   TRANSACTION_SETTINGS: () => (/* binding */ TRANSACTION_SETTINGS),
/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),
/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),
/* harmony export */   cleanOldMessages: () => (/* binding */ cleanOldMessages),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   commitIndexedDBTransaction: () => (/* binding */ commitIndexedDBTransaction),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   createDatabase: () => (/* binding */ createDatabase),
/* harmony export */   getAllMessages: () => (/* binding */ getAllMessages),
/* harmony export */   getIdb: () => (/* binding */ getIdb),
/* harmony export */   getMessagesHigherThan: () => (/* binding */ getMessagesHigherThan),
/* harmony export */   getOldMessages: () => (/* binding */ getOldMessages),
/* harmony export */   microSeconds: () => (/* binding */ microSeconds),
/* harmony export */   onMessage: () => (/* binding */ onMessage),
/* harmony export */   postMessage: () => (/* binding */ postMessage),
/* harmony export */   removeMessagesById: () => (/* binding */ removeMessagesById),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   writeMessage: () => (/* binding */ writeMessage)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");
/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ "./node_modules/oblivious-set/dist/esm/src/index.js");
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ "./node_modules/broadcast-channel/dist/esbrowser/options.js");
/**
 * this method uses indexeddb to store the messages
 * There is currently no observerAPI for idb
 * @link https://github.com/w3c/IndexedDB/issues/51
 * 
 * When working on this, ensure to use these performance optimizations:
 * @link https://rxdb.info/slow-indexeddb.html
 */


var microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;


var DB_PREFIX = 'pubkey.broadcast-channel-0-';
var OBJECT_STORE_ID = 'messages';

/**
 * Use relaxed durability for faster performance on all transactions.
 * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
 */
var TRANSACTION_SETTINGS = {
  durability: 'relaxed'
};
var type = 'idb';
function getIdb() {
  if (typeof indexedDB !== 'undefined') return indexedDB;
  if (typeof window !== 'undefined') {
    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;
  }
  return false;
}

/**
 * If possible, we should explicitly commit IndexedDB transactions
 * for better performance.
 * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
 */
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();

  // create table
  var dbName = DB_PREFIX + channelName;

  /**
   * All IndexedDB databases are opened without version
   * because it is a bit faster, especially on firefox
   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version
   */
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function (ev) {
    var db = ev.target.result;
    db.createObjectStore(OBJECT_STORE_ID, {
      keyPath: 'id',
      autoIncrement: true
    });
  };
  return new Promise(function (res, rej) {
    openRequest.onerror = function (ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function () {
      res(openRequest.result);
    };
  });
}

/**
 * writes the new message to the database
 * so other readers can find it
 */
function writeMessage(db, readerUuid, messageJson) {
  var time = Date.now();
  var writeObject = {
    uuid: readerUuid,
    time: time,
    data: messageJson
  };
  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);
  return new Promise(function (res, rej) {
    tx.oncomplete = function () {
      return res();
    };
    tx.onerror = function (ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getAllMessages(db) {
  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function (res) {
    objectStore.openCursor().onsuccess = function (ev) {
      var cursor = ev.target.result;
      if (cursor) {
        ret.push(cursor.value);
        //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);
        cursor["continue"]();
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function getMessagesHigherThan(db, lastCursorId) {
  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);

  /**
   * Optimization shortcut,
   * if getAll() can be used, do not use a cursor.
   * @link https://rxdb.info/slow-indexeddb.html
   */
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function (res, rej) {
      getAllRequest.onerror = function (err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function (e) {
        res(e.target.result);
      };
    });
  }
  function openCursor() {
    // Occasionally Safari will fail on IDBKeyRange.bound, this
    // catches that error, having it open the cursor to the first
    // item. When it gets data it will advance to the desired key.
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function (res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function (err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function (ev) {
      var cursor = ev.target.result;
      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, 'readwrite', TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function (id) {
    var deleteRequest = objectStore["delete"](id);
    return new Promise(function (res) {
      deleteRequest.onsuccess = function () {
        return res();
      };
    });
  }));
}
function getOldMessages(db, ttl) {
  var olderThen = Date.now() - ttl;
  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function (res) {
    objectStore.openCursor().onsuccess = function (ev) {
      var cursor = ev.target.result;
      if (cursor) {
        var msgObk = cursor.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);
          cursor["continue"]();
        } else {
          // no more old messages,
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function (tooOld) {
    return removeMessagesById(channelState, tooOld.map(function (msg) {
      return msg.id;
    }));
  });
}
function create(channelName, options) {
  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);
  return createDatabase(channelName).then(function (db) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName: channelName,
      options: options,
      uuid: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db
    };

    /**
     * Handle abrupt closes that do not originate from db.close().
     * This could happen, for example, if the underlying storage is
     * removed or if the user clears the database in the browser's
     * history preferences.
     */
    db.onclose = function () {
      state.closed = true;
      if (options.idb.onclose) options.idb.onclose();
    };

    /**
     * if service-workers are used,
     * we have no 'storage'-event if they post a message,
     * therefore we also have to set an interval
     */
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed) return;
  readNewMessages(state).then(function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(state.options.idb.fallbackInterval);
  }).then(function () {
    return _readLoop(state);
  });
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid) return false; // send by own
  if (state.eMIs.has(msgObj.id)) return false; // already emitted
  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback
  return true;
}

/**
 * reads all new messages from the database and emits them
 */
function readNewMessages(state) {
  // channel already closed
  if (state.closed) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;

  // if no one is listening, we do not need to scan for new messages
  if (!state.messagesCallback) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {
    var useMessages = newerMessages
    /**
     * there is a bug in iOS where the msgObj can be undefined sometimes
     * so we filter them out
     * @link https://github.com/pubkey/broadcast-channel/issues/19
     */.filter(function (msgObj) {
      return !!msgObj;
    }).map(function (msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function (msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function (msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    }); // sort by time
    useMessages.forEach(function (msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;
  });
}
function close(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function () {
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomInt)(0, 10) === 0) {
      /* await (do not await) */
      cleanOldMessages(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed() {
  return !!getIdb();
}
function averageResponseTime(options) {
  return options.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocalstorageMethod: () => (/* binding */ LocalstorageMethod),
/* harmony export */   addStorageEventListener: () => (/* binding */ addStorageEventListener),
/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),
/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   getLocalStorage: () => (/* binding */ getLocalStorage),
/* harmony export */   microSeconds: () => (/* binding */ microSeconds),
/* harmony export */   onMessage: () => (/* binding */ onMessage),
/* harmony export */   postMessage: () => (/* binding */ postMessage),
/* harmony export */   removeStorageEventListener: () => (/* binding */ removeStorageEventListener),
/* harmony export */   storageKey: () => (/* binding */ storageKey),
/* harmony export */   type: () => (/* binding */ type)
/* harmony export */ });
/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ "./node_modules/oblivious-set/dist/esm/src/index.js");
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ "./node_modules/broadcast-channel/dist/esbrowser/options.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");
/**
 * A localStorage-only method which uses localstorage and its 'storage'-event
 * This does not work inside webworkers because they have no access to localstorage
 * This is basically implemented to support IE9 or your grandmother's toaster.
 * @link https://caniuse.com/#feat=namevalue-storage
 * @link https://caniuse.com/#feat=indexeddb
 */




var microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;
var KEY_PREFIX = 'pubkey.broadcastChannel-';
var type = 'localstorage';

/**
 * copied from crosstab
 * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
 */
function getLocalStorage() {
  var localStorage;
  if (typeof window === 'undefined') return null;
  try {
    localStorage = window.localStorage;
    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;
  } catch (e) {
    // New versions of Firefox throw a Security exception
    // if cookies are disabled. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153
  }
  return localStorage;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}

/**
* writes the new message to the storage
* and fires the storage-event so other readers can find it
*/
function postMessage(channelState, messageJson) {
  return new Promise(function (res) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)().then(function () {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),
        time: Date.now(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);

      /**
       * StorageEvent does not fire the 'storage' event
       * in the window that changes the state of the local storage.
       * So we fire it manually
       */
      var ev = document.createEvent('Event');
      ev.initEvent('storage', true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener = function listener(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener('storage', listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener('storage', listener);
}
function create(channelName, options) {
  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);
  if (!canBeUsed()) {
    throw new Error('BroadcastChannel: localstorage cannot be used');
  }
  var uuid = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)();

  /**
   * eMIs
   * contains all messages that have been emitted before
   * @type {ObliviousSet}
   */
  var eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName: channelName,
    uuid: uuid,
    eMIs: eMIs // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function (msgObj) {
    if (!state.messagesCallback) return; // no listener
    if (msgObj.uuid === uuid) return; // own message
    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old

    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  var ls = getLocalStorage();
  if (!ls) return false;
  try {
    var key = '__broadcastchannel_check';
    ls.setItem(key, 'works');
    ls.removeItem(key);
  } catch (e) {
    // Safari 10 in private mode will not allow write access to local
    // storage and fail with a QuotaExceededError. See
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes
    return false;
  }
  return true;
}
function averageResponseTime() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
    // safari is much slower so this time is higher
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/native.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/native.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NativeMethod: () => (/* binding */ NativeMethod),
/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),
/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   microSeconds: () => (/* binding */ microSeconds),
/* harmony export */   onMessage: () => (/* binding */ onMessage),
/* harmony export */   postMessage: () => (/* binding */ postMessage),
/* harmony export */   type: () => (/* binding */ type)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");

var microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;
var type = 'native';
function create(channelName) {
  var state = {
    time: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds)(),
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: [] // subscriberFunctions
  };
  state.bc.onmessage = function (msgEvent) {
    if (state.messagesCallback) {
      state.messagesCallback(msgEvent.data);
    }
  };
  return state;
}
function close(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  // Deno runtime
  // eslint-disable-next-line
  if (typeof globalThis !== 'undefined' && globalThis.Deno && globalThis.Deno.args) {
    return true;
  }

  // Browser runtime
  if ((typeof window !== 'undefined' || typeof self !== 'undefined') && typeof BroadcastChannel === 'function') {
    if (BroadcastChannel._pubkey) {
      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime() {
  return 150;
}
var NativeMethod = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SIMULATE_DELAY_TIME: () => (/* binding */ SIMULATE_DELAY_TIME),
/* harmony export */   SimulateMethod: () => (/* binding */ SimulateMethod),
/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),
/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   microSeconds: () => (/* binding */ microSeconds),
/* harmony export */   onMessage: () => (/* binding */ onMessage),
/* harmony export */   postMessage: () => (/* binding */ postMessage),
/* harmony export */   type: () => (/* binding */ type)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/broadcast-channel/dist/esbrowser/util.js");

var microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;
var type = 'simulate';
var SIMULATE_CHANNELS = new Set();
function create(channelName) {
  var state = {
    time: microSeconds(),
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
var SIMULATE_DELAY_TIME = 5;
function postMessage(channelState, messageJson) {
  return new Promise(function (res) {
    return setTimeout(function () {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.forEach(function (channel) {
        if (channel.name === channelState.name &&
        // has same name
        channel !== channelState &&
        // not own channel
        !!channel.messagesCallback &&
        // has subscribers
        channel.time < messageJson.time // channel not created after postMessage() call
        ) {
          channel.messagesCallback(messageJson);
        }
      });
      res();
    }, SIMULATE_DELAY_TIME);
  });
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  return true;
}
function averageResponseTime() {
  return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/options.js":
/*!******************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillOptionsWithDefaults: () => (/* binding */ fillOptionsWithDefaults)
/* harmony export */ });
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));

  // main
  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;

  // indexed-db
  if (!options.idb) options.idb = {};
  //  after this time the messages get deleted
  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;
  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
  //  handles abrupt db onclose events.
  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;

  // localstorage
  if (!options.localstorage) options.localstorage = {};
  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;

  // custom methods
  if (originalOptions.methods) options.methods = originalOptions.methods;

  // node
  if (!options.node) options.node = {};
  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;
  /**
   * On linux use 'ulimit -Hn' to get the limit of open files.
   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.
   */
  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;
  return options;
}

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PROMISE_RESOLVED_FALSE: () => (/* binding */ PROMISE_RESOLVED_FALSE),
/* harmony export */   PROMISE_RESOLVED_TRUE: () => (/* binding */ PROMISE_RESOLVED_TRUE),
/* harmony export */   PROMISE_RESOLVED_VOID: () => (/* binding */ PROMISE_RESOLVED_VOID),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   microSeconds: () => (/* binding */ microSeconds),
/* harmony export */   randomInt: () => (/* binding */ randomInt),
/* harmony export */   randomToken: () => (/* binding */ randomToken),
/* harmony export */   sleep: () => (/* binding */ sleep),
/* harmony export */   supportsWebLockAPI: () => (/* binding */ supportsWebLockAPI)
/* harmony export */ });
/**
 * returns true if the given object is a promise
 */
function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}
var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
  if (!time) time = 0;
  return new Promise(function (res) {
    return setTimeout(function () {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

/**
 * https://stackoverflow.com/a/8084248
 */
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;

/**
 * Returns the current unix time in micro-seconds,
 * WARNING: This is a pseudo-function
 * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
 * This is enough in browsers, and this function will not be used in nodejs.
 * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
 */
function microSeconds() {
  var ret = Date.now() * 1000; // milliseconds to microseconds
  if (ret <= lastMs) {
    ret = lastMs + 1;
  }
  lastMs = ret;
  return ret;
}

/**
 * Check if WebLock API is supported.
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
 */
function supportsWebLockAPI() {
  if (typeof navigator !== 'undefined' && typeof navigator.locks !== 'undefined' && typeof navigator.locks.request === 'function') {
    return true;
  } else {
    return false;
  }
}

/***/ }),

/***/ "./node_modules/custom-idle-queue/dist/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/custom-idle-queue/dist/es/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IdleQueue: () => (/* binding */ IdleQueue)
/* harmony export */ });
/**
 * Creates a new Idle-Queue
 * @constructor
 * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource
 */
var IdleQueue = function IdleQueue() {
  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  this._parallels = parallels || 1;
  /**
   * _queueCounter
   * each lock() increased this number
   * each unlock() decreases this number
   * If _qC==0, the state is in idle
   * @type {Number}
   */

  this._qC = 0;
  /**
   * _idleCalls
   * contains all promises that where added via requestIdlePromise()
   * and not have been resolved
   * @type {Set<Promise>} _iC with oldest promise first
   */

  this._iC = new Set();
  /**
   * _lastHandleNumber
   * @type {Number}
   */

  this._lHN = 0;
  /**
   * _handlePromiseMap
   * Contains the handleNumber on the left
   * And the assigned promise on the right.
   * This is stored so you can use cancelIdleCallback(handleNumber)
   * to stop executing the callback.
   * @type {Map<Number><Promise>}
   */

  this._hPM = new Map();
  this._pHM = new Map(); // _promiseHandleMap
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },

  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;

    _tryIdleCall(this);
  },

  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;

    this.lock();
    var maybePromise;

    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }

    if (!maybePromise.then || typeof maybePromise.then !== 'function') {
      // no promise
      this.unlock();
      return maybePromise;
    } else {
      // promise
      return maybePromise.then(function (ret) {
        // sucessfull -> unlock before return
        _this.unlock();

        return ret;
      })["catch"](function (err) {
        // not sucessfull -> unlock before throwing
        _this.unlock();

        throw err;
      });
    }
  },

  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise(options) {
    var _this2 = this;

    options = options || {};
    var resolve;
    var prom = new Promise(function (res) {
      return resolve = res;
    });

    var resolveFromOutside = function resolveFromOutside() {
      _removeIdlePromise(_this2, prom);

      resolve();
    };

    prom._manRes = resolveFromOutside;

    if (options.timeout) {
      // if timeout has passed, resolve promise even if not idle
      var timeoutObj = setTimeout(function () {
        prom._manRes();
      }, options.timeout);
      prom._timeoutObj = timeoutObj;
    }

    this._iC.add(prom);

    _tryIdleCall(this);

    return prom;
  },

  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise) {
    _removeIdlePromise(this, promise);
  },

  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback(callback, options) {
    var handle = this._lHN++;
    var promise = this.requestIdlePromise(options);

    this._hPM.set(handle, promise);

    this._pHM.set(promise, handle);

    promise.then(function () {
      return callback();
    });
    return handle;
  },

  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise = this._hPM.get(handle);

    this.cancelIdlePromise(promise);
  },

  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;

    // remove all non-cleared
    this._iC.forEach(function (promise) {
      return _removeIdlePromise(_this3, promise);
    });

    this._qC = 0;

    this._iC.clear();

    this._hPM = new Map();
    this._pHM = new Map();
  }
};
/**
 * processes the oldest call of the idleCalls-queue
 * @return {Promise<void>}
 */

function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0) return;

  var iterator = idleQueue._iC.values();

  var oldestPromise = iterator.next().value;

  oldestPromise._manRes(); // try to call the next tick


  setTimeout(function () {
    return _tryIdleCall(idleQueue);
  }, 0);
}
/**
 * removes the promise from the queue and maps and also its corresponding handle-number
 * @param  {Promise} promise from requestIdlePromise()
 * @return {void}
 */


function _removeIdlePromise(idleQueue, promise) {
  if (!promise) return; // remove timeout if exists

  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists

  if (idleQueue._pHM.has(promise)) {
    var handle = idleQueue._pHM.get(promise);

    idleQueue._hPM["delete"](handle);

    idleQueue._pHM["delete"](promise);
  } // remove from queue


  idleQueue._iC["delete"](promise);
}
/**
 * resolves the last entry of this._iC
 * but only if the queue is empty
 * @return {Promise}
 */


function _tryIdleCall(idleQueue) {
  // ensure this does not run in parallel
  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;
  idleQueue._tryIR = true; // w8 one tick

  setTimeout(function () {
    // check if queue empty
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    /**
     * wait 1 tick here
     * because many functions do IO->CPU->IO
     * which means the queue is empty for a short time
     * but the ressource is not idle
     */


    setTimeout(function () {
      // check if queue still empty
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      } // ressource is idle


      _resolveOneIdleCall(idleQueue);

      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}

/***/ }),

/***/ "./node_modules/dexie/dist/dexie.js":
/*!******************************************!*\
  !*** ./node_modules/dexie/dist/dexie.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 4.0.10, Fri Nov 15 2024
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */
 
(function (global, factory) {
     true ? module.exports = factory() :
    0;
})(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var _global = typeof globalThis !== 'undefined' ? globalThis :
        typeof self !== 'undefined' ? self :
            typeof window !== 'undefined' ? window :
                __webpack_require__.g;

    var keys = Object.keys;
    var isArray = Array.isArray;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend(obj, extension) {
        if (typeof extension !== 'object')
            return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function')
            extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
            { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function (Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b)
            throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
        if (_global.setImmediate)
            setImmediate(fn);
        else
            setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
        return array.reduce(function (result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
                result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))
            return obj[keyPath];
        if (!keyPath)
            return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined)
            return;
        if ('isFrozen' in Object && Object.isFrozen(obj))
            return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        }
        else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "")
                    if (value === undefined) {
                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                            obj.splice(currentKeyPath, 1);
                        else
                            delete obj[currentKeyPath];
                    }
                    else
                        obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj || !hasOwn(obj, currentKeyPath))
                        innerObj = (obj[currentKeyPath] = {});
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            }
            else {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(keyPath)))
                        obj.splice(keyPath, 1);
                    else
                        delete obj[keyPath];
                }
                else
                    obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string')
            setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath)
            [].map.call(keyPath, function (kp) {
                setByKeyPath(obj, kp, undefined);
            });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn(obj, m))
                rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return ["Int", "Uint", "Float"].map(function (t) { return t + num + "Array"; }); }))).filter(function (t) { return _global[t]; });
    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));
    function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
            if (hasOwn(o, k)) {
                var v = o[k];
                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
            }
        return rv;
    }
    function objectIsEmpty(o) {
        for (var k in o)
            if (hasOwn(o, k))
                return false;
        return true;
    }
    var circularRefs = null;
    function deepClone(any) {
        circularRefs = new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
    }
    function innerDeepClone(x) {
        if (!x || typeof x !== 'object')
            return x;
        var rv = circularRefs.get(x);
        if (rv)
            return rv;
        if (isArray(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for (var i = 0, l = x.length; i < l; ++i) {
                rv.push(innerDeepClone(x[i]));
            }
        }
        else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
        }
        else {
            var proto = getProto(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for (var prop in x) {
                if (hasOwn(x, prop)) {
                    rv[prop] = innerDeepClone(x[prop]);
                }
            }
        }
        return rv;
    }
    var toString = {}.toString;
    function toStringTag(o) {
        return toString.call(o).slice(8, -1);
    }
    var iteratorSymbol = typeof Symbol !== 'undefined' ?
        Symbol.iterator :
        '@@iterator';
    var getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () { return null; };
    function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0)
            a.splice(i, 1);
        return i >= 0;
    }
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike))
                return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                return [arrayLike];
            if ((it = getIteratorOf(arrayLike))) {
                a = [];
                while ((x = it.next()), !x.done)
                    a.push(x.value);
                return a;
            }
            if (arrayLike == null)
                return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--)
                    a[i] = arrayLike[i];
                return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
            a[i] = arguments[i];
        return a;
    }
    var isAsyncFunction = typeof Symbol !== 'undefined'
        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }
        : function () { return false; };

    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        toString: function () { return this.name + ": " + this.message; }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures)
            .map(function (key) { return failures[key].toString(); })
            .filter(function (v, i, s) { return s.indexOf(v) === i; })
            .join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + "Error", obj); }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function (obj, name) {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            }
            else if (typeof msgOrInner === 'string') {
                this.message = "".concat(msgOrInner).concat(!inner ? '' : '\n ' + inner);
                this.inner = inner || null;
            }
            else if (typeof msgOrInner === 'object') {
                this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", { get: function () {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function (obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() { }
    function mirror(val) { return val; }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
            return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined)
                arguments[0] = res;
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ?
                (res2 === undefined ? undefined : res2) :
                (extend(res, res2));
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            if (f2.apply(this, arguments) === false)
                return false;
            return f1.apply(this, arguments);
        };
    }
    function promisableChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while (i--)
                    args[i] = arguments[i];
                return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    var debug = typeof location !== 'undefined' &&
        /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
    }

    var INTERNAL = {};
    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?
        [] :
        (function () {
            var globalP = Promise.resolve();
            if (typeof crypto === 'undefined' || !crypto.subtle)
                return [globalP, getProto(globalP), globalP];
            var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
            return [
                nativeP,
                getProto(nativeP),
                globalP
            ];
        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
    }
    var asap = function (callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true,
    needsNewPhysicalTick = true,
    unhandledErrors = [],
    rejectingErrors = [],
    rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this._lib = false;
        var psd = (this._PSD = PSD);
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL)
                throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
                handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    var thenProp = {
        get: function () {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                var cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise(function (resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                if (this._consoleTask)
                    rv._consoleTask = this._consoleTask;
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function (value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ?
                thenProp :
                {
                    get: function () {
                        return value;
                    },
                    set: thenProp.set
                });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function (onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function (onRejected) {
            if (arguments.length === 1)
                return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function (err) {
                return err instanceof type ? handler(err) : PromiseReject(err);
            })
                : this.then(null, function (err) {
                    return err && err.name === type ? handler(err) : PromiseReject(err);
                });
        },
        finally: function (onFinally) {
            return this.then(function (value) {
                return DexiePromise.resolve(onFinally()).then(function () { return value; });
            }, function (err) {
                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });
            });
        },
        timeout: function (ms, msg) {
            var _this = this;
            return ms < Infinity ?
                new DexiePromise(function (resolve, reject) {
                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);
                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function () {
            var values = getArrayOf.apply(null, arguments)
                .map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                if (values.length === 0)
                    resolve([]);
                var remaining = values.length;
                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {
                    values[i] = x;
                    if (!--remaining)
                        resolve(values);
                }, reject); });
            });
        },
        resolve: function (value) {
            if (value instanceof DexiePromise)
                return value;
            if (value && typeof value.then === 'function')
                return new DexiePromise(function (resolve, reject) {
                    value.then(resolve, reject);
                });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
        },
        reject: PromiseReject,
        race: function () {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });
            });
        },
        PSD: {
            get: function () { return PSD; },
            set: function (value) { return PSD = value; }
        },
        totalEchoes: { get: function () { return totalEchoes; } },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function () { return asap; },
            set: function (value) { asap = value; }
        },
        rejectionMapper: {
            get: function () { return rejectionMapper; },
            set: function (value) { rejectionMapper = value; }
        },
        follow: function (fn, zoneProps) {
            return new DexiePromise(function (resolve, reject) {
                return newScope(function (resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function () {
                        var _this = this;
                        run_at_end_of_this_or_next_physical_tick(function () {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve) {
                    if (possiblePromises.length === 0)
                        resolve([]);
                    var remaining = possiblePromises.length;
                    var results = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: "fulfilled", value: value }; }, function (reason) { return results[i] = { status: "rejected", reason: reason }; })
                        .then(function () { return --remaining || resolve(results); }); });
                });
            });
        if (NativePromise.any && typeof AggregateError !== 'undefined')
            setProp(DexiePromise, "any", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve, reject) {
                    if (possiblePromises.length === 0)
                        reject(new AggregateError([]));
                    var remaining = possiblePromises.length;
                    var failures = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {
                        failures[i] = failure;
                        if (!--remaining)
                            reject(new AggregateError(failures));
                    }); });
                });
            });
        if (NativePromise.withResolvers)
            DexiePromise.withResolvers = NativePromise.withResolvers;
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(function (value) {
                if (promise._state !== null)
                    return;
                if (value === promise)
                    throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function (resolve, reject) {
                        value instanceof DexiePromise ?
                            value._then(resolve, reject) :
                            value.then(resolve, reject);
                    });
                }
                else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick)
                    endMicroTickScope();
            }, handleRejection.bind(null, promise));
        }
        catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
            return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
            endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function () {
                if (--numScheduledCalls === 0)
                    finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length)
                rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
                markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        }
        catch (e) {
            listener.reject(e);
        }
        finally {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function physicalTick() {
        usePSD(globalPSD, function () {
            beginMicroTickScope() && endMicroTickScope();
        });
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function (p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
            finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(function () {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))
            unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
            if (unhandledErrors[--i]._value === promise._value) {
                unhandledErrors.splice(i, 1);
                return;
            }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            }
            catch (e) {
                errorCatcher && errorCatcher(e);
            }
            finally {
                switchToZone(outerScope, false);
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
    }
    var task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject,
        } : {};
        if (props)
            extend(psd, props);
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
            psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id)
            task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits)
            return false;
        if (--task.awaits === 0)
            task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function (x) {
                decrementExpectedAwaits();
                return x;
            }, function (e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
            return;
        PSD = targetZone;
        if (currentZone === globalPSD)
            globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise.all = targetEnv.all;
                GlobalPromise.race = targetEnv.race;
                GlobalPromise.resolve = targetEnv.resolve;
                GlobalPromise.reject = targetEnv.reject;
                if (targetEnv.allSettled)
                    GlobalPromise.allSettled = targetEnv.allSettled;
                if (targetEnv.any)
                    GlobalPromise.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        }
        finally {
            switchToZone(outerScope, false);
        }
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait)
                incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                switchToZone(outerZone, false);
                if (cleanup)
                    queueMicrotask(decrementExpectedAwaits);
            }
        };
    }
    function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
                cb();
            }
            else {
                enqueueNativeMicroTask(cb);
            }
        }
        else {
            setTimeout(cb, 0);
        }
    }
    var rejection = DexiePromise.reject;

    function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
            if (db._state.openComplete) {
                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
            }
            if (!db._state.isBeingOpened) {
                if (!db._state.autoOpen)
                    return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });
        }
        else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            }
            catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db.close({ disableAutoOpen: false });
                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });
                }
                return rejection(ex);
            }
            return trans._promise(mode, function (resolve, reject) {
                return newScope(function () {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(function (result) {
                if (mode === 'readwrite')
                    try {
                        trans.idbtrans.commit();
                    }
                    catch (_a) { }
                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });
            });
        }
    }

    var DEXIE_VERSION = '4.0.10';
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var DBNAMES_DB = '__dbnames';
    var READONLY = 'readonly';
    var READWRITE = 'readwrite';

    function combine(filter1, filter2) {
        return filter1 ?
            filter2 ?
                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                filter1 :
            filter2;
    }

    var AnyRange = {
        type: 3 ,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
    };

    function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath)
            ? function (obj) {
                if (obj[keyPath] === undefined && (keyPath in obj)) {
                    obj = deepClone(obj);
                    delete obj[keyPath];
                }
                return obj;
            }
            : function (obj) { return obj; };
    }

    function Entity() {
        throw exceptions.Type();
    }

    function cmp(a, b) {
        try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
                if (ta === 'Array')
                    return 1;
                if (tb === 'Array')
                    return -1;
                if (ta === 'binary')
                    return 1;
                if (tb === 'binary')
                    return -1;
                if (ta === 'string')
                    return 1;
                if (tb === 'string')
                    return -1;
                if (ta === 'Date')
                    return 1;
                if (tb !== 'Date')
                    return NaN;
                return -1;
            }
            switch (ta) {
                case 'number':
                case 'Date':
                case 'string':
                    return a > b ? 1 : a < b ? -1 : 0;
                case 'binary': {
                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                }
                case 'Array':
                    return compareArrays(a, b);
            }
        }
        catch (_a) { }
        return NaN;
    }
    function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            var res = cmp(a[i], b[i]);
            if (res !== 0)
                return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
                return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function type(x) {
        var t = typeof x;
        if (t !== 'object')
            return t;
        if (ArrayBuffer.isView(x))
            return 'binary';
        var tsTag = toStringTag(x);
        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
    }
    function getUint8Array(a) {
        if (a instanceof Uint8Array)
            return a;
        if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
    }

    var Table =  (function () {
        function Table() {
        }
        Table.prototype._trans = function (mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask("Dexie: ".concat(mode === 'readonly' ? 'read' : 'write', " ").concat(this.name));
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName])
                    throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            var wasRootExec = beginMicroTickScope();
            try {
                var p = trans && trans.db._novip === this.db._novip ?
                    trans === PSD.trans ?
                        trans._promise(mode, checkTableInTransaction, writeLocked) :
                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :
                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
                if (task) {
                    p._consoleTask = task;
                    p = p.catch(function (err) {
                        console.trace(err);
                        return rejection(err);
                    });
                }
                return p;
            }
            finally {
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
        Table.prototype.get = function (keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
                return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null)
                return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans('readonly', function (trans) {
                return _this.core.get({ trans: trans, key: keyOrCrit })
                    .then(function (res) { return _this.hook.reading.fire(res); });
            }).then(cb);
        };
        Table.prototype.where = function (indexOrCrit) {
            if (typeof indexOrCrit === 'string')
                return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit))
                return new this.db.WhereClause(this, "[".concat(indexOrCrit.join('+'), "]"));
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
                return this
                    .where(keyPaths[0])
                    .equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                if (ix.compound &&
                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {
                    for (var i = 0; i < keyPaths.length; ++i) {
                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                            return false;
                    }
                    return true;
                }
                return false;
            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
                return this
                    .where(keyPathsInValidOrder)
                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));
            }
            if (!compoundIndex && debug)
                console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") +
                    "compound index [".concat(keyPaths.join('+'), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
                return cmp(a, b) === 0;
            }
            var _a = keyPaths.reduce(function (_a, keyPath) {
                var prevIndex = _a[0], prevFilterFn = _a[1];
                var index = idxByName[keyPath];
                var value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ?
                        combine(prevFilterFn, index && index.multi ?
                            function (x) {
                                var prop = getByKeyPath(x, keyPath);
                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });
                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })
                        : prevFilterFn
                ];
            }, [null, null]), idx = _a[0], filterFunction = _a[1];
            return idx ?
                this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                    .filter(filterFunction) :
                compoundIndex ?
                    this.filter(filterFunction) :
                    this.where(keyPaths).equals('');
        };
        Table.prototype.filter = function (filterFunction) {
            return this.toCollection().and(filterFunction);
        };
        Table.prototype.count = function (thenShortcut) {
            return this.toCollection().count(thenShortcut);
        };
        Table.prototype.offset = function (offset) {
            return this.toCollection().offset(offset);
        };
        Table.prototype.limit = function (numRows) {
            return this.toCollection().limit(numRows);
        };
        Table.prototype.each = function (callback) {
            return this.toCollection().each(callback);
        };
        Table.prototype.toArray = function (thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        };
        Table.prototype.toCollection = function () {
            return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table.prototype.orderBy = function (index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
                "[".concat(index.join('+'), "]") :
                index));
        };
        Table.prototype.reverse = function () {
            return this.toCollection().reverse();
        };
        Table.prototype.mapToClass = function (constructor) {
            var _a = this, db = _a.db, tableName = _a.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity) {
                constructor =  (function (_super) {
                    __extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(class_1.prototype, "db", {
                        get: function () { return db; },
                        enumerable: false,
                        configurable: true
                    });
                    class_1.prototype.table = function () { return tableName; };
                    return class_1;
                }(constructor));
            }
            var inheritedProps = new Set();
            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });
            }
            var readHook = function (obj) {
                if (!obj)
                    return obj;
                var res = Object.create(constructor.prototype);
                for (var m in obj)
                    if (!inheritedProps.has(m))
                        try {
                            res[m] = obj[m];
                        }
                        catch (_) { }
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        };
        Table.prototype.defineClass = function () {
            function Class(content) {
                extend(this, content);
            }
            return this.mapToClass(Class);
        };
        Table.prototype.add = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.update = function (keyOrObject, modifications) {
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined)
                    return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                return this.where(":id").equals(key).modify(modifications);
            }
            else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        };
        Table.prototype.put = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.delete = function (key) {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.clear = function () {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.bulkGet = function (keys) {
            var _this = this;
            return this._trans('readonly', function (trans) {
                return _this.core.getMany({
                    keys: keys,
                    trans: trans
                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });
            });
        };
        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToAdd = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToPut = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkUpdate = function (keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys = keysAndChanges.map(function (entry) { return entry.key; });
            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });
            var offsetMap = [];
            return this._trans('readwrite', function (trans) {
                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {
                    var resultKeys = [];
                    var resultObjs = [];
                    keysAndChanges.forEach(function (_a, idx) {
                        var key = _a.key, changes = _a.changes;
                        var obj = objs[idx];
                        if (obj) {
                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                                var keyPath = _b[_i];
                                var value = changes[keyPath];
                                if (keyPath === _this.schema.primKey.keyPath) {
                                    if (cmp(value, key) !== 0) {
                                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                                    }
                                }
                                else {
                                    setByKeyPath(obj, keyPath, value);
                                }
                            }
                            offsetMap.push(idx);
                            resultKeys.push(key);
                            resultObjs.push(obj);
                        }
                    });
                    var numEntries = resultKeys.length;
                    return coreTable
                        .mutate({
                        trans: trans,
                        type: 'put',
                        keys: resultKeys,
                        values: resultObjs,
                        updates: {
                            keys: keys,
                            changeSpecs: changeSpecs
                        }
                    })
                        .then(function (_a) {
                        var numFailures = _a.numFailures, failures = _a.failures;
                        if (numFailures === 0)
                            return numEntries;
                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                            var offset = _b[_i];
                            var mappedOffset = offsetMap[Number(offset)];
                            if (mappedOffset != null) {
                                var failure = failures[offset];
                                delete failures[offset];
                                failures[mappedOffset] = failure;
                            }
                        }
                        throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                    });
                });
            });
        };
        Table.prototype.bulkDelete = function (keys) {
            var _this = this;
            var numKeys = keys.length;
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });
            }).then(function (_a) {
                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                if (numFailures === 0)
                    return lastResult;
                throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
        };
        return Table;
    }());

    function Events(ctx) {
        var evs = {};
        var rv = function (eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            }
            else if (typeof (eventName) === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object')
                return addConfiguredEvents(eventName);
            if (!chainFunction)
                chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
                defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function (cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function (cb) {
                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                }
                else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        context.subscribers.forEach(function (fn) {
                            asap$1(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                }
                else
                    throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype: prototype });
        return constructor;
    }

    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        });
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) &&
            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
            return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans: trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index: index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        }
        else {
            var set_1 = {};
            var union = function (item, cursor, advance) {
                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]')
                        key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn(set_1, key)) {
                        set_1[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function (cursor) {
            if (cursor) {
                return cursor.start(function () {
                    var c = function () { return cursor.continue(); };
                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))
                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });
                    c();
                });
            }
        });
    }

    var PropModSymbol = Symbol();
    var PropModification =  (function () {
        function PropModification(spec) {
            Object.assign(this, spec);
        }
        PropModification.prototype.execute = function (value) {
            var _a;
            if (this.add !== undefined) {
                var term = this.add;
                if (isArray(term)) {
                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();
                }
                if (typeof term === 'number')
                    return (Number(value) || 0) + term;
                if (typeof term === 'bigint') {
                    try {
                        return BigInt(value) + term;
                    }
                    catch (_b) {
                        return BigInt(0) + term;
                    }
                }
                throw new TypeError("Invalid term ".concat(term));
            }
            if (this.remove !== undefined) {
                var subtrahend_1 = this.remove;
                if (isArray(subtrahend_1)) {
                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];
                }
                if (typeof subtrahend_1 === 'number')
                    return Number(value) - subtrahend_1;
                if (typeof subtrahend_1 === 'bigint') {
                    try {
                        return BigInt(value) - subtrahend_1;
                    }
                    catch (_c) {
                        return BigInt(0) - subtrahend_1;
                    }
                }
                throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];
            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {
                return this.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
        };
        return PropModification;
    }());

    var Collection =  (function () {
        function Collection() {
        }
        Collection.prototype._read = function (fn, cb) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readonly', fn).then(cb);
        };
        Collection.prototype._write = function (fn) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readwrite', fn, "locked");
        };
        Collection.prototype._addAlgorithm = function (fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection.prototype._iterate = function (fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection.prototype.clone = function (props) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props)
                extend(ctx, props);
            rv._ctx = ctx;
            return rv;
        };
        Collection.prototype.raw = function () {
            this._ctx.valueMapper = null;
            return this;
        };
        Collection.prototype.each = function (fn) {
            var ctx = this._ctx;
            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });
        };
        Collection.prototype.count = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                var coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans: trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(function (count) { return Math.min(count, ctx.limit); });
                }
                else {
                    var count = 0;
                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)
                        .then(function () { return count; });
                }
            }).then(cb);
        };
        Collection.prototype.sortBy = function (keyPath, cb) {
            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i)
                    return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return cmp(aVal, bVal) * order;
            }
            return this.toArray(function (a) {
                return a.sort(sorter);
            }).then(cb);
        };
        Collection.prototype.toArray = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    var valueMapper_1 = ctx.valueMapper;
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    }).then(function (_a) {
                        var result = _a.result;
                        return valueMapper_1 ? result.map(valueMapper_1) : result;
                    });
                }
                else {
                    var a_1 = [];
                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });
                }
            }, cb);
        };
        Collection.prototype.offset = function (offset) {
            var ctx = this._ctx;
            if (offset <= 0)
                return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function (cursor, advance) {
                        if (offsetLeft === 0)
                            return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(function () {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            }
            else {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function () { return (--offsetLeft < 0); };
                });
            }
            return this;
        };
        Collection.prototype.limit = function (numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function () {
                var rowsLeft = numRows;
                return function (cursor, advance, resolve) {
                    if (--rowsLeft <= 0)
                        advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        };
        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function (cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                }
                else {
                    return true;
                }
            });
            return this;
        };
        Collection.prototype.first = function (cb) {
            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.last = function (cb) {
            return this.reverse().first(cb);
        };
        Collection.prototype.filter = function (filterFunction) {
            addFilter(this._ctx, function (cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        };
        Collection.prototype.and = function (filter) {
            return this.filter(filter);
        };
        Collection.prototype.or = function (indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection.prototype.reverse = function () {
            this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
            if (this._ondirectionchange)
                this._ondirectionchange(this._ctx.dir);
            return this;
        };
        Collection.prototype.desc = function () {
            return this.reverse();
        };
        Collection.prototype.eachKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.key, cursor); });
        };
        Collection.prototype.eachUniqueKey = function (cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        };
        Collection.prototype.eachPrimaryKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
        };
        Collection.prototype.keys = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.key);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.primaryKeys = function (cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(function (trans) {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    });
                }).then(function (_a) {
                    var result = _a.result;
                    return result;
                }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.uniqueKeys = function (cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        };
        Collection.prototype.firstKey = function (cb) {
            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.lastKey = function (cb) {
            return this.reverse().firstKey(cb);
        };
        Collection.prototype.distinct = function () {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
                return this;
            var set = {};
            addFilter(this._ctx, function (cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        };
        Collection.prototype.modify = function (changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function (trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                }
                else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i];
                            var val = changes[keyPath];
                            var origVal = getByKeyPath(item, keyPath);
                            if (val instanceof PropModification) {
                                setByKeyPath(item, keyPath, val.execute(origVal));
                                anythingModified = true;
                            }
                            else if (origVal !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                var coreTable = ctx.table.core;
                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                var limit = 200;
                var modifyChunkSize = _this.db._options.modifyChunkSize;
                if (modifyChunkSize) {
                    if (typeof modifyChunkSize == 'object') {
                        limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;
                    }
                    else {
                        limit = modifyChunkSize;
                    }
                }
                var totalFailures = [];
                var successCount = 0;
                var failedKeys = [];
                var applyMutateResult = function (expectedCount, res) {
                    var failures = res.failures, numFailures = res.numFailures;
                    successCount += expectedCount - numFailures;
                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
                        var pos = _a[_i];
                        totalFailures.push(failures[pos]);
                    }
                };
                return _this.clone().primaryKeys().then(function (keys) {
                    var criteria = isPlainKeyRange(ctx) &&
                        ctx.limit === Infinity &&
                        (typeof changes !== 'function' || changes === deleteCallback) && {
                        index: ctx.index,
                        range: ctx.range
                    };
                    var nextChunk = function (offset) {
                        var count = Math.min(limit, keys.length - offset);
                        return coreTable.getMany({
                            trans: trans,
                            keys: keys.slice(offset, offset + count),
                            cache: "immutable"
                        }).then(function (values) {
                            var addValues = [];
                            var putValues = [];
                            var putKeys = outbound ? [] : null;
                            var deleteKeys = [];
                            for (var i = 0; i < count; ++i) {
                                var origValue = values[i];
                                var ctx_1 = {
                                    value: deepClone(origValue),
                                    primKey: keys[offset + i]
                                };
                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                    if (ctx_1.value == null) {
                                        deleteKeys.push(keys[offset + i]);
                                    }
                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                        deleteKeys.push(keys[offset + i]);
                                        addValues.push(ctx_1.value);
                                    }
                                    else {
                                        putValues.push(ctx_1.value);
                                        if (outbound)
                                            putKeys.push(keys[offset + i]);
                                    }
                                }
                            }
                            return Promise.resolve(addValues.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })
                                    .then(function (res) {
                                    for (var pos in res.failures) {
                                        deleteKeys.splice(parseInt(pos), 1);
                                    }
                                    applyMutateResult(addValues.length, res);
                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'put',
                                    keys: putKeys,
                                    values: putValues,
                                    criteria: criteria,
                                    changeSpec: typeof changes !== 'function'
                                        && changes,
                                    isAdditionalChunk: offset > 0
                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'delete',
                                    keys: deleteKeys,
                                    criteria: criteria,
                                    isAdditionalChunk: offset > 0
                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {
                                return keys.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(function () {
                        if (totalFailures.length > 0)
                            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys.length;
                    });
                });
            });
        };
        Collection.prototype.delete = function () {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) &&
                (ctx.isPrimKey || range.type === 3 ))
             {
                return this._write(function (trans) {
                    var primaryKey = ctx.table.core.schema.primaryKey;
                    var coreRange = range;
                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {
                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })
                            .then(function (_a) {
                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;
                            if (numFailures)
                                throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(deleteCallback);
        };
        return Collection;
    }());
    var deleteCallback = function (value, ctx) { return ctx.value = null; };

    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
            this.db = db;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
                try {
                    keyRange = keyRangeGenerator();
                }
                catch (ex) {
                    error = ex;
                }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ?
            new collectionOrWhereClause.Collection(collectionOrWhereClause) :
            collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function () { return rangeEqual(""); }).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toUpperCase(); } :
            function (s) { return s.toLowerCase(); };
    }
    function lowerFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toLowerCase(); } :
            function (s) { return s.toUpperCase(); };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0)
                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0)
                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0)
                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0)
                llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function (s) { return typeof s === 'string'; })) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
            var needleBounds = needles.map(function (needle) {
                return { lower: lower(needle), upper: upper(needle) };
            }).sort(function (a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
            direction = dir;
            nextKeySuffix = (dir === "next" ? "" : suffix);
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });
        c._ondirectionchange = function (direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function (cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string')
                return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            }
            else {
                var lowestPossibleCasing = null;
                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null)
                        firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                }
                else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2 ,
            lower: lower,
            upper: upper,
            lowerOpen: lowerOpen,
            upperOpen: upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1 ,
            lower: value,
            upper: value
        };
    }

    var WhereClause =  (function () {
        function WhereClause() {
        }
        Object.defineProperty(WhereClause.prototype, "Collection", {
            get: function () {
                return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
        });
        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if ((this._cmp(lower, upper) > 0) ||
                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                    return emptyCollection(this);
                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        };
        WhereClause.prototype.equals = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return rangeEqual(value); });
        };
        WhereClause.prototype.above = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, true); });
        };
        WhereClause.prototype.aboveOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, false); });
        };
        WhereClause.prototype.below = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });
        };
        WhereClause.prototype.belowOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value); });
        };
        WhereClause.prototype.startsWith = function (str) {
            if (typeof str !== 'string')
                return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        };
        WhereClause.prototype.startsWithIgnoreCase = function (str) {
            if (str === "")
                return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);
        };
        WhereClause.prototype.equalsIgnoreCase = function (str) {
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], "");
        };
        WhereClause.prototype.anyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, "");
        };
        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);
        };
        WhereClause.prototype.anyOf = function () {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
                set.sort(compare);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
                return emptyCollection(this);
            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });
            c._ondirectionchange = function (direction) {
                compare = (direction === "next" ?
                    _this._ascending :
                    _this._descending);
                set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (compare(key, set[i]) > 0) {
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                }
                else {
                    advance(function () { cursor.continue(set[i]); });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.notEqual = function (value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.noneOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return new this.Collection(this);
            try {
                set.sort(this._ascending);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function (res, val) { return res ?
                res.concat([[res[res.length - 1][1], val]]) :
                [[minKey, val]]; }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.inAnyRange = function (ranges, options) {
            var _this = this;
            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
                return emptyCollection(this);
            if (!ranges.every(function (range) {
                return range[0] !== undefined &&
                    range[1] !== undefined &&
                    ascending(range[0], range[1]) <= 0;
            })) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                var i = 0, l = ranges.length;
                for (; i < l; ++i) {
                    var range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l)
                    ranges.push(newRange);
                return ranges;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
            var set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            }
            catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ?
                function (key) { return ascending(key, set[rangePos][1]) > 0; } :
                function (key) { return ascending(key, set[rangePos][1]) >= 0; };
            var keyIsBeforeCurrentEntry = includeLowers ?
                function (key) { return descending(key, set[rangePos][0]) > 0; } :
                function (key) { return descending(key, set[rangePos][0]) >= 0; };
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });
            c._ondirectionchange = function (direction) {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                }
                else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (checkKey(key)) {
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                }
                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                }
                else {
                    advance(function () {
                        if (sortDirection === ascending)
                            cursor.continue(set[rangePos][0]);
                        else
                            cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.startsWithAnyOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function (s) { return typeof s === 'string'; })) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
                return emptyCollection(this);
            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));
        };
        return WhereClause;
    }());

    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            this._cmp = this._ascending = cmp;
            this._descending = function (a, b) { return cmp(b, a); };
            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };
            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };
            this._IDBKeyRange = db._deps.IDBKeyRange;
            if (!this._IDBKeyRange)
                throw new exceptions.MissingAPI();
        });
    }

    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation)
            event.stopPropagation();
        if (event.preventDefault)
            event.preventDefault();
    }

    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

    var Transaction =  (function () {
        function Transaction() {
        }
        Transaction.prototype._lock = function () {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
                PSD.lockOwnerFor = this;
            return this;
        };
        Transaction.prototype._unlock = function () {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global)
                    PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    }
                    catch (e) { }
                }
            }
            return this;
        };
        Transaction.prototype._locked = function () {
            return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction.prototype.create = function (idbtrans) {
            var _this = this;
            if (!this.mode)
                return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active)
                throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans ||
                (this.db.core
                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(function (ev) {
                preventDefault(ev);
                _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function (ev) {
                preventDefault(ev);
                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                _this.active = false;
                _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function () {
                _this.active = false;
                _this._resolve();
                if ('mutatedParts' in idbtrans) {
                    globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                }
            });
            return this;
        };
        Transaction.prototype._promise = function (mode, fn, bWriteLock) {
            var _this = this;
            if (mode === 'readwrite' && this.mode !== 'readwrite')
                return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
                return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise(function (resolve, reject) {
                    _this._blockedFuncs.push([function () {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                });
            }
            else if (bWriteLock) {
                return newScope(function () {
                    var p = new DexiePromise(function (resolve, reject) {
                        _this._lock();
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then)
                            rv.then(resolve, reject);
                    });
                    p.finally(function () { return _this._unlock(); });
                    p._lib = true;
                    return p;
                });
            }
            else {
                var p = new DexiePromise(function (resolve, reject) {
                    var rv = fn(resolve, reject, _this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        };
        Transaction.prototype._root = function () {
            return this.parent ? this.parent._root() : this;
        };
        Transaction.prototype.waitFor = function (promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(function () { return promise; });
            }
            else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while (root._waitingQueue.length)
                        (root._waitingQueue.shift())();
                    if (root._waitingFor)
                        store.get(-Infinity).onsuccess = spin;
                }());
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function (resolve, reject) {
                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        };
        Transaction.prototype.abort = function () {
            if (this.active) {
                this.active = false;
                if (this.idbtrans)
                    this.idbtrans.abort();
                this._reject(new exceptions.Abort());
            }
        };
        Transaction.prototype.table = function (tableName) {
            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
            if (hasOwn(memoizedTables, tableName))
                return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        };
        return Transaction;
    }());

    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function () {
                _this.active = false;
                _this.on.complete.fire();
            }, function (e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ?
                    _this.parent._reject(e) :
                    wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e);
            });
        });
    }

    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
            name: name,
            keyPath: keyPath,
            unique: unique,
            multi: multi,
            auto: auto,
            compound: compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ?
            keyPath :
            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
    }

    function createTableSchema(name, primKey, indexes) {
        return {
            name: name,
            primKey: primKey,
            indexes: indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })
        };
    }

    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    var getMaxKey = function (IdbKeyRange) {
        try {
            IdbKeyRange.only([[]]);
            getMaxKey = function () { return [[]]; };
            return [[]];
        }
        catch (e) {
            getMaxKey = function () { return maxString; };
            return maxString;
        }
    };

    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return function () { return undefined; };
        }
        else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split('.');
        if (split.length === 1) {
            return function (obj) { return obj[keyPath]; };
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }

    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }
    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ?
            ":id" :
            typeof keyPath === 'string' ?
                keyPath :
                "[".concat(keyPath.join('+'), "]");
    }
    function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db, trans) {
            var tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {
                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                        var compound = isArray(keyPath);
                        var outbound = keyPath == null;
                        var indexByKeyPath = {};
                        var result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound: outbound,
                                compound: compound,
                                keyPath: keyPath,
                                autoIncrement: autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })
                                .map(function (index) {
                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                var compound = isArray(keyPath);
                                var result = {
                                    name: name,
                                    compound: compound,
                                    keyPath: keyPath,
                                    unique: unique,
                                    multiEntry: multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3 )
                return null;
            if (range.type === 4 )
                throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === undefined ?
                upper === undefined ?
                    null :
                    IdbKeyRange.upperBound(upper, !!upperOpen) :
                upper === undefined ?
                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a) {
                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var outbound = store.keyPath == null;
                    var isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                        throw new Error("Invalid operation type: " + type);
                    var length = (keys || values || { length: 1 }).length;
                    if (keys && values && keys.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0)
                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                    var req;
                    var reqs = [];
                    var failures = [];
                    var numFailures = 0;
                    var errorHandler = function (event) {
                        ++numFailures;
                        preventDefault(event);
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4 )
                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });
                        if (range.type === 3 )
                            reqs.push(req = store.clear());
                        else
                            reqs.push(req = store.delete(makeIDBKeyRange(range)));
                    }
                    else {
                        var _a = isAddOrPut ?
                            outbound ?
                                [values, keys] :
                                [values, null] :
                            [keys, null], args1 = _a[0], args2 = _a[1];
                        if (isAddOrPut) {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = (args2 && args2[i] !== undefined ?
                                    store[type](args1[i], args2[i]) :
                                    store[type](args1[i])));
                                req.onerror = errorHandler;
                            }
                        }
                        else {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    var done = function (event) {
                        var lastResult = event.target.result;
                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });
                        resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: type === "delete" ? keys : reqs.map(function (req) { return req.result; }),
                            lastResult: lastResult
                        });
                    };
                    req.onerror = function (event) {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor(_a) {
                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ?
                        store :
                        store.index(index.name);
                    var direction = reverse ?
                        unique ?
                            "prevunique" :
                            "prev" :
                        unique ?
                            "nextunique" :
                            "next";
                    var req = values || !('openKeyCursor' in source) ?
                        source.openCursor(makeIDBKeyRange(range), direction) :
                        source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function (ev) {
                        var cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        var _cursorContinue = cursor.continue.bind(cursor);
                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey)
                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        var _cursorAdvance = cursor.advance.bind(cursor);
                        var doThrowCursorIsNotStarted = function () { throw new Error("Cursor not started"); };
                        var doThrowCursorIsStopped = function () { throw new Error("Cursor not stopped"); };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function () {
                            var _this = this;
                            var gotOne = 1;
                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });
                        };
                        cursor.start = function (callback) {
                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = function (value) {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            var guardedCallback = function () {
                                if (req.result) {
                                    try {
                                        callback();
                                    }
                                    catch (err) {
                                        cursor.fail(err);
                                    }
                                }
                                else {
                                    cursor.done = true;
                                    cursor.start = function () { throw new Error("Cursor behind last entry"); };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(function (ev) {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return function (request) {
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                        var nonInfinitLimit = limit === Infinity ? undefined : limit;
                        var index = query.index, range = query.range;
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0)
                            return resolve({ result: [] });
                        if (hasGetAll) {
                            var req = values ?
                                source.getAll(idbKeyRange, nonInfinitLimit) :
                                source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };
                            req.onerror = eventRejectHandler(reject);
                        }
                        else {
                            var count_1 = 0;
                            var req_1 = values || !('openKeyCursor' in source) ?
                                source.openCursor(idbKeyRange) :
                                source.openKeyCursor(idbKeyRange);
                            var result_1 = [];
                            req_1.onsuccess = function (event) {
                                var cursor = req_1.result;
                                if (!cursor)
                                    return resolve({ result: result_1 });
                                result_1.push(values ? cursor.value : cursor.primaryKey);
                                if (++count_1 === limit)
                                    return resolve({ result: result_1 });
                                cursor.continue();
                            };
                            req_1.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate: mutate,
                getMany: function (_a) {
                    var trans = _a.trans, keys = _a.keys;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var length = keys.length;
                        var result = new Array(length);
                        var keyCount = 0;
                        var callbackCount = 0;
                        var req;
                        var successHandler = function (event) {
                            var req = event.target;
                            if ((result[req._pos] = req.result) != null)
                                ;
                            if (++callbackCount === keyCount)
                                resolve(result);
                        };
                        var errorHandler = eventRejectHandler(reject);
                        for (var i = 0; i < length; ++i) {
                            var key = keys[i];
                            if (key != null) {
                                req = store.get(keys[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0)
                            resolve(result);
                    });
                },
                get: function (_a) {
                    var trans = _a.trans, key = _a.key;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var req = store.get(key);
                        req.onsuccess = function (event) { return resolve(event.target.result); };
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor: openCursor,
                count: function (_a) {
                    var query = _a.query, trans = _a.trans;
                    var index = query.index, range = query.range;
                    return new Promise(function (resolve, reject) {
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });
        var tableMap = {};
        tables.forEach(function (table) { return tableMap[table.name] = table; });
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table: function (name) {
                var result = tableMap[name];
                if (!result)
                    throw new Error("Table '".concat(name, "' not found"));
                return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema: schema
        };
    }

    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function (down, _a) {
            var create = _a.create;
            return (__assign(__assign({}, down), create(down)));
        }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore: dbcore
        };
    }
    function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function (table) {
            var tableName = table.name;
            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }

    function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function (tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function (obj) {
                var propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get: function () { return this.table(tableName); },
                            set: function (value) {
                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });
                            }
                        });
                    }
                    else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi(db, objs) {
        objs.forEach(function (obj) {
            for (var key in obj) {
                if (obj[key] instanceof db.Table)
                    delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db._storeNames.push('$meta');
        }
        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function () {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(function (tableName) {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);
            }
            else {
                generateMiddlewareStacks(db, idbUpgradeTrans);
                return getExistingVersion(db, trans, oldVersion)
                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })
                    .catch(rejectTransaction);
            }
        });
    }
    function patchCurrentVersion(db, idbUpgradeTrans) {
        createMissingTables(db._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {
            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');
        }
        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db._dbSchema);
        var _loop_1 = function (tableChange) {
            if (tableChange.change.length || tableChange.recreate) {
                console.warn("Unable to patch indexes of table ".concat(tableChange.name, " because it has changes on the type of index or primary key."));
                return { value: void 0 };
            }
            var store = idbUpgradeTrans.objectStore(tableChange.name);
            tableChange.add.forEach(function (idx) {
                if (debug)
                    console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange.name, ".").concat(idx.src));
                addIndex(store, idx);
            });
        };
        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {
            var tableChange = _a[_i];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    function getExistingVersion(db, trans, oldVersion) {
        if (trans.storeNames.includes('$meta')) {
            return trans.table('$meta').get('version').then(function (metaVersion) {
                return metaVersion != null ? metaVersion : oldVersion;
            });
        }
        else {
            return DexiePromise.resolve(oldVersion);
        }
    }
    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });
        if (versToRun.length === 0) {
            return DexiePromise.resolve();
        }
        versToRun.forEach(function (version) {
            queue.push(function () {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(function (tuple) {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(function (change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    }
                    else {
                        var store_1 = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });
                        change.change.forEach(function (idx) {
                            store_1.deleteIndex(idx.name);
                            addIndex(store_1, idx);
                        });
                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });
                    }
                });
                var contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    var upgradeSchema_1 = shallowClone(newSchema);
                    diff.del.forEach(function (table) {
                        upgradeSchema_1[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [db.Transaction.prototype]);
                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                    trans.schema = upgradeSchema_1;
                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync_1) {
                        incrementExpectedAwaits();
                    }
                    var returnValue_1;
                    var promiseFollowed = DexiePromise.follow(function () {
                        returnValue_1 = contentUpgrade(trans);
                        if (returnValue_1) {
                            if (contentUpgradeIsAsync_1) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue_1.then(decrementor, decrementor);
                            }
                        }
                    });
                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?
                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));
                }
            });
            queue.push(function (idbtrans) {
                var newSchema = version._cfg.dbschema;
                deleteRemovedTables(newSchema, idbtrans);
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
            queue.push(function (idbtrans) {
                if (db.idbdb.objectStoreNames.contains('$meta')) {
                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                        db.idbdb.deleteObjectStore('$meta');
                        delete db._dbSchema.$meta;
                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });
                    }
                    else {
                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');
                    }
                }
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                DexiePromise.resolve();
        }
        return runQueue().then(function () {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [],
            add: [],
            change: []
        };
        var table;
        for (table in oldSchema) {
            if (!newSchema[table])
                diff.del.push(table);
        }
        for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            }
            else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ((
                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                    (oldDef.primKey.auto !== newDef.primKey.auto)) {
                    change.recreate = true;
                    diff.change.push(change);
                }
                else {
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    var idxName = void 0;
                    for (idxName in oldIndexes) {
                        if (!newIndexes[idxName])
                            change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx)
                            change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src)
                            change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
            { autoIncrement: primKey.auto });
        indexes.forEach(function (idx) { return addIndex(store, idx); });
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function (tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                if (debug)
                    console.debug('Dexie: Creating missing table', tableName);
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function (storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));
    }
    function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
            !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
            [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map(function (index, indexNum) {
            index = index.trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
        });
    }

    var Version =  (function () {
        function Version() {
        }
        Version.prototype._parseStoresSpec = function (stores, outSchema) {
            keys(stores).forEach(function (tableName) {
                if (stores[tableName] !== null) {
                    var indexes = parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    primKey.unique = true;
                    if (primKey.multi)
                        throw new exceptions.Schema("Primary key cannot be multi-valued");
                    indexes.forEach(function (idx) {
                        if (idx.auto)
                            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!idx.keyPath)
                            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                    });
                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
                }
            });
        };
        Version.prototype.stores = function (stores) {
            var db = this.db;
            this._cfg.storesSource = this._cfg.storesSource ?
                extend(this._cfg.storesSource, stores) :
                stores;
            var versions = db._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function (version) {
                extend(storesSpec, version._cfg.storesSource);
                dbschema = (version._cfg.dbschema = {});
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        };
        Version.prototype.upgrade = function (upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
        };
        return Version;
    }());

    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }

    function getDbNamesTable(indexedDB, IDBKeyRange) {
        var dbNamesDB = indexedDB["_dbNamesDB"];
        if (!dbNamesDB) {
            dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                addons: [],
                indexedDB: indexedDB,
                IDBKeyRange: IDBKeyRange,
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB) {
        return indexedDB && typeof indexedDB.databases === "function";
    }
    function getDatabaseNames(_a) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        return hasDatabasesNative(indexedDB)
            ? Promise.resolve(indexedDB.databases()).then(function (infos) {
                return infos
                    .map(function (info) { return info.name; })
                    .filter(function (name) { return name !== DBNAMES_DB; });
            })
            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);
    }
    function _onDatabaseDeleted(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
    }

    function vip(fn) {
        return newScope(function () {
            PSD.letThrough = true;
            return fn();
        });
    }

    function idbReady() {
        var isSafari = !navigator.userAgentData &&
            /Safari\//.test(navigator.userAgent) &&
            !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
        var intervalId;
        return new Promise(function (resolve) {
            var tryIdb = function () { return indexedDB.databases().finally(resolve); };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
        }).finally(function () { return clearInterval(intervalId); });
    }

    var _a;
    function isEmptyRange(node) {
        return !("from" in node);
    }
    var RangeSet = function (fromOrTree, to) {
        if (this) {
            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        }
        else {
            var rv = new RangeSet();
            if (fromOrTree && ("d" in fromOrTree)) {
                extend(rv, fromOrTree);
            }
            return rv;
        }
    };
    props(RangeSet.prototype, (_a = {
            add: function (rangeSet) {
                mergeRanges(this, rangeSet);
                return this;
            },
            addKey: function (key) {
                addRange(this, key, key);
                return this;
            },
            addKeys: function (keys) {
                var _this = this;
                keys.forEach(function (key) { return addRange(_this, key, key); });
                return this;
            },
            hasKey: function (key) {
                var node = getRangeSetIterator(this).next(key).value;
                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;
            }
        },
        _a[iteratorSymbol] = function () {
            return getRangeSetIterator(this);
        },
        _a));
    function addRange(target, from, to) {
        var diff = cmp(from, to);
        if (isNaN(diff))
            return;
        if (diff > 0)
            throw RangeError();
        if (isEmptyRange(target))
            return extend(target, { from: from, to: to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp(to, target.from) < 0) {
            left
                ? addRange(left, from, to)
                : (target.l = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.to) > 0) {
            right
                ? addRange(right, from, to)
                : (target.r = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
        }
        if (cmp(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
            mergeRanges(target, left);
        }
        if (right && rightWasCutOff) {
            mergeRanges(target, right);
        }
    }
    function mergeRanges(target, newSet) {
        function _addRangeSet(target, _a) {
            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
            addRange(target, from, to);
            if (l)
                _addRangeSet(target, l);
            if (r)
                _addRangeSet(target, r);
        }
        if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
            return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
                return true;
            cmp(a.from, b.from) < 0
                ? (a = (nextResult1 = i1.next(b.from)).value)
                : (b = (nextResult2 = i2.next(a.from)).value);
        }
        return false;
    }
    function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
            next: function (key) {
                var keyProvided = arguments.length > 0;
                while (state) {
                    switch (state.s) {
                        case 0:
                            state.s = 1;
                            if (keyProvided) {
                                while (state.n.l && cmp(key, state.n.from) < 0)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                            else {
                                while (state.n.l)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                        case 1:
                            state.s = 2;
                            if (!keyProvided || cmp(key, state.n.to) <= 0)
                                return { value: state.n, done: false };
                        case 2:
                            if (state.n.r) {
                                state.s = 3;
                                state = { up: state, n: state.n.r, s: 0 };
                                continue;
                            }
                        case 3:
                            state = state.up;
                    }
                }
                return { done: true };
            },
        };
    }
    function rebalance(target) {
        var _a, _b;
        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
    }
    function computeDepth(_a) {
        var r = _a.r, l = _a.l;
        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
    }

    function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function (part) {
            if (target[part])
                mergeRanges(target[part], newSet[part]);
            else
                target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
    }

    function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });
    }

    var cache = {};

    var unsignaledParts = {};
    var isTaskEnqueued = false;
    function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function () {
                isTaskEnqueued = false;
                var parts = unsignaledParts;
                unsignaledParts = {};
                signalSubscribersNow(parts, false);
            }, 0);
        }
    }
    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }
        var queriesToSignal = new Set();
        if (updatedParts.all) {
            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {
                var tblCache = _a[_i];
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
        }
        else {
            for (var key in updatedParts) {
                var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
                if (parts) {
                    var dbName = parts[1], tableName = parts[2];
                    var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                    if (tblCache)
                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
                }
            }
        }
        queriesToSignal.forEach(function (requery) { return requery(); });
    }
    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {
            var _b = _a[_i], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
                var entry = entries_1[_c];
                if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });
                }
                else if (deleteAffectedCacheEntries) {
                    filteredEntries.push(entry);
                }
            }
            if (deleteAffectedCacheEntries)
                updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
                tblCache.queries.query[indexName] = filteredEntries;
            }
        }
    }

    function dexieOpen(db) {
        var state = db._state;
        var indexedDB = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
            return state.dbReadyPromise.then(function () { return state.dbOpenError ?
                rejection(state.dbOpenError) :
                db; });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
                throw new exceptions.DatabaseClosed('db.open() was cancelled');
        }
        var resolveDbReady = state.dbReadyResolve,
        upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {
            throwIfCancelled();
            if (!indexedDB)
                throw new exceptions.MissingAPI();
            var dbName = db.name;
            var req = state.autoSchema || !nativeVerToOpen ?
                indexedDB.open(dbName) :
                indexedDB.open(dbName, nativeVerToOpen);
            if (!req)
                throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db._fireOnBlocked);
            req.onupgradeneeded = wrap(function (e) {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db._options.allowEmptyDB) {
                    req.onerror = preventDefault;
                    upgradeTransaction.abort();
                    req.result.close();
                    var delreq = indexedDB.deleteDatabase(dbName);
                    delreq.onsuccess = delreq.onerror = wrap(function () {
                        reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                    });
                }
                else {
                    upgradeTransaction.onerror = eventRejectHandler(reject);
                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                    wasCreated = oldVer < 1;
                    db.idbdb = req.result;
                    if (schemaPatchMode) {
                        patchCurrentVersion(db, upgradeTransaction);
                    }
                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                }
            }, reject);
            req.onsuccess = wrap(function () {
                upgradeTransaction = null;
                var idbdb = db.idbdb = req.result;
                var objectStoreNames = slice(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                    try {
                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                        if (state.autoSchema)
                            readGlobalSchema(db, idbdb, tmpTrans);
                        else {
                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                                console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                                idbdb.close();
                                nativeVerToOpen = idbdb.version + 1;
                                schemaPatchMode = true;
                                return resolve(tryOpenDB());
                            }
                        }
                        generateMiddlewareStacks(db, tmpTrans);
                    }
                    catch (e) {
                    }
                connections.push(db);
                idbdb.onversionchange = wrap(function (ev) {
                    state.vcFired = true;
                    db.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap(function (ev) {
                    db.on("close").fire(ev);
                });
                if (wasCreated)
                    _onDatabaseCreated(db._deps, dbName);
                resolve();
            }, reject);
        }).catch(function (err) {
            switch (err === null || err === void 0 ? void 0 : err.name) {
                case "UnknownError":
                    if (state.PR1398_maxLoop > 0) {
                        state.PR1398_maxLoop--;
                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');
                        return tryOpenDB();
                    }
                    break;
                case "VersionError":
                    if (nativeVerToOpen > 0) {
                        nativeVerToOpen = 0;
                        return tryOpenDB();
                    }
                    break;
            }
            return DexiePromise.reject(err);
        }); };
        return DexiePromise.race([
            openCanceller,
            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function () {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);
                }
            });
        }).finally(function () {
            if (state.openCanceller === openCanceller) {
                state.onReadyBeingFired = null;
                state.isBeingOpened = false;
            }
        }).catch(function (err) {
            state.dbOpenError = err;
            try {
                upgradeTransaction && upgradeTransaction.abort();
            }
            catch (_a) { }
            if (openCanceller === state.openCanceller) {
                db._close();
            }
            return rejection(err);
        }).finally(function () {
            state.openComplete = true;
            resolveDbReady();
        }).then(function () {
            if (wasCreated) {
                var everything_1 = {};
                db.tables.forEach(function (table) {
                    table.schema.indexes.forEach(function (idx) {
                        if (idx.name)
                            everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);
                    });
                    everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet(-Infinity, [[[]]]);
                });
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
                signalSubscribersNow(everything_1, true);
            }
            return db;
        });
    }

    function awaitIterator(iterator) {
        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return function (val) {
                var next = getNext(val), value = next.value;
                return next.done ? value :
                    (!value || typeof value.then !== 'function' ?
                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                        value.then(onSuccess, onError));
            };
        }
        return step(callNext)();
    }

    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
            args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function () {
            var transless = PSD.transless || PSD;
            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            }
            else {
                try {
                    trans.create();
                    trans.idbtrans._explicit = true;
                    db._state.PR1398_maxLoop = 3;
                }
                catch (ex) {
                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                        console.warn('Dexie: Need to reopen db');
                        db.close({ disableAutoOpen: false });
                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });
                    }
                    return rejection(ex);
                }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function () {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    }
                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ?
                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?
                    x
                    : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")); })
                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {
                if (parentTransaction)
                    trans._resolve();
                return trans._completion.then(function () { return x; });
            }).catch(function (e) {
                trans._reject(e);
                return rejection(e);
            });
        });
    }

    function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [a];
        for (var i = 0; i < count; ++i)
            result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function (tableName) {
                var table = down.table(tableName);
                var schema = table.schema;
                var indexLookup = {};
                var allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    var keyPathAlias = getKeyPathAlias(keyPath);
                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    var isVirtual = keyTail > 0;
                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual
                            ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")")
                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        var virtualKeyPath = keyLength === 2 ?
                            keyPath[0] :
                            keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });
                    return virtualIndex;
                }
                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [primaryKey];
                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
                    var index = _a[_i];
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    var result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1  ?
                            2  :
                            range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    var index = req.query.index;
                    return index.isVirtual ? __assign(__assign({}, req), { query: {
                            index: index.lowLevelIndex,
                            range: translateRange(req.query.range, index.keyTail)
                        } }) : req;
                }
                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {
                        return table.count(translateRequest(req));
                    }, query: function (req) {
                        return table.query(translateRequest(req));
                    }, openCursor: function (req) {
                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                        if (!isVirtual)
                            return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ?
                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                    req.unique ?
                                        cursor.continue(cursor.key.slice(0, keyLength)
                                            .concat(req.reverse
                                            ? down.MIN_KEY
                                            : down.MAX_KEY, keyTail)) :
                                        cursor.continue();
                            }
                            var virtualCursor = Object.create(cursor, {
                                continue: { value: _continue },
                                continuePrimaryKey: {
                                    value: function (key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                primaryKey: {
                                    get: function () {
                                        return cursor.primaryKey;
                                    }
                                },
                                key: {
                                    get: function () {
                                        var key = cursor.key;
                                        return keyLength === 1 ?
                                            key[0] :
                                            key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get: function () {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req))
                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });
                    } });
                return result;
            } });
    }
    var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };

    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function (prop) {
            if (!hasOwn(b, prop)) {
                rv[prfx + prop] = undefined;
            }
            else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    var apTypeName = toStringTag(ap);
                    var bpTypeName = toStringTag(bp);
                    if (apTypeName !== bpTypeName) {
                        rv[prfx + prop] = b[prop];
                    }
                    else if (apTypeName === 'Object') {
                        getObjectDiff(ap, bp, rv, prfx + prop + '.');
                    }
                    else if (ap !== bp) {
                        rv[prfx + prop] = b[prop];
                    }
                }
                else if (ap !== bp)
                    rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach(function (prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }

    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete')
            return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }

    var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {
                var downTable = downCore.table(tableName);
                var primaryKey = downTable.schema.primaryKey;
                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {
                        var dxTrans = PSD.trans;
                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                        switch (req.type) {
                            case 'add':
                                if (creating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'put':
                                if (creating.fire === nop && updating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'delete':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'deleteRange':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            var dxTrans = PSD.trans;
                            var keys = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys)
                                throw new Error("Keys missing");
                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);
                            if (req.type !== 'delete')
                                req.values = __spreadArray([], req.values, true);
                            if (req.keys)
                                req.keys = __spreadArray([], req.keys, true);
                            return getExistingValues(downTable, req, keys).then(function (existingValues) {
                                var contexts = keys.map(function (key, i) {
                                    var existingValue = existingValues[i];
                                    var ctx = { onerror: null, onsuccess: null };
                                    if (req.type === 'delete') {
                                        deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    }
                                    else if (req.type === 'add' || existingValue === undefined) {
                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) {
                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                            }
                                        }
                                    }
                                    else {
                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges_1) {
                                            var requestedValue_1 = req.values[i];
                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {
                                                if (hasOwn(requestedValue_1, keyPath)) {
                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                }
                                                else {
                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                }
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(function (_a) {
                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                    for (var i = 0; i < keys.length; ++i) {
                                        var primKey = results ? results[i] : keys[i];
                                        var ctx = contexts[i];
                                        if (primKey == null) {
                                            ctx.onerror && ctx.onerror(failures[i]);
                                        }
                                        else {
                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                req.values[i] :
                                                primKey
                                            );
                                        }
                                    }
                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };
                                }).catch(function (error) {
                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })
                                .then(function (_a) {
                                var result = _a.result;
                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {
                                    if (res.numFailures > 0)
                                        return Promise.reject(res.failures[0]);
                                    if (result.length < limit) {
                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                    }
                                    else {
                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                                    }
                                });
                            });
                        }
                    } });
                return tableMiddleware;
            } })); }
    };
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add"
            ? Promise.resolve([])
            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
    }

    function getFromTransactionCache(keys, cache, clone) {
        try {
            if (!cache)
                return null;
            if (cache.keys.length < keys.length)
                return null;
            var result = [];
            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
                if (cmp(cache.keys[i], keys[j]) !== 0)
                    continue;
                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                ++j;
            }
            return result.length === keys.length ? result : null;
        }
        catch (_a) {
            return null;
        }
    }
    var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function (core) {
            return {
                table: function (tableName) {
                    var table = core.table(tableName);
                    return __assign(__assign({}, table), { getMany: function (req) {
                            if (!req.cache) {
                                return table.getMany(req);
                            }
                            var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                            if (cachedResult) {
                                return DexiePromise.resolve(cachedResult);
                            }
                            return table.getMany(req).then(function (res) {
                                req.trans["_cache"] = {
                                    keys: req.keys,
                                    values: req.cache === "clone" ? deepClone(res) : res,
                                };
                                return res;
                            });
                        }, mutate: function (req) {
                            if (req.type !== "add")
                                req.trans["_cache"] = null;
                            return table.mutate(req);
                        } });
                },
            };
        },
    };

    function isCachableContext(ctx, table) {
        return (ctx.trans.mode === 'readonly' &&
            !!ctx.subscr &&
            !ctx.trans.explicit &&
            ctx.trans.db._options.cache !== 'disabled' &&
            !table.schema.primaryKey.outbound);
    }

    function isCachableRequest(type, req) {
        switch (type) {
            case 'query':
                return req.values && !req.unique;
            case 'get':
                return false;
            case 'getMany':
                return false;
            case 'count':
                return false;
            case 'openCursor':
                return false;
        }
    }

    var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: function (core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {
                    if (PSD.subscr && mode !== 'readonly') {
                        throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
                    }
                    return core.transaction(stores, mode, options);
                }, table: function (tableName) {
                    var table = core.table(tableName);
                    var schema = table.schema;
                    var primaryKey = schema.primaryKey, indexes = schema.indexes;
                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });
                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {
                            var _a, _b;
                            var trans = req.trans;
                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                            var getRangeSet = function (indexName) {
                                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                return (mutatedParts[part] ||
                                    (mutatedParts[part] = new RangeSet()));
                            };
                            var pkRangeSet = getRangeSet("");
                            var delsRangeSet = getRangeSet(":dels");
                            var type = req.type;
                            var _c = req.type === "deleteRange"
                                ? [req.range]
                                : req.type === "delete"
                                    ? [req.keys]
                                    : req.values.length < 50
                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]
                                        : [], keys = _c[0], newObjs = _c[1];
                            var oldCache = req.trans["_cache"];
                            if (isArray(keys)) {
                                pkRangeSet.addKeys(keys);
                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;
                                if (!oldObjs) {
                                    delsRangeSet.addKeys(keys);
                                }
                                if (oldObjs || newObjs) {
                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                }
                            }
                            else if (keys) {
                                var range = {
                                    from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,
                                    to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                                };
                                delsRangeSet.add(range);
                                pkRangeSet.add(range);
                            }
                            else {
                                pkRangeSet.add(FULL_RANGE);
                                delsRangeSet.add(FULL_RANGE);
                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });
                            }
                            return table.mutate(req).then(function (res) {
                                if (keys && (req.type === 'add' || req.type === 'put')) {
                                    pkRangeSet.addKeys(res.results);
                                    if (indexesWithAutoIncPK) {
                                        indexesWithAutoIncPK.forEach(function (idx) {
                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });
                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });
                                            for (var i = 0, len = res.results.length; i < len; ++i) {
                                                idxVals[i][pkPos] = res.results[i];
                                            }
                                            getRangeSet(idx.name).addKeys(idxVals);
                                        });
                                    }
                                }
                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                                return res;
                            });
                        } });
                    var getRange = function (_a) {
                        var _b, _c;
                        var _d = _a.query, index = _d.index, range = _d.range;
                        return [
                            index,
                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),
                        ];
                    };
                    var readSubscribers = {
                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },
                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },
                        count: getRange,
                        query: getRange,
                        openCursor: getRange,
                    };
                    keys(readSubscribers).forEach(function (method) {
                        tableClone[method] = function (req) {
                            var subscr = PSD.subscr;
                            var isLiveQuery = !!subscr;
                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                            var obsSet = cachable
                                ? req.obsSet = {}
                                : subscr;
                            if (isLiveQuery) {
                                var getRangeSet = function (indexName) {
                                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                    return (obsSet[part] ||
                                        (obsSet[part] = new RangeSet()));
                                };
                                var pkRangeSet_1 = getRangeSet("");
                                var delsRangeSet_1 = getRangeSet(":dels");
                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {
                                    delsRangeSet_1.add(queriedRanges);
                                }
                                else {
                                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                }
                                if (!queriedIndex.isPrimaryKey) {
                                    if (method === "count") {
                                        delsRangeSet_1.add(FULL_RANGE);
                                    }
                                    else {
                                        var keysPromise_1 = method === "query" &&
                                            outbound &&
                                            req.values &&
                                            table.query(__assign(__assign({}, req), { values: false }));
                                        return table[method].apply(this, arguments).then(function (res) {
                                            if (method === "query") {
                                                if (outbound && req.values) {
                                                    return keysPromise_1.then(function (_a) {
                                                        var resultingKeys = _a.result;
                                                        pkRangeSet_1.addKeys(resultingKeys);
                                                        return res;
                                                    });
                                                }
                                                var pKeys = req.values
                                                    ? res.result.map(extractKey)
                                                    : res.result;
                                                if (req.values) {
                                                    pkRangeSet_1.addKeys(pKeys);
                                                }
                                                else {
                                                    delsRangeSet_1.addKeys(pKeys);
                                                }
                                            }
                                            else if (method === "openCursor") {
                                                var cursor_1 = res;
                                                var wantValues_1 = req.values;
                                                return (cursor_1 &&
                                                    Object.create(cursor_1, {
                                                        key: {
                                                            get: function () {
                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.key;
                                                            },
                                                        },
                                                        primaryKey: {
                                                            get: function () {
                                                                var pkey = cursor_1.primaryKey;
                                                                delsRangeSet_1.addKey(pkey);
                                                                return pkey;
                                                            },
                                                        },
                                                        value: {
                                                            get: function () {
                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.value;
                                                            },
                                                        },
                                                    }));
                                            }
                                            return res;
                                        });
                                    }
                                }
                            }
                            return table[method].apply(this, arguments);
                        };
                    });
                    return tableClone;
                } });
        },
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
                return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)
                ? key.forEach(function (key) { return rangeSet.addKey(key); })
                : rangeSet.addKey(key); };
            (oldObjs || newObjs).forEach(function (_, i) {
                var oldKey = oldObjs && extractKey(oldObjs[i]);
                var newKey = newObjs && extractKey(newObjs[i]);
                if (cmp(oldKey, newKey) !== 0) {
                    if (oldKey != null)
                        addKeyOrKeys(oldKey);
                    if (newKey != null)
                        addKeyOrKeys(newKey);
                }
            });
        }
        schema.indexes.forEach(addAffectedIndex);
    }

    function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
            return req;
        if (req.type === 'deleteRange') {
            return null;
        }
        var numBulkOps = req.keys
            ? req.keys.length
            : 'values' in req && req.values
                ? req.values.length
                : 1;
        if (res.numFailures === numBulkOps) {
            return null;
        }
        var clone = __assign({}, req);
        if (isArray(clone.keys)) {
            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });
        }
        if ('values' in clone && isArray(clone.values)) {
            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });
        }
        return clone;
    }

    function isAboveLower(key, range) {
        return range.lower === undefined
            ? true
            : range.lowerOpen
                ? cmp(key, range.lower) > 0
                : cmp(key, range.lower) >= 0;
    }
    function isBelowUpper(key, range) {
        return range.upper === undefined
            ? true
            : range.upperOpen
                ? cmp(key, range.upper) < 0
                : cmp(key, range.upper) <= 0;
    }
    function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
    }

    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
            return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function (result, op) {
            var modifedResult = result;
            var includedValues = [];
            if (op.type === 'add' || op.type === 'put') {
                var includedPKs = new RangeSet();
                for (var i = op.values.length - 1; i >= 0; --i) {
                    var value = op.values[i];
                    var pk = extractPrimKey(value);
                    if (includedPKs.hasKey(pk))
                        continue;
                    var key = extractIndex(value);
                    if (multiEntry && isArray(key)
                        ? key.some(function (k) { return isWithinRange(k, queryRange); })
                        : isWithinRange(key, queryRange)) {
                        includedPKs.addKey(pk);
                        includedValues.push(value);
                    }
                }
            }
            switch (op.type) {
                case 'add': {
                    var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);
                    modifedResult = result.concat(req.values
                        ? includedValues.filter(function (v) {
                            var key = extractPrimKey(v);
                            if (existingKeys_1.hasKey(key))
                                return false;
                            existingKeys_1.addKey(key);
                            return true;
                        })
                        : includedValues
                            .map(function (v) { return extractPrimKey(v); })
                            .filter(function (k) {
                            if (existingKeys_1.hasKey(k))
                                return false;
                            existingKeys_1.addKey(k);
                            return true;
                        }));
                    break;
                }
                case 'put': {
                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));
                    modifedResult = result
                        .filter(
                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })
                        .concat(
                    req.values
                        ? includedValues
                        : includedValues.map(function (v) { return extractPrimKey(v); }));
                    break;
                }
                case 'delete':
                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);
                    modifedResult = result.filter(function (item) {
                        return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                    });
                    break;
                case 'deleteRange':
                    var range_1 = op.range;
                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });
                    break;
            }
            return modifedResult;
        }, result);
        if (finalResult === result)
            return result;
        finalResult.sort(function (a, b) {
            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||
                cmp(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
                finalResult.length = req.limit;
            }
            else if (result.length === req.limit && finalResult.length < req.limit) {
                cacheEntry.dirty = true;
            }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
    }

    function areRangesEqual(r1, r2) {
        return (cmp(r1.lower, r2.lower) === 0 &&
            cmp(r1.upper, r2.upper) === 0 &&
            !!r1.lowerOpen === !!r2.lowerOpen &&
            !!r1.upperOpen === !!r2.upperOpen);
    }

    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === undefined)
            return lower2 !== undefined ? -1 : 0;
        if (lower2 === undefined)
            return 1;
        var c = cmp(lower1, lower2);
        if (c === 0) {
            if (lowerOpen1 && lowerOpen2)
                return 0;
            if (lowerOpen1)
                return 1;
            if (lowerOpen2)
                return -1;
        }
        return c;
    }
    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === undefined)
            return upper2 !== undefined ? 1 : 0;
        if (upper2 === undefined)
            return -1;
        var c = cmp(upper1, upper2);
        if (c === 0) {
            if (upperOpen1 && upperOpen2)
                return 0;
            if (upperOpen1)
                return -1;
            if (upperOpen2)
                return 1;
        }
        return c;
    }
    function isSuperRange(r1, r2) {
        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&
            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);
    }

    function findCompatibleQuery(dbName, tableName, type, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
            return [];
        var queries = tblCache.queries[type];
        if (!queries)
            return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ''];
        if (!entries)
            return [null, false, tblCache, null];
        switch (type) {
            case 'query':
                var equalEntry = entries.find(function (entry) {
                    return entry.req.limit === req.limit &&
                        entry.req.values === req.values &&
                        areRangesEqual(entry.req.query.range, req.query.range);
                });
                if (equalEntry)
                    return [
                        equalEntry,
                        true,
                        tblCache,
                        entries,
                    ];
                var superEntry = entries.find(function (entry) {
                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;
                    return (limit >= req.limit &&
                        (req.values ? entry.req.values : true) &&
                        isSuperRange(entry.req.query.range, req.query.range));
                });
                return [superEntry, false, tblCache, entries];
            case 'count':
                var countQuery = entries.find(function (entry) {
                    return areRangesEqual(entry.req.query.range, req.query.range);
                });
                return [countQuery, !!countQuery, tblCache, entries];
        }
    }

    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function () {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
                enqueForDeletion(cacheEntry, container);
            }
        });
    }
    function enqueForDeletion(cacheEntry, container) {
        setTimeout(function () {
            if (cacheEntry.subscribers.size === 0) {
                delArrayItem(container, cacheEntry);
            }
        }, 3000);
    }

    var cacheMiddleware = {
        stack: 'dbcore',
        level: 0,
        name: 'Cache',
        create: function (core) {
            var dbName = core.schema.name;
            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {
                    var idbtrans = core.transaction(stores, mode, options);
                    if (mode === 'readwrite') {
                        var ac_1 = new AbortController();
                        var signal = ac_1.signal;
                        var endTransaction = function (wasCommitted) { return function () {
                            ac_1.abort();
                            if (mode === 'readwrite') {
                                var affectedSubscribers_1 = new Set();
                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                                    var storeName = stores_1[_i];
                                    var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                                    if (tblCache) {
                                        var table = core.table(storeName);
                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });
                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {
                                                var entries = _b[_a];
                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                                    var entry = _d[_c];
                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                                        delArrayItem(entries, entry);
                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                    }
                                                }
                                            }
                                        }
                                        else if (ops.length > 0) {
                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });
                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                                                var entries = _f[_e];
                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                                    var entry = _h[_g];
                                                    if (entry.res != null &&
                                                        idbtrans.mutatedParts
    ) {
                                                        if (wasCommitted && !entry.dirty) {
                                                            var freezeResults = Object.isFrozen(entry.res);
                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                                            if (entry.dirty) {
                                                                delArrayItem(entries, entry);
                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                            }
                                                            else if (modRes !== entry.res) {
                                                                entry.res = modRes;
                                                                entry.promise = DexiePromise.resolve({ result: modRes });
                                                            }
                                                        }
                                                        else {
                                                            if (entry.dirty) {
                                                                delArrayItem(entries, entry);
                                                            }
                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                affectedSubscribers_1.forEach(function (requery) { return requery(); });
                            }
                        }; };
                        idbtrans.addEventListener('abort', endTransaction(false), {
                            signal: signal,
                        });
                        idbtrans.addEventListener('error', endTransaction(false), {
                            signal: signal,
                        });
                        idbtrans.addEventListener('complete', endTransaction(true), {
                            signal: signal,
                        });
                    }
                    return idbtrans;
                }, table: function (tableName) {
                    var downTable = core.table(tableName);
                    var primKey = downTable.schema.primaryKey;
                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {
                            var trans = PSD.trans;
                            if (primKey.outbound ||
                                trans.db._options.cache === 'disabled' ||
                                trans.explicit ||
                                trans.idbtrans.mode !== 'readwrite'
                            ) {
                                return downTable.mutate(req);
                            }
                            var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                            if (!tblCache)
                                return downTable.mutate(req);
                            var promise = downTable.mutate(req);
                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {
                                promise.then(function (res) {
                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {
                                            var _a;
                                            if (res.failures[i])
                                                return value;
                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))
                                                ? deepClone(value)
                                                : __assign({}, value);
                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                                            return valueWithKey;
                                        }) });
                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                                    tblCache.optimisticOps.push(adjustedReq);
                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });
                                });
                            }
                            else {
                                tblCache.optimisticOps.push(req);
                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                promise.then(function (res) {
                                    if (res.numFailures > 0) {
                                        delArrayItem(tblCache.optimisticOps, req);
                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                                        if (adjustedReq) {
                                            tblCache.optimisticOps.push(adjustedReq);
                                        }
                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                    }
                                });
                                promise.catch(function () {
                                    delArrayItem(tblCache.optimisticOps, req);
                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                });
                            }
                            return promise;
                        }, query: function (req) {
                            var _a;
                            if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                                return downTable.query(req);
                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';
                            var _b = PSD, requery = _b.requery, signal = _b.signal;
                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                            if (cacheEntry && exactMatch) {
                                cacheEntry.obsSet = req.obsSet;
                            }
                            else {
                                var promise = downTable.query(req).then(function (res) {
                                    var result = res.result;
                                    if (cacheEntry)
                                        cacheEntry.res = result;
                                    if (freezeResults) {
                                        for (var i = 0, l = result.length; i < l; ++i) {
                                            Object.freeze(result[i]);
                                        }
                                        Object.freeze(result);
                                    }
                                    else {
                                        res.result = deepClone(result);
                                    }
                                    return res;
                                }).catch(function (error) {
                                    if (container && cacheEntry)
                                        delArrayItem(container, cacheEntry);
                                    return Promise.reject(error);
                                });
                                cacheEntry = {
                                    obsSet: req.obsSet,
                                    promise: promise,
                                    subscribers: new Set(),
                                    type: 'query',
                                    req: req,
                                    dirty: false,
                                };
                                if (container) {
                                    container.push(cacheEntry);
                                }
                                else {
                                    container = [cacheEntry];
                                    if (!tblCache) {
                                        tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                                            queries: {
                                                query: {},
                                                count: {},
                                            },
                                            objs: new Map(),
                                            optimisticOps: [],
                                            unsignaledParts: {}
                                        };
                                    }
                                    tblCache.queries.query[req.query.index.name || ''] = container;
                                }
                            }
                            subscribeToCacheEntry(cacheEntry, container, requery, signal);
                            return cacheEntry.promise.then(function (res) {
                                return {
                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),
                                };
                            });
                        } });
                    return tableMW;
                } });
            return coreMW;
        },
    };

    function vipify(target, vipDb) {
        return new Proxy(target, {
            get: function (target, prop, receiver) {
                if (prop === 'db')
                    return vipDb;
                return Reflect.get(target, prop, receiver);
            }
        });
    }

    var Dexie$1 =  (function () {
        function Dexie(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie.dependencies;
            this._options = options = __assign({
                addons: Dexie.addons, autoOpen: true,
                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true,
                PR1398_maxLoop: 3,
                autoOpen: options.autoOpen,
            };
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
                return function (subscriber, bSticky) {
                    Dexie.vip(function () {
                        var state = _this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError)
                                DexiePromise.resolve().then(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else {
                            subscribe(subscriber);
                            var db_1 = _this;
                            if (!bSticky)
                                subscribe(function unsubscribe() {
                                    db_1.on.ready.unsubscribe(subscriber);
                                    db_1.on.ready.unsubscribe(unsubscribe);
                                });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function (ev) {
                if (ev.newVersion > 0)
                    console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
                else
                    console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
                _this.close({ disableAutoOpen: false });
            });
            this.on("blocked", function (ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                    console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
                else
                    console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };
            this._fireOnBlocked = function (ev) {
                _this.on("blocked").fire(ev);
                connections
                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })
                    .map(function (c) { return c.on("versionchange").fire(ev); });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
                get: function (_, prop, receiver) {
                    if (prop === '_vip')
                        return true;
                    if (prop === 'table')
                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };
                    var rv = Reflect.get(_, prop, receiver);
                    if (rv instanceof Table)
                        return vipify(rv, vipDB);
                    if (prop === 'tables')
                        return rv.map(function (t) { return vipify(t, vipDB); });
                    if (prop === '_createTransaction')
                        return function () {
                            var tx = rv.apply(this, arguments);
                            return vipify(tx, vipDB);
                        };
                    return rv;
                }
            });
            this.vip = vipDB;
            addons.forEach(function (addon) { return addon(_this); });
        }
        Dexie.prototype.version = function (versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
                throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
                throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];
            if (versionInstance)
                return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        };
        Dexie.prototype._whenReady = function (fn) {
            var _this = this;
            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {
                if (_this._state.openComplete) {
                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
                }
                if (!_this._state.isBeingOpened) {
                    if (!_this._state.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    _this.open().catch(nop);
                }
                _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        Dexie.prototype.use = function (_a) {
            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
            if (name)
                this.unuse({ stack: stack, name: name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });
            middlewares.sort(function (a, b) { return a.level - b.level; });
            return this;
        };
        Dexie.prototype.unuse = function (_a) {
            var stack = _a.stack, name = _a.name, create = _a.create;
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
                    return create ? mw.create !== create :
                        name ? mw.name !== name :
                            false;
                });
            }
            return this;
        };
        Dexie.prototype.open = function () {
            var _this = this;
            return usePSD(globalPSD,
            function () { return dexieOpen(_this); });
        };
        Dexie.prototype._close = function () {
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
                connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                }
                catch (e) { }
                this.idbdb = null;
            }
            if (!state.isBeingOpened) {
                state.dbReadyPromise = new DexiePromise(function (resolve) {
                    state.dbReadyResolve = resolve;
                });
                state.openCanceller = new DexiePromise(function (_, reject) {
                    state.cancelOpen = reject;
                });
            }
        };
        Dexie.prototype.close = function (_a) {
            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
                if (state.isBeingOpened) {
                    state.cancelOpen(new exceptions.DatabaseClosed());
                }
                this._close();
                state.autoOpen = false;
                state.dbOpenError = new exceptions.DatabaseClosed();
            }
            else {
                this._close();
                state.autoOpen = this._options.autoOpen ||
                    state.isBeingOpened;
                state.openComplete = false;
                state.dbOpenError = null;
            }
        };
        Dexie.prototype.delete = function (closeOptions) {
            var _this = this;
            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';
            var state = this._state;
            return new DexiePromise(function (resolve, reject) {
                var doDelete = function () {
                    _this.close(closeOptions);
                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                    req.onsuccess = wrap(function () {
                        _onDatabaseDeleted(_this._deps, _this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = _this._fireOnBlocked;
                };
                if (hasInvalidArguments)
                    throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                }
                else {
                    doDelete();
                }
            });
        };
        Dexie.prototype.backendDB = function () {
            return this.idbdb;
        };
        Dexie.prototype.isOpen = function () {
            return this.idbdb !== null;
        };
        Dexie.prototype.hasBeenClosed = function () {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
        };
        Dexie.prototype.hasFailed = function () {
            return this._state.dbOpenError !== null;
        };
        Dexie.prototype.dynamicallyOpened = function () {
            return this._state.autoSchema;
        };
        Object.defineProperty(Dexie.prototype, "tables", {
            get: function () {
                var _this = this;
                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });
            },
            enumerable: false,
            configurable: true
        });
        Dexie.prototype.transaction = function () {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            var idbMode, storeNames;
            try {
                storeNames = tables.map(function (table) {
                    var storeName = table instanceof _this.Table ? table.name : table;
                    if (typeof storeName !== 'string')
                        throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY)
                    idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE)
                    idbMode = READWRITE;
                else
                    throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        }
                        else
                            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function (storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Table " + storeName +
                                        " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            }
            catch (e) {
                return parentTransaction ?
                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :
                    rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return (parentTransaction ?
                parentTransaction._promise(idbMode, enterTransaction, "lock") :
                PSD.trans ?
                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :
                    this._whenReady(enterTransaction));
        };
        Dexie.prototype.table = function (tableName) {
            if (!hasOwn(this._allTables, tableName)) {
                throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
        };
        return Dexie;
    }());

    var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
        ? Symbol.observable
        : "@@observable";
    var Observable =  (function () {
        function Observable(subscribe) {
            this._subscribe = subscribe;
        }
        Observable.prototype.subscribe = function (x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error: error, complete: complete } : x);
        };
        Observable.prototype[symbolObservable] = function () {
            return this;
        };
        return Observable;
    }());

    var domDeps;
    try {
        domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
    }
    catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
    }

    function liveQuery(querier) {
        var hasValue = false;
        var currentValue;
        var observable = new Observable(function (observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(ctx) {
                var wasRootExec = beginMicroTickScope();
                try {
                    if (scopeFuncIsAsync) {
                        incrementExpectedAwaits();
                    }
                    var rv = newScope(querier, ctx);
                    if (scopeFuncIsAsync) {
                        rv = rv.finally(decrementExpectedAwaits);
                    }
                    return rv;
                }
                finally {
                    wasRootExec && endMicroTickScope();
                }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
                get closed() {
                    return closed;
                },
                unsubscribe: function () {
                    if (closed)
                        return;
                    closed = true;
                    if (abortController)
                        abortController.abort();
                    if (startedListening)
                        globalEvents.storagemutated.unsubscribe(mutationListener);
                },
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function () { return execInGlobalContext(_doQuery); };
            function shouldNotify() {
                return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function (parts) {
                extendObservabilitySet(accumMuts, parts);
                if (shouldNotify()) {
                    doQuery();
                }
            };
            var _doQuery = function () {
                if (closed ||
                    !domDeps.indexedDB)
                 {
                    return;
                }
                accumMuts = {};
                var subscr = {};
                if (abortController)
                    abortController.abort();
                abortController = new AbortController();
                var ctx = {
                    subscr: subscr,
                    signal: abortController.signal,
                    requery: doQuery,
                    querier: querier,
                    trans: null
                };
                var ret = execute(ctx);
                Promise.resolve(ret).then(function (result) {
                    hasValue = true;
                    currentValue = result;
                    if (closed || ctx.signal.aborted) {
                        return;
                    }
                    accumMuts = {};
                    currentObs = subscr;
                    if (!objectIsEmpty(currentObs) && !startedListening) {
                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                        startedListening = true;
                    }
                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });
                }, function (err) {
                    hasValue = false;
                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {
                        if (!closed)
                            execInGlobalContext(function () {
                                if (closed)
                                    return;
                                observer.error && observer.error(err);
                            });
                    }
                });
            };
            setTimeout(doQuery, 0);
            return subscription;
        });
        observable.hasValue = function () { return hasValue; };
        observable.getValue = function () { return currentValue; };
        return observable;
    }

    var Dexie = Dexie$1;
    props(Dexie, __assign(__assign({}, fullNameExceptions), {
        delete: function (databaseName) {
            var db = new Dexie(databaseName, { addons: [] });
            return db.delete();
        },
        exists: function (name) {
            return new Dexie(name, { addons: [] }).open().then(function (db) {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', function () { return false; });
        },
        getDatabaseNames: function (cb) {
            try {
                return getDatabaseNames(Dexie.dependencies).then(cb);
            }
            catch (_a) {
                return rejection(new exceptions.MissingAPI());
            }
        },
        defineClass: function () {
            function Class(content) {
                extend(this, content);
            }
            return Class;
        }, ignoreTransaction: function (scopeFunc) {
            return PSD.trans ?
                usePSD(PSD.transless, scopeFunc) :
                scopeFunc();
        }, vip: vip, async: function (generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function')
                        return DexiePromise.resolve(rv);
                    return rv;
                }
                catch (e) {
                    return rejection(e);
                }
            };
        }, spawn: function (generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: function () { return PSD.trans || null; }
        }, waitFor: function (promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                Dexie.ignoreTransaction(promiseOrFunction) :
                promiseOrFunction)
                .timeout(optionalTimeout || 60000);
            return PSD.trans ?
                PSD.trans.waitFor(promise) :
                promise;
        },
        Promise: DexiePromise,
        debug: {
            get: function () { return debug; },
            set: function (value) {
                setDebug(value);
            }
        },
        derive: derive, extend: extend, props: props, override: override,
        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,
        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: domDeps, cache: cache,
        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')
            .map(function (n) { return parseInt(n); })
            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {
            if (!propagatingLocally) {
                var event_1;
                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                    detail: updatedParts
                });
                propagatingLocally = true;
                dispatchEvent(event_1);
                propagatingLocally = false;
            }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {
            var detail = _a.detail;
            if (!propagatingLocally) {
                propagateLocally(detail);
            }
        });
    }
    function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
        }
        finally {
            propagatingLocally = wasMe;
        }
    }
    var propagatingLocally = false;

    var bc;
    var createBC = function () { };
    if (typeof BroadcastChannel !== 'undefined') {
        createBC = function () {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };
        };
        createBC();
        if (typeof bc.unref === 'function') {
            bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
            if (!propagatingLocally) {
                bc.postMessage(changedParts);
            }
        });
    }

    if (typeof addEventListener !== 'undefined') {
        addEventListener('pagehide', function (event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug)
                    console.debug('Dexie: handling persisted pagehide');
                bc === null || bc === void 0 ? void 0 : bc.close();
                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
                    var db = connections_1[_i];
                    db.close({ disableAutoOpen: false });
                }
            }
        });
        addEventListener('pageshow', function (event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug)
                    console.debug('Dexie: handling persisted pageshow');
                createBC();
                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });
            }
        });
    }

    function add(value) {
        return new PropModification({ add: value });
    }

    function remove(value) {
        return new PropModification({ remove: value });
    }

    function replacePrefix(a, b) {
        return new PropModification({ replacePrefix: [a, b] });
    }

    DexiePromise.rejectionMapper = mapError;
    setDebug(debug);

    var namedExports = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery,
        Entity: Entity,
        cmp: cmp,
        PropModSymbol: PropModSymbol,
        PropModification: PropModification,
        replacePrefix: replacePrefix,
        add: add,
        remove: remove,
        'default': Dexie$1,
        RangeSet: RangeSet,
        mergeRanges: mergeRanges,
        rangesOverlap: rangesOverlap
    });

    __assign(Dexie$1, namedExports, { default: Dexie$1 });

    return Dexie$1;

}));
//# sourceMappingURL=dexie.js.map


/***/ }),

/***/ "./node_modules/dexie/import-wrapper.mjs":
/*!***********************************************!*\
  !*** ./node_modules/dexie/import-wrapper.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dexie: () => (/* binding */ Dexie),
/* harmony export */   Entity: () => (/* binding */ Entity),
/* harmony export */   PropModSymbol: () => (/* binding */ PropModSymbol),
/* harmony export */   PropModification: () => (/* binding */ PropModification),
/* harmony export */   RangeSet: () => (/* binding */ RangeSet),
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   cmp: () => (/* binding */ cmp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   liveQuery: () => (/* binding */ liveQuery),
/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),
/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   replacePrefix: () => (/* binding */ replacePrefix)
/* harmony export */ });
/* harmony import */ var _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/dexie.js */ "./node_modules/dexie/dist/dexie.js");
// Making the module version consumable via require - to prohibit
// multiple occurrancies of the same module in the same app
// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)

const DexieSymbol = Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__);
if (_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer !== Dexie.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer} and ${Dexie.semVer}`);
}
const { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,
    PropModSymbol, PropModification, replacePrefix, add, remove } = Dexie;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dexie);


/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alwaysWrong: () => (/* binding */ alwaysWrong),
/* harmony export */   doNothing: () => (/* binding */ doNothing),
/* harmony export */   insertAtSortPosition: () => (/* binding */ insertAtSortPosition),
/* harmony export */   insertFirst: () => (/* binding */ insertFirst),
/* harmony export */   insertLast: () => (/* binding */ insertLast),
/* harmony export */   removeExisting: () => (/* binding */ removeExisting),
/* harmony export */   removeExistingAndInsertAtSortPosition: () => (/* binding */ removeExistingAndInsertAtSortPosition),
/* harmony export */   removeFirstInsertFirst: () => (/* binding */ removeFirstInsertFirst),
/* harmony export */   removeFirstInsertLast: () => (/* binding */ removeFirstInsertLast),
/* harmony export */   removeFirstItem: () => (/* binding */ removeFirstItem),
/* harmony export */   removeLastInsertFirst: () => (/* binding */ removeLastInsertFirst),
/* harmony export */   removeLastInsertLast: () => (/* binding */ removeLastInsertLast),
/* harmony export */   removeLastItem: () => (/* binding */ removeLastItem),
/* harmony export */   replaceExisting: () => (/* binding */ replaceExisting),
/* harmony export */   runFullQueryAgain: () => (/* binding */ runFullQueryAgain),
/* harmony export */   unknownAction: () => (/* binding */ unknownAction)
/* harmony export */ });
/* harmony import */ var array_push_at_sort_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! array-push-at-sort-position */ "./node_modules/array-push-at-sort-position/dist/esm/index.js");

const doNothing = (_input) => { };
const insertFirst = (input) => {
    input.previousResults.unshift(input.changeEvent.doc);
    if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
    }
};
const insertLast = (input) => {
    input.previousResults.push(input.changeEvent.doc);
    if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
    }
};
const removeFirstItem = (input) => {
    const first = input.previousResults.shift();
    if (input.keyDocumentMap && first) {
        input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);
    }
};
const removeLastItem = (input) => {
    const last = input.previousResults.pop();
    if (input.keyDocumentMap && last) {
        input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);
    }
};
const removeFirstInsertLast = (input) => {
    removeFirstItem(input);
    insertLast(input);
};
const removeLastInsertFirst = (input) => {
    removeLastItem(input);
    insertFirst(input);
};
const removeFirstInsertFirst = (input) => {
    removeFirstItem(input);
    insertFirst(input);
};
const removeLastInsertLast = (input) => {
    removeLastItem(input);
    insertLast(input);
};
const removeExisting = (input) => {
    if (input.keyDocumentMap) {
        input.keyDocumentMap.delete(input.changeEvent.id);
    }
    // find index of document
    const primary = input.queryParams.primaryKey;
    const results = input.previousResults;
    for (let i = 0; i < results.length; i++) {
        const item = results[i];
        // remove
        if (item[primary] === input.changeEvent.id) {
            results.splice(i, 1);
            break;
        }
    }
};
const replaceExisting = (input) => {
    // find index of document
    const doc = input.changeEvent.doc;
    const primary = input.queryParams.primaryKey;
    const results = input.previousResults;
    for (let i = 0; i < results.length; i++) {
        const item = results[i];
        // replace
        if (item[primary] === input.changeEvent.id) {
            results[i] = doc;
            if (input.keyDocumentMap) {
                input.keyDocumentMap.set(input.changeEvent.id, doc);
            }
            break;
        }
    }
};
/**
 * this function always returns wrong results
 * it must be later optimised out
 * otherwise there is something broken
 */
const alwaysWrong = (input) => {
    const wrongHuman = {
        _id: 'wrongHuman' + new Date().getTime()
    };
    input.previousResults.length = 0; // clear array
    input.previousResults.push(wrongHuman);
    if (input.keyDocumentMap) {
        input.keyDocumentMap.clear();
        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
    }
};
const insertAtSortPosition = (input) => {
    const docId = input.changeEvent.id;
    const doc = input.changeEvent.doc;
    if (input.keyDocumentMap) {
        if (input.keyDocumentMap.has(docId)) {
            /**
             * If document is already in results,
             * we cannot add it again because it would throw on non-deterministic ordering.
             */
            return;
        }
        input.keyDocumentMap.set(docId, doc);
    }
    else {
        const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);
        /**
         * If document is already in results,
         * we cannot add it again because it would throw on non-deterministic ordering.
         */
        if (isDocInResults) {
            return;
        }
    }
    (0,array_push_at_sort_position__WEBPACK_IMPORTED_MODULE_0__.pushAtSortPosition)(input.previousResults, doc, input.queryParams.sortComparator, 0);
};
const removeExistingAndInsertAtSortPosition = (input) => {
    removeExisting(input);
    insertAtSortPosition(input);
};
const runFullQueryAgain = (_input) => {
    throw new Error('Action runFullQueryAgain must be implemented by yourself');
};
const unknownAction = (_input) => {
    throw new Error('Action unknownAction should never be called');
};
//# sourceMappingURL=action-functions.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/actions/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/actions/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionFunctions: () => (/* binding */ actionFunctions),
/* harmony export */   alwaysWrong: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.alwaysWrong),
/* harmony export */   doNothing: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.doNothing),
/* harmony export */   insertAtSortPosition: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertAtSortPosition),
/* harmony export */   insertFirst: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertFirst),
/* harmony export */   insertLast: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertLast),
/* harmony export */   orderedActionList: () => (/* binding */ orderedActionList),
/* harmony export */   removeExisting: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeExisting),
/* harmony export */   removeExistingAndInsertAtSortPosition: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeExistingAndInsertAtSortPosition),
/* harmony export */   removeFirstInsertFirst: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertFirst),
/* harmony export */   removeFirstInsertLast: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertLast),
/* harmony export */   removeFirstItem: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstItem),
/* harmony export */   removeLastInsertFirst: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertFirst),
/* harmony export */   removeLastInsertLast: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertLast),
/* harmony export */   removeLastItem: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastItem),
/* harmony export */   replaceExisting: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.replaceExisting),
/* harmony export */   runFullQueryAgain: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.runFullQueryAgain),
/* harmony export */   unknownAction: () => (/* reexport safe */ _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.unknownAction)
/* harmony export */ });
/* harmony import */ var _action_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./action-functions.js */ "./node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js");


/**
 * all actions ordered by performance-cost
 * cheapest first
 * TODO run tests on which is really the fastest
 */
const orderedActionList = [
    'doNothing',
    'insertFirst',
    'insertLast',
    'removeFirstItem',
    'removeLastItem',
    'removeFirstInsertLast',
    'removeLastInsertFirst',
    'removeFirstInsertFirst',
    'removeLastInsertLast',
    'removeExisting',
    'replaceExisting',
    'alwaysWrong',
    'insertAtSortPosition',
    'removeExistingAndInsertAtSortPosition',
    'runFullQueryAgain',
    'unknownAction'
];
const actionFunctions = {
    doNothing: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.doNothing,
    insertFirst: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertFirst,
    insertLast: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertLast,
    removeFirstItem: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstItem,
    removeLastItem: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastItem,
    removeFirstInsertLast: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertLast,
    removeLastInsertFirst: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertFirst,
    removeFirstInsertFirst: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertFirst,
    removeLastInsertLast: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertLast,
    removeExisting: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeExisting,
    replaceExisting: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.replaceExisting,
    alwaysWrong: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.alwaysWrong,
    insertAtSortPosition: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.insertAtSortPosition,
    removeExistingAndInsertAtSortPosition: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeExistingAndInsertAtSortPosition,
    runFullQueryAgain: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.runFullQueryAgain,
    unknownAction: _action_functions_js__WEBPACK_IMPORTED_MODULE_0__.unknownAction
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js":
/*!************************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSimpleBdd: () => (/* binding */ getSimpleBdd),
/* harmony export */   minimalBddString: () => (/* binding */ minimalBddString),
/* harmony export */   resolveInput: () => (/* binding */ resolveInput)
/* harmony export */ });
/* harmony import */ var binary_decision_diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-decision-diagram */ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js");
/* harmony import */ var binary_decision_diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! binary-decision-diagram */ "./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js");
/* harmony import */ var _states_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../states/index.js */ "./node_modules/event-reduce-js/dist/esm/src/states/index.js");


const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9bf9bq9cg9ck9cn9nd9np9nq9nf9ng9nm9nk9mr9ms9mt9mj9mk9ml9mn9mc8{8}888mn88m8m4z4w4z44444m4v7yn77~777n777m77m7m7m5m5m55m555m55m5m552|2u2222x222|222222n2n222n2/an/bn/cn///////////,cn,,,,,,,ac0bc00000000000m-m-----------3333(((++++11*m*.';
let simpleBdd;
function getSimpleBdd() {
    if (!simpleBdd) {
        simpleBdd = (0,binary_decision_diagram__WEBPACK_IMPORTED_MODULE_0__.minimalStringToSimpleBdd)(minimalBddString);
    }
    return simpleBdd;
}
const resolveInput = (input) => {
    return (0,binary_decision_diagram__WEBPACK_IMPORTED_MODULE_1__.resolveWithSimpleBdd)(getSimpleBdd(), _states_index_js__WEBPACK_IMPORTED_MODULE_2__.stateResolveFunctionByIndex, input);
};
//# sourceMappingURL=bdd.generated.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionFunctions: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.actionFunctions),
/* harmony export */   alwaysWrong: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.alwaysWrong),
/* harmony export */   calculateActionFromMap: () => (/* binding */ calculateActionFromMap),
/* harmony export */   calculateActionFunction: () => (/* binding */ calculateActionFunction),
/* harmony export */   calculateActionName: () => (/* binding */ calculateActionName),
/* harmony export */   cloneMap: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.cloneMap),
/* harmony export */   doNothing: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.doNothing),
/* harmony export */   doesMatchNow: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow),
/* harmony export */   ensureNotFalsy: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy),
/* harmony export */   flatClone: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.flatClone),
/* harmony export */   getProperty: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.getProperty),
/* harmony export */   getSortFieldsOfQuery: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.getSortFieldsOfQuery),
/* harmony export */   getStateSet: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.getStateSet),
/* harmony export */   hasLimit: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.hasLimit),
/* harmony export */   hasSkip: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.hasSkip),
/* harmony export */   insertAtSortPosition: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.insertAtSortPosition),
/* harmony export */   insertFirst: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.insertFirst),
/* harmony export */   insertLast: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.insertLast),
/* harmony export */   isDelete: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isDelete),
/* harmony export */   isFindOne: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isFindOne),
/* harmony export */   isInsert: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isInsert),
/* harmony export */   isObject: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.isObject),
/* harmony export */   isSortedAfterLast: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast),
/* harmony export */   isSortedBeforeFirst: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst),
/* harmony export */   isUpdate: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.isUpdate),
/* harmony export */   lastOfArray: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.lastOfArray),
/* harmony export */   logStateSet: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.logStateSet),
/* harmony export */   mapToObject: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.mapToObject),
/* harmony export */   mergeSets: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.mergeSets),
/* harmony export */   normalizeSortField: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.normalizeSortField),
/* harmony export */   objectToMap: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.objectToMap),
/* harmony export */   orderedActionList: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.orderedActionList),
/* harmony export */   orderedStateList: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.orderedStateList),
/* harmony export */   randomOfArray: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.randomOfArray),
/* harmony export */   removeExisting: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeExisting),
/* harmony export */   removeExistingAndInsertAtSortPosition: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeExistingAndInsertAtSortPosition),
/* harmony export */   removeFirstInsertFirst: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeFirstInsertFirst),
/* harmony export */   removeFirstInsertLast: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeFirstInsertLast),
/* harmony export */   removeFirstItem: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeFirstItem),
/* harmony export */   removeLastInsertFirst: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeLastInsertFirst),
/* harmony export */   removeLastInsertLast: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeLastInsertLast),
/* harmony export */   removeLastItem: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.removeLastItem),
/* harmony export */   replaceCharAt: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.replaceCharAt),
/* harmony export */   replaceExisting: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.replaceExisting),
/* harmony export */   resolveState: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveState),
/* harmony export */   roundToTwoDecimals: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.roundToTwoDecimals),
/* harmony export */   runAction: () => (/* binding */ runAction),
/* harmony export */   runFullQueryAgain: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.runFullQueryAgain),
/* harmony export */   shuffleArray: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.shuffleArray),
/* harmony export */   sortParamsChanged: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged),
/* harmony export */   stateResolveFunctionByIndex: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.stateResolveFunctionByIndex),
/* harmony export */   stateResolveFunctions: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.stateResolveFunctions),
/* harmony export */   unknownAction: () => (/* reexport safe */ _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.unknownAction),
/* harmony export */   wasFirst: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasFirst),
/* harmony export */   wasInResult: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasInResult),
/* harmony export */   wasLast: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasLast),
/* harmony export */   wasLimitReached: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached),
/* harmony export */   wasMatching: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasMatching),
/* harmony export */   wasResultsEmpty: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty),
/* harmony export */   wasSortedAfterLast: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast),
/* harmony export */   wasSortedBeforeFirst: () => (/* reexport safe */ _states_index_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst)
/* harmony export */ });
/* harmony import */ var _states_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./states/index.js */ "./node_modules/event-reduce-js/dist/esm/src/states/index.js");
/* harmony import */ var _actions_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions/index.js */ "./node_modules/event-reduce-js/dist/esm/src/actions/index.js");
/* harmony import */ var _bdd_bdd_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bdd/bdd.generated.js */ "./node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/event-reduce-js/dist/esm/src/util.js");






function calculateActionFromMap(stateSetToActionMap, input) {
    const stateSet = (0,_states_index_js__WEBPACK_IMPORTED_MODULE_0__.getStateSet)(input);
    const actionName = stateSetToActionMap.get(stateSet);
    if (!actionName) {
        return {
            action: 'runFullQueryAgain',
            stateSet
        };
    }
    else {
        return {
            action: actionName,
            stateSet
        };
    }
}
function calculateActionName(input) {
    const resolvedActionId = (0,_bdd_bdd_generated_js__WEBPACK_IMPORTED_MODULE_3__.resolveInput)(input);
    return _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.orderedActionList[resolvedActionId];
}
function calculateActionFunction(input) {
    const actionName = calculateActionName(input);
    return _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.actionFunctions[actionName];
}
/**
 * for performance reasons,
 * @mutates the input
 * @returns the new results
 */
function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {
    const fn = _actions_index_js__WEBPACK_IMPORTED_MODULE_2__.actionFunctions[action];
    fn({
        queryParams,
        changeEvent,
        previousResults,
        keyDocumentMap
    });
    return previousResults;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/states/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/states/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doesMatchNow: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow),
/* harmony export */   getStateSet: () => (/* binding */ getStateSet),
/* harmony export */   hasLimit: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasLimit),
/* harmony export */   hasSkip: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasSkip),
/* harmony export */   isDelete: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isDelete),
/* harmony export */   isFindOne: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isFindOne),
/* harmony export */   isInsert: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isInsert),
/* harmony export */   isSortedAfterLast: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast),
/* harmony export */   isSortedBeforeFirst: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst),
/* harmony export */   isUpdate: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isUpdate),
/* harmony export */   logStateSet: () => (/* binding */ logStateSet),
/* harmony export */   orderedStateList: () => (/* binding */ orderedStateList),
/* harmony export */   resolveState: () => (/* binding */ resolveState),
/* harmony export */   sortParamsChanged: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged),
/* harmony export */   stateResolveFunctionByIndex: () => (/* binding */ stateResolveFunctionByIndex),
/* harmony export */   stateResolveFunctions: () => (/* binding */ stateResolveFunctions),
/* harmony export */   wasFirst: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasFirst),
/* harmony export */   wasInResult: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasInResult),
/* harmony export */   wasLast: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLast),
/* harmony export */   wasLimitReached: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached),
/* harmony export */   wasMatching: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasMatching),
/* harmony export */   wasResultsEmpty: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty),
/* harmony export */   wasSortedAfterLast: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast),
/* harmony export */   wasSortedBeforeFirst: () => (/* reexport safe */ _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst)
/* harmony export */ });
/* harmony import */ var _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-resolver.js */ "./node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js");


/**
 * all states ordered by performance-cost
 * cheapest first
 * TODO run tests on which is really the fastest
 */
const orderedStateList = [
    'isInsert',
    'isUpdate',
    'isDelete',
    'hasLimit',
    'isFindOne',
    'hasSkip',
    'wasResultsEmpty',
    'wasLimitReached',
    'wasFirst',
    'wasLast',
    'sortParamsChanged',
    'wasInResult',
    'wasSortedBeforeFirst',
    'wasSortedAfterLast',
    'isSortedBeforeFirst',
    'isSortedAfterLast',
    'wasMatching',
    'doesMatchNow'
];
const stateResolveFunctions = {
    isInsert: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isInsert,
    isUpdate: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isUpdate,
    isDelete: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isDelete,
    hasLimit: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasLimit,
    isFindOne: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isFindOne,
    hasSkip: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasSkip,
    wasResultsEmpty: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty,
    wasLimitReached: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached,
    wasFirst: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasFirst,
    wasLast: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLast,
    sortParamsChanged: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged,
    wasInResult: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasInResult,
    wasSortedBeforeFirst: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst,
    wasSortedAfterLast: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast,
    isSortedBeforeFirst: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst,
    isSortedAfterLast: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast,
    wasMatching: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasMatching,
    doesMatchNow: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow
};
const stateResolveFunctionByIndex = {
    0: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isInsert,
    1: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isUpdate,
    2: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isDelete,
    3: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasLimit,
    4: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isFindOne,
    5: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.hasSkip,
    6: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty,
    7: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached,
    8: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasFirst,
    9: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasLast,
    10: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged,
    11: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasInResult,
    12: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst,
    13: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast,
    14: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst,
    15: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast,
    16: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.wasMatching,
    17: _state_resolver_js__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow
};
function resolveState(stateName, input) {
    const fn = stateResolveFunctions[stateName];
    if (!fn) {
        throw new Error('resolveState() has no function for ' + stateName);
    }
    return fn(input);
}
function getStateSet(input) {
    let set = '';
    for (let i = 0; i < orderedStateList.length; i++) {
        const name = orderedStateList[i];
        const value = resolveState(name, input);
        const add = value ? '1' : '0';
        set += add;
    }
    return set;
}
function logStateSet(stateSet) {
    orderedStateList.forEach((state, index) => {
        console.log('state: ' + state + ' : ' + stateSet[index]);
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doesMatchNow: () => (/* binding */ doesMatchNow),
/* harmony export */   hasLimit: () => (/* binding */ hasLimit),
/* harmony export */   hasSkip: () => (/* binding */ hasSkip),
/* harmony export */   isDelete: () => (/* binding */ isDelete),
/* harmony export */   isFindOne: () => (/* binding */ isFindOne),
/* harmony export */   isInsert: () => (/* binding */ isInsert),
/* harmony export */   isSortedAfterLast: () => (/* binding */ isSortedAfterLast),
/* harmony export */   isSortedBeforeFirst: () => (/* binding */ isSortedBeforeFirst),
/* harmony export */   isUpdate: () => (/* binding */ isUpdate),
/* harmony export */   sortParamsChanged: () => (/* binding */ sortParamsChanged),
/* harmony export */   wasFirst: () => (/* binding */ wasFirst),
/* harmony export */   wasInResult: () => (/* binding */ wasInResult),
/* harmony export */   wasLast: () => (/* binding */ wasLast),
/* harmony export */   wasLimitReached: () => (/* binding */ wasLimitReached),
/* harmony export */   wasMatching: () => (/* binding */ wasMatching),
/* harmony export */   wasResultsEmpty: () => (/* binding */ wasResultsEmpty),
/* harmony export */   wasSortedAfterLast: () => (/* binding */ wasSortedAfterLast),
/* harmony export */   wasSortedBeforeFirst: () => (/* binding */ wasSortedBeforeFirst)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/event-reduce-js/dist/esm/src/util.js");

const hasLimit = (input) => {
    return !!input.queryParams.limit;
};
const isFindOne = (input) => {
    return input.queryParams.limit === 1;
};
const hasSkip = (input) => {
    if (input.queryParams.skip && input.queryParams.skip > 0) {
        return true;
    }
    else {
        return false;
    }
};
const isDelete = (input) => {
    return input.changeEvent.operation === 'DELETE';
};
const isInsert = (input) => {
    return input.changeEvent.operation === 'INSERT';
};
const isUpdate = (input) => {
    return input.changeEvent.operation === 'UPDATE';
};
const wasLimitReached = (input) => {
    return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;
};
const sortParamsChanged = (input) => {
    const sortFields = input.queryParams.sortFields;
    const prev = input.changeEvent.previous;
    const doc = input.changeEvent.doc;
    if (!doc) {
        return false;
    }
    if (!prev) {
        return true;
    }
    for (let i = 0; i < sortFields.length; i++) {
        const field = sortFields[i];
        const beforeData = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getProperty)(prev, field);
        const afterData = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getProperty)(doc, field);
        if (beforeData !== afterData) {
            return true;
        }
    }
    return false;
};
const wasInResult = (input) => {
    const id = input.changeEvent.id;
    if (input.keyDocumentMap) {
        const has = input.keyDocumentMap.has(id);
        return has;
    }
    else {
        const primary = input.queryParams.primaryKey;
        const results = input.previousResults;
        for (let i = 0; i < results.length; i++) {
            const item = results[i];
            if (item[primary] === id) {
                return true;
            }
        }
        return false;
    }
};
const wasFirst = (input) => {
    const first = input.previousResults[0];
    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    else {
        return false;
    }
};
const wasLast = (input) => {
    const last = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);
    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    else {
        return false;
    }
};
const wasSortedBeforeFirst = (input) => {
    const prev = input.changeEvent.previous;
    if (!prev) {
        return false;
    }
    const first = input.previousResults[0];
    if (!first) {
        return false;
    }
    /**
     * If the changed document is the same as the first,
     * we cannot sort-compare them, because it might end in a non-deterministic
     * sort order. Because both document could be equal.
     * So instead we have to return true.
     */
    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    const comp = input.queryParams.sortComparator(prev, first);
    return comp < 0;
};
const wasSortedAfterLast = (input) => {
    const prev = input.changeEvent.previous;
    if (!prev) {
        return false;
    }
    const last = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);
    if (!last) {
        return false;
    }
    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    const comp = input.queryParams.sortComparator(prev, last);
    return comp > 0;
};
const isSortedBeforeFirst = (input) => {
    const doc = input.changeEvent.doc;
    if (!doc) {
        return false;
    }
    const first = input.previousResults[0];
    if (!first) {
        return false;
    }
    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    const comp = input.queryParams.sortComparator(doc, first);
    return comp < 0;
};
const isSortedAfterLast = (input) => {
    const doc = input.changeEvent.doc;
    if (!doc) {
        return false;
    }
    const last = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);
    if (!last) {
        return false;
    }
    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
    }
    const comp = input.queryParams.sortComparator(doc, last);
    return comp > 0;
};
const wasMatching = (input) => {
    const prev = input.changeEvent.previous;
    if (!prev) {
        return false;
    }
    return input.queryParams.queryMatcher(prev);
};
const doesMatchNow = (input) => {
    const doc = input.changeEvent.doc;
    if (!doc) {
        return false;
    }
    const ret = input.queryParams.queryMatcher(doc);
    return ret;
};
const wasResultsEmpty = (input) => {
    return input.previousResults.length === 0;
};
//# sourceMappingURL=state-resolver.js.map

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/esm/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/esm/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneMap: () => (/* binding */ cloneMap),
/* harmony export */   ensureNotFalsy: () => (/* binding */ ensureNotFalsy),
/* harmony export */   flatClone: () => (/* binding */ flatClone),
/* harmony export */   getProperty: () => (/* binding */ getProperty),
/* harmony export */   getSortFieldsOfQuery: () => (/* binding */ getSortFieldsOfQuery),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   lastOfArray: () => (/* binding */ lastOfArray),
/* harmony export */   mapToObject: () => (/* binding */ mapToObject),
/* harmony export */   mergeSets: () => (/* binding */ mergeSets),
/* harmony export */   normalizeSortField: () => (/* binding */ normalizeSortField),
/* harmony export */   objectToMap: () => (/* binding */ objectToMap),
/* harmony export */   randomOfArray: () => (/* binding */ randomOfArray),
/* harmony export */   replaceCharAt: () => (/* binding */ replaceCharAt),
/* harmony export */   roundToTwoDecimals: () => (/* binding */ roundToTwoDecimals),
/* harmony export */   shuffleArray: () => (/* binding */ shuffleArray)
/* harmony export */ });
function lastOfArray(ar) {
    return ar[ar.length - 1];
}
/**
 * @link https://stackoverflow.com/a/5915122
 */
function randomOfArray(items) {
    return items[Math.floor(Math.random() * items.length)];
}
function shuffleArray(arr) {
    return arr.slice().sort(() => (Math.random() - 0.5));
}
/**
 * normalizes sort-field
 * in: '-age'
 * out: 'age'
 */
function normalizeSortField(field) {
    if (field.startsWith('-')) {
        return field.substr(1);
    }
    else {
        return field;
    }
}
function getSortFieldsOfQuery(query) {
    if (!query.sort) {
        // if no sort-order is set, use the primary key
        return ['_id'];
    }
    return query.sort.map(maybeArray => {
        if (Array.isArray(maybeArray)) {
            return maybeArray[0].map((field) => normalizeSortField(field));
        }
        else {
            return normalizeSortField(maybeArray);
        }
    });
}
/**
 *  @link https://stackoverflow.com/a/1431113
 */
function replaceCharAt(str, index, replacement) {
    return str.substr(0, index) + replacement + str.substr(index + replacement.length);
}
function mapToObject(map) {
    const ret = {};
    map.forEach((value, key) => {
        ret[key] = value;
    });
    return ret;
}
function objectToMap(object) {
    const ret = new Map();
    Object.entries(object).forEach(([k, v]) => {
        ret.set(k, v);
    });
    return ret;
}
function cloneMap(map) {
    const ret = new Map();
    map.forEach((value, key) => {
        ret[key] = value;
    });
    return ret;
}
/**
 * does a flat copy on the objects,
 * is about 3 times faster then using deepClone
 * @link https://jsperf.com/object-rest-spread-vs-clone/2
 */
function flatClone(obj) {
    return Object.assign({}, obj);
}
function ensureNotFalsy(obj) {
    if (!obj) {
        throw new Error('ensureNotFalsy() is falsy');
    }
    return obj;
}
function mergeSets(sets) {
    let ret = new Set();
    sets.forEach(set => {
        ret = new Set([...ret, ...set]);
    });
    return ret;
}
/**
 * @link https://stackoverflow.com/a/12830454/3443137
 */
function roundToTwoDecimals(num) {
    return parseFloat(num.toFixed(2));
}
function isObject(value) {
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
}
function getProperty(object, path, value) {
    if (Array.isArray(path)) {
        path = path.join('.');
    }
    if (!isObject(object) || typeof path !== 'string') {
        return value === undefined ? object : value;
    }
    const pathArray = path.split('.');
    if (pathArray.length === 0) {
        return value;
    }
    for (let index = 0; index < pathArray.length; index++) {
        const key = pathArray[index];
        if (isStringIndex(object, key)) {
            object = index === pathArray.length - 1 ? undefined : null;
        }
        else {
            object = object[key];
        }
        if (object === undefined || object === null) {
            // `object` is either `undefined` or `null` so we want to stop the loop, and
            // if this is not the last bit of the path, and
            // if it didn't return `undefined`
            // it would return `null` if `object` is `null`
            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
            if (index !== pathArray.length - 1) {
                return value;
            }
            break;
        }
    }
    return object === undefined ? value : object;
}
function isStringIndex(object, key) {
    if (typeof key !== 'number' && Array.isArray(object)) {
        const index = Number.parseInt(key, 10);
        return Number.isInteger(index) && object[index] === object[key];
    }
    return false;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/mingo/dist/esm/aggregator.js":
/*!***************************************************!*\
  !*** ./node_modules/mingo/dist/esm/aggregator.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Aggregator: () => (/* binding */ Aggregator)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");



class Aggregator {
  #pipeline;
  #options;
  constructor(pipeline, options) {
    this.#pipeline = pipeline;
    this.#options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);
  }
  /**
   * Returns an {@link Iterator} for lazy evaluation of the pipeline.
   *
   * @param collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection, options) {
    let iter = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(collection);
    const opts = options ?? this.#options;
    const mode = opts.processingMode;
    if (mode & _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_INPUT) iter.map(_util__WEBPACK_IMPORTED_MODULE_2__.cloneDeep);
    const stages = new Array();
    if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.#pipeline)) {
      for (const opExpr of this.#pipeline) {
        const opKeys = Object.keys(opExpr);
        const opName = opKeys[0];
        const call = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("pipeline", opName, opts);
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
          opKeys.length === 1 && !!call,
          `invalid pipeline operator ${opName}`
        );
        stages.push(opName);
        iter = call(iter, opExpr[opName], opts);
      }
    }
    if (mode & _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_OUTPUT) iter.map(_util__WEBPACK_IMPORTED_MODULE_2__.cloneDeep);
    return iter;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param collection
   */
  run(collection, options) {
    return this.stream(collection, options).value();
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/core.js":
/*!*********************************************!*\
  !*** ./node_modules/mingo/dist/esm/core.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComputeOptions: () => (/* binding */ ComputeOptions),
/* harmony export */   Context: () => (/* binding */ Context),
/* harmony export */   OperatorType: () => (/* binding */ OperatorType),
/* harmony export */   ProcessingMode: () => (/* binding */ ProcessingMode),
/* harmony export */   computeValue: () => (/* binding */ computeValue),
/* harmony export */   getOperator: () => (/* binding */ getOperator),
/* harmony export */   initOptions: () => (/* binding */ initOptions),
/* harmony export */   redact: () => (/* binding */ redact),
/* harmony export */   useOperators: () => (/* binding */ useOperators)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");

var ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {
  ProcessingMode2[ProcessingMode2["CLONE_OFF"] = 0] = "CLONE_OFF";
  ProcessingMode2[ProcessingMode2["CLONE_INPUT"] = 1] = "CLONE_INPUT";
  ProcessingMode2[ProcessingMode2["CLONE_OUTPUT"] = 2] = "CLONE_OUTPUT";
  ProcessingMode2[ProcessingMode2["CLONE_ALL"] = 3] = "CLONE_ALL";
  return ProcessingMode2;
})(ProcessingMode || {});
class ComputeOptions {
  #options;
  /** Reference to the root object when processing subgraphs of the object. */
  #root;
  #local;
  constructor(options, root, local) {
    this.#options = options;
    this.update(root, local);
  }
  /**
   * Initialize new ComputeOptions.
   * @returns {ComputeOptions}
   */
  static init(options, root, local) {
    return !(options instanceof ComputeOptions) ? new ComputeOptions(options, root, local) : new ComputeOptions(options.#options, options.root ?? root, {
      ...options.#local,
      ...local,
      variables: Object.assign(
        {},
        options.#local?.variables,
        local?.variables
      )
    });
  }
  /**
   * Updates the internal state.
   *
   * @param root The new root context for this object.
   * @param local The new local state to merge into current if it exists.
   * @returns
   */
  update(root, local) {
    this.#root = root;
    const variables = Object.assign(
      {},
      this.#local?.variables,
      local?.variables
    );
    if (Object.keys(variables).length) {
      this.#local = { ...local, variables };
    } else {
      this.#local = local ?? {};
    }
    return this;
  }
  getOptions() {
    return Object.freeze({
      ...this.#options,
      context: Context.from(this.#options.context)
    });
  }
  get root() {
    return this.#root;
  }
  get local() {
    return this.#local;
  }
  get idKey() {
    return this.#options.idKey;
  }
  get collation() {
    return this.#options?.collation;
  }
  get processingMode() {
    return this.#options?.processingMode || 0 /* CLONE_OFF */;
  }
  get useStrictMode() {
    return this.#options?.useStrictMode;
  }
  get scriptEnabled() {
    return this.#options?.scriptEnabled;
  }
  get useGlobalContext() {
    return this.#options?.useGlobalContext;
  }
  get hashFunction() {
    return this.#options?.hashFunction;
  }
  get collectionResolver() {
    return this.#options?.collectionResolver;
  }
  get jsonSchemaValidator() {
    return this.#options?.jsonSchemaValidator;
  }
  get variables() {
    return this.#options?.variables;
  }
  get context() {
    return this.#options?.context;
  }
}
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({
    idKey: "_id",
    scriptEnabled: true,
    useStrictMode: true,
    useGlobalContext: true,
    processingMode: 0 /* CLONE_OFF */,
    ...options,
    context: options?.context ? Context.from(options?.context) : Context.init()
  });
}
var OperatorType = /* @__PURE__ */ ((OperatorType2) => {
  OperatorType2["ACCUMULATOR"] = "accumulator";
  OperatorType2["EXPRESSION"] = "expression";
  OperatorType2["PIPELINE"] = "pipeline";
  OperatorType2["PROJECTION"] = "projection";
  OperatorType2["QUERY"] = "query";
  OperatorType2["WINDOW"] = "window";
  return OperatorType2;
})(OperatorType || {});
class Context {
  #operators = /* @__PURE__ */ new Map();
  constructor() {
  }
  static init() {
    return new Context();
  }
  static from(ctx) {
    const instance = Context.init();
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(ctx)) return instance;
    ctx.#operators.forEach((v, k) => instance.addOperators(k, v));
    return instance;
  }
  addOperators(type, operators) {
    if (!this.#operators.has(type)) this.#operators.set(type, {});
    for (const [name, fn] of Object.entries(operators)) {
      if (!this.getOperator(type, name)) {
        this.#operators.get(type)[name] = fn;
      }
    }
    return this;
  }
  getOperator(type, name) {
    const ops = this.#operators.get(type) ?? {};
    return ops[name] ?? null;
  }
  addAccumulatorOps(ops) {
    return this.addOperators("accumulator", ops);
  }
  addExpressionOps(ops) {
    return this.addOperators("expression", ops);
  }
  addQueryOps(ops) {
    return this.addOperators("query", ops);
  }
  addPipelineOps(ops) {
    return this.addOperators("pipeline", ops);
  }
  addProjectionOps(ops) {
    return this.addOperators("projection", ops);
  }
  addWindowOps(ops) {
    return this.addOperators("window", ops);
  }
}
const GLOBAL_CONTEXT = Context.init();
function useOperators(type, operators) {
  for (const [name, fn] of Object.entries(operators)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isOperator)(name),
      `'${name}' is not a valid operator`
    );
    const currentFn = getOperator(type, name, null);
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
      !currentFn || fn === currentFn,
      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`
    );
  }
  switch (type) {
    case "accumulator":
      GLOBAL_CONTEXT.addAccumulatorOps(operators);
      break;
    case "expression":
      GLOBAL_CONTEXT.addExpressionOps(operators);
      break;
    case "pipeline":
      GLOBAL_CONTEXT.addPipelineOps(operators);
      break;
    case "projection":
      GLOBAL_CONTEXT.addProjectionOps(operators);
      break;
    case "query":
      GLOBAL_CONTEXT.addQueryOps(operators);
      break;
    case "window":
      GLOBAL_CONTEXT.addWindowOps(operators);
      break;
  }
}
function getOperator(type, name, options) {
  const { context: ctx, useGlobalContext: fallback } = options || {};
  const fn = ctx ? ctx.getOperator(type, name) : null;
  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, name) : fn;
}
function computeValue(obj, expr, operator, options) {
  const copts = ComputeOptions.init(options, obj);
  return !!operator && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isOperator)(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);
}
const SYSTEM_VARS = ["$$ROOT", "$$CURRENT", "$$REMOVE", "$$NOW"];
function computeExpression(obj, expr, options) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) && expr.length > 0 && expr[0] === "$") {
    if (REDACT_ACTIONS.includes(expr)) return expr;
    let ctx = options.root;
    const arr = expr.split(".");
    if (SYSTEM_VARS.includes(arr[0])) {
      switch (arr[0]) {
        case "$$ROOT":
          break;
        case "$$CURRENT":
          ctx = obj;
          break;
        case "$$REMOVE":
          ctx = void 0;
          break;
        case "$$NOW":
          ctx = /* @__PURE__ */ new Date();
          break;
      }
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      ctx = Object.assign(
        {},
        // global vars
        options.variables,
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        // local vars
        options?.local?.variables
      );
      const name = arr[0].slice(2);
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(ctx, name), `Use of undefined variable: ${name}`);
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    return expr === "" ? ctx : (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(ctx, expr);
  }
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(expr)) {
    return expr.map((item) => computeExpression(obj, item, options));
  }
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(expr)) {
    const result = {};
    const elems = Object.entries(expr);
    for (const [key, val] of elems) {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isOperator)(key)) {
        (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(elems.length == 1, "expression must have single operator.");
        return computeOperator(obj, val, key, options);
      }
      result[key] = computeExpression(obj, val, options);
    }
    return result;
  }
  return expr;
}
function computeOperator(obj, expr, operator, options) {
  const callExpression = getOperator(
    "expression",
    operator,
    options
  );
  if (callExpression) return callExpression(obj, expr, options);
  const callAccumulator = getOperator(
    "accumulator",
    operator,
    options
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(!!callAccumulator, `accumulator '${operator}' is not registered.`);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj)) {
    obj = computeExpression(obj, expr, options);
    expr = null;
  }
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj), `arguments must resolve to array for ${operator}.`);
  return callAccumulator(obj, expr, options);
}
const REDACT_ACTIONS = ["$$KEEP", "$$PRUNE", "$$DESCEND"];
function redact(obj, expr, options) {
  const action = computeValue(obj, expr, null, options);
  switch (action) {
    case "$$KEEP":
      return obj;
    case "$$PRUNE":
      return void 0;
    case "$$DESCEND": {
      if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(expr, "$cond")) return obj;
      const output = {};
      for (const [key, value] of Object.entries(obj)) {
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
          const res = new Array();
          for (let elem of value) {
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(elem)) {
              elem = redact(elem, expr, options.update(elem));
            }
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(elem)) res.push(elem);
          }
          output[key] = res;
        } else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
          const res = redact(
            value,
            expr,
            options.update(value)
          );
          if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(res)) output[key] = res;
        } else {
          output[key] = value;
        }
      }
      return output;
    }
    default:
      return action;
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/cursor.js":
/*!***********************************************!*\
  !*** ./node_modules/mingo/dist/esm/cursor.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cursor: () => (/* binding */ Cursor)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _operators_pipeline_limit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./operators/pipeline/limit */ "./node_modules/mingo/dist/esm/operators/pipeline/limit.js");
/* harmony import */ var _operators_pipeline_project__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operators/pipeline/project */ "./node_modules/mingo/dist/esm/operators/pipeline/project.js");
/* harmony import */ var _operators_pipeline_skip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./operators/pipeline/skip */ "./node_modules/mingo/dist/esm/operators/pipeline/skip.js");
/* harmony import */ var _operators_pipeline_sort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./operators/pipeline/sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");







const OPERATORS = { $sort: _operators_pipeline_sort__WEBPACK_IMPORTED_MODULE_5__.$sort, $skip: _operators_pipeline_skip__WEBPACK_IMPORTED_MODULE_4__.$skip, $limit: _operators_pipeline_limit__WEBPACK_IMPORTED_MODULE_2__.$limit };
class Cursor {
  #source;
  #predicate;
  #projection;
  #options;
  #operators = {};
  #result = null;
  #buffer = [];
  constructor(source, predicate, projection, options) {
    this.#source = source;
    this.#predicate = predicate;
    this.#projection = projection;
    this.#options = options;
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.#result) return this.#result;
    this.#result = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(this.#source).filter(this.#predicate);
    const mode = this.#options.processingMode;
    if (mode & _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_INPUT) this.#result.map(_util__WEBPACK_IMPORTED_MODULE_6__.cloneDeep);
    for (const op of ["$sort", "$skip", "$limit"]) {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_6__.has)(this.#operators, op)) {
        this.#result = OPERATORS[op](
          this.#result,
          this.#operators[op],
          this.#options
        );
      }
    }
    if (Object.keys(this.#projection).length) {
      this.#result = (0,_operators_pipeline_project__WEBPACK_IMPORTED_MODULE_3__.$project)(this.#result, this.#projection, this.#options);
    }
    if (mode & _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_OUTPUT) this.#result.map(_util__WEBPACK_IMPORTED_MODULE_6__.cloneDeep);
    return this.#result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)([...this.#buffer]);
    this.#buffer = [];
    return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.concat)(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n) {
    this.#operators["$skip"] = n;
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n) {
    this.#operators["$limit"] = n;
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {AnyObject} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.#operators["$sort"] = modifier;
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.#options = { ...this.#options, collation: spec };
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {AnyObject | Boolean}
   */
  next() {
    if (this.#buffer.length > 0) {
      return this.#buffer.pop();
    }
    const o = this.fetch().next();
    if (o.done) return;
    return o.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.#buffer.length > 0) return true;
    const o = this.fetch().next();
    if (o.done) return false;
    this.#buffer.push(o.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn) {
    return this.all().map(fn);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn) {
    this.all().forEach(fn);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/lazy.js":
/*!*********************************************!*\
  !*** ./node_modules/mingo/dist/esm/lazy.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Iterator: () => (/* binding */ Iterator),
/* harmony export */   Lazy: () => (/* binding */ Lazy),
/* harmony export */   concat: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");

function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
function concat(...iterators) {
  let index = 0;
  return Lazy(() => {
    while (index < iterators.length) {
      const o = iterators[index].next();
      if (!o.done) return o;
      index++;
    }
    return { done: true };
  });
}
function isGenerator(o) {
  return !!o && typeof o === "object" && o?.next instanceof Function;
}
function dropItem(array, i) {
  const rest = array.slice(i + 1);
  array.splice(i);
  Array.prototype.push.apply(array, rest);
}
const DONE = new Error();
var Action = /* @__PURE__ */ ((Action2) => {
  Action2[Action2["MAP"] = 0] = "MAP";
  Action2[Action2["FILTER"] = 1] = "FILTER";
  Action2[Action2["TAKE"] = 2] = "TAKE";
  Action2[Action2["DROP"] = 3] = "DROP";
  return Action2;
})(Action || {});
function createCallback(nextFn, iteratees, buffer) {
  let done = false;
  let index = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer: while (!done) {
        let o = nextFn();
        index++;
        let i = -1;
        const size = iteratees.length;
        let innerDone = false;
        while (++i < size) {
          const r = iteratees[i];
          switch (r.action) {
            case 0 /* MAP */:
              o = r.func(o, index);
              break;
            case 1 /* FILTER */:
              if (!r.func(o, index)) continue outer;
              break;
            case 2 /* TAKE */:
              --r.count;
              if (!r.count) innerDone = true;
              break;
            case 3 /* DROP */:
              --r.count;
              if (!r.count) dropItem(iteratees, i);
              continue outer;
            default:
              break outer;
          }
        }
        done = innerDone;
        if (storeResult) {
          buffer[bufferIndex++] = o;
        } else {
          return { value: o, done: false };
        }
      }
    } catch (e) {
      if (e !== DONE) throw e;
    }
    done = true;
    return { done };
  };
}
class Iterator {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source) {
    this.#iteratees = [];
    this.#yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source instanceof Function) {
      source = { next: source };
    }
    if (isGenerator(source)) {
      const src = source;
      nextVal = () => {
        const o = src.next();
        if (o.done) throw DONE;
        return o.value;
      };
    } else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
      const data = source;
      const size = data.length;
      let index = 0;
      nextVal = () => {
        if (index < size) return data[index++];
        throw DONE;
      };
    } else if (!(source instanceof Function)) {
      throw new _util__WEBPACK_IMPORTED_MODULE_0__.MingoError(
        `Lazy must be initialized with an array, generator, or function.`
      );
    }
    this.#getNext = createCallback(
      nextVal,
      this.#iteratees,
      this.#yieldedValues
    );
  }
  #iteratees;
  #yieldedValues;
  #getNext;
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action, value) {
    if (typeof value === "function") {
      this.#iteratees.push({ action, func: value });
    } else if (typeof value === "number") {
      this.#iteratees.push({ action, count: value });
    }
    return this;
  }
  next() {
    return this.#getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f) {
    return this.push(0 /* MAP */, f);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(1 /* FILTER */, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n) {
    return n > 0 ? this.push(2 /* TAKE */, n) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n) {
    return n > 0 ? this.push(3 /* DROP */, n) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Callback<Source, Any[]>} fn Tranform function of type (Array) => (Any)
   */
  transform(fn) {
    const self = this;
    let iter;
    return Lazy(() => {
      if (!iter) {
        iter = Lazy(fn(self.value()));
      }
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.#getNext(true).done;
    }
    return this.#yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f) {
    for (; ; ) {
      const o = this.next();
      if (o.done) break;
      if (f(o.value) === false) return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f, initialValue) {
    let o = this.next();
    if (initialValue === void 0 && !o.done) {
      initialValue = o.value;
      o = this.next();
    }
    while (!o.done) {
      initialValue = f(initialValue, o.value);
      o = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce(
      (acc, _) => ++acc,
      0
    );
  }
  [Symbol.iterator]() {
    return this;
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/_predicates.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/_predicates.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $all: () => (/* binding */ $all),
/* harmony export */   $elemMatch: () => (/* binding */ $elemMatch),
/* harmony export */   $eq: () => (/* binding */ $eq),
/* harmony export */   $gt: () => (/* binding */ $gt),
/* harmony export */   $gte: () => (/* binding */ $gte),
/* harmony export */   $in: () => (/* binding */ $in),
/* harmony export */   $lt: () => (/* binding */ $lt),
/* harmony export */   $lte: () => (/* binding */ $lte),
/* harmony export */   $mod: () => (/* binding */ $mod),
/* harmony export */   $ne: () => (/* binding */ $ne),
/* harmony export */   $nin: () => (/* binding */ $nin),
/* harmony export */   $regex: () => (/* binding */ $regex),
/* harmony export */   $size: () => (/* binding */ $size),
/* harmony export */   $type: () => (/* binding */ $type),
/* harmony export */   createExpressionOperator: () => (/* binding */ createExpressionOperator),
/* harmony export */   createQueryOperator: () => (/* binding */ createQueryOperator)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/mingo/dist/esm/util.js");



function createQueryOperator(predicate) {
  const f = (selector, value, options) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = (0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(obj, selector, opts);
      return predicate(lhs, value, { ...options, depth });
    };
  };
  return f;
}
function createExpressionOperator(predicate) {
  return (obj, expr, options) => {
    const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
    return predicate(...args);
  };
}
function $eq(a, b, options) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(a, b)) return true;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(a) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(b)) return true;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(a)) {
    return a.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(v, b)) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(a, options?.depth).some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(v, b));
  }
  return false;
}
function $ne(a, b, options) {
  return !$eq(a, b, options);
}
function $in(a, b, options) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(a)) return b.some((v) => v === null);
  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.intersection)([(0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a), b], options?.hashFunction).length > 0;
}
function $nin(a, b, options) {
  return !$in(a, b, options);
}
function $lt(a, b, _options) {
  return compare(a, b, (x, y) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(x, y) < 0);
}
function $lte(a, b, _options) {
  return compare(a, b, (x, y) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(x, y) <= 0);
}
function $gt(a, b, _options) {
  return compare(a, b, (x, y) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(x, y) > 0);
}
function $gte(a, b, _options) {
  return compare(a, b, (x, y) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(x, y) >= 0);
}
function $mod(a, b, _options) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a).some(
    (x) => b.length === 2 && x % b[0] === b[1]
  );
}
function $regex(a, b, options) {
  const lhs = (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a);
  const match = (x) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(x) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.truthy)(b.exec(x), options?.useStrictMode);
  return lhs.some(match) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(lhs, 1).some(match);
}
function $all(values, queries, options) {
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(values) || !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query of queries) {
    if (!matched) break;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(query) && Object.keys(query).includes("$elemMatch")) {
      matched = $elemMatch(values, query["$elemMatch"], options);
    } else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(query)) {
      matched = values.some((s) => typeof s === "string" && query.test(s));
    } else {
      matched = values.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(query, v));
    }
  }
  return matched;
}
function $size(a, b, _options) {
  return Array.isArray(a) && a.length === b;
}
function isNonBooleanOperator(name) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.isOperator)(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch(a, b, options) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(a) && !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(a)) {
    let format = (x) => x;
    let criteria = b;
    if (Object.keys(b).every(isNonBooleanOperator)) {
      criteria = { temp: b };
      format = (x) => ({ temp: x });
    }
    const query = new _query__WEBPACK_IMPORTED_MODULE_1__.Query(criteria, options);
    for (let i = 0, len = a.length; i < len; i++) {
      if (query.test(format(a[i]))) {
        return true;
      }
    }
  }
  return false;
}
const isNull = (a) => a === null;
const compareFuncs = {
  array: _util__WEBPACK_IMPORTED_MODULE_2__.isArray,
  boolean: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,
  bool: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,
  date: _util__WEBPACK_IMPORTED_MODULE_2__.isDate,
  number: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  int: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  long: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  double: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  decimal: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  null: isNull,
  object: _util__WEBPACK_IMPORTED_MODULE_2__.isObject,
  regexp: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,
  regex: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,
  string: _util__WEBPACK_IMPORTED_MODULE_2__.isString,
  // added for completeness
  undefined: _util__WEBPACK_IMPORTED_MODULE_2__.isNil,
  // deprecated
  function: (_) => {
    throw new _util__WEBPACK_IMPORTED_MODULE_2__.MingoError("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  //double
  2: _util__WEBPACK_IMPORTED_MODULE_2__.isString,
  3: _util__WEBPACK_IMPORTED_MODULE_2__.isObject,
  4: _util__WEBPACK_IMPORTED_MODULE_2__.isArray,
  6: _util__WEBPACK_IMPORTED_MODULE_2__.isNil,
  // deprecated
  8: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,
  9: _util__WEBPACK_IMPORTED_MODULE_2__.isDate,
  10: isNull,
  11: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,
  16: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  //int
  18: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,
  //long
  19: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber
  //decimal
};
function compareType(a, b, _) {
  const f = compareFuncs[b];
  return f ? f(a) : false;
}
function $type(a, b, options) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);
}
function compare(a, b, f) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a).some((x) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(x) === (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(b) && f(x, b));
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/_internal.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/_internal.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   covariance: () => (/* binding */ covariance),
/* harmony export */   stddev: () => (/* binding */ stddev)
/* harmony export */ });
function stddev(data, sampled = true) {
  const sum = data.reduce((acc, n) => acc + n, 0);
  const N = data.length || 1;
  const avg = sum / N;
  return Math.sqrt(
    data.reduce((acc, n) => acc + Math.pow(n - avg, 2), 0) / (N - Number(sampled))
  );
}
function covariance(dataset, sampled = true) {
  if (!dataset) return null;
  if (dataset.length < 2) return sampled ? null : 0;
  let meanX = 0;
  let meanY = 0;
  for (const [x, y] of dataset) {
    meanX += x;
    meanY += y;
  }
  meanX /= dataset.length;
  meanY /= dataset.length;
  let result = 0;
  for (const [x, y] of dataset) {
    result += (x - meanX) * (y - meanY);
  }
  return result / (dataset.length - Number(sampled));
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/accumulator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/accumulator.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $accumulator: () => (/* binding */ $accumulator)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $accumulator = (collection, expr, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    !!options && options.scriptEnabled,
    "$accumulator operator requires 'scriptEnabled' option to be true"
  );
  if (collection.length == 0) return expr.initArgs;
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const initArgs = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    {},
    expr.initArgs || [],
    null,
    copts.update(copts?.local?.groupId || {})
  );
  let state = expr.init.call(null, ...initArgs);
  for (const doc of collection) {
    const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
      doc,
      expr.accumulateArgs,
      null,
      copts.update(doc)
    );
    state = expr.accumulate.call(null, ...[state, ...args]);
  }
  return expr.finalize ? expr.finalize.call(null, state) : state;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/addToSet.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/addToSet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $addToSet: () => (/* binding */ $addToSet)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $addToSet = (collection, expr, options) => {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.unique)(
    (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options),
    options?.hashFunction
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/avg.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/avg.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $avg: () => (/* binding */ $avg)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $avg = (collection, expr, options) => {
  const data = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber);
  const sum = data.reduce((acc, n) => acc + n, 0);
  return sum / (data.length || 1);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/bottom.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/bottom.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bottom: () => (/* binding */ $bottom)
/* harmony export */ });
/* harmony import */ var _bottomN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bottomN */ "./node_modules/mingo/dist/esm/operators/accumulator/bottomN.js");

const $bottom = (collection, expr, options) => (0,_bottomN__WEBPACK_IMPORTED_MODULE_0__.$bottomN)(collection, { ...expr, n: 1 }, options);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/bottomN.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/bottomN.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bottomN: () => (/* binding */ $bottomN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _pipeline_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pipeline/sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");




const $bottomN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const { n, sortBy } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    copts.local.groupId,
    expr,
    null,
    copts
  );
  const result = (0,_pipeline_sort__WEBPACK_IMPORTED_MODULE_2__.$sort)((0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(collection), sortBy, options).value();
  const m = result.length;
  const p = n;
  return (0,_push__WEBPACK_IMPORTED_MODULE_3__.$push)(m <= p ? result : result.slice(m - p), expr.output, copts);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/count.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/count.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $count: () => (/* binding */ $count)
/* harmony export */ });
const $count = (collection, _expr, _options) => collection.length;



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/covariancePop.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/covariancePop.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $covariancePop: () => (/* binding */ $covariancePop)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/accumulator/_internal.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $covariancePop = (collection, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_0__.covariance)((0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options), false);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/covarianceSamp.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/covarianceSamp.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $covarianceSamp: () => (/* binding */ $covarianceSamp)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/accumulator/_internal.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $covarianceSamp = (collection, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_0__.covariance)((0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options), true);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/first.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/first.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $first: () => (/* binding */ $first)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");

const $first = (collection, expr, options) => {
  if (collection.length === 0) return void 0;
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options).update(collection[0]);
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(collection[0], expr, null, copts);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/firstN.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/firstN.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $firstN: () => (/* binding */ $firstN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $firstN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const m = collection.length;
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(copts?.local?.groupId, expr.n, null, copts);
  return (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(
    m <= n ? collection : collection.slice(0, n),
    expr.input,
    options
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $accumulator: () => (/* reexport safe */ _accumulator__WEBPACK_IMPORTED_MODULE_0__.$accumulator),
/* harmony export */   $addToSet: () => (/* reexport safe */ _addToSet__WEBPACK_IMPORTED_MODULE_1__.$addToSet),
/* harmony export */   $avg: () => (/* reexport safe */ _avg__WEBPACK_IMPORTED_MODULE_2__.$avg),
/* harmony export */   $bottom: () => (/* reexport safe */ _bottom__WEBPACK_IMPORTED_MODULE_3__.$bottom),
/* harmony export */   $bottomN: () => (/* reexport safe */ _bottomN__WEBPACK_IMPORTED_MODULE_4__.$bottomN),
/* harmony export */   $count: () => (/* reexport safe */ _count__WEBPACK_IMPORTED_MODULE_5__.$count),
/* harmony export */   $covariancePop: () => (/* reexport safe */ _covariancePop__WEBPACK_IMPORTED_MODULE_6__.$covariancePop),
/* harmony export */   $covarianceSamp: () => (/* reexport safe */ _covarianceSamp__WEBPACK_IMPORTED_MODULE_7__.$covarianceSamp),
/* harmony export */   $first: () => (/* reexport safe */ _first__WEBPACK_IMPORTED_MODULE_8__.$first),
/* harmony export */   $firstN: () => (/* reexport safe */ _firstN__WEBPACK_IMPORTED_MODULE_9__.$firstN),
/* harmony export */   $last: () => (/* reexport safe */ _last__WEBPACK_IMPORTED_MODULE_10__.$last),
/* harmony export */   $lastN: () => (/* reexport safe */ _lastN__WEBPACK_IMPORTED_MODULE_11__.$lastN),
/* harmony export */   $max: () => (/* reexport safe */ _max__WEBPACK_IMPORTED_MODULE_12__.$max),
/* harmony export */   $maxN: () => (/* reexport safe */ _maxN__WEBPACK_IMPORTED_MODULE_13__.$maxN),
/* harmony export */   $median: () => (/* reexport safe */ _median__WEBPACK_IMPORTED_MODULE_14__.$median),
/* harmony export */   $mergeObjects: () => (/* reexport safe */ _mergeObjects__WEBPACK_IMPORTED_MODULE_15__.$mergeObjects),
/* harmony export */   $min: () => (/* reexport safe */ _min__WEBPACK_IMPORTED_MODULE_16__.$min),
/* harmony export */   $minN: () => (/* reexport safe */ _minN__WEBPACK_IMPORTED_MODULE_17__.$minN),
/* harmony export */   $percentile: () => (/* reexport safe */ _percentile__WEBPACK_IMPORTED_MODULE_18__.$percentile),
/* harmony export */   $push: () => (/* reexport safe */ _push__WEBPACK_IMPORTED_MODULE_19__.$push),
/* harmony export */   $stdDevPop: () => (/* reexport safe */ _stdDevPop__WEBPACK_IMPORTED_MODULE_20__.$stdDevPop),
/* harmony export */   $stdDevSamp: () => (/* reexport safe */ _stdDevSamp__WEBPACK_IMPORTED_MODULE_21__.$stdDevSamp),
/* harmony export */   $sum: () => (/* reexport safe */ _sum__WEBPACK_IMPORTED_MODULE_22__.$sum),
/* harmony export */   $top: () => (/* reexport safe */ _top__WEBPACK_IMPORTED_MODULE_23__.$top),
/* harmony export */   $topN: () => (/* reexport safe */ _topN__WEBPACK_IMPORTED_MODULE_24__.$topN)
/* harmony export */ });
/* harmony import */ var _accumulator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accumulator */ "./node_modules/mingo/dist/esm/operators/accumulator/accumulator.js");
/* harmony import */ var _addToSet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addToSet */ "./node_modules/mingo/dist/esm/operators/accumulator/addToSet.js");
/* harmony import */ var _avg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avg */ "./node_modules/mingo/dist/esm/operators/accumulator/avg.js");
/* harmony import */ var _bottom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bottom */ "./node_modules/mingo/dist/esm/operators/accumulator/bottom.js");
/* harmony import */ var _bottomN__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bottomN */ "./node_modules/mingo/dist/esm/operators/accumulator/bottomN.js");
/* harmony import */ var _count__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./count */ "./node_modules/mingo/dist/esm/operators/accumulator/count.js");
/* harmony import */ var _covariancePop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./covariancePop */ "./node_modules/mingo/dist/esm/operators/accumulator/covariancePop.js");
/* harmony import */ var _covarianceSamp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./covarianceSamp */ "./node_modules/mingo/dist/esm/operators/accumulator/covarianceSamp.js");
/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./first */ "./node_modules/mingo/dist/esm/operators/accumulator/first.js");
/* harmony import */ var _firstN__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./firstN */ "./node_modules/mingo/dist/esm/operators/accumulator/firstN.js");
/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./last */ "./node_modules/mingo/dist/esm/operators/accumulator/last.js");
/* harmony import */ var _lastN__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lastN */ "./node_modules/mingo/dist/esm/operators/accumulator/lastN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./max */ "./node_modules/mingo/dist/esm/operators/accumulator/max.js");
/* harmony import */ var _maxN__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./maxN */ "./node_modules/mingo/dist/esm/operators/accumulator/maxN.js");
/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./median */ "./node_modules/mingo/dist/esm/operators/accumulator/median.js");
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./mergeObjects */ "./node_modules/mingo/dist/esm/operators/accumulator/mergeObjects.js");
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./min */ "./node_modules/mingo/dist/esm/operators/accumulator/min.js");
/* harmony import */ var _minN__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./minN */ "./node_modules/mingo/dist/esm/operators/accumulator/minN.js");
/* harmony import */ var _percentile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./percentile */ "./node_modules/mingo/dist/esm/operators/accumulator/percentile.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");
/* harmony import */ var _stdDevPop__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./stdDevPop */ "./node_modules/mingo/dist/esm/operators/accumulator/stdDevPop.js");
/* harmony import */ var _stdDevSamp__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./stdDevSamp */ "./node_modules/mingo/dist/esm/operators/accumulator/stdDevSamp.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./node_modules/mingo/dist/esm/operators/accumulator/sum.js");
/* harmony import */ var _top__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./top */ "./node_modules/mingo/dist/esm/operators/accumulator/top.js");
/* harmony import */ var _topN__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./topN */ "./node_modules/mingo/dist/esm/operators/accumulator/topN.js");



























/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/last.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/last.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $last: () => (/* binding */ $last)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");

const $last = (collection, expr, options) => {
  if (collection.length === 0) return void 0;
  const obj = collection[collection.length - 1];
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options).update(obj);
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, copts);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/lastN.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/lastN.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lastN: () => (/* binding */ $lastN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $lastN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const m = collection.length;
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(copts?.local?.groupId, expr.n, null, copts);
  return (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(
    m <= n ? collection : collection.slice(m - n),
    expr.input,
    options
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/max.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/max.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $max: () => (/* binding */ $max)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $max = (collection, expr, options) => {
  const items = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(items)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(items), "$max: input must resolve to array");
  let max = items[0];
  for (const n of items) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(n) || isNaN(n)) continue;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(n, max) >= 0) max = n;
  }
  return max;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/maxN.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/maxN.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $maxN: () => (/* binding */ $maxN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");



const $maxN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const m = collection.length;
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(copts?.local?.groupId, expr.n, null, copts);
  const arr = (0,_push__WEBPACK_IMPORTED_MODULE_2__.$push)(collection, expr.input, options).filter((o) => !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(o));
  arr.sort((a, b) => -1 * (0,_util__WEBPACK_IMPORTED_MODULE_1__.compare)(a, b));
  return m <= n ? arr : arr.slice(0, n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/median.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/median.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $median: () => (/* binding */ $median)
/* harmony export */ });
/* harmony import */ var _percentile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./percentile */ "./node_modules/mingo/dist/esm/operators/accumulator/percentile.js");

const $median = (collection, expr, options) => (0,_percentile__WEBPACK_IMPORTED_MODULE_0__.$percentile)(collection, { ...expr, p: [0.5] }, options).pop();



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/mergeObjects.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/mergeObjects.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mergeObjects: () => (/* binding */ $mergeObjects)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _expression_object_mergeObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expression/object/mergeObjects */ "./node_modules/mingo/dist/esm/operators/expression/object/mergeObjects.js");


const $mergeObjects = (collection, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(collection, expr, null, options);
  return (0,_expression_object_mergeObjects__WEBPACK_IMPORTED_MODULE_1__.$mergeObjects)(null, arr, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/min.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/min.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $min: () => (/* binding */ $min)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $min = (collection, expr, options) => {
  const items = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(items)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(items), "$min: input must resolve to array");
  let min = items[0];
  for (const n of items) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(n) || isNaN(n)) continue;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(n, min) <= 0) min = n;
  }
  return min;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/minN.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/minN.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $minN: () => (/* binding */ $minN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");



const $minN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const m = collection.length;
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(copts?.local?.groupId, expr.n, null, copts);
  const arr = (0,_push__WEBPACK_IMPORTED_MODULE_2__.$push)(collection, expr.input, options).filter((o) => !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(o));
  arr.sort(_util__WEBPACK_IMPORTED_MODULE_1__.compare);
  return m <= n ? arr : arr.slice(0, n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/percentile.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/percentile.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $percentile: () => (/* binding */ $percentile)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $percentile = (collection, expr, options) => {
  const X = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr.input, options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber).sort();
  const centiles = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(expr.p, "$$CURRENT", options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber);
  const method = expr.method || "approximate";
  return centiles.map((p) => {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
      p > 0 && p <= 1,
      `percentile value must be between 0 (exclusive) and 1 (inclusive): invalid '${p}'.`
    );
    const r = p * (X.length - 1) + 1;
    const ri = Math.floor(r);
    const result = r === ri ? X[r - 1] : X[ri - 1] + r % 1 * (X[ri] - X[ri - 1] || 0);
    switch (method) {
      case "exact":
        return result;
      case "approximate": {
        const i = (0,_util__WEBPACK_IMPORTED_MODULE_0__.findInsertIndex)(X, result);
        return i / X.length >= p ? X[Math.max(i - 1, 0)] : X[i];
      }
    }
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/push.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/push.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $push: () => (/* binding */ $push)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $push = (collection, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(expr)) return collection;
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  return collection.map(
    (obj) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, copts.update(obj))
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/stdDevPop.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/stdDevPop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $stdDevPop: () => (/* binding */ $stdDevPop)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/accumulator/_internal.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");



const $stdDevPop = (collection, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_1__.stddev)((0,_push__WEBPACK_IMPORTED_MODULE_2__.$push)(collection, expr, options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber), false);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/stdDevSamp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/stdDevSamp.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $stdDevSamp: () => (/* binding */ $stdDevSamp)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/accumulator/_internal.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");



const $stdDevSamp = (collection, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_1__.stddev)((0,_push__WEBPACK_IMPORTED_MODULE_2__.$push)(collection, expr, options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber), true);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/sum.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/sum.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sum: () => (/* binding */ $sum)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");


const $sum = (collection, expr, options) => {
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(collection)) return 0;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(expr)) return collection.length * expr;
  const nums = (0,_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr, options).filter(_util__WEBPACK_IMPORTED_MODULE_0__.isNumber);
  return nums.reduce((acc, n) => acc + n, 0);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/top.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/top.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $top: () => (/* binding */ $top)
/* harmony export */ });
/* harmony import */ var _topN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./topN */ "./node_modules/mingo/dist/esm/operators/accumulator/topN.js");

const $top = (collection, expr, options) => (0,_topN__WEBPACK_IMPORTED_MODULE_0__.$topN)(collection, { ...expr, n: 1 }, options);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/accumulator/topN.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/accumulator/topN.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $topN: () => (/* binding */ $topN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _pipeline_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pipeline/sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");




const $topN = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const { n, sortBy } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    copts.local.groupId,
    expr,
    null,
    copts
  );
  const result = (0,_pipeline_sort__WEBPACK_IMPORTED_MODULE_2__.$sort)((0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(collection), sortBy, options).take(n).value();
  return (0,_push__WEBPACK_IMPORTED_MODULE_3__.$push)(result, expr.output, copts);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/_internal.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/_internal.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   truncate: () => (/* binding */ truncate)
/* harmony export */ });
function truncate(num, places = 0, roundOff = false) {
  const sign = Math.abs(num) === num ? 1 : -1;
  num = Math.abs(num);
  let result = Math.trunc(num);
  const decimals = parseFloat((num - result).toFixed(places + 1));
  if (places === 0) {
    const firstDigit = Math.trunc(10 * decimals);
    if (roundOff && ((result & 1) === 1 && firstDigit >= 5 || firstDigit > 5)) {
      result++;
    }
  } else if (places > 0) {
    const offset = Math.pow(10, places);
    let remainder = Math.trunc(decimals * offset);
    const lastDigit = Math.trunc(decimals * offset * 10) % 10;
    if (roundOff && lastDigit > 5) {
      remainder += 1;
    }
    result = (result * offset + remainder) / offset;
  } else if (places < 0) {
    const offset = Math.pow(10, -1 * places);
    let excess = result % offset;
    result = Math.max(0, result - excess);
    if (roundOff && sign === -1) {
      while (excess > 10) {
        excess -= excess % 10;
      }
      if (result > 0 && excess >= 5) {
        result += offset;
      }
    }
  }
  return result * sign;
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/abs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/abs.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $abs: () => (/* binding */ $abs)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $abs = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n) ? null : Math.abs(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/add.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/add.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $add: () => (/* binding */ $add)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $add = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  let hasDate = false;
  let sum = 0;
  for (const n of args) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(n)) {
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!hasDate, "'$add' can only have one date value");
      hasDate = true;
    }
    sum += +n;
  }
  return hasDate ? new Date(sum) : sum;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/ceil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/ceil.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ceil: () => (/* binding */ $ceil)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $ceil = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) || isNaN(n), "$ceil expression must resolve to a number.");
  return Math.ceil(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/divide.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/divide.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $divide: () => (/* binding */ $divide)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $divide = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return args[0] / args[1];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/exp.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/exp.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $exp: () => (/* binding */ $exp)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $exp = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) || isNaN(n), "$exp expression must resolve to a number.");
  return Math.exp(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/floor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/floor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $floor: () => (/* binding */ $floor)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $floor = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) || isNaN(n),
    "$floor expression must resolve to a number."
  );
  return Math.floor(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $abs: () => (/* reexport safe */ _abs__WEBPACK_IMPORTED_MODULE_0__.$abs),
/* harmony export */   $add: () => (/* reexport safe */ _add__WEBPACK_IMPORTED_MODULE_1__.$add),
/* harmony export */   $ceil: () => (/* reexport safe */ _ceil__WEBPACK_IMPORTED_MODULE_2__.$ceil),
/* harmony export */   $divide: () => (/* reexport safe */ _divide__WEBPACK_IMPORTED_MODULE_3__.$divide),
/* harmony export */   $exp: () => (/* reexport safe */ _exp__WEBPACK_IMPORTED_MODULE_4__.$exp),
/* harmony export */   $floor: () => (/* reexport safe */ _floor__WEBPACK_IMPORTED_MODULE_5__.$floor),
/* harmony export */   $ln: () => (/* reexport safe */ _ln__WEBPACK_IMPORTED_MODULE_6__.$ln),
/* harmony export */   $log: () => (/* reexport safe */ _log__WEBPACK_IMPORTED_MODULE_7__.$log),
/* harmony export */   $log10: () => (/* reexport safe */ _log10__WEBPACK_IMPORTED_MODULE_8__.$log10),
/* harmony export */   $mod: () => (/* reexport safe */ _mod__WEBPACK_IMPORTED_MODULE_9__.$mod),
/* harmony export */   $multiply: () => (/* reexport safe */ _multiply__WEBPACK_IMPORTED_MODULE_10__.$multiply),
/* harmony export */   $pow: () => (/* reexport safe */ _pow__WEBPACK_IMPORTED_MODULE_11__.$pow),
/* harmony export */   $round: () => (/* reexport safe */ _round__WEBPACK_IMPORTED_MODULE_12__.$round),
/* harmony export */   $sqrt: () => (/* reexport safe */ _sqrt__WEBPACK_IMPORTED_MODULE_13__.$sqrt),
/* harmony export */   $subtract: () => (/* reexport safe */ _subtract__WEBPACK_IMPORTED_MODULE_14__.$subtract),
/* harmony export */   $trunc: () => (/* reexport safe */ _trunc__WEBPACK_IMPORTED_MODULE_15__.$trunc)
/* harmony export */ });
/* harmony import */ var _abs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abs */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/abs.js");
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/add.js");
/* harmony import */ var _ceil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ceil */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/ceil.js");
/* harmony import */ var _divide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./divide */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/divide.js");
/* harmony import */ var _exp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exp */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/exp.js");
/* harmony import */ var _floor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./floor */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/floor.js");
/* harmony import */ var _ln__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ln */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/ln.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./log */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/log.js");
/* harmony import */ var _log10__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./log10 */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/log10.js");
/* harmony import */ var _mod__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mod */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/mod.js");
/* harmony import */ var _multiply__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./multiply */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/multiply.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pow */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/pow.js");
/* harmony import */ var _round__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./round */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/round.js");
/* harmony import */ var _sqrt__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sqrt */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/sqrt.js");
/* harmony import */ var _subtract__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./subtract */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/subtract.js");
/* harmony import */ var _trunc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./trunc */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/trunc.js");


















/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/ln.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/ln.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ln: () => (/* binding */ $ln)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $ln = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) || isNaN(n), "$ln expression must resolve to a number.");
  return Math.log(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/log.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/log.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $log: () => (/* binding */ $log)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $log = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const msg = "$log expression must resolve to array(2) of numbers";
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.length === 2, msg);
  if (args.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(args.some(isNaN) || args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isNumber), msg);
  return Math.log10(args[0]) / Math.log10(args[1]);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/log10.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/log10.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $log10: () => (/* binding */ $log10)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $log10 = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) || isNaN(n),
    "$log10 expression must resolve to a number."
  );
  return Math.log10(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/mod.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/mod.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mod: () => (/* binding */ $mod)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $mod = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return args[0] % args[1];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/multiply.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/multiply.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $multiply: () => (/* binding */ $multiply)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $multiply = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return args.reduce((acc, num) => acc * num, 1);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/pow.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/pow.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $pow: () => (/* binding */ $pow)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $pow = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.length === 2 && args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isNumber),
    "$pow expression must resolve to array(2) of numbers"
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    !(args[0] === 0 && args[1] < 0),
    "$pow cannot raise 0 to a negative exponent"
  );
  return Math.pow(args[0], args[1]);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/round.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/round.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $round: () => (/* binding */ $round)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/_internal.js");



const $round = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const num = args[0];
  const place = args[1];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity) return num;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(num), "$round expression must resolve to a number.");
  return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.truncate)(num, place, true);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/sqrt.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/sqrt.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sqrt: () => (/* binding */ $sqrt)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $sqrt = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) && n > 0 || isNaN(n),
    "$sqrt expression must resolve to non-negative number."
  );
  return Math.sqrt(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/subtract.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/subtract.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $subtract: () => (/* binding */ $subtract)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $subtract = (obj, expr, options) => {
  const [a, b] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(a) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(b) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(a) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(b)) return +a - +b;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(a) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(b)) return new Date(+a - b);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, "$subtract: must resolve to number/date.");
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/trunc.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/arithmetic/trunc.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $trunc: () => (/* binding */ $trunc)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/_internal.js");



const $trunc = (obj, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const num = arr[0];
  const places = arr[1];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity) return num;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(num), "$trunc expression must resolve to a number.");
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(places) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(places) && places > -20 && places < 100,
    "$trunc expression has invalid place"
  );
  return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.truncate)(num, places, false);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/arrayElemAt.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/arrayElemAt.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $arrayElemAt: () => (/* binding */ $arrayElemAt)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $arrayElemAt = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.length === 2,
    "$arrayElemAt expression must resolve to array(2)"
  );
  if (args.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  const index = args[1];
  const arr = args[0];
  if (index < 0 && Math.abs(index) <= arr.length) {
    return arr[(index + arr.length) % arr.length];
  } else if (index >= 0 && index < arr.length) {
    return arr[index];
  }
  return void 0;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/arrayToObject.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/arrayToObject.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $arrayToObject: () => (/* binding */ $arrayToObject)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $arrayToObject = (obj, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr), "$arrayToObject: expression must resolve to an array");
  return arr.reduce((newObj, val) => {
    while ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(val) && val.length === 1) val = val[0];
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(val) && val.length == 2) {
      newObj[val[0]] = val[1];
    } else {
      const valObj = val;
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(valObj) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(valObj, "k") && (0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(valObj, "v"),
        "$arrayToObject expression is invalid."
      );
      newObj[valObj.k] = valObj.v;
    }
    return newObj;
  }, {});
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/concatArrays.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/concatArrays.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $concatArrays: () => (/* binding */ $concatArrays)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $concatArrays = (obj, expr, options) => {
  const nArray = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nArray), "$concatArrays: input must resolve to an array");
  let size = 0;
  for (const arr of nArray) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
    size += arr.length;
  }
  const result = new Array(size);
  let i = 0;
  for (const arr of nArray) for (const item of arr) result[i++] = item;
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/filter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/filter.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $filter: () => (/* binding */ $filter)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $filter = (obj, expr, options) => {
  const input = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.input, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "$filter 'input' expression must resolve to an array");
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options, obj);
  const k = expr.as || "this";
  const local = {
    variables: { [k]: null }
  };
  return input.filter((o) => {
    local.variables[k] = o;
    const b = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
      obj,
      expr.cond,
      null,
      copts.update(copts.root, local)
    );
    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(b, options.useStrictMode);
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/first.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/first.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $first: () => (/* binding */ $first)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/first */ "./node_modules/mingo/dist/esm/operators/accumulator/first.js");



const $first = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_first__WEBPACK_IMPORTED_MODULE_2__.$first)(obj, expr, options);
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr) && arr.length > 0,
    "$first must resolve to a non-empty array."
  );
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.flatten)(arr)[0];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/firstN.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/firstN.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $firstN: () => (/* binding */ $firstN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_firstN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/firstN */ "./node_modules/mingo/dist/esm/operators/accumulator/firstN.js");



const $firstN = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_firstN__WEBPACK_IMPORTED_MODULE_2__.$firstN)(obj, expr, options);
  const { input, n } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "Must resolve to an array/null or missing");
  return (0,_accumulator_firstN__WEBPACK_IMPORTED_MODULE_2__.$firstN)(input, { n, input: "$$this" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/in.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/in.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $in: () => (/* binding */ $in)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $in = (obj, expr, options) => {
  const [item, arr] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr), "$in second argument must be an array");
  return arr.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.isEqual)(v, item));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $arrayElemAt: () => (/* reexport safe */ _arrayElemAt__WEBPACK_IMPORTED_MODULE_0__.$arrayElemAt),
/* harmony export */   $arrayToObject: () => (/* reexport safe */ _arrayToObject__WEBPACK_IMPORTED_MODULE_1__.$arrayToObject),
/* harmony export */   $concatArrays: () => (/* reexport safe */ _concatArrays__WEBPACK_IMPORTED_MODULE_2__.$concatArrays),
/* harmony export */   $filter: () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_3__.$filter),
/* harmony export */   $first: () => (/* reexport safe */ _first__WEBPACK_IMPORTED_MODULE_4__.$first),
/* harmony export */   $firstN: () => (/* reexport safe */ _firstN__WEBPACK_IMPORTED_MODULE_5__.$firstN),
/* harmony export */   $in: () => (/* reexport safe */ _in__WEBPACK_IMPORTED_MODULE_6__.$in),
/* harmony export */   $indexOfArray: () => (/* reexport safe */ _indexOfArray__WEBPACK_IMPORTED_MODULE_7__.$indexOfArray),
/* harmony export */   $isArray: () => (/* reexport safe */ _isArray__WEBPACK_IMPORTED_MODULE_8__.$isArray),
/* harmony export */   $last: () => (/* reexport safe */ _last__WEBPACK_IMPORTED_MODULE_9__.$last),
/* harmony export */   $lastN: () => (/* reexport safe */ _lastN__WEBPACK_IMPORTED_MODULE_10__.$lastN),
/* harmony export */   $map: () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_11__.$map),
/* harmony export */   $maxN: () => (/* reexport safe */ _maxN__WEBPACK_IMPORTED_MODULE_12__.$maxN),
/* harmony export */   $minN: () => (/* reexport safe */ _minN__WEBPACK_IMPORTED_MODULE_13__.$minN),
/* harmony export */   $nin: () => (/* reexport safe */ _nin__WEBPACK_IMPORTED_MODULE_14__.$nin),
/* harmony export */   $range: () => (/* reexport safe */ _range__WEBPACK_IMPORTED_MODULE_15__.$range),
/* harmony export */   $reduce: () => (/* reexport safe */ _reduce__WEBPACK_IMPORTED_MODULE_16__.$reduce),
/* harmony export */   $reverseArray: () => (/* reexport safe */ _reverseArray__WEBPACK_IMPORTED_MODULE_17__.$reverseArray),
/* harmony export */   $size: () => (/* reexport safe */ _size__WEBPACK_IMPORTED_MODULE_18__.$size),
/* harmony export */   $slice: () => (/* reexport safe */ _slice__WEBPACK_IMPORTED_MODULE_19__.$slice),
/* harmony export */   $sortArray: () => (/* reexport safe */ _sortArray__WEBPACK_IMPORTED_MODULE_20__.$sortArray),
/* harmony export */   $zip: () => (/* reexport safe */ _zip__WEBPACK_IMPORTED_MODULE_21__.$zip)
/* harmony export */ });
/* harmony import */ var _arrayElemAt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayElemAt */ "./node_modules/mingo/dist/esm/operators/expression/array/arrayElemAt.js");
/* harmony import */ var _arrayToObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrayToObject */ "./node_modules/mingo/dist/esm/operators/expression/array/arrayToObject.js");
/* harmony import */ var _concatArrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./concatArrays */ "./node_modules/mingo/dist/esm/operators/expression/array/concatArrays.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter */ "./node_modules/mingo/dist/esm/operators/expression/array/filter.js");
/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./first */ "./node_modules/mingo/dist/esm/operators/expression/array/first.js");
/* harmony import */ var _firstN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./firstN */ "./node_modules/mingo/dist/esm/operators/expression/array/firstN.js");
/* harmony import */ var _in__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./in */ "./node_modules/mingo/dist/esm/operators/expression/array/in.js");
/* harmony import */ var _indexOfArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./indexOfArray */ "./node_modules/mingo/dist/esm/operators/expression/array/indexOfArray.js");
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isArray */ "./node_modules/mingo/dist/esm/operators/expression/array/isArray.js");
/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./last */ "./node_modules/mingo/dist/esm/operators/expression/array/last.js");
/* harmony import */ var _lastN__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lastN */ "./node_modules/mingo/dist/esm/operators/expression/array/lastN.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./map */ "./node_modules/mingo/dist/esm/operators/expression/array/map.js");
/* harmony import */ var _maxN__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./maxN */ "./node_modules/mingo/dist/esm/operators/expression/array/maxN.js");
/* harmony import */ var _minN__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./minN */ "./node_modules/mingo/dist/esm/operators/expression/array/minN.js");
/* harmony import */ var _nin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./nin */ "./node_modules/mingo/dist/esm/operators/expression/array/nin.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./range */ "./node_modules/mingo/dist/esm/operators/expression/array/range.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./reduce */ "./node_modules/mingo/dist/esm/operators/expression/array/reduce.js");
/* harmony import */ var _reverseArray__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./reverseArray */ "./node_modules/mingo/dist/esm/operators/expression/array/reverseArray.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./size */ "./node_modules/mingo/dist/esm/operators/expression/array/size.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./slice */ "./node_modules/mingo/dist/esm/operators/expression/array/slice.js");
/* harmony import */ var _sortArray__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./sortArray */ "./node_modules/mingo/dist/esm/operators/expression/array/sortArray.js");
/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./zip */ "./node_modules/mingo/dist/esm/operators/expression/array/zip.js");
























/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/indexOfArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/indexOfArray.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $indexOfArray: () => (/* binding */ $indexOfArray)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $indexOfArray = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args)) return null;
  let arr = args[0];
  const searchValue = args[1];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr), "$indexOfArray expression must resolve to an array.");
  const start = args[2] || 0;
  let end = args[3];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(end)) end = arr.length;
  if (start > end) return -1;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(start >= 0 && end >= 0, "$indexOfArray expression is invalid");
  if (start > 0 || end < arr.length) {
    arr = arr.slice(start, end);
  }
  let index = -1;
  arr.some((v, i) => {
    const b = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isEqual)(v, searchValue);
    if (b) index = i;
    return b;
  });
  return index + start;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/isArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/isArray.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $isArray: () => (/* binding */ $isArray)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $isArray = (obj, expr, options) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)((0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr[0], null, options));



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/last.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/last.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $last: () => (/* binding */ $last)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_last__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/last */ "./node_modules/mingo/dist/esm/operators/accumulator/last.js");



const $last = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_last__WEBPACK_IMPORTED_MODULE_2__.$last)(obj, expr, options);
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr) && arr.length > 0,
    "$last must resolve to a non-empty array."
  );
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.flatten)(arr)[arr.length - 1];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/lastN.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/lastN.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lastN: () => (/* binding */ $lastN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_lastN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/lastN */ "./node_modules/mingo/dist/esm/operators/accumulator/lastN.js");



const $lastN = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_lastN__WEBPACK_IMPORTED_MODULE_2__.$lastN)(obj, expr, options);
  const { input, n } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "Must resolve to an array/null or missing");
  return (0,_accumulator_lastN__WEBPACK_IMPORTED_MODULE_2__.$lastN)(input, { n, input: "$$this" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/map.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $map: () => (/* binding */ $map)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $map = (obj, expr, options) => {
  const input = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.input, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), `$map 'input' expression must resolve to an array`);
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const k = expr.as || "this";
  return input.map((o) => {
    return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
      obj,
      expr.in,
      null,
      copts.update(copts.root, {
        variables: { [k]: o }
      })
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/maxN.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/maxN.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $maxN: () => (/* binding */ $maxN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_maxN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/maxN */ "./node_modules/mingo/dist/esm/operators/accumulator/maxN.js");



const $maxN = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_maxN__WEBPACK_IMPORTED_MODULE_2__.$maxN)(obj, expr, options);
  const { input, n } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "Must resolve to an array/null or missing");
  return (0,_accumulator_maxN__WEBPACK_IMPORTED_MODULE_2__.$maxN)(input, { n, input: "$$this" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/minN.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/minN.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $minN: () => (/* binding */ $minN)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_minN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../accumulator/minN */ "./node_modules/mingo/dist/esm/operators/accumulator/minN.js");



const $minN = (obj, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(obj)) return (0,_accumulator_minN__WEBPACK_IMPORTED_MODULE_2__.$minN)(obj, expr, options);
  const { input, n } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "Must resolve to an array/null or missing");
  return (0,_accumulator_minN__WEBPACK_IMPORTED_MODULE_2__.$minN)(input, { n, input: "$$this" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/nin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/nin.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $nin: () => (/* binding */ $nin)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $nin = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$nin);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/range.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/range.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $range: () => (/* binding */ $range)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $range = (obj, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const start = arr[0];
  const end = arr[1];
  const step = arr[2] || 1;
  const result = new Array();
  let counter = start;
  while (counter < end && step > 0 || counter > end && step < 0) {
    result.push(counter);
    counter += step;
  }
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/reduce.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/reduce.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $reduce: () => (/* binding */ $reduce)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $reduce = (obj, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const input = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.input, null, copts);
  const initialValue = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.initialValue, null, copts);
  const inExpr = expr["in"];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(input), "$reduce 'input' expression must resolve to an array");
  return input.reduce((acc, n) => {
    return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
      n,
      inExpr,
      null,
      copts.update(copts.root, {
        variables: { value: acc }
      })
    );
  }, initialValue);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/reverseArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/reverseArray.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $reverseArray: () => (/* binding */ $reverseArray)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $reverseArray = (obj, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr), "$reverseArray expression must resolve to an array");
  const result = arr.slice(0);
  result.reverse();
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/size.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/size.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $size: () => (/* binding */ $size)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $size = (obj, expr, options) => {
  const value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.length : void 0;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/slice.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/slice.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $slice: () => (/* binding */ $slice)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $slice = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const arr = args[0];
  let skip = args[1];
  let limit = args[2];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(limit)) {
    if (skip < 0) {
      skip = Math.max(0, arr.length + skip);
    } else {
      limit = skip;
      skip = 0;
    }
  } else {
    if (skip < 0) {
      skip = Math.max(0, arr.length + skip);
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      limit > 0,
      `Invalid argument for $slice operator. Limit must be a positive number`
    );
    limit += skip;
  }
  return arr.slice(skip, limit);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/sortArray.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/sortArray.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sortArray: () => (/* binding */ $sortArray)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _pipeline_sort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pipeline/sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");




const $sortArray = (obj, expr, options) => {
  const { input, sortBy } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(input), "$sortArray expression must resolve to an array");
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(sortBy)) {
    return (0,_pipeline_sort__WEBPACK_IMPORTED_MODULE_3__.$sort)((0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(input), sortBy, options).value();
  }
  const result = [...input];
  result.sort(_util__WEBPACK_IMPORTED_MODULE_2__.compare);
  if (sortBy === -1) result.reverse();
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/array/zip.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/array/zip.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $zip: () => (/* binding */ $zip)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $zip = (obj, expr, options) => {
  const inputs = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.inputs, null, options);
  const useLongestLength = expr.useLongestLength || false;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(inputs)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(inputs), "'inputs' expression must resolve to an array");
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(useLongestLength), "'useLongestLength' must be a boolean");
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(expr.defaults)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      useLongestLength,
      "'useLongestLength' must be set to true to use 'defaults'"
    );
  }
  let zipCount = 0;
  for (const arr of inputs) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr)) return null;
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(arr),
      "'inputs' expression values must resolve to an array or null"
    );
    zipCount = useLongestLength ? Math.max(zipCount, arr.length) : Math.min(zipCount || arr.length, arr.length);
  }
  const result = [];
  const defaults = expr.defaults || [];
  for (let i = 0; i < zipCount; i++) {
    const temp = inputs.map((val, index) => {
      return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val[i]) ? defaults[index] || null : val[i];
    });
    result.push(temp);
  }
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitwise: () => (/* binding */ bitwise)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const bitwise = (op, compute) => (obj, expr, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(expr), `${op}: expression must be an array.`);
  const nums = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (nums.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    nums.every(_util__WEBPACK_IMPORTED_MODULE_1__.isNumber),
    `${op}: expression must evalue to array of numbers.`
  );
  return compute(nums);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitAnd: () => (/* binding */ $bitAnd)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js");

const $bitAnd = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.bitwise)(
  "$bitAnd",
  (nums) => nums.reduce((a, b) => a & b, -1)
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitNot.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/bitNot.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitNot: () => (/* binding */ $bitNot)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $bitNot = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(n)) return null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n)) return ~n;
  throw new _util__WEBPACK_IMPORTED_MODULE_1__.MingoError("$bitNot: expression must evaluate to a number.");
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitOr: () => (/* binding */ $bitOr)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js");

const $bitOr = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.bitwise)(
  "$bitOr",
  (nums) => nums.reduce((a, b) => a | b, 0)
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitXor: () => (/* binding */ $bitXor)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js");

const $bitXor = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.bitwise)(
  "$bitXor",
  (nums) => nums.reduce((a, b) => a ^ b, 0)
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/bitwise/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/bitwise/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitAnd: () => (/* reexport safe */ _bitAnd__WEBPACK_IMPORTED_MODULE_0__.$bitAnd),
/* harmony export */   $bitNot: () => (/* reexport safe */ _bitNot__WEBPACK_IMPORTED_MODULE_1__.$bitNot),
/* harmony export */   $bitOr: () => (/* reexport safe */ _bitOr__WEBPACK_IMPORTED_MODULE_2__.$bitOr),
/* harmony export */   $bitXor: () => (/* reexport safe */ _bitXor__WEBPACK_IMPORTED_MODULE_3__.$bitXor)
/* harmony export */ });
/* harmony import */ var _bitAnd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitAnd */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js");
/* harmony import */ var _bitNot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitNot */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitNot.js");
/* harmony import */ var _bitOr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bitOr */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js");
/* harmony import */ var _bitXor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bitXor */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js");






/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/boolean/and.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/boolean/and.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $and: () => (/* binding */ $and)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $and = (obj, expr, options) => {
  const value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(value, options.useStrictMode) && value.every((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(v, options.useStrictMode));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/boolean/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/boolean/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $and: () => (/* reexport safe */ _and__WEBPACK_IMPORTED_MODULE_0__.$and),
/* harmony export */   $not: () => (/* reexport safe */ _not__WEBPACK_IMPORTED_MODULE_1__.$not),
/* harmony export */   $or: () => (/* reexport safe */ _or__WEBPACK_IMPORTED_MODULE_2__.$or)
/* harmony export */ });
/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./and */ "./node_modules/mingo/dist/esm/operators/expression/boolean/and.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./not */ "./node_modules/mingo/dist/esm/operators/expression/boolean/not.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./or */ "./node_modules/mingo/dist/esm/operators/expression/boolean/or.js");





/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/boolean/not.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/boolean/not.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $not: () => (/* binding */ $not)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $not = (obj, expr, options) => {
  const booleanExpr = (0,_util__WEBPACK_IMPORTED_MODULE_1__.ensureArray)(expr);
  if (booleanExpr.length == 0) return false;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(booleanExpr.length == 1, "Expression $not takes exactly 1 argument");
  return !(0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, booleanExpr[0], null, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/boolean/or.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/boolean/or.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $or: () => (/* binding */ $or)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $or = (obj, expr, options) => {
  const value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const strict = options.useStrictMode;
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(value, strict) && value.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(v, strict));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cmp: () => (/* binding */ $cmp)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $cmp = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.length == 2,
    "$cmp: expression must resolve to array of size 2."
  );
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.compare)(args[0], args[1]);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/eq.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/eq.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $eq: () => (/* binding */ $eq)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $eq = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$eq);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/gt.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/gt.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $gt: () => (/* binding */ $gt)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $gt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gt);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/gte.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/gte.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $gte: () => (/* binding */ $gte)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $gte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gte);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cmp: () => (/* reexport safe */ _cmp__WEBPACK_IMPORTED_MODULE_0__.$cmp),
/* harmony export */   $eq: () => (/* reexport safe */ _eq__WEBPACK_IMPORTED_MODULE_1__.$eq),
/* harmony export */   $gt: () => (/* reexport safe */ _gt__WEBPACK_IMPORTED_MODULE_2__.$gt),
/* harmony export */   $gte: () => (/* reexport safe */ _gte__WEBPACK_IMPORTED_MODULE_3__.$gte),
/* harmony export */   $lt: () => (/* reexport safe */ _lt__WEBPACK_IMPORTED_MODULE_4__.$lt),
/* harmony export */   $lte: () => (/* reexport safe */ _lte__WEBPACK_IMPORTED_MODULE_5__.$lte),
/* harmony export */   $ne: () => (/* reexport safe */ _ne__WEBPACK_IMPORTED_MODULE_6__.$ne)
/* harmony export */ });
/* harmony import */ var _cmp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cmp */ "./node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js");
/* harmony import */ var _eq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eq */ "./node_modules/mingo/dist/esm/operators/expression/comparison/eq.js");
/* harmony import */ var _gt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gt */ "./node_modules/mingo/dist/esm/operators/expression/comparison/gt.js");
/* harmony import */ var _gte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gte */ "./node_modules/mingo/dist/esm/operators/expression/comparison/gte.js");
/* harmony import */ var _lt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lt */ "./node_modules/mingo/dist/esm/operators/expression/comparison/lt.js");
/* harmony import */ var _lte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lte */ "./node_modules/mingo/dist/esm/operators/expression/comparison/lte.js");
/* harmony import */ var _ne__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ne */ "./node_modules/mingo/dist/esm/operators/expression/comparison/ne.js");









/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/lt.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/lt.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lt: () => (/* binding */ $lt)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $lt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lt);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/lte.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/lte.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lte: () => (/* binding */ $lte)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $lte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lte);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/comparison/ne.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/comparison/ne.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ne: () => (/* binding */ $ne)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $ne = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createExpressionOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$ne);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/conditional/cond.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/conditional/cond.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cond: () => (/* binding */ $cond)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $cond = (obj, expr, options) => {
  let ifExpr;
  let thenExpr;
  let elseExpr;
  const errorMsg = "$cond: invalid arguments";
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(expr)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(expr.length === 3, errorMsg);
    ifExpr = expr[0];
    thenExpr = expr[1];
    elseExpr = expr[2];
  } else {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(expr), errorMsg);
    ifExpr = expr.if;
    thenExpr = expr.then;
    elseExpr = expr.else;
  }
  const condition = (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(
    (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, ifExpr, null, options),
    options.useStrictMode
  );
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, condition ? thenExpr : elseExpr, null, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/conditional/ifNull.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/conditional/ifNull.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ifNull: () => (/* binding */ $ifNull)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $ifNull = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return args.find((arg) => !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arg)) ?? args[args.length - 1];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/conditional/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/conditional/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cond: () => (/* reexport safe */ _cond__WEBPACK_IMPORTED_MODULE_0__.$cond),
/* harmony export */   $ifNull: () => (/* reexport safe */ _ifNull__WEBPACK_IMPORTED_MODULE_1__.$ifNull),
/* harmony export */   $switch: () => (/* reexport safe */ _switch__WEBPACK_IMPORTED_MODULE_2__.$switch)
/* harmony export */ });
/* harmony import */ var _cond__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cond */ "./node_modules/mingo/dist/esm/operators/expression/conditional/cond.js");
/* harmony import */ var _ifNull__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ifNull */ "./node_modules/mingo/dist/esm/operators/expression/conditional/ifNull.js");
/* harmony import */ var _switch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./switch */ "./node_modules/mingo/dist/esm/operators/expression/conditional/switch.js");





/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/conditional/switch.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/conditional/switch.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $switch: () => (/* binding */ $switch)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $switch = (obj, expr, options) => {
  let thenExpr = null;
  expr.branches.some((b) => {
    const condition = (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(
      (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, b.case, null, options),
      options.useStrictMode
    );
    if (condition) thenExpr = b.then;
    return condition;
  });
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    obj,
    thenExpr !== null ? thenExpr : expr.default,
    null,
    options
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/custom/function.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/custom/function.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $function: () => (/* binding */ $function)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $function = (obj, expr, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    options.scriptEnabled,
    "$function operator requires 'scriptEnabled' option to be true"
  );
  const fn = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return fn.body.apply(null, fn.args);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/custom/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/custom/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $function: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.$function)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/mingo/dist/esm/operators/expression/custom/function.js");



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/_internal.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATE_FORMAT: () => (/* binding */ DATE_FORMAT),
/* harmony export */   DATE_PART_INTERVAL: () => (/* binding */ DATE_PART_INTERVAL),
/* harmony export */   DATE_SYM_TABLE: () => (/* binding */ DATE_SYM_TABLE),
/* harmony export */   DAYS_OF_WEEK: () => (/* binding */ DAYS_OF_WEEK),
/* harmony export */   DAYS_OF_WEEK_SET: () => (/* binding */ DAYS_OF_WEEK_SET),
/* harmony export */   DAYS_PER_WEEK: () => (/* binding */ DAYS_PER_WEEK),
/* harmony export */   LEAP_YEAR_REF_POINT: () => (/* binding */ LEAP_YEAR_REF_POINT),
/* harmony export */   MILLIS_PER_DAY: () => (/* binding */ MILLIS_PER_DAY),
/* harmony export */   MINUTES_PER_HOUR: () => (/* binding */ MINUTES_PER_HOUR),
/* harmony export */   TIMEUNIT_IN_MILLIS: () => (/* binding */ TIMEUNIT_IN_MILLIS),
/* harmony export */   adjustDate: () => (/* binding */ adjustDate),
/* harmony export */   computeDate: () => (/* binding */ computeDate),
/* harmony export */   dateAdd: () => (/* binding */ dateAdd),
/* harmony export */   dateDiffDay: () => (/* binding */ dateDiffDay),
/* harmony export */   dateDiffHour: () => (/* binding */ dateDiffHour),
/* harmony export */   dateDiffMonth: () => (/* binding */ dateDiffMonth),
/* harmony export */   dateDiffQuarter: () => (/* binding */ dateDiffQuarter),
/* harmony export */   dateDiffWeek: () => (/* binding */ dateDiffWeek),
/* harmony export */   dateDiffYear: () => (/* binding */ dateDiffYear),
/* harmony export */   dayOfYear: () => (/* binding */ dayOfYear),
/* harmony export */   daysBetweenYears: () => (/* binding */ daysBetweenYears),
/* harmony export */   daysInMonth: () => (/* binding */ daysInMonth),
/* harmony export */   daysInYear: () => (/* binding */ daysInYear),
/* harmony export */   formatTimezone: () => (/* binding */ formatTimezone),
/* harmony export */   isLeapYear: () => (/* binding */ isLeapYear),
/* harmony export */   isoWeek: () => (/* binding */ isoWeek),
/* harmony export */   isoWeekYear: () => (/* binding */ isoWeekYear),
/* harmony export */   isoWeekday: () => (/* binding */ isoWeekday),
/* harmony export */   padDigits: () => (/* binding */ padDigits),
/* harmony export */   parseTimezone: () => (/* binding */ parseTimezone)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const LEAP_YEAR_REF_POINT = -1e9;
const DAYS_PER_WEEK = 7;
const isLeapYear = (y) => (y & 3) == 0 && (y % 100 != 0 || y % 400 == 0);
const DAYS_IN_YEAR = [
  365,
  366
  /*leap*/
];
const daysInYear = (year) => DAYS_IN_YEAR[+isLeapYear(year)];
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const daysInMonth = (d) => DAYS_IN_MONTH[d.getUTCMonth()] + Number(
  d.getUTCMonth() === 1 && isLeapYear(d.getUTCFullYear())
);
const YEAR_DAYS_OFFSET = [
  [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]
  /*leap*/
];
const dayOfYear = (d) => YEAR_DAYS_OFFSET[+isLeapYear(d.getUTCFullYear())][d.getUTCMonth()] + d.getUTCDate();
const isoWeekday = (date, startOfWeek = "sun") => {
  const dow = date.getUTCDay() || 7;
  return (dow - ISO_WEEKDAY_MAP[startOfWeek] + DAYS_PER_WEEK) % DAYS_PER_WEEK;
};
const p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;
const weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);
function isoWeek(d) {
  const dow = d.getUTCDay() || 7;
  const w = Math.floor((10 + dayOfYear(d) - dow) / 7);
  if (w < 1) return weeks(d.getUTCFullYear() - 1);
  if (w > weeks(d.getUTCFullYear())) return 1;
  return w;
}
function isoWeekYear(d) {
  return d.getUTCFullYear() - Number(d.getUTCMonth() === 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);
}
const MINUTES_PER_HOUR = 60;
const MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;
const TIMEUNIT_IN_MILLIS = {
  week: MILLIS_PER_DAY * DAYS_PER_WEEK,
  day: MILLIS_PER_DAY,
  hour: 1e3 * 60 * 60,
  minute: 1e3 * 60,
  second: 1e3,
  millisecond: 1
};
const DAYS_OF_WEEK = [
  "monday",
  "mon",
  "tuesday",
  "tue",
  "wednesday",
  "wed",
  "thursday",
  "thu",
  "friday",
  "fri",
  "saturday",
  "sat",
  "sunday",
  "sun"
];
const DAYS_OF_WEEK_SET = new Set(DAYS_OF_WEEK);
const ISO_WEEKDAY_MAP = Object.freeze({
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6,
  sun: 7
});
const DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.%LZ";
const DATE_PART_INTERVAL = [
  ["year", 0, 9999],
  ["month", 1, 12],
  ["day", 1, 31],
  ["hour", 0, 23],
  ["minute", 0, 59],
  ["second", 0, 59],
  ["millisecond", 0, 999]
];
const DATE_SYM_TABLE = Object.freeze({
  "%Y": { name: "year", padding: 4, re: /([0-9]{4})/ },
  "%G": { name: "year", padding: 4, re: /([0-9]{4})/ },
  "%m": { name: "month", padding: 2, re: /(0[1-9]|1[012])/ },
  "%d": { name: "day", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },
  "%H": { name: "hour", padding: 2, re: /([01][0-9]|2[0-3])/ },
  "%M": { name: "minute", padding: 2, re: /([0-5][0-9])/ },
  "%S": { name: "second", padding: 2, re: /([0-5][0-9]|60)/ },
  "%L": { name: "millisecond", padding: 3, re: /([0-9]{3})/ },
  "%u": { name: "weekday", padding: 1, re: /([1-7])/ },
  "%U": { name: "week", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
  "%V": { name: "isoWeek", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
  "%z": {
    name: "timezone",
    padding: 2,
    re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/
  },
  "%Z": { name: "minuteOffset", padding: 3, re: /([+-][0-9]{3})/ }
  // "%%": "%",
});
const TIMEZONE_RE = /^[a-zA-Z_]+\/[a-zA-Z_]+$/;
function parseTimezone(tzstr) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(tzstr)) return 0;
  if (TIMEZONE_RE.test(tzstr)) {
    const date = /* @__PURE__ */ new Date();
    const utcDate = new Date(date.toLocaleString("en-US", { timeZone: "UTC" }));
    const tzDate = new Date(date.toLocaleString("en-US", { timeZone: tzstr }));
    return (tzDate.getTime() - utcDate.getTime()) / 6e4;
  }
  const m = DATE_SYM_TABLE["%z"].re.exec(tzstr);
  if (!m) {
    throw new _util__WEBPACK_IMPORTED_MODULE_1__.MingoError(`Timezone '${tzstr}' is invalid or not supported`);
  }
  const hr = parseInt(m[2]) || 0;
  const min = parseInt(m[3]) || 0;
  return (Math.abs(hr * MINUTES_PER_HOUR) + min) * (hr < 0 ? -1 : 1);
}
function formatTimezone(minuteOffset) {
  return (minuteOffset < 0 ? "-" : "+") + padDigits(Math.abs(Math.floor(minuteOffset / MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % MINUTES_PER_HOUR, 2);
}
function adjustDate(d, minuteOffset) {
  d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);
}
function computeDate(obj, expr, options) {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(obj)) return obj;
  const d = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(d)) return new Date(d);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(d)) return new Date(d * 1e3);
  if (d.date) {
    const date = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(d.date) ? new Date(d.date) : new Date(d.date * 1e3);
    if (d.timezone) {
      adjustDate(date, parseTimezone(d.timezone));
    }
    return date;
  }
  throw Error(`cannot convert ${JSON.stringify(expr)} to date`);
}
function padDigits(n, digits) {
  return new Array(Math.max(digits - String(n).length + 1, 0)).join("0") + n.toString();
}
const leapYearsSinceReferencePoint = (year) => {
  const yearsSinceReferencePoint = year - LEAP_YEAR_REF_POINT;
  return Math.trunc(yearsSinceReferencePoint / 4) - Math.trunc(yearsSinceReferencePoint / 100) + Math.trunc(yearsSinceReferencePoint / 400);
};
function daysBetweenYears(startYear, endYear) {
  return Math.trunc(
    leapYearsSinceReferencePoint(endYear - 1) - leapYearsSinceReferencePoint(startYear - 1) + (endYear - startYear) * DAYS_IN_YEAR[0]
  );
}
const dateDiffYear = (start, end) => end.getUTCFullYear() - start.getUTCFullYear();
const dateDiffMonth = (start, end) => end.getUTCMonth() - start.getUTCMonth() + dateDiffYear(start, end) * 12;
const dateDiffQuarter = (start, end) => {
  const a = Math.trunc(start.getUTCMonth() / 3);
  const b = Math.trunc(end.getUTCMonth() / 3);
  return b - a + dateDiffYear(start, end) * 4;
};
const dateDiffDay = (start, end) => dayOfYear(end) - dayOfYear(start) + daysBetweenYears(start.getUTCFullYear(), end.getUTCFullYear());
const dateDiffWeek = (start, end, startOfWeek) => {
  const wk = (startOfWeek || "sun").substring(0, 3);
  return Math.trunc(
    (dateDiffDay(start, end) + isoWeekday(start, wk) - isoWeekday(end, wk)) / DAYS_PER_WEEK
  );
};
const dateDiffHour = (start, end) => end.getUTCHours() - start.getUTCHours() + dateDiffDay(start, end) * 24;
const addMonth = (d, amount) => {
  const m = d.getUTCMonth() + amount;
  const yearOffset = Math.floor(m / 12);
  if (m < 0) {
    const month = m % 12 + 12;
    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, month, d.getUTCDate());
  } else {
    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, m % 12, d.getUTCDate());
  }
};
const dateAdd = (date, unit, amount, _timezone) => {
  const d = new Date(date);
  switch (unit) {
    case "year":
      d.setUTCFullYear(d.getUTCFullYear() + amount);
      break;
    case "quarter":
      addMonth(d, 3 * amount);
      break;
    case "month":
      addMonth(d, amount);
      break;
    default:
      d.setTime(d.getTime() + TIMEUNIT_IN_MILLIS[unit] * amount);
  }
  return d;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateAdd: () => (/* binding */ $dateAdd)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");


const $dateAdd = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateAdd)(args.startDate, args.unit, args.amount, args.timezone);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateDiff.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateDiff.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateDiff: () => (/* binding */ $dateDiff)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");


const $dateDiff = (obj, expr, options) => {
  const { startDate, endDate, unit, timezone, startOfWeek } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    obj,
    expr,
    null,
    options
  );
  const d1 = new Date(startDate);
  const d2 = new Date(endDate);
  const minuteOffset = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.parseTimezone)(timezone);
  (0,_internal__WEBPACK_IMPORTED_MODULE_1__.adjustDate)(d1, minuteOffset);
  (0,_internal__WEBPACK_IMPORTED_MODULE_1__.adjustDate)(d2, minuteOffset);
  switch (unit) {
    case "year":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffYear)(d1, d2);
    case "quarter":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffQuarter)(d1, d2);
    case "month":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffMonth)(d1, d2);
    case "week":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffWeek)(d1, d2, startOfWeek);
    case "day":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffDay)(d1, d2);
    case "hour":
      return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.dateDiffHour)(d1, d2);
    case "minute":
      d1.setUTCSeconds(0);
      d1.setUTCMilliseconds(0);
      d2.setUTCSeconds(0);
      d2.setUTCMilliseconds(0);
      return Math.round(
        (d2.getTime() - d1.getTime()) / _internal__WEBPACK_IMPORTED_MODULE_1__.TIMEUNIT_IN_MILLIS[unit]
      );
    default:
      return Math.round(
        (d2.getTime() - d1.getTime()) / _internal__WEBPACK_IMPORTED_MODULE_1__.TIMEUNIT_IN_MILLIS[unit]
      );
  }
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateFromParts.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateFromParts.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateFromParts: () => (/* binding */ $dateFromParts)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");


const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const getDaysInMonth = (date) => {
  return date.month == 2 && (0,_internal__WEBPACK_IMPORTED_MODULE_1__.isLeapYear)(date.year) ? 29 : DAYS_IN_MONTH[date.month - 1];
};
const $dateFromParts = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const minuteOffset = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.parseTimezone)(args.timezone);
  for (let i = _internal__WEBPACK_IMPORTED_MODULE_1__.DATE_PART_INTERVAL.length - 1, remainder = 0; i >= 0; i--) {
    const datePartInterval = _internal__WEBPACK_IMPORTED_MODULE_1__.DATE_PART_INTERVAL[i];
    const k = datePartInterval[0];
    const min = datePartInterval[1];
    const max = datePartInterval[2];
    let part = (args[k] || 0) + remainder;
    remainder = 0;
    const limit = max + 1;
    if (k == "hour") part += Math.floor(minuteOffset / _internal__WEBPACK_IMPORTED_MODULE_1__.MINUTES_PER_HOUR) * -1;
    if (k == "minute") part += minuteOffset % _internal__WEBPACK_IMPORTED_MODULE_1__.MINUTES_PER_HOUR * -1;
    if (part < min) {
      const delta = min - part;
      remainder = -1 * Math.ceil(delta / limit);
      part = limit - delta % limit;
    } else if (part > max) {
      part += min;
      remainder = Math.trunc(part / limit);
      part %= limit;
    }
    args[k] = part;
  }
  args.day = Math.min(args.day, getDaysInMonth(args));
  return new Date(
    Date.UTC(
      args.year,
      args.month - 1,
      args.day,
      args.hour,
      args.minute,
      args.second,
      args.millisecond
    )
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateFromString: () => (/* binding */ $dateFromString)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");



const buildMap = (letters, sign) => {
  const h = {};
  letters.split("").forEach((v, i) => h[v] = sign * (i + 1));
  return h;
};
const TZ_LETTER_OFFSETS = {
  ...buildMap("ABCDEFGHIKLM", 1),
  ...buildMap("NOPQRSTUVWXY", -1),
  Z: 0
};
const regexStrip = (s) => s.replace(/^\//, "").replace(/\/$/, "");
const REGEX_SPECIAL_CHARS = ["^", ".", "-", "*", "?", "$"];
const regexQuote = (s) => {
  REGEX_SPECIAL_CHARS.forEach((c) => {
    s = s.replace(c, `\\${c}`);
  });
  return s;
};
const $dateFromString = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  args.format = args.format || _internal__WEBPACK_IMPORTED_MODULE_2__.DATE_FORMAT;
  args.onNull = args.onNull || null;
  let dateString = args.dateString;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateString)) return args.onNull;
  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);
  separators.reverse();
  const matches = args.format.match(
    /(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g
  );
  const dateParts = {};
  let expectedPattern = "";
  for (let i = 0, len = matches.length; i < len; i++) {
    const formatSpecifier = matches[i];
    const props = _internal__WEBPACK_IMPORTED_MODULE_2__.DATE_SYM_TABLE[formatSpecifier];
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(props)) {
      const m2 = props.re.exec(dateString);
      const delimiter = separators.pop() || "";
      if (m2 !== null) {
        dateParts[props.name] = /^\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];
        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);
        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());
      } else {
        dateParts[props.name] = null;
      }
    }
  }
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.year) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.month) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.day) || !new RegExp("^" + expectedPattern + "[A-Z]?$").exec(args.dateString)) {
    return args.onError;
  }
  const m = args.dateString.match(/([A-Z])$/);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    // only one of in-date timeone or timezone argument but not both.
    !(m && args.timezone),
    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`
  );
  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * _internal__WEBPACK_IMPORTED_MODULE_2__.MINUTES_PER_HOUR : (0,_internal__WEBPACK_IMPORTED_MODULE_2__.parseTimezone)(args.timezone);
  const d = new Date(
    Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0)
  );
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.hour)) d.setUTCHours(dateParts.hour);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.minute)) d.setUTCMinutes(dateParts.minute);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.second)) d.setUTCSeconds(dateParts.second);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(dateParts.millisecond))
    d.setUTCMilliseconds(dateParts.millisecond);
  (0,_internal__WEBPACK_IMPORTED_MODULE_2__.adjustDate)(d, -minuteOffset);
  return d;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateSubtract.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateSubtract.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateSubtract: () => (/* binding */ $dateSubtract)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _dateAdd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dateAdd */ "./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js");


const $dateSubtract = (obj, expr, options) => {
  const amount = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr?.amount, null, options);
  return (0,_dateAdd__WEBPACK_IMPORTED_MODULE_1__.$dateAdd)(obj, { ...expr, amount: -1 * amount }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateToParts.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateToParts.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateToParts: () => (/* binding */ $dateToParts)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");


const $dateToParts = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const d = new Date(args.date);
  const tz = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.parseTimezone)(args.timezone);
  (0,_internal__WEBPACK_IMPORTED_MODULE_1__.adjustDate)(d, tz);
  const timePart = {
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
  if (args.iso8601 == true) {
    return Object.assign(timePart, {
      isoWeekYear: (0,_internal__WEBPACK_IMPORTED_MODULE_1__.isoWeekYear)(d),
      isoWeek: (0,_internal__WEBPACK_IMPORTED_MODULE_1__.isoWeek)(d),
      isoDayOfWeek: d.getUTCDay() || 7
    });
  }
  return Object.assign(timePart, {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate()
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateToString.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateToString.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateToString: () => (/* binding */ $dateToString)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");
/* harmony import */ var _dayOfMonth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dayOfMonth */ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfMonth.js");
/* harmony import */ var _hour__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hour */ "./node_modules/mingo/dist/esm/operators/expression/date/hour.js");
/* harmony import */ var _isoDayOfWeek__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isoDayOfWeek */ "./node_modules/mingo/dist/esm/operators/expression/date/isoDayOfWeek.js");
/* harmony import */ var _isoWeek__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isoWeek */ "./node_modules/mingo/dist/esm/operators/expression/date/isoWeek.js");
/* harmony import */ var _millisecond__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./millisecond */ "./node_modules/mingo/dist/esm/operators/expression/date/millisecond.js");
/* harmony import */ var _minute__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./minute */ "./node_modules/mingo/dist/esm/operators/expression/date/minute.js");
/* harmony import */ var _month__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./month */ "./node_modules/mingo/dist/esm/operators/expression/date/month.js");
/* harmony import */ var _second__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./second */ "./node_modules/mingo/dist/esm/operators/expression/date/second.js");
/* harmony import */ var _week__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./week */ "./node_modules/mingo/dist/esm/operators/expression/date/week.js");
/* harmony import */ var _year__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./year */ "./node_modules/mingo/dist/esm/operators/expression/date/year.js");













const DATE_FUNCTIONS = {
  "%Y": _year__WEBPACK_IMPORTED_MODULE_12__.$year,
  "%G": _year__WEBPACK_IMPORTED_MODULE_12__.$year,
  "%m": _month__WEBPACK_IMPORTED_MODULE_9__.$month,
  "%d": _dayOfMonth__WEBPACK_IMPORTED_MODULE_3__.$dayOfMonth,
  "%H": _hour__WEBPACK_IMPORTED_MODULE_4__.$hour,
  "%M": _minute__WEBPACK_IMPORTED_MODULE_8__.$minute,
  "%S": _second__WEBPACK_IMPORTED_MODULE_10__.$second,
  "%L": _millisecond__WEBPACK_IMPORTED_MODULE_7__.$millisecond,
  "%u": _isoDayOfWeek__WEBPACK_IMPORTED_MODULE_5__.$isoDayOfWeek,
  "%U": _week__WEBPACK_IMPORTED_MODULE_11__.$week,
  "%V": _isoWeek__WEBPACK_IMPORTED_MODULE_6__.$isoWeek
};
const $dateToString = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args.onNull)) args.onNull = null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args.date)) return args.onNull;
  const date = (0,_internal__WEBPACK_IMPORTED_MODULE_2__.computeDate)(obj, args.date, options);
  let format = args.format || _internal__WEBPACK_IMPORTED_MODULE_2__.DATE_FORMAT;
  const minuteOffset = (0,_internal__WEBPACK_IMPORTED_MODULE_2__.parseTimezone)(args.timezone);
  const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);
  (0,_internal__WEBPACK_IMPORTED_MODULE_2__.adjustDate)(date, minuteOffset);
  for (let i = 0, len = matches.length; i < len; i++) {
    const formatSpecifier = matches[i];
    const props = _internal__WEBPACK_IMPORTED_MODULE_2__.DATE_SYM_TABLE[formatSpecifier];
    const operatorFn = DATE_FUNCTIONS[formatSpecifier];
    let value;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(props)) {
      if (props.name === "timezone") {
        value = (0,_internal__WEBPACK_IMPORTED_MODULE_2__.formatTimezone)(minuteOffset);
      } else if (props.name === "minuteOffset") {
        value = minuteOffset.toString();
      } else {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
          !!operatorFn,
          `unsupported date format specifier '${formatSpecifier}'`
        );
        value = (0,_internal__WEBPACK_IMPORTED_MODULE_2__.padDigits)(operatorFn(obj, date, options), props.padding);
      }
    }
    format = format.replace(formatSpecifier, value);
  }
  return format;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dateTrunc.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dateTrunc.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateTrunc: () => (/* binding */ $dateTrunc)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../types */ "./node_modules/mingo/dist/esm/types.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");




const REF_DATE_MILLIS = 9466848e5;
const distanceToBinLowerBound = (value, binSize) => {
  let remainder = value % binSize;
  if (remainder < 0) {
    remainder += binSize;
  }
  return remainder;
};
const DATE_DIFF_FN = {
  day: _internal__WEBPACK_IMPORTED_MODULE_3__.dateDiffDay,
  month: _internal__WEBPACK_IMPORTED_MODULE_3__.dateDiffMonth,
  quarter: _internal__WEBPACK_IMPORTED_MODULE_3__.dateDiffQuarter,
  year: _internal__WEBPACK_IMPORTED_MODULE_3__.dateDiffYear
};
const $dateTrunc = (obj, expr, options) => {
  const {
    date,
    unit,
    binSize: optBinSize,
    timezone,
    startOfWeek: optStartOfWeek
  } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(date) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(unit)) return null;
  const startOfWeek = (optStartOfWeek ?? "sun").toLowerCase().substring(0, 3);
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.isDate)(date),
    "$dateTrunc: 'date' must resolve to a valid Date object."
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(_types__WEBPACK_IMPORTED_MODULE_1__.TIME_UNITS.includes(unit), "$dateTrunc: unit is invalid.");
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    unit != "week" || _internal__WEBPACK_IMPORTED_MODULE_3__.DAYS_OF_WEEK_SET.has(startOfWeek),
    `$dateTrunc: startOfWeek '${startOfWeek}' is not a valid.`
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(optBinSize) || optBinSize > 0,
    "$dateTrunc requires 'binSize' to be greater than 0, but got value 0."
  );
  const binSize = optBinSize ?? 1;
  switch (unit) {
    case "millisecond":
    case "second":
    case "minute":
    case "hour": {
      const binSizeMillis = binSize * _internal__WEBPACK_IMPORTED_MODULE_3__.TIMEUNIT_IN_MILLIS[unit];
      const shiftedDate = date.getTime() - REF_DATE_MILLIS;
      return new Date(
        date.getTime() - distanceToBinLowerBound(shiftedDate, binSizeMillis)
      );
    }
    default: {
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(binSize <= 1e11, "dateTrunc unsupported binSize value");
      const d = new Date(date);
      const refPointDate = new Date(REF_DATE_MILLIS);
      let distanceFromRefPoint = 0;
      if (unit == "week") {
        const refPointDayOfWeek = (0,_internal__WEBPACK_IMPORTED_MODULE_3__.isoWeekday)(refPointDate, startOfWeek);
        const daysToAdjustBy = (_internal__WEBPACK_IMPORTED_MODULE_3__.DAYS_PER_WEEK - refPointDayOfWeek) % _internal__WEBPACK_IMPORTED_MODULE_3__.DAYS_PER_WEEK;
        refPointDate.setTime(
          refPointDate.getTime() + daysToAdjustBy * _internal__WEBPACK_IMPORTED_MODULE_3__.TIMEUNIT_IN_MILLIS.day
        );
        distanceFromRefPoint = (0,_internal__WEBPACK_IMPORTED_MODULE_3__.dateDiffWeek)(refPointDate, d, startOfWeek);
      } else {
        distanceFromRefPoint = DATE_DIFF_FN[unit](refPointDate, d);
      }
      const binLowerBoundFromRefPoint = distanceFromRefPoint - distanceToBinLowerBound(distanceFromRefPoint, binSize);
      const newDate = (0,_internal__WEBPACK_IMPORTED_MODULE_3__.dateAdd)(
        refPointDate,
        unit,
        binLowerBoundFromRefPoint,
        timezone
      );
      const minuteOffset = (0,_internal__WEBPACK_IMPORTED_MODULE_3__.parseTimezone)(timezone);
      (0,_internal__WEBPACK_IMPORTED_MODULE_3__.adjustDate)(newDate, -minuteOffset);
      return newDate;
    }
  }
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfMonth.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dayOfMonth.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dayOfMonth: () => (/* binding */ $dayOfMonth)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $dayOfMonth = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCDate();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfWeek.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dayOfWeek.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dayOfWeek: () => (/* binding */ $dayOfWeek)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $dayOfWeek = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCDay() + 1;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfYear.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/dayOfYear.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dayOfYear: () => (/* binding */ $dayOfYear)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $dayOfYear = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.dayOfYear)((0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/hour.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/hour.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $hour: () => (/* binding */ $hour)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $hour = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCHours();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $dateAdd: () => (/* reexport safe */ _dateAdd__WEBPACK_IMPORTED_MODULE_0__.$dateAdd),
/* harmony export */   $dateDiff: () => (/* reexport safe */ _dateDiff__WEBPACK_IMPORTED_MODULE_1__.$dateDiff),
/* harmony export */   $dateFromParts: () => (/* reexport safe */ _dateFromParts__WEBPACK_IMPORTED_MODULE_2__.$dateFromParts),
/* harmony export */   $dateFromString: () => (/* reexport safe */ _dateFromString__WEBPACK_IMPORTED_MODULE_3__.$dateFromString),
/* harmony export */   $dateSubtract: () => (/* reexport safe */ _dateSubtract__WEBPACK_IMPORTED_MODULE_4__.$dateSubtract),
/* harmony export */   $dateToParts: () => (/* reexport safe */ _dateToParts__WEBPACK_IMPORTED_MODULE_5__.$dateToParts),
/* harmony export */   $dateToString: () => (/* reexport safe */ _dateToString__WEBPACK_IMPORTED_MODULE_6__.$dateToString),
/* harmony export */   $dateTrunc: () => (/* reexport safe */ _dateTrunc__WEBPACK_IMPORTED_MODULE_7__.$dateTrunc),
/* harmony export */   $dayOfMonth: () => (/* reexport safe */ _dayOfMonth__WEBPACK_IMPORTED_MODULE_8__.$dayOfMonth),
/* harmony export */   $dayOfWeek: () => (/* reexport safe */ _dayOfWeek__WEBPACK_IMPORTED_MODULE_9__.$dayOfWeek),
/* harmony export */   $dayOfYear: () => (/* reexport safe */ _dayOfYear__WEBPACK_IMPORTED_MODULE_10__.$dayOfYear),
/* harmony export */   $hour: () => (/* reexport safe */ _hour__WEBPACK_IMPORTED_MODULE_11__.$hour),
/* harmony export */   $isoDayOfWeek: () => (/* reexport safe */ _isoDayOfWeek__WEBPACK_IMPORTED_MODULE_12__.$isoDayOfWeek),
/* harmony export */   $isoWeek: () => (/* reexport safe */ _isoWeek__WEBPACK_IMPORTED_MODULE_13__.$isoWeek),
/* harmony export */   $isoWeekYear: () => (/* reexport safe */ _isoWeekYear__WEBPACK_IMPORTED_MODULE_14__.$isoWeekYear),
/* harmony export */   $millisecond: () => (/* reexport safe */ _millisecond__WEBPACK_IMPORTED_MODULE_15__.$millisecond),
/* harmony export */   $minute: () => (/* reexport safe */ _minute__WEBPACK_IMPORTED_MODULE_16__.$minute),
/* harmony export */   $month: () => (/* reexport safe */ _month__WEBPACK_IMPORTED_MODULE_17__.$month),
/* harmony export */   $second: () => (/* reexport safe */ _second__WEBPACK_IMPORTED_MODULE_18__.$second),
/* harmony export */   $week: () => (/* reexport safe */ _week__WEBPACK_IMPORTED_MODULE_19__.$week),
/* harmony export */   $year: () => (/* reexport safe */ _year__WEBPACK_IMPORTED_MODULE_20__.$year)
/* harmony export */ });
/* harmony import */ var _dateAdd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dateAdd */ "./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js");
/* harmony import */ var _dateDiff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dateDiff */ "./node_modules/mingo/dist/esm/operators/expression/date/dateDiff.js");
/* harmony import */ var _dateFromParts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dateFromParts */ "./node_modules/mingo/dist/esm/operators/expression/date/dateFromParts.js");
/* harmony import */ var _dateFromString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dateFromString */ "./node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js");
/* harmony import */ var _dateSubtract__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dateSubtract */ "./node_modules/mingo/dist/esm/operators/expression/date/dateSubtract.js");
/* harmony import */ var _dateToParts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dateToParts */ "./node_modules/mingo/dist/esm/operators/expression/date/dateToParts.js");
/* harmony import */ var _dateToString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dateToString */ "./node_modules/mingo/dist/esm/operators/expression/date/dateToString.js");
/* harmony import */ var _dateTrunc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dateTrunc */ "./node_modules/mingo/dist/esm/operators/expression/date/dateTrunc.js");
/* harmony import */ var _dayOfMonth__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dayOfMonth */ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfMonth.js");
/* harmony import */ var _dayOfWeek__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dayOfWeek */ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfWeek.js");
/* harmony import */ var _dayOfYear__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dayOfYear */ "./node_modules/mingo/dist/esm/operators/expression/date/dayOfYear.js");
/* harmony import */ var _hour__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hour */ "./node_modules/mingo/dist/esm/operators/expression/date/hour.js");
/* harmony import */ var _isoDayOfWeek__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isoDayOfWeek */ "./node_modules/mingo/dist/esm/operators/expression/date/isoDayOfWeek.js");
/* harmony import */ var _isoWeek__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isoWeek */ "./node_modules/mingo/dist/esm/operators/expression/date/isoWeek.js");
/* harmony import */ var _isoWeekYear__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isoWeekYear */ "./node_modules/mingo/dist/esm/operators/expression/date/isoWeekYear.js");
/* harmony import */ var _millisecond__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./millisecond */ "./node_modules/mingo/dist/esm/operators/expression/date/millisecond.js");
/* harmony import */ var _minute__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./minute */ "./node_modules/mingo/dist/esm/operators/expression/date/minute.js");
/* harmony import */ var _month__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./month */ "./node_modules/mingo/dist/esm/operators/expression/date/month.js");
/* harmony import */ var _second__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./second */ "./node_modules/mingo/dist/esm/operators/expression/date/second.js");
/* harmony import */ var _week__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./week */ "./node_modules/mingo/dist/esm/operators/expression/date/week.js");
/* harmony import */ var _year__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./year */ "./node_modules/mingo/dist/esm/operators/expression/date/year.js");























/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/isoDayOfWeek.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/isoDayOfWeek.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $isoDayOfWeek: () => (/* binding */ $isoDayOfWeek)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $isoDayOfWeek = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCDay() || 7;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/isoWeek.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/isoWeek.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $isoWeek: () => (/* binding */ $isoWeek)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $isoWeek = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.isoWeek)((0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/isoWeekYear.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/isoWeekYear.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $isoWeekYear: () => (/* binding */ $isoWeekYear)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $isoWeekYear = (obj, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_0__.isoWeekYear)((0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options));



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/millisecond.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/millisecond.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $millisecond: () => (/* binding */ $millisecond)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $millisecond = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCMilliseconds();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/minute.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/minute.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $minute: () => (/* binding */ $minute)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $minute = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCMinutes();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/month.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/month.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $month: () => (/* binding */ $month)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $month = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCMonth() + 1;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/second.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/second.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $second: () => (/* binding */ $second)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $second = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCSeconds();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/week.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/week.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $week: () => (/* binding */ $week)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $week = (obj, expr, options) => {
  const d = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options);
  const result = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.isoWeek)(d);
  if (d.getUTCDay() > 0 && d.getUTCDate() == 1 && d.getUTCMonth() == 0)
    return 0;
  if (d.getUTCDay() == 0) return result + 1;
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/date/year.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/date/year.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $year: () => (/* binding */ $year)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");

const $year = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.computeDate)(obj, expr, options).getUTCFullYear();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $abs: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$abs),
/* harmony export */   $acos: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$acos),
/* harmony export */   $acosh: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$acosh),
/* harmony export */   $add: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$add),
/* harmony export */   $allElementsTrue: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$allElementsTrue),
/* harmony export */   $and: () => (/* reexport safe */ _boolean__WEBPACK_IMPORTED_MODULE_3__.$and),
/* harmony export */   $anyElementTrue: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$anyElementTrue),
/* harmony export */   $arrayElemAt: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$arrayElemAt),
/* harmony export */   $arrayToObject: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$arrayToObject),
/* harmony export */   $asin: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$asin),
/* harmony export */   $asinh: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$asinh),
/* harmony export */   $atan: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$atan),
/* harmony export */   $atan2: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$atan2),
/* harmony export */   $atanh: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$atanh),
/* harmony export */   $bitAnd: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_2__.$bitAnd),
/* harmony export */   $bitNot: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_2__.$bitNot),
/* harmony export */   $bitOr: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_2__.$bitOr),
/* harmony export */   $bitXor: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_2__.$bitXor),
/* harmony export */   $ceil: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$ceil),
/* harmony export */   $cmp: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$cmp),
/* harmony export */   $concat: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$concat),
/* harmony export */   $concatArrays: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$concatArrays),
/* harmony export */   $cond: () => (/* reexport safe */ _conditional__WEBPACK_IMPORTED_MODULE_5__.$cond),
/* harmony export */   $convert: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$convert),
/* harmony export */   $cos: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$cos),
/* harmony export */   $cosh: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$cosh),
/* harmony export */   $dateAdd: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateAdd),
/* harmony export */   $dateDiff: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateDiff),
/* harmony export */   $dateFromParts: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateFromParts),
/* harmony export */   $dateFromString: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateFromString),
/* harmony export */   $dateSubtract: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateSubtract),
/* harmony export */   $dateToParts: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateToParts),
/* harmony export */   $dateToString: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateToString),
/* harmony export */   $dateTrunc: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dateTrunc),
/* harmony export */   $dayOfMonth: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dayOfMonth),
/* harmony export */   $dayOfWeek: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dayOfWeek),
/* harmony export */   $dayOfYear: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$dayOfYear),
/* harmony export */   $degreesToRadians: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$degreesToRadians),
/* harmony export */   $divide: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$divide),
/* harmony export */   $eq: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$eq),
/* harmony export */   $exp: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$exp),
/* harmony export */   $filter: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$filter),
/* harmony export */   $first: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$first),
/* harmony export */   $firstN: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$firstN),
/* harmony export */   $floor: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$floor),
/* harmony export */   $function: () => (/* reexport safe */ _custom__WEBPACK_IMPORTED_MODULE_6__.$function),
/* harmony export */   $getField: () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_10__.$getField),
/* harmony export */   $gt: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$gt),
/* harmony export */   $gte: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$gte),
/* harmony export */   $hour: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$hour),
/* harmony export */   $ifNull: () => (/* reexport safe */ _conditional__WEBPACK_IMPORTED_MODULE_5__.$ifNull),
/* harmony export */   $in: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$in),
/* harmony export */   $indexOfArray: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$indexOfArray),
/* harmony export */   $indexOfBytes: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$indexOfBytes),
/* harmony export */   $isArray: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$isArray),
/* harmony export */   $isNumber: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$isNumber),
/* harmony export */   $isoDayOfWeek: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$isoDayOfWeek),
/* harmony export */   $isoWeek: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$isoWeek),
/* harmony export */   $isoWeekYear: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$isoWeekYear),
/* harmony export */   $last: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$last),
/* harmony export */   $lastN: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$lastN),
/* harmony export */   $let: () => (/* reexport safe */ _variable__WEBPACK_IMPORTED_MODULE_17__.$let),
/* harmony export */   $literal: () => (/* reexport safe */ _literal__WEBPACK_IMPORTED_MODULE_8__.$literal),
/* harmony export */   $ln: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$ln),
/* harmony export */   $log: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$log),
/* harmony export */   $log10: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$log10),
/* harmony export */   $lt: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$lt),
/* harmony export */   $lte: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$lte),
/* harmony export */   $ltrim: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$ltrim),
/* harmony export */   $map: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$map),
/* harmony export */   $maxN: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$maxN),
/* harmony export */   $median: () => (/* reexport safe */ _median__WEBPACK_IMPORTED_MODULE_9__.$median),
/* harmony export */   $mergeObjects: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_11__.$mergeObjects),
/* harmony export */   $millisecond: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$millisecond),
/* harmony export */   $minN: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$minN),
/* harmony export */   $minute: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$minute),
/* harmony export */   $mod: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$mod),
/* harmony export */   $month: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$month),
/* harmony export */   $multiply: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$multiply),
/* harmony export */   $ne: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_4__.$ne),
/* harmony export */   $nin: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$nin),
/* harmony export */   $not: () => (/* reexport safe */ _boolean__WEBPACK_IMPORTED_MODULE_3__.$not),
/* harmony export */   $objectToArray: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_11__.$objectToArray),
/* harmony export */   $or: () => (/* reexport safe */ _boolean__WEBPACK_IMPORTED_MODULE_3__.$or),
/* harmony export */   $percentile: () => (/* reexport safe */ _percentile__WEBPACK_IMPORTED_MODULE_12__.$percentile),
/* harmony export */   $pow: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$pow),
/* harmony export */   $radiansToDegrees: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$radiansToDegrees),
/* harmony export */   $rand: () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_10__.$rand),
/* harmony export */   $range: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$range),
/* harmony export */   $reduce: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$reduce),
/* harmony export */   $regexFind: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$regexFind),
/* harmony export */   $regexFindAll: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$regexFindAll),
/* harmony export */   $regexMatch: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$regexMatch),
/* harmony export */   $replaceAll: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$replaceAll),
/* harmony export */   $replaceOne: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$replaceOne),
/* harmony export */   $reverseArray: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$reverseArray),
/* harmony export */   $round: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$round),
/* harmony export */   $rtrim: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$rtrim),
/* harmony export */   $sampleRate: () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_10__.$sampleRate),
/* harmony export */   $second: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$second),
/* harmony export */   $setDifference: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$setDifference),
/* harmony export */   $setEquals: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$setEquals),
/* harmony export */   $setField: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_11__.$setField),
/* harmony export */   $setIntersection: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$setIntersection),
/* harmony export */   $setIsSubset: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$setIsSubset),
/* harmony export */   $setUnion: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_13__.$setUnion),
/* harmony export */   $sin: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$sin),
/* harmony export */   $sinh: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$sinh),
/* harmony export */   $size: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$size),
/* harmony export */   $slice: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$slice),
/* harmony export */   $sortArray: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$sortArray),
/* harmony export */   $split: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$split),
/* harmony export */   $sqrt: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$sqrt),
/* harmony export */   $strLenBytes: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$strLenBytes),
/* harmony export */   $strLenCP: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$strLenCP),
/* harmony export */   $strcasecmp: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$strcasecmp),
/* harmony export */   $substr: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$substr),
/* harmony export */   $substrBytes: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$substrBytes),
/* harmony export */   $substrCP: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$substrCP),
/* harmony export */   $subtract: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$subtract),
/* harmony export */   $switch: () => (/* reexport safe */ _conditional__WEBPACK_IMPORTED_MODULE_5__.$switch),
/* harmony export */   $tan: () => (/* reexport safe */ _trignometry__WEBPACK_IMPORTED_MODULE_15__.$tan),
/* harmony export */   $toBool: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toBool),
/* harmony export */   $toDate: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toDate),
/* harmony export */   $toDecimal: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toDecimal),
/* harmony export */   $toDouble: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toDouble),
/* harmony export */   $toInt: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toInt),
/* harmony export */   $toLong: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toLong),
/* harmony export */   $toLower: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$toLower),
/* harmony export */   $toString: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$toString),
/* harmony export */   $toUpper: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$toUpper),
/* harmony export */   $trim: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_14__.$trim),
/* harmony export */   $trunc: () => (/* reexport safe */ _arithmetic__WEBPACK_IMPORTED_MODULE_0__.$trunc),
/* harmony export */   $type: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_16__.$type),
/* harmony export */   $unsetField: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_11__.$unsetField),
/* harmony export */   $week: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$week),
/* harmony export */   $year: () => (/* reexport safe */ _date__WEBPACK_IMPORTED_MODULE_7__.$year),
/* harmony export */   $zip: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.$zip)
/* harmony export */ });
/* harmony import */ var _arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arithmetic */ "./node_modules/mingo/dist/esm/operators/expression/arithmetic/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/mingo/dist/esm/operators/expression/array/index.js");
/* harmony import */ var _bitwise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bitwise */ "./node_modules/mingo/dist/esm/operators/expression/bitwise/index.js");
/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boolean */ "./node_modules/mingo/dist/esm/operators/expression/boolean/index.js");
/* harmony import */ var _comparison__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./comparison */ "./node_modules/mingo/dist/esm/operators/expression/comparison/index.js");
/* harmony import */ var _conditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./conditional */ "./node_modules/mingo/dist/esm/operators/expression/conditional/index.js");
/* harmony import */ var _custom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./custom */ "./node_modules/mingo/dist/esm/operators/expression/custom/index.js");
/* harmony import */ var _date__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./date */ "./node_modules/mingo/dist/esm/operators/expression/date/index.js");
/* harmony import */ var _literal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./literal */ "./node_modules/mingo/dist/esm/operators/expression/literal.js");
/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./median */ "./node_modules/mingo/dist/esm/operators/expression/median.js");
/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./misc */ "./node_modules/mingo/dist/esm/operators/expression/misc/index.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./object */ "./node_modules/mingo/dist/esm/operators/expression/object/index.js");
/* harmony import */ var _percentile__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./percentile */ "./node_modules/mingo/dist/esm/operators/expression/percentile.js");
/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./set */ "./node_modules/mingo/dist/esm/operators/expression/set/index.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./string */ "./node_modules/mingo/dist/esm/operators/expression/string/index.js");
/* harmony import */ var _trignometry__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./trignometry */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/index.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./type */ "./node_modules/mingo/dist/esm/operators/expression/type/index.js");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./variable */ "./node_modules/mingo/dist/esm/operators/expression/variable/index.js");




















/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/literal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/literal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $literal: () => (/* binding */ $literal)
/* harmony export */ });
const $literal = (_obj, expr, _options) => expr;



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/median.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/median.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $median: () => (/* binding */ $median)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _accumulator_median__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accumulator/median */ "./node_modules/mingo/dist/esm/operators/accumulator/median.js");


const $median = (obj, expr, options) => {
  const input = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.input, null, options);
  return (0,_accumulator_median__WEBPACK_IMPORTED_MODULE_1__.$median)(input, { input: "$$CURRENT" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/misc/getField.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/misc/getField.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $getField: () => (/* binding */ $getField)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $getField = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const [field, input] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(args) ? [args.field, args.input || obj] : [args, obj];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(input),
    "$getField expression 'input' must evaluate to an object"
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(field),
    "$getField expression 'field' must evaluate to a string"
  );
  return input[field];
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/misc/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/misc/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $getField: () => (/* reexport safe */ _getField__WEBPACK_IMPORTED_MODULE_0__.$getField),
/* harmony export */   $rand: () => (/* reexport safe */ _rand__WEBPACK_IMPORTED_MODULE_1__.$rand),
/* harmony export */   $sampleRate: () => (/* reexport safe */ _sampleRate__WEBPACK_IMPORTED_MODULE_2__.$sampleRate)
/* harmony export */ });
/* harmony import */ var _getField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getField */ "./node_modules/mingo/dist/esm/operators/expression/misc/getField.js");
/* harmony import */ var _rand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rand */ "./node_modules/mingo/dist/esm/operators/expression/misc/rand.js");
/* harmony import */ var _sampleRate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sampleRate */ "./node_modules/mingo/dist/esm/operators/expression/misc/sampleRate.js");





/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/misc/rand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/misc/rand.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $rand: () => (/* binding */ $rand)
/* harmony export */ });
const $rand = (_obj, _expr, _options) => Math.random();



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/misc/sampleRate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/misc/sampleRate.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sampleRate: () => (/* binding */ $sampleRate)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $sampleRate = (obj, expr, options) => Math.random() <= (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/object/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/object/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mergeObjects: () => (/* reexport safe */ _mergeObjects__WEBPACK_IMPORTED_MODULE_0__.$mergeObjects),
/* harmony export */   $objectToArray: () => (/* reexport safe */ _objectToArray__WEBPACK_IMPORTED_MODULE_1__.$objectToArray),
/* harmony export */   $setField: () => (/* reexport safe */ _setField__WEBPACK_IMPORTED_MODULE_2__.$setField),
/* harmony export */   $unsetField: () => (/* reexport safe */ _unsetField__WEBPACK_IMPORTED_MODULE_3__.$unsetField)
/* harmony export */ });
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeObjects */ "./node_modules/mingo/dist/esm/operators/expression/object/mergeObjects.js");
/* harmony import */ var _objectToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objectToArray */ "./node_modules/mingo/dist/esm/operators/expression/object/objectToArray.js");
/* harmony import */ var _setField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setField */ "./node_modules/mingo/dist/esm/operators/expression/object/setField.js");
/* harmony import */ var _unsetField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unsetField */ "./node_modules/mingo/dist/esm/operators/expression/object/unsetField.js");






/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/object/mergeObjects.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/object/mergeObjects.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mergeObjects: () => (/* binding */ $mergeObjects)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $mergeObjects = (obj, expr, options) => {
  const docs = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options) ?? [];
  const acc = {};
  for (const o of docs) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(o)) continue;
    for (const k of Object.keys(o)) {
      if (o[k] !== void 0) acc[k] = o[k];
    }
  }
  return acc;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/object/objectToArray.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/object/objectToArray.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $objectToArray: () => (/* binding */ $objectToArray)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $objectToArray = (obj, expr, options) => {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(val),
    `$objectToArray requires a document input, found: ${(0,_util__WEBPACK_IMPORTED_MODULE_1__.typeOf)(val)}`
  );
  const entries = Object.entries(val);
  const result = new Array(entries.length);
  let i = 0;
  for (const [k, v] of entries) {
    result[i++] = { k, v };
  }
  return result;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/object/setField.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/object/setField.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setField: () => (/* binding */ $setField)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setField = (obj, expr, options) => {
  const { input, field, value } = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    obj,
    expr,
    null,
    options
  );
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(input)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(input),
    "$setField expression 'input' must evaluate to an object"
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(field),
    "$setField expression 'field' must evaluate to a string"
  );
  const newObj = { ...input };
  if (expr.value == "$$REMOVE") {
    delete newObj[field];
  } else {
    newObj[field] = value;
  }
  return newObj;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/object/unsetField.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/object/unsetField.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $unsetField: () => (/* binding */ $unsetField)
/* harmony export */ });
/* harmony import */ var _setField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setField */ "./node_modules/mingo/dist/esm/operators/expression/object/setField.js");

const $unsetField = (obj, expr, options) => {
  return (0,_setField__WEBPACK_IMPORTED_MODULE_0__.$setField)(
    obj,
    {
      ...expr,
      value: "$$REMOVE"
    },
    options
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/percentile.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/percentile.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $percentile: () => (/* binding */ $percentile)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _accumulator_percentile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accumulator/percentile */ "./node_modules/mingo/dist/esm/operators/accumulator/percentile.js");


const $percentile = (obj, expr, options) => {
  const input = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.input, null, options);
  return (0,_accumulator_percentile__WEBPACK_IMPORTED_MODULE_1__.$percentile)(input, { ...expr, input: "$$CURRENT" }, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/allElementsTrue.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/allElementsTrue.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $allElementsTrue: () => (/* binding */ $allElementsTrue)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $allElementsTrue = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options)[0];
  return args.every((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(v, options.useStrictMode));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/anyElementTrue.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/anyElementTrue.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $anyElementTrue: () => (/* binding */ $anyElementTrue)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $anyElementTrue = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options)[0];
  return args.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.truthy)(v, options.useStrictMode));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $allElementsTrue: () => (/* reexport safe */ _allElementsTrue__WEBPACK_IMPORTED_MODULE_0__.$allElementsTrue),
/* harmony export */   $anyElementTrue: () => (/* reexport safe */ _anyElementTrue__WEBPACK_IMPORTED_MODULE_1__.$anyElementTrue),
/* harmony export */   $setDifference: () => (/* reexport safe */ _setDifference__WEBPACK_IMPORTED_MODULE_2__.$setDifference),
/* harmony export */   $setEquals: () => (/* reexport safe */ _setEquals__WEBPACK_IMPORTED_MODULE_3__.$setEquals),
/* harmony export */   $setIntersection: () => (/* reexport safe */ _setIntersection__WEBPACK_IMPORTED_MODULE_4__.$setIntersection),
/* harmony export */   $setIsSubset: () => (/* reexport safe */ _setIsSubset__WEBPACK_IMPORTED_MODULE_5__.$setIsSubset),
/* harmony export */   $setUnion: () => (/* reexport safe */ _setUnion__WEBPACK_IMPORTED_MODULE_6__.$setUnion)
/* harmony export */ });
/* harmony import */ var _allElementsTrue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./allElementsTrue */ "./node_modules/mingo/dist/esm/operators/expression/set/allElementsTrue.js");
/* harmony import */ var _anyElementTrue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./anyElementTrue */ "./node_modules/mingo/dist/esm/operators/expression/set/anyElementTrue.js");
/* harmony import */ var _setDifference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setDifference */ "./node_modules/mingo/dist/esm/operators/expression/set/setDifference.js");
/* harmony import */ var _setEquals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./setEquals */ "./node_modules/mingo/dist/esm/operators/expression/set/setEquals.js");
/* harmony import */ var _setIntersection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./setIntersection */ "./node_modules/mingo/dist/esm/operators/expression/set/setIntersection.js");
/* harmony import */ var _setIsSubset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./setIsSubset */ "./node_modules/mingo/dist/esm/operators/expression/set/setIsSubset.js");
/* harmony import */ var _setUnion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./setUnion */ "./node_modules/mingo/dist/esm/operators/expression/set/setUnion.js");









/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/setDifference.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/setDifference.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setDifference: () => (/* binding */ $setDifference)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setDifference = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args), "$setDifference must be an arrays.");
  if (args.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(args.length == 2, `$setDifference takes exactly 2 arguments.`);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isArray), "$setDifference operands must be arrays.");
  const m = _util__WEBPACK_IMPORTED_MODULE_1__.ValueMap.init(options.hashFunction);
  args[0].forEach((v) => m.set(v, true));
  args[1].forEach((v) => m.delete(v));
  return Array.from(m.keys());
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/setEquals.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/setEquals.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setEquals: () => (/* binding */ $setEquals)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setEquals = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isArray),
    "$setEquals operands must be arrays."
  );
  const map = _util__WEBPACK_IMPORTED_MODULE_1__.ValueMap.init();
  args[0].every((v, i) => map.set(v, i));
  for (let i = 1; i < args.length; i++) {
    const arr = args[i];
    const set = /* @__PURE__ */ new Set();
    for (let j = 0; j < arr.length; j++) {
      const n = map.get(arr[j]) ?? -1;
      if (n === -1) return false;
      set.add(n);
    }
    if (set.size !== map.size) return false;
  }
  return true;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/setIntersection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/setIntersection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setIntersection: () => (/* binding */ $setIntersection)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setIntersection = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isArray),
    "$setIntersection operands must be arrays."
  );
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.intersection)(args, options?.hashFunction);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/setIsSubset.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/setIsSubset.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setIsSubset: () => (/* binding */ $setIsSubset)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setIsSubset = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) && args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isArray),
    "$setIsSubset operands must be arrays."
  );
  const first = args[0];
  const second = args[1];
  const map = _util__WEBPACK_IMPORTED_MODULE_1__.ValueMap.init();
  const set = /* @__PURE__ */ new Set();
  first.every((v, i) => map.set(v, i));
  for (const v of second) {
    set.add(map.get(v) ?? -1);
    if (set.size > map.size) return true;
  }
  set.delete(-1);
  return set.size == map.size;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/set/setUnion.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/set/setUnion.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setUnion: () => (/* binding */ $setUnion)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $setUnion = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(args), "$setUnion operands must be arrays.");
  if (args.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.unique)((0,_util__WEBPACK_IMPORTED_MODULE_1__.flatten)(args), options?.hashFunction);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/_internal.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   regexSearch: () => (/* binding */ regexSearch),
/* harmony export */   trimString: () => (/* binding */ trimString)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const WHITESPACE_CHARS = [
  0,
  // '\0' Null character
  32,
  // ' ', Space
  9,
  // '\t' Horizontal tab
  10,
  // '\n' Line feed/new line
  11,
  // '\v' Vertical tab
  12,
  // '\f' Form feed
  13,
  // '\r' Carriage return
  160,
  // Non-breaking space
  5760,
  // Ogham space mark
  8192,
  // En quad
  8193,
  // Em quad
  8194,
  // En space
  8195,
  // Em space
  8196,
  // Three-per-em space
  8197,
  // Four-per-em space
  8198,
  // Six-per-em space
  8199,
  // Figure space
  8200,
  // Punctuation space
  8201,
  // Thin space
  8202
  // Hair space
];
function trimString(obj, expr, options, trimOpts) {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const s = val.input;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(s)) return null;
  const codepoints = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val.chars) ? WHITESPACE_CHARS : val.chars.split("").map((c) => c.codePointAt(0));
  let i = 0;
  let j = s.length - 1;
  while (trimOpts.left && i <= j && codepoints.indexOf(s[i].codePointAt(0)) !== -1)
    i++;
  while (trimOpts.right && i <= j && codepoints.indexOf(s[j].codePointAt(0)) !== -1)
    j--;
  return s.substring(i, j + 1);
}
function regexSearch(obj, expr, options, reOpts) {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(val.input)) return [];
  const regexOptions = val.options;
  if (regexOptions) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      regexOptions.indexOf("x") === -1,
      "extended capability option 'x' not supported"
    );
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(regexOptions.indexOf("g") === -1, "global option 'g' not supported");
  }
  let input = val.input;
  const re = new RegExp(val.regex, regexOptions);
  let m;
  const matches = new Array();
  let offset = 0;
  while (m = re.exec(input)) {
    const result = {
      match: m[0],
      idx: m.index + offset,
      captures: []
    };
    for (let i = 1; i < m.length; i++) result.captures.push(m[i] || null);
    matches.push(result);
    if (!reOpts.global) break;
    offset = m.index + m[0].length;
    input = input.substring(offset);
  }
  return matches;
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/concat.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/concat.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $concat: () => (/* binding */ $concat)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $concat = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    args.every((v) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(v) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(v)),
    "$concat only supports strings."
  );
  if (args.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  return args.join("");
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $concat: () => (/* reexport safe */ _concat__WEBPACK_IMPORTED_MODULE_0__.$concat),
/* harmony export */   $indexOfBytes: () => (/* reexport safe */ _indexOfBytes__WEBPACK_IMPORTED_MODULE_1__.$indexOfBytes),
/* harmony export */   $ltrim: () => (/* reexport safe */ _ltrim__WEBPACK_IMPORTED_MODULE_2__.$ltrim),
/* harmony export */   $regexFind: () => (/* reexport safe */ _regexFind__WEBPACK_IMPORTED_MODULE_3__.$regexFind),
/* harmony export */   $regexFindAll: () => (/* reexport safe */ _regexFindAll__WEBPACK_IMPORTED_MODULE_4__.$regexFindAll),
/* harmony export */   $regexMatch: () => (/* reexport safe */ _regexMatch__WEBPACK_IMPORTED_MODULE_5__.$regexMatch),
/* harmony export */   $replaceAll: () => (/* reexport safe */ _replaceAll__WEBPACK_IMPORTED_MODULE_6__.$replaceAll),
/* harmony export */   $replaceOne: () => (/* reexport safe */ _replaceOne__WEBPACK_IMPORTED_MODULE_7__.$replaceOne),
/* harmony export */   $rtrim: () => (/* reexport safe */ _rtrim__WEBPACK_IMPORTED_MODULE_8__.$rtrim),
/* harmony export */   $split: () => (/* reexport safe */ _split__WEBPACK_IMPORTED_MODULE_9__.$split),
/* harmony export */   $strLenBytes: () => (/* reexport safe */ _strLenBytes__WEBPACK_IMPORTED_MODULE_11__.$strLenBytes),
/* harmony export */   $strLenCP: () => (/* reexport safe */ _strLenCP__WEBPACK_IMPORTED_MODULE_12__.$strLenCP),
/* harmony export */   $strcasecmp: () => (/* reexport safe */ _strcasecmp__WEBPACK_IMPORTED_MODULE_10__.$strcasecmp),
/* harmony export */   $substr: () => (/* reexport safe */ _substr__WEBPACK_IMPORTED_MODULE_13__.$substr),
/* harmony export */   $substrBytes: () => (/* reexport safe */ _substrBytes__WEBPACK_IMPORTED_MODULE_14__.$substrBytes),
/* harmony export */   $substrCP: () => (/* reexport safe */ _substrCP__WEBPACK_IMPORTED_MODULE_15__.$substrCP),
/* harmony export */   $toLower: () => (/* reexport safe */ _toLower__WEBPACK_IMPORTED_MODULE_16__.$toLower),
/* harmony export */   $toUpper: () => (/* reexport safe */ _toUpper__WEBPACK_IMPORTED_MODULE_17__.$toUpper),
/* harmony export */   $trim: () => (/* reexport safe */ _trim__WEBPACK_IMPORTED_MODULE_18__.$trim)
/* harmony export */ });
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./concat */ "./node_modules/mingo/dist/esm/operators/expression/string/concat.js");
/* harmony import */ var _indexOfBytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./indexOfBytes */ "./node_modules/mingo/dist/esm/operators/expression/string/indexOfBytes.js");
/* harmony import */ var _ltrim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ltrim */ "./node_modules/mingo/dist/esm/operators/expression/string/ltrim.js");
/* harmony import */ var _regexFind__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./regexFind */ "./node_modules/mingo/dist/esm/operators/expression/string/regexFind.js");
/* harmony import */ var _regexFindAll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./regexFindAll */ "./node_modules/mingo/dist/esm/operators/expression/string/regexFindAll.js");
/* harmony import */ var _regexMatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./regexMatch */ "./node_modules/mingo/dist/esm/operators/expression/string/regexMatch.js");
/* harmony import */ var _replaceAll__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./replaceAll */ "./node_modules/mingo/dist/esm/operators/expression/string/replaceAll.js");
/* harmony import */ var _replaceOne__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./replaceOne */ "./node_modules/mingo/dist/esm/operators/expression/string/replaceOne.js");
/* harmony import */ var _rtrim__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rtrim */ "./node_modules/mingo/dist/esm/operators/expression/string/rtrim.js");
/* harmony import */ var _split__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./split */ "./node_modules/mingo/dist/esm/operators/expression/string/split.js");
/* harmony import */ var _strcasecmp__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./strcasecmp */ "./node_modules/mingo/dist/esm/operators/expression/string/strcasecmp.js");
/* harmony import */ var _strLenBytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./strLenBytes */ "./node_modules/mingo/dist/esm/operators/expression/string/strLenBytes.js");
/* harmony import */ var _strLenCP__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./strLenCP */ "./node_modules/mingo/dist/esm/operators/expression/string/strLenCP.js");
/* harmony import */ var _substr__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./substr */ "./node_modules/mingo/dist/esm/operators/expression/string/substr.js");
/* harmony import */ var _substrBytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./substrBytes */ "./node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js");
/* harmony import */ var _substrCP__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./substrCP */ "./node_modules/mingo/dist/esm/operators/expression/string/substrCP.js");
/* harmony import */ var _toLower__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./toLower */ "./node_modules/mingo/dist/esm/operators/expression/string/toLower.js");
/* harmony import */ var _toUpper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./toUpper */ "./node_modules/mingo/dist/esm/operators/expression/string/toUpper.js");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./trim */ "./node_modules/mingo/dist/esm/operators/expression/string/trim.js");





















/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/indexOfBytes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/indexOfBytes.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $indexOfBytes: () => (/* binding */ $indexOfBytes)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $indexOfBytes = (obj, expr, options) => {
  const arr = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const errorMsg = "$indexOfBytes expression resolves to invalid an argument";
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(arr[0])) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(arr[0]) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(arr[1]), errorMsg);
  const str = arr[0];
  const searchStr = arr[1];
  let start = arr[2];
  let end = arr[3];
  let valid = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(start) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(start) && start >= 0 && Math.round(start) === start;
  valid = valid && ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(end) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(end) && end >= 0 && Math.round(end) === end);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(valid, errorMsg);
  start = start || 0;
  end = end || str.length;
  if (start > end) return -1;
  const index = str.substring(start, end).indexOf(searchStr);
  return index > -1 ? index + start : index;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/ltrim.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/ltrim.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ltrim: () => (/* binding */ $ltrim)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $ltrim = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.trimString)(obj, expr, options, { left: true, right: false });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/regexFind.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/regexFind.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $regexFind: () => (/* binding */ $regexFind)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $regexFind = (obj, expr, options) => {
  const result = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.regexSearch)(obj, expr, options, { global: false });
  return result && result.length > 0 ? result[0] : null;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/regexFindAll.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/regexFindAll.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $regexFindAll: () => (/* binding */ $regexFindAll)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $regexFindAll = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.regexSearch)(obj, expr, options, { global: true });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/regexMatch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/regexMatch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $regexMatch: () => (/* binding */ $regexMatch)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $regexMatch = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.regexSearch)(obj, expr, options, { global: false }).length != 0;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/replaceAll.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/replaceAll.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $replaceAll: () => (/* binding */ $replaceAll)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $replaceAll = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const arr = [args.input, args.find, args.replacement];
  if (arr.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    arr.every(_util__WEBPACK_IMPORTED_MODULE_1__.isString),
    "$replaceAll expression fields must evaluate to string"
  );
  return args.input.replace(new RegExp(args.find, "g"), args.replacement);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/replaceOne.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/replaceOne.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $replaceOne: () => (/* binding */ $replaceOne)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $replaceOne = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const arr = [args.input, args.find, args.replacement];
  if (arr.some(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    arr.every(_util__WEBPACK_IMPORTED_MODULE_1__.isString),
    "$replaceOne expression fields must evaluate to string"
  );
  return args.input.replace(args.find, args.replacement);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/rtrim.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/rtrim.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $rtrim: () => (/* binding */ $rtrim)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $rtrim = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.trimString)(obj, expr, options, { left: false, right: true });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/split.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/split.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $split: () => (/* binding */ $split)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $split = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args[0])) return null;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isString),
    "$split expression must result to array(2) of strings"
  );
  return args[0].split(args[1]);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/strLenBytes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/strLenBytes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $strLenBytes: () => (/* binding */ $strLenBytes)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $strLenBytes = (obj, expr, options) => {
  return ~-encodeURI((0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options)).split(
    /%..|./
  ).length;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/strLenCP.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/strLenCP.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $strLenCP: () => (/* binding */ $strLenCP)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $strLenCP = (obj, expr, options) => {
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options).length;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/strcasecmp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/strcasecmp.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $strcasecmp: () => (/* binding */ $strcasecmp)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $strcasecmp = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  let a = args[0];
  let b = args[1];
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isEqual)(a, b) || args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isNil)) return 0;
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    args.every(_util__WEBPACK_IMPORTED_MODULE_1__.isString),
    "$strcasecmp must resolve to array(2) of strings"
  );
  a = a.toUpperCase();
  b = b.toUpperCase();
  return a > b && 1 || a < b && -1 || 0;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/substr.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/substr.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $substr: () => (/* binding */ $substr)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $substr = (obj, expr, options) => {
  const [s, start, count] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (start < 0 || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(s)) return "";
  if (count < 0) return s.substring(start);
  return s.substring(start, start + count);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $substrBytes: () => (/* binding */ $substrBytes)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const UTF8_MASK = [192, 224, 240];
function toUtf8(n) {
  if (n < 128) return [n];
  let count = n < 2048 && 1 || n < 65536 && 2 || 3;
  const offset = UTF8_MASK[count - 1];
  const utf8 = [(n >> 6 * count) + offset];
  while (count > 0) utf8.push(128 | n >> 6 * --count & 63);
  return utf8;
}
function utf8Encode(s) {
  const buf = [];
  for (let i = 0, len = s.length; i < len; i++) {
    buf.push(toUtf8(s.codePointAt(i)));
  }
  return buf;
}
const $substrBytes = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  const s = args[0];
  const index = args[1];
  const count = args[2];
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(s) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) && index >= 0 && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(count) && count >= 0,
    "$substrBytes: invalid arguments"
  );
  const buf = utf8Encode(s);
  const validIndex = [];
  let acc = 0;
  for (let i = 0; i < buf.length; i++) {
    validIndex.push(acc);
    acc += buf[i].length;
  }
  const begin = validIndex.indexOf(index);
  const end = validIndex.indexOf(index + count);
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    begin > -1 && end > -1,
    "$substrBytes: invalid range, start or end index is a UTF-8 continuation byte."
  );
  return s.substring(begin, end);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/substrCP.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/substrCP.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $substrCP: () => (/* binding */ $substrCP)
/* harmony export */ });
/* harmony import */ var _substr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./substr */ "./node_modules/mingo/dist/esm/operators/expression/string/substr.js");

const $substrCP = (obj, expr, options) => {
  return (0,_substr__WEBPACK_IMPORTED_MODULE_0__.$substr)(obj, expr, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/toLower.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/toLower.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toLower: () => (/* binding */ $toLower)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $toLower = (obj, expr, options) => {
  const value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(value) ? "" : value.toLowerCase();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/toUpper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/toUpper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toUpper: () => (/* binding */ $toUpper)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $toUpper = (obj, expr, options) => {
  const value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(value) ? "" : value.toUpperCase();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/string/trim.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/string/trim.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $trim: () => (/* binding */ $trim)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/string/_internal.js");

const $trim = (obj, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.trimString)(obj, expr, options, { left: true, right: true });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTrignometryOperator: () => (/* binding */ createTrignometryOperator)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr, options) => {
    const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
    if (keySet.has(`${n}`)) {
      const res = fp[`${n}`];
      if (res instanceof Error) {
        throw new _util__WEBPACK_IMPORTED_MODULE_1__.MingoError(
          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`
        );
      }
      return res;
    }
    return f(n);
  };
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $acos: () => (/* binding */ $acos)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $acos = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $acosh: () => (/* binding */ $acosh)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $acosh = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $asin: () => (/* binding */ $asin)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $asin = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.asin);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $asinh: () => (/* binding */ $asinh)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $asinh = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $atan: () => (/* binding */ $atan)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $atan = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.atan);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atan2.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/atan2.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $atan2: () => (/* binding */ $atan2)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $atan2 = (obj, expr, options) => {
  const [y, x] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (isNaN(y) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(y)) return y;
  if (isNaN(x) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(x)) return x;
  return Math.atan2(y, x);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $atanh: () => (/* binding */ $atanh)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $atanh = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cos: () => (/* binding */ $cos)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $cos = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.cos);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $cosh: () => (/* binding */ $cosh)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $cosh = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $degreesToRadians: () => (/* binding */ $degreesToRadians)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const RADIANS_FACTOR = Math.PI / 180;
const $degreesToRadians = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(
  (n) => n * RADIANS_FACTOR,
  {
    Infinity: Infinity,
    "-Infinity": Infinity
  }
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $acos: () => (/* reexport safe */ _acos__WEBPACK_IMPORTED_MODULE_0__.$acos),
/* harmony export */   $acosh: () => (/* reexport safe */ _acosh__WEBPACK_IMPORTED_MODULE_1__.$acosh),
/* harmony export */   $asin: () => (/* reexport safe */ _asin__WEBPACK_IMPORTED_MODULE_2__.$asin),
/* harmony export */   $asinh: () => (/* reexport safe */ _asinh__WEBPACK_IMPORTED_MODULE_3__.$asinh),
/* harmony export */   $atan: () => (/* reexport safe */ _atan__WEBPACK_IMPORTED_MODULE_4__.$atan),
/* harmony export */   $atan2: () => (/* reexport safe */ _atan2__WEBPACK_IMPORTED_MODULE_5__.$atan2),
/* harmony export */   $atanh: () => (/* reexport safe */ _atanh__WEBPACK_IMPORTED_MODULE_6__.$atanh),
/* harmony export */   $cos: () => (/* reexport safe */ _cos__WEBPACK_IMPORTED_MODULE_7__.$cos),
/* harmony export */   $cosh: () => (/* reexport safe */ _cosh__WEBPACK_IMPORTED_MODULE_8__.$cosh),
/* harmony export */   $degreesToRadians: () => (/* reexport safe */ _degreesToRadians__WEBPACK_IMPORTED_MODULE_9__.$degreesToRadians),
/* harmony export */   $radiansToDegrees: () => (/* reexport safe */ _radiansToDegrees__WEBPACK_IMPORTED_MODULE_10__.$radiansToDegrees),
/* harmony export */   $sin: () => (/* reexport safe */ _sin__WEBPACK_IMPORTED_MODULE_11__.$sin),
/* harmony export */   $sinh: () => (/* reexport safe */ _sinh__WEBPACK_IMPORTED_MODULE_12__.$sinh),
/* harmony export */   $tan: () => (/* reexport safe */ _tan__WEBPACK_IMPORTED_MODULE_13__.$tan)
/* harmony export */ });
/* harmony import */ var _acos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./acos */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js");
/* harmony import */ var _acosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./acosh */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js");
/* harmony import */ var _asin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./asin */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js");
/* harmony import */ var _asinh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asinh */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js");
/* harmony import */ var _atan__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./atan */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js");
/* harmony import */ var _atan2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./atan2 */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atan2.js");
/* harmony import */ var _atanh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./atanh */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js");
/* harmony import */ var _cos__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cos */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js");
/* harmony import */ var _cosh__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cosh */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js");
/* harmony import */ var _degreesToRadians__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./degreesToRadians */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js");
/* harmony import */ var _radiansToDegrees__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./radiansToDegrees */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js");
/* harmony import */ var _sin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sin */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js");
/* harmony import */ var _sinh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sinh */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js");
/* harmony import */ var _tan__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tan */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js");
















/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $radiansToDegrees: () => (/* binding */ $radiansToDegrees)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const DEGREES_FACTOR = 180 / Math.PI;
const $radiansToDegrees = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(
  (n) => n * DEGREES_FACTOR,
  {
    Infinity: Infinity,
    "-Infinity": -Infinity
  }
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sin: () => (/* binding */ $sin)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $sin = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.sin);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sinh: () => (/* binding */ $sinh)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $sinh = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $tan: () => (/* binding */ $tan)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js");

const $tan = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createTrignometryOperator)(Math.tan);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/_internal.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_INT: () => (/* binding */ MAX_INT),
/* harmony export */   MAX_LONG: () => (/* binding */ MAX_LONG),
/* harmony export */   MIN_INT: () => (/* binding */ MIN_INT),
/* harmony export */   MIN_LONG: () => (/* binding */ MIN_LONG),
/* harmony export */   TypeConvertError: () => (/* binding */ TypeConvertError),
/* harmony export */   toInteger: () => (/* binding */ toInteger)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const MAX_INT = 2147483647;
const MIN_INT = -2147483648;
const MAX_LONG = Number.MAX_SAFE_INTEGER;
const MIN_LONG = Number.MIN_SAFE_INTEGER;
class TypeConvertError extends Error {
  constructor(message) {
    super(message);
  }
}
function toInteger(obj, expr, options, min, max) {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (val === true) return 1;
  if (val === false) return 0;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(val)) return val.getTime();
  const n = Number(val);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n) && n >= min && n <= max) {
    if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(val) || n.toString().indexOf(".") === -1) {
      return Math.trunc(n);
    }
  }
  throw new TypeConvertError(
    `cannot convert '${val}' to ${max == MAX_INT ? "int" : "long"}`
  );
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/convert.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/convert.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $convert: () => (/* binding */ $convert)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");
/* harmony import */ var _toBool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toBool */ "./node_modules/mingo/dist/esm/operators/expression/type/toBool.js");
/* harmony import */ var _toDate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toDate */ "./node_modules/mingo/dist/esm/operators/expression/type/toDate.js");
/* harmony import */ var _toDouble__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toDouble */ "./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js");
/* harmony import */ var _toInt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toInt */ "./node_modules/mingo/dist/esm/operators/expression/type/toInt.js");
/* harmony import */ var _toLong__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./toLong */ "./node_modules/mingo/dist/esm/operators/expression/type/toLong.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toString */ "./node_modules/mingo/dist/esm/operators/expression/type/toString.js");









const $convert = (obj, expr, options) => {
  const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  args.onNull = args.onNull === void 0 ? null : args.onNull;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(args.input)) return args.onNull;
  try {
    switch (args.to) {
      case 2:
      case "string":
        return (0,_toString__WEBPACK_IMPORTED_MODULE_8__.$toString)(obj, args.input, options);
      case 8:
      case "boolean":
      case "bool":
        return (0,_toBool__WEBPACK_IMPORTED_MODULE_3__.$toBool)(obj, args.input, options);
      case 9:
      case "date":
        return (0,_toDate__WEBPACK_IMPORTED_MODULE_4__.$toDate)(obj, args.input, options);
      case 1:
      case 19:
      case "double":
      case "decimal":
      case "number":
        return (0,_toDouble__WEBPACK_IMPORTED_MODULE_5__.$toDouble)(obj, args.input, options);
      case 16:
      case "int":
        return (0,_toInt__WEBPACK_IMPORTED_MODULE_6__.$toInt)(obj, args.input, options);
      case 18:
      case "long":
        return (0,_toLong__WEBPACK_IMPORTED_MODULE_7__.$toLong)(obj, args.input, options);
    }
  } catch {
  }
  if (args.onError !== void 0) return args.onError;
  throw new _internal__WEBPACK_IMPORTED_MODULE_2__.TypeConvertError(`could not convert to type ${args.to}.`);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $convert: () => (/* reexport safe */ _convert__WEBPACK_IMPORTED_MODULE_0__.$convert),
/* harmony export */   $isNumber: () => (/* reexport safe */ _isNumber__WEBPACK_IMPORTED_MODULE_1__.$isNumber),
/* harmony export */   $toBool: () => (/* reexport safe */ _toBool__WEBPACK_IMPORTED_MODULE_2__.$toBool),
/* harmony export */   $toDate: () => (/* reexport safe */ _toDate__WEBPACK_IMPORTED_MODULE_3__.$toDate),
/* harmony export */   $toDecimal: () => (/* reexport safe */ _toDecimal__WEBPACK_IMPORTED_MODULE_4__.$toDecimal),
/* harmony export */   $toDouble: () => (/* reexport safe */ _toDouble__WEBPACK_IMPORTED_MODULE_5__.$toDouble),
/* harmony export */   $toInt: () => (/* reexport safe */ _toInt__WEBPACK_IMPORTED_MODULE_6__.$toInt),
/* harmony export */   $toLong: () => (/* reexport safe */ _toLong__WEBPACK_IMPORTED_MODULE_7__.$toLong),
/* harmony export */   $toString: () => (/* reexport safe */ _toString__WEBPACK_IMPORTED_MODULE_8__.$toString),
/* harmony export */   $type: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_9__.$type)
/* harmony export */ });
/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert */ "./node_modules/mingo/dist/esm/operators/expression/type/convert.js");
/* harmony import */ var _isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNumber */ "./node_modules/mingo/dist/esm/operators/expression/type/isNumber.js");
/* harmony import */ var _toBool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toBool */ "./node_modules/mingo/dist/esm/operators/expression/type/toBool.js");
/* harmony import */ var _toDate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toDate */ "./node_modules/mingo/dist/esm/operators/expression/type/toDate.js");
/* harmony import */ var _toDecimal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toDecimal */ "./node_modules/mingo/dist/esm/operators/expression/type/toDecimal.js");
/* harmony import */ var _toDouble__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toDouble */ "./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js");
/* harmony import */ var _toInt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toInt */ "./node_modules/mingo/dist/esm/operators/expression/type/toInt.js");
/* harmony import */ var _toLong__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./toLong */ "./node_modules/mingo/dist/esm/operators/expression/type/toLong.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toString */ "./node_modules/mingo/dist/esm/operators/expression/type/toString.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./type */ "./node_modules/mingo/dist/esm/operators/expression/type/type.js");












/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/isNumber.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/isNumber.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $isNumber: () => (/* binding */ $isNumber)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $isNumber = (obj, expr, options) => {
  const n = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toBool.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toBool.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toBool: () => (/* binding */ $toBool)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $toBool = (obj, expr, options) => {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(val)) return true;
  return Boolean(val);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toDate.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toDate.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toDate: () => (/* binding */ $toDate)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");



const $toDate = (obj, expr, options) => {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(val)) return val;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  const d = new Date(val);
  const n = d.getTime();
  if (!isNaN(n)) return d;
  throw new _internal__WEBPACK_IMPORTED_MODULE_2__.TypeConvertError(`cannot convert '${val}' to date`);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toDecimal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toDecimal.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toDecimal: () => (/* binding */ $toDecimal)
/* harmony export */ });
/* harmony import */ var _toDouble__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDouble */ "./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js");

const $toDecimal = _toDouble__WEBPACK_IMPORTED_MODULE_0__.$toDouble;



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toDouble: () => (/* binding */ $toDouble)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");



const $toDouble = (obj, expr, options) => {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(val)) return val.getTime();
  if (val === true) return 1;
  if (val === false) return 0;
  const n = Number(val);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n)) return n;
  throw new _internal__WEBPACK_IMPORTED_MODULE_2__.TypeConvertError(`cannot convert '${val}' to double/decimal`);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toInt.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toInt.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toInt: () => (/* binding */ $toInt)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");

const $toInt = (obj, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_0__.toInteger)(obj, expr, options, _internal__WEBPACK_IMPORTED_MODULE_0__.MIN_INT, _internal__WEBPACK_IMPORTED_MODULE_0__.MAX_INT);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toLong.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toLong.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toLong: () => (/* binding */ $toLong)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");

const $toLong = (obj, expr, options) => (0,_internal__WEBPACK_IMPORTED_MODULE_0__.toInteger)(obj, expr, options, _internal__WEBPACK_IMPORTED_MODULE_0__.MIN_LONG, _internal__WEBPACK_IMPORTED_MODULE_0__.MAX_LONG);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/toString.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/toString.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $toString: () => (/* binding */ $toString)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _date_dateToString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../date/dateToString */ "./node_modules/mingo/dist/esm/operators/expression/date/dateToString.js");



const $toString = (obj, expr, options) => {
  const val = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(val)) return null;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isDate)(val)) {
    return (0,_date_dateToString__WEBPACK_IMPORTED_MODULE_2__.$dateToString)(
      obj,
      {
        date: expr,
        format: "%Y-%m-%dT%H:%M:%S.%LZ"
      },
      options
    );
  }
  return val.toString();
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/type/type.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/type/type.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $type: () => (/* binding */ $type)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/expression/type/_internal.js");



const $type = (obj, expr, options) => {
  const v = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
  if (options.useStrictMode) {
    if (v === void 0) return "missing";
    if (v === true || v === false) return "bool";
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v)) {
      if (v % 1 != 0) return "double";
      return v >= _internal__WEBPACK_IMPORTED_MODULE_2__.MIN_INT && v <= _internal__WEBPACK_IMPORTED_MODULE_2__.MAX_INT ? "int" : "long";
    }
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(v)) return "regex";
  }
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.typeOf)(v);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/variable/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/variable/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $let: () => (/* reexport safe */ _let__WEBPACK_IMPORTED_MODULE_0__.$let)
/* harmony export */ });
/* harmony import */ var _let__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./let */ "./node_modules/mingo/dist/esm/operators/expression/variable/let.js");



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/expression/variable/let.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/expression/variable/let.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $let: () => (/* binding */ $let)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

const $let = (obj, expr, options) => {
  const variables = {};
  for (const [key, val] of Object.entries(expr.vars)) {
    variables[key] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, val, null, options);
  }
  return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
    obj,
    expr.in,
    null,
    _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options, obj, { variables })
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/_internal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/_internal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isUnbounded: () => (/* binding */ isUnbounded)
/* harmony export */ });
const isUnbounded = (window) => {
  const boundary = window?.documents || window?.range;
  return !boundary || boundary[0] === "unbounded" && boundary[1] === "unbounded";
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/addFields.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/addFields.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $addFields: () => (/* binding */ $addFields)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $addFields = (collection, expr, options) => {
  const newFields = Object.keys(expr);
  if (newFields.length === 0) return collection;
  return collection.map((obj) => {
    const newObj = { ...obj };
    for (const field of newFields) {
      const newValue = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr[field], null, options);
      if (newValue !== void 0) {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.setValue)(newObj, field, newValue);
      } else {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(newObj, field);
      }
    }
    return newObj;
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/bucket.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/bucket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bucket: () => (/* binding */ $bucket)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");



const $bucket = (collection, expr, options) => {
  const bounds = [...expr.boundaries];
  const defaultKey = expr.default;
  const lower = bounds[0];
  const upper = bounds[bounds.length - 1];
  const outputExpr = expr.output || { count: { $sum: 1 } };
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(bounds.length > 1, "$bucket must specify at least two boundaries.");
  const isValid = bounds.every(
    (v, i) => i === 0 || (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(v) === (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(bounds[i - 1]) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(v, bounds[i - 1]) > 0
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    isValid,
    `$bucket: bounds must be of same type and in ascending order`
  );
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(defaultKey) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(defaultKey) === (0,_util__WEBPACK_IMPORTED_MODULE_2__.typeOf)(lower)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(defaultKey, upper) >= 0 || (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(defaultKey, lower) < 0,
      "$bucket 'default' expression must be out of boundaries range"
    );
  }
  const createBuckets = () => {
    const buckets = /* @__PURE__ */ new Map();
    for (let i = 0; i < bounds.length - 1; i++) {
      buckets.set(bounds[i], []);
    }
    if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(defaultKey)) buckets.set(defaultKey, []);
    collection.each((obj) => {
      const key = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.groupBy, null, options);
      if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(key) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(key, lower) < 0 || (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(key, upper) >= 0) {
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
          !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(defaultKey),
          "$bucket require a default for out of range values"
        );
        buckets.get(defaultKey).push(obj);
      } else {
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
          (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(key, lower) >= 0 && (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(key, upper) < 0,
          "$bucket 'groupBy' expression must resolve to a value in range of boundaries"
        );
        const index = (0,_util__WEBPACK_IMPORTED_MODULE_2__.findInsertIndex)(bounds, key);
        const boundKey = bounds[Math.max(0, index - 1)];
        buckets.get(boundKey).push(obj);
      }
    });
    bounds.pop();
    if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(defaultKey)) bounds.push(defaultKey);
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      buckets.size === bounds.length,
      "bounds and groups must be of equal size."
    );
    return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(bounds).map((key) => {
      return {
        ...(0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
          buckets.get(key),
          outputExpr,
          null,
          options
        ),
        _id: key
      };
    });
  };
  let iterator;
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(() => {
    if (!iterator) iterator = createBuckets();
    return iterator.next();
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bucketAuto: () => (/* binding */ $bucketAuto)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");



const $bucketAuto = (collection, expr, options) => {
  const {
    buckets: bucketCount,
    groupBy: groupByExpr,
    output: optOutputExpr,
    // Available only if the all groupBy values are numeric and none of them are NaN.
    granularity
  } = expr;
  const outputExpr = optOutputExpr ?? { count: { $sum: 1 } };
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    bucketCount > 0,
    `$bucketAuto: 'buckets' field must be greater than 0, but found: ${bucketCount}`
  );
  if (granularity) {
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      /^(POWERSOF2|1-2-5|E(6|12|24|48|96|192)|R(5|10|20|40|80))$/.test(
        granularity
      ),
      `$bucketAuto: invalid granularity '${granularity}'.`
    );
  }
  const keyMap = /* @__PURE__ */ new Map();
  const setKey = !granularity ? (o, k) => keyMap.set(o, k) : (_, _2) => {
  };
  const sorted = collection.map((o) => {
    const k = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, groupByExpr, null, options) ?? null;
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      !granularity || (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(k),
      "$bucketAuto: groupBy values must be numeric when granularity is specified."
    );
    setKey(o, k ?? null);
    return [k ?? null, o];
  }).value();
  sorted.sort((x, y) => {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(x[0])) return -1;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(y[0])) return 1;
    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.compare)(x[0], y[0]);
  });
  let getNext;
  if (!granularity) {
    getNext = granularityDefault(sorted, bucketCount, keyMap);
  } else if (granularity == "POWERSOF2") {
    getNext = granularityPowerOfTwo(
      sorted,
      bucketCount
    );
  } else {
    getNext = granularityPreferredSeries(
      sorted,
      bucketCount,
      granularity
    );
  }
  let terminate = false;
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(() => {
    if (terminate) return { done: true };
    const { min, max, bucket, done } = getNext();
    terminate = done;
    const outFields = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
      bucket,
      outputExpr,
      null,
      options
    );
    for (const [k, v] of Object.entries(outFields)) {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(v)) outFields[k] = v.filter((v2) => v2 !== void 0);
    }
    return {
      done: false,
      value: {
        ...outFields,
        _id: { min, max }
      }
    };
  });
};
function granularityDefault(sorted, bucketCount, keyMap) {
  const size = sorted.length;
  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));
  let index = 0;
  let nBuckets = 0;
  return () => {
    const isLastBucket = ++nBuckets == bucketCount;
    const bucket = new Array();
    while (index < size && (isLastBucket || bucket.length < approxBucketSize || index > 0 && (0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(sorted[index - 1][0], sorted[index][0]))) {
      bucket.push(sorted[index++][1]);
    }
    const min = keyMap.get(bucket[0]);
    let max;
    if (index < size) {
      max = sorted[index][0];
    } else {
      max = keyMap.get(bucket[bucket.length - 1]);
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(max) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(min) || min <= max,
      `error: $bucketAuto boundary must be in order.`
    );
    return {
      min,
      max,
      bucket,
      done: index >= size
    };
  };
}
function granularityPowerOfTwo(sorted, bucketCount) {
  const size = sorted.length;
  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));
  const roundUp2 = (n) => n === 0 ? 0 : 2 ** (Math.floor(Math.log2(n)) + 1);
  let index = 0;
  let min = 0;
  let max = 0;
  return () => {
    const bucket = new Array();
    const boundValue = roundUp2(max);
    min = index > 0 ? max : 0;
    while (bucket.length < approxBucketSize && index < size && (max === 0 || sorted[index][0] < boundValue)) {
      bucket.push(sorted[index++][1]);
    }
    max = max == 0 ? roundUp2(sorted[index - 1][0]) : boundValue;
    while (index < size && sorted[index][0] < max) {
      bucket.push(sorted[index++][1]);
    }
    return {
      min,
      max,
      bucket,
      done: index >= size
    };
  };
}
const PREFERRED_NUMBERS = Object.freeze({
  // "Least rounded" Renard number series, taken from Wikipedia page on preferred
  // numbers: https://en.wikipedia.org/wiki/Preferred_number#Renard_numbers
  R5: [10, 16, 25, 40, 63],
  R10: [100, 125, 160, 200, 250, 315, 400, 500, 630, 800],
  R20: [
    100,
    112,
    125,
    140,
    160,
    180,
    200,
    224,
    250,
    280,
    315,
    355,
    400,
    450,
    500,
    560,
    630,
    710,
    800,
    900
  ],
  R40: [
    100,
    106,
    112,
    118,
    125,
    132,
    140,
    150,
    160,
    170,
    180,
    190,
    200,
    212,
    224,
    236,
    250,
    265,
    280,
    300,
    315,
    355,
    375,
    400,
    425,
    450,
    475,
    500,
    530,
    560,
    600,
    630,
    670,
    710,
    750,
    800,
    850,
    900,
    950
  ],
  R80: [
    103,
    109,
    115,
    122,
    128,
    136,
    145,
    155,
    165,
    175,
    185,
    195,
    206,
    218,
    230,
    243,
    258,
    272,
    290,
    307,
    325,
    345,
    365,
    387,
    412,
    437,
    462,
    487,
    515,
    545,
    575,
    615,
    650,
    690,
    730,
    775,
    825,
    875,
    925,
    975
  ],
  // https://en.wikipedia.org/wiki/Preferred_number#1-2-5_series
  "1-2-5": [10, 20, 50],
  // E series, taken from Wikipedia page on preferred numbers:
  // https://en.wikipedia.org/wiki/Preferred_number#E_series
  E6: [10, 15, 22, 33, 47, 68],
  E12: [10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82],
  E24: [
    10,
    11,
    12,
    13,
    15,
    16,
    18,
    20,
    22,
    24,
    27,
    30,
    33,
    36,
    39,
    43,
    47,
    51,
    56,
    62,
    68,
    75,
    82,
    91
  ],
  E48: [
    100,
    105,
    110,
    115,
    121,
    127,
    133,
    140,
    147,
    154,
    162,
    169,
    178,
    187,
    196,
    205,
    215,
    226,
    237,
    249,
    261,
    274,
    287,
    301,
    316,
    332,
    348,
    365,
    383,
    402,
    422,
    442,
    464,
    487,
    511,
    536,
    562,
    590,
    619,
    649,
    681,
    715,
    750,
    787,
    825,
    866,
    909,
    953
  ],
  E96: [
    100,
    102,
    105,
    107,
    110,
    113,
    115,
    118,
    121,
    124,
    127,
    130,
    133,
    137,
    140,
    143,
    147,
    150,
    154,
    158,
    162,
    165,
    169,
    174,
    178,
    182,
    187,
    191,
    196,
    200,
    205,
    210,
    215,
    221,
    226,
    232,
    237,
    243,
    249,
    255,
    261,
    267,
    274,
    280,
    287,
    294,
    301,
    309,
    316,
    324,
    332,
    340,
    348,
    357,
    365,
    374,
    383,
    392,
    402,
    412,
    422,
    432,
    442,
    453,
    464,
    475,
    487,
    499,
    511,
    523,
    536,
    549,
    562,
    576,
    590,
    604,
    619,
    634,
    649,
    665,
    681,
    698,
    715,
    732,
    750,
    768,
    787,
    806,
    825,
    845,
    866,
    887,
    909,
    931,
    953,
    976
  ],
  E192: [
    100,
    101,
    102,
    104,
    105,
    106,
    107,
    109,
    110,
    111,
    113,
    114,
    115,
    117,
    118,
    120,
    121,
    123,
    124,
    126,
    127,
    129,
    130,
    132,
    133,
    135,
    137,
    138,
    140,
    142,
    143,
    145,
    147,
    149,
    150,
    152,
    154,
    156,
    158,
    160,
    162,
    164,
    165,
    167,
    169,
    172,
    174,
    176,
    178,
    180,
    182,
    184,
    187,
    189,
    191,
    193,
    196,
    198,
    200,
    203,
    205,
    208,
    210,
    213,
    215,
    218,
    221,
    223,
    226,
    229,
    232,
    234,
    237,
    240,
    243,
    246,
    249,
    252,
    255,
    258,
    261,
    264,
    267,
    271,
    274,
    277,
    280,
    284,
    287,
    291,
    294,
    298,
    301,
    305,
    309,
    312,
    316,
    320,
    324,
    328,
    332,
    336,
    340,
    344,
    348,
    352,
    357,
    361,
    365,
    370,
    374,
    379,
    383,
    388,
    392,
    397,
    402,
    407,
    412,
    417,
    422,
    427,
    432,
    437,
    442,
    448,
    453,
    459,
    464,
    470,
    475,
    481,
    487,
    493,
    499,
    505,
    511,
    517,
    523,
    530,
    536,
    542,
    549,
    556,
    562,
    569,
    576,
    583,
    590,
    597,
    604,
    612,
    619,
    626,
    634,
    642,
    649,
    657,
    665,
    673,
    681,
    690,
    698,
    706,
    715,
    723,
    732,
    741,
    750,
    759,
    768,
    777,
    787,
    796,
    806,
    816,
    825,
    835,
    845,
    856,
    866,
    876,
    887,
    898,
    909,
    920,
    931,
    942,
    953,
    965,
    976,
    988
  ]
});
const roundUp = (n, granularity) => {
  if (n == 0) return 0;
  const series = PREFERRED_NUMBERS[granularity];
  const first = series[0];
  const last = series[series.length - 1];
  let multiplier = 1;
  while (n >= last * multiplier) {
    multiplier *= 10;
  }
  let previousMin = 0;
  while (n < first * multiplier) {
    previousMin = first * multiplier;
    multiplier /= 10;
    if (n >= last * multiplier) {
      return previousMin;
    }
  }
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
    n >= first * multiplier && n < last * multiplier,
    "$bucketAuto: number out of range of series."
  );
  const i = (0,_util__WEBPACK_IMPORTED_MODULE_2__.findInsertIndex)(series, n, (a, b) => {
    b *= multiplier;
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });
  const seriesNumber = series[i] * multiplier;
  return n == seriesNumber ? series[i + 1] * multiplier : seriesNumber;
};
function granularityPreferredSeries(sorted, bucketCount, granularity) {
  const size = sorted.length;
  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));
  let index = 0;
  let nBuckets = 0;
  let min = 0;
  let max = 0;
  return () => {
    const isLastBucket = ++nBuckets == bucketCount;
    const bucket = new Array();
    min = index > 0 ? max : 0;
    while (index < size && (isLastBucket || bucket.length < approxBucketSize)) {
      bucket.push(sorted[index++][1]);
    }
    max = roundUp(sorted[index - 1][0], granularity);
    const nItems = bucket.length;
    while (index < size && (isLastBucket || sorted[index][0] < max)) {
      bucket.push(sorted[index++][1]);
    }
    if (nItems != bucket.length) {
      max = roundUp(sorted[index - 1][0], granularity);
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(min < max, `$bucketAuto: ${min} < ${max}.`);
    return {
      min,
      max,
      bucket,
      done: index >= size
    };
  };
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/count.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/count.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $count: () => (/* binding */ $count)
/* harmony export */ });
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $count = (collection, expr, _options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(expr) && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(expr) && expr.indexOf(".") === -1 && expr.trim()[0] !== "$",
    "Invalid expression value for $count"
  );
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_0__.Lazy)([
    {
      [expr]: collection.size()
    }
  ]);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/densify.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/densify.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $densify: () => (/* binding */ $densify)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types */ "./node_modules/mingo/dist/esm/types.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _expression_date_dateAdd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../expression/date/dateAdd */ "./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");






const EMPTY_OBJECT = Object.freeze({});
const $densify = (collection, expr, options) => {
  const { step, bounds, unit } = expr.range;
  if (unit) {
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(_types__WEBPACK_IMPORTED_MODULE_2__.TIME_UNITS.includes(unit), "");
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      Number.isInteger(step) && step > 0,
      "The step parameter in a range statement must be a whole number when densifying a date range."
    );
  } else {
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.isNumber)(step) && step > 0,
      "The step parameter in a range statement must be a strictly positive numeric value."
    );
  }
  if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isArray)(bounds)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      !!bounds && bounds.length === 2,
      "A bounding array in a range statement must have exactly two elements."
    );
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      (bounds.every(_util__WEBPACK_IMPORTED_MODULE_3__.isNumber) || bounds.every(_util__WEBPACK_IMPORTED_MODULE_3__.isDate)) && bounds[0] < bounds[1],
      "A bounding array must be an ascending array of either two dates or two numbers."
    );
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      unit && !bounds.some(_util__WEBPACK_IMPORTED_MODULE_3__.isNumber),
      "Numeric bounds may not have unit parameter."
    );
  }
  if (expr.partitionByFields) {
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.isArray)(expr.partitionByFields),
      "$densify: `partitionByFields` must be an array of strings"
    );
  }
  collection = (0,_sort__WEBPACK_IMPORTED_MODULE_5__.$sort)(collection, { [expr.field]: 1 }, options);
  const nilOptions = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options, null);
  const computeNextValue = (value) => {
    return (0,_util__WEBPACK_IMPORTED_MODULE_3__.isNumber)(value) ? value + step : (0,_expression_date_dateAdd__WEBPACK_IMPORTED_MODULE_4__.$dateAdd)(
      EMPTY_OBJECT,
      { startDate: value, unit, amount: step },
      nilOptions
    );
  };
  const isValidUnit = !!unit && _types__WEBPACK_IMPORTED_MODULE_2__.TIME_UNITS.includes(unit);
  const getFieldValue = (o) => {
    const v = (0,_util__WEBPACK_IMPORTED_MODULE_3__.resolve)(o, expr.field);
    if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isNil)(v)) return v;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isNumber)(v)) {
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
        !isValidUnit,
        "$densify: Encountered non-date value in collection when step has a date unit."
      );
    } else if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isDate)(v)) {
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
        isValidUnit,
        "$densify: Encountered date value in collection when step does not have a date unit."
      );
    } else {
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(false, "$densify: Densify field type must be numeric or a date");
    }
    return v;
  };
  const peekItem = new Array();
  const nilFieldsIterator = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(() => {
    const item = collection.next();
    const fieldValue = getFieldValue(item.value);
    if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isNil)(fieldValue)) return item;
    peekItem.push(item);
    return { done: true };
  });
  const nextDensifyValueMap = _util__WEBPACK_IMPORTED_MODULE_3__.ValueMap.init(
    options.hashFunction
  );
  const [lower, upper] = (0,_util__WEBPACK_IMPORTED_MODULE_3__.isArray)(bounds) ? bounds : [bounds, bounds];
  let maxFieldValue = void 0;
  const updateMaxFieldValue = (value) => {
    maxFieldValue = maxFieldValue === void 0 || maxFieldValue < value ? value : maxFieldValue;
  };
  const rootKey = [];
  const densifyIterator = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(() => {
    const item = peekItem.length > 0 ? peekItem.pop() : collection.next();
    if (item.done) return item;
    let partitionKey = rootKey;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isArray)(expr.partitionByFields)) {
      partitionKey = expr.partitionByFields.map(
        (k) => (0,_util__WEBPACK_IMPORTED_MODULE_3__.resolve)(item.value, k)
      );
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
        partitionKey.every(_util__WEBPACK_IMPORTED_MODULE_3__.isString),
        "$densify: Partition fields must evaluate to string values."
      );
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_3__.isObject)(item.value), "$densify: collection must contain documents");
    const itemValue = getFieldValue(item.value);
    if (!nextDensifyValueMap.has(partitionKey)) {
      if (lower == "full") {
        if (!nextDensifyValueMap.has(rootKey)) {
          nextDensifyValueMap.set(rootKey, itemValue);
        }
        nextDensifyValueMap.set(partitionKey, nextDensifyValueMap.get(rootKey));
      } else if (lower == "partition") {
        nextDensifyValueMap.set(partitionKey, itemValue);
      } else {
        nextDensifyValueMap.set(partitionKey, lower);
      }
    }
    const densifyValue = nextDensifyValueMap.get(partitionKey);
    if (
      // current item field value is lower than current densify value.
      itemValue <= densifyValue || // range value equals or exceeds upper bound
      upper != "full" && upper != "partition" && densifyValue >= upper
    ) {
      if (densifyValue <= itemValue) {
        nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));
      }
      updateMaxFieldValue(itemValue);
      return item;
    }
    nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));
    updateMaxFieldValue(densifyValue);
    const denseObj = { [expr.field]: densifyValue };
    if (partitionKey) {
      partitionKey.forEach((v, i) => {
        denseObj[expr.partitionByFields[i]] = v;
      });
    }
    peekItem.push(item);
    return { done: false, value: denseObj };
  });
  if (lower !== "full") return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.concat)(nilFieldsIterator, densifyIterator);
  let paritionIndex = -1;
  let partitionKeysSet = void 0;
  const fullBoundsIterator = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(() => {
    if (paritionIndex === -1) {
      const fullDensifyValue = nextDensifyValueMap.get(rootKey);
      nextDensifyValueMap.delete(rootKey);
      partitionKeysSet = Array.from(nextDensifyValueMap.keys());
      if (partitionKeysSet.length === 0) {
        partitionKeysSet.push(rootKey);
        nextDensifyValueMap.set(rootKey, fullDensifyValue);
      }
      paritionIndex++;
    }
    do {
      const partitionKey = partitionKeysSet[paritionIndex];
      const partitionMaxValue = nextDensifyValueMap.get(partitionKey);
      if (partitionMaxValue < maxFieldValue) {
        nextDensifyValueMap.set(
          partitionKey,
          computeNextValue(partitionMaxValue)
        );
        const denseObj = { [expr.field]: partitionMaxValue };
        partitionKey.forEach((v, i) => {
          denseObj[expr.partitionByFields[i]] = v;
        });
        return { done: false, value: denseObj };
      }
      paritionIndex++;
    } while (paritionIndex < partitionKeysSet.length);
    return { done: true };
  });
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.concat)(nilFieldsIterator, densifyIterator, fullBoundsIterator);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/facet.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/facet.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $facet: () => (/* binding */ $facet)
/* harmony export */ });
/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../aggregator */ "./node_modules/mingo/dist/esm/aggregator.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");


const $facet = (collection, expr, options) => {
  return collection.transform((array) => {
    const o = {};
    for (const [k, pipeline] of Object.entries(expr)) {
      o[k] = new _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator(pipeline, {
        ...options,
        processingMode: _core__WEBPACK_IMPORTED_MODULE_1__.ProcessingMode.CLONE_INPUT
      }).run(array);
    }
    return [o];
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/fill.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/fill.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $fill: () => (/* binding */ $fill)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _expression_conditional_ifNull__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expression/conditional/ifNull */ "./node_modules/mingo/dist/esm/operators/expression/conditional/ifNull.js");
/* harmony import */ var _window_linearFill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../window/linearFill */ "./node_modules/mingo/dist/esm/operators/window/linearFill.js");
/* harmony import */ var _window_locf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../window/locf */ "./node_modules/mingo/dist/esm/operators/window/locf.js");
/* harmony import */ var _addFields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./addFields */ "./node_modules/mingo/dist/esm/operators/pipeline/addFields.js");
/* harmony import */ var _setWindowFields__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./setWindowFields */ "./node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js");







const FILL_METHODS = {
  locf: "$locf",
  linear: "$linearFill"
};
const $fill = (collection, expr, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!expr.sortBy || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(expr.sortBy), "sortBy must be an object.");
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    !!expr.sortBy || Object.values(expr.output).every((m) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(m, "value")),
    "sortBy required if any output field specifies a 'method'."
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    !(expr.partitionBy && expr.partitionByFields),
    "specify either partitionBy or partitionByFields."
  );
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    !expr.partitionByFields || expr?.partitionByFields?.every((s) => s[0] !== "$"),
    "fields in partitionByFields cannot begin with '$'."
  );
  options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);
  options.context.addExpressionOps({ $ifNull: _expression_conditional_ifNull__WEBPACK_IMPORTED_MODULE_2__.$ifNull });
  options.context.addWindowOps({ $locf: _window_locf__WEBPACK_IMPORTED_MODULE_4__.$locf, $linearFill: _window_linearFill__WEBPACK_IMPORTED_MODULE_3__.$linearFill });
  const partitionExpr = expr.partitionBy || expr?.partitionByFields?.map((s) => "$" + s);
  const valueExpr = {};
  const methodExpr = {};
  for (const [k, m] of Object.entries(expr.output)) {
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(m, "value")) {
      valueExpr[k] = { $ifNull: [`$$CURRENT.${k}`, m["value"]] };
    } else {
      const fillOp = FILL_METHODS[m["method"]];
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!!fillOp, `invalid fill method '${m["method"]}'.`);
      methodExpr[k] = { [fillOp]: "$" + k };
    }
  }
  if (Object.keys(methodExpr).length > 0) {
    collection = (0,_setWindowFields__WEBPACK_IMPORTED_MODULE_6__.$setWindowFields)(
      collection,
      {
        sortBy: expr.sortBy || {},
        partitionBy: partitionExpr,
        output: methodExpr
      },
      options
    );
  }
  if (Object.keys(valueExpr).length > 0) {
    collection = (0,_addFields__WEBPACK_IMPORTED_MODULE_5__.$addFields)(collection, valueExpr, options);
  }
  return collection;
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/graphLookup.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/graphLookup.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $graphLookup: () => (/* binding */ $graphLookup)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookup */ "./node_modules/mingo/dist/esm/operators/pipeline/lookup.js");




const $graphLookup = (collection, expr, options) => {
  const fromColl = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(expr.from) ? options?.collectionResolver(expr.from) : expr.from;
  const {
    connectFromField,
    connectToField,
    as: asField,
    maxDepth,
    depthField,
    restrictSearchWithMatch: matchExpr
  } = expr;
  const pipelineExpr = matchExpr ? { pipeline: [{ $match: matchExpr }] } : {};
  return collection.map((obj) => {
    const matchObj = {};
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.setValue)(
      matchObj,
      connectFromField,
      (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.startWith, null, options)
    );
    let matches = [matchObj];
    let i = -1;
    const map = _util__WEBPACK_IMPORTED_MODULE_2__.ValueMap.init(options.hashFunction);
    do {
      i++;
      matches = (0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(
        (0,_lookup__WEBPACK_IMPORTED_MODULE_3__.$lookup)(
          (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(matches),
          {
            from: fromColl,
            localField: connectFromField,
            foreignField: connectToField,
            as: asField,
            ...pipelineExpr
          },
          options
        ).map((o) => o[asField]).value()
      );
      const oldSize = map.size;
      matches.forEach((k) => map.set(k, map.get(k) ?? i));
      if (oldSize == map.size) break;
    } while ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(maxDepth) || i < maxDepth);
    const result = new Array(map.size);
    let n = 0;
    map.forEach((v, k) => {
      result[n++] = Object.assign(depthField ? { [depthField]: v } : {}, k);
    });
    return { ...obj, [asField]: result };
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/group.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/group.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $group: () => (/* binding */ $group)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const ID_KEY = "_id";
const $group = (collection, expr, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(expr, ID_KEY), "$group specification must include an '_id'");
  const idExpr = expr[ID_KEY];
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  const newFields = Object.keys(expr).filter((k) => k != ID_KEY);
  return collection.transform((coll) => {
    const partitions = (0,_util__WEBPACK_IMPORTED_MODULE_1__.groupBy)(
      coll,
      (obj) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, idExpr, null, options),
      options.hashFunction
    );
    let i = -1;
    const partitionKeys = Array.from(partitions.keys());
    return () => {
      if (++i === partitions.size) return { done: true };
      const groupId = partitionKeys[i];
      const obj = {};
      if (groupId !== void 0) {
        obj[ID_KEY] = groupId;
      }
      for (const key of newFields) {
        obj[key] = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(
          partitions.get(groupId),
          expr[key],
          null,
          copts.update(null, { groupId })
        );
      }
      return { value: obj, done: false };
    };
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $addFields: () => (/* reexport safe */ _addFields__WEBPACK_IMPORTED_MODULE_0__.$addFields),
/* harmony export */   $bucket: () => (/* reexport safe */ _bucket__WEBPACK_IMPORTED_MODULE_1__.$bucket),
/* harmony export */   $bucketAuto: () => (/* reexport safe */ _bucketAuto__WEBPACK_IMPORTED_MODULE_2__.$bucketAuto),
/* harmony export */   $count: () => (/* reexport safe */ _count__WEBPACK_IMPORTED_MODULE_3__.$count),
/* harmony export */   $densify: () => (/* reexport safe */ _densify__WEBPACK_IMPORTED_MODULE_4__.$densify),
/* harmony export */   $facet: () => (/* reexport safe */ _facet__WEBPACK_IMPORTED_MODULE_5__.$facet),
/* harmony export */   $fill: () => (/* reexport safe */ _fill__WEBPACK_IMPORTED_MODULE_6__.$fill),
/* harmony export */   $graphLookup: () => (/* reexport safe */ _graphLookup__WEBPACK_IMPORTED_MODULE_7__.$graphLookup),
/* harmony export */   $group: () => (/* reexport safe */ _group__WEBPACK_IMPORTED_MODULE_8__.$group),
/* harmony export */   $limit: () => (/* reexport safe */ _limit__WEBPACK_IMPORTED_MODULE_9__.$limit),
/* harmony export */   $lookup: () => (/* reexport safe */ _lookup__WEBPACK_IMPORTED_MODULE_10__.$lookup),
/* harmony export */   $match: () => (/* reexport safe */ _match__WEBPACK_IMPORTED_MODULE_11__.$match),
/* harmony export */   $merge: () => (/* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_12__.$merge),
/* harmony export */   $out: () => (/* reexport safe */ _out__WEBPACK_IMPORTED_MODULE_13__.$out),
/* harmony export */   $project: () => (/* reexport safe */ _project__WEBPACK_IMPORTED_MODULE_14__.$project),
/* harmony export */   $redact: () => (/* reexport safe */ _redact__WEBPACK_IMPORTED_MODULE_15__.$redact),
/* harmony export */   $replaceRoot: () => (/* reexport safe */ _replaceRoot__WEBPACK_IMPORTED_MODULE_16__.$replaceRoot),
/* harmony export */   $replaceWith: () => (/* reexport safe */ _replaceWith__WEBPACK_IMPORTED_MODULE_17__.$replaceWith),
/* harmony export */   $sample: () => (/* reexport safe */ _sample__WEBPACK_IMPORTED_MODULE_18__.$sample),
/* harmony export */   $set: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_19__.$set),
/* harmony export */   $setWindowFields: () => (/* reexport safe */ _setWindowFields__WEBPACK_IMPORTED_MODULE_20__.$setWindowFields),
/* harmony export */   $skip: () => (/* reexport safe */ _skip__WEBPACK_IMPORTED_MODULE_21__.$skip),
/* harmony export */   $sort: () => (/* reexport safe */ _sort__WEBPACK_IMPORTED_MODULE_22__.$sort),
/* harmony export */   $sortByCount: () => (/* reexport safe */ _sortByCount__WEBPACK_IMPORTED_MODULE_23__.$sortByCount),
/* harmony export */   $unionWith: () => (/* reexport safe */ _unionWith__WEBPACK_IMPORTED_MODULE_24__.$unionWith),
/* harmony export */   $unset: () => (/* reexport safe */ _unset__WEBPACK_IMPORTED_MODULE_25__.$unset),
/* harmony export */   $unwind: () => (/* reexport safe */ _unwind__WEBPACK_IMPORTED_MODULE_26__.$unwind)
/* harmony export */ });
/* harmony import */ var _addFields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addFields */ "./node_modules/mingo/dist/esm/operators/pipeline/addFields.js");
/* harmony import */ var _bucket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bucket */ "./node_modules/mingo/dist/esm/operators/pipeline/bucket.js");
/* harmony import */ var _bucketAuto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bucketAuto */ "./node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js");
/* harmony import */ var _count__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./count */ "./node_modules/mingo/dist/esm/operators/pipeline/count.js");
/* harmony import */ var _densify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./densify */ "./node_modules/mingo/dist/esm/operators/pipeline/densify.js");
/* harmony import */ var _facet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./facet */ "./node_modules/mingo/dist/esm/operators/pipeline/facet.js");
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fill */ "./node_modules/mingo/dist/esm/operators/pipeline/fill.js");
/* harmony import */ var _graphLookup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graphLookup */ "./node_modules/mingo/dist/esm/operators/pipeline/graphLookup.js");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./group */ "./node_modules/mingo/dist/esm/operators/pipeline/group.js");
/* harmony import */ var _limit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./limit */ "./node_modules/mingo/dist/esm/operators/pipeline/limit.js");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lookup */ "./node_modules/mingo/dist/esm/operators/pipeline/lookup.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./match */ "./node_modules/mingo/dist/esm/operators/pipeline/match.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./merge */ "./node_modules/mingo/dist/esm/operators/pipeline/merge.js");
/* harmony import */ var _out__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./out */ "./node_modules/mingo/dist/esm/operators/pipeline/out.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./project */ "./node_modules/mingo/dist/esm/operators/pipeline/project.js");
/* harmony import */ var _redact__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./redact */ "./node_modules/mingo/dist/esm/operators/pipeline/redact.js");
/* harmony import */ var _replaceRoot__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./replaceRoot */ "./node_modules/mingo/dist/esm/operators/pipeline/replaceRoot.js");
/* harmony import */ var _replaceWith__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./replaceWith */ "./node_modules/mingo/dist/esm/operators/pipeline/replaceWith.js");
/* harmony import */ var _sample__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./sample */ "./node_modules/mingo/dist/esm/operators/pipeline/sample.js");
/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./set */ "./node_modules/mingo/dist/esm/operators/pipeline/set.js");
/* harmony import */ var _setWindowFields__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./setWindowFields */ "./node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js");
/* harmony import */ var _skip__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./skip */ "./node_modules/mingo/dist/esm/operators/pipeline/skip.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");
/* harmony import */ var _sortByCount__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./sortByCount */ "./node_modules/mingo/dist/esm/operators/pipeline/sortByCount.js");
/* harmony import */ var _unionWith__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./unionWith */ "./node_modules/mingo/dist/esm/operators/pipeline/unionWith.js");
/* harmony import */ var _unset__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./unset */ "./node_modules/mingo/dist/esm/operators/pipeline/unset.js");
/* harmony import */ var _unwind__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./unwind */ "./node_modules/mingo/dist/esm/operators/pipeline/unwind.js");





























/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/limit.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/limit.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $limit: () => (/* binding */ $limit)
/* harmony export */ });
const $limit = (collection, expr, _options) => collection.take(expr);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/lookup.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/lookup.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lookup: () => (/* binding */ $lookup)
/* harmony export */ });
/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../aggregator */ "./node_modules/mingo/dist/esm/aggregator.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");



const $lookup = (collection, expr, options) => {
  const joinColl = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(expr.from) ? options?.collectionResolver(expr.from) : expr.from;
  const { let: letExpr, pipeline, foreignField, localField } = expr;
  const subQueryPipeline = pipeline || [];
  let lookupEq = (_) => [true, []];
  if (foreignField && localField) {
    const map = _util__WEBPACK_IMPORTED_MODULE_2__.ValueMap.init(options.hashFunction);
    for (const doc of joinColl) {
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)((0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(doc, foreignField) ?? null).forEach((v) => {
        const xs = map.get(v);
        const arr = xs ?? [];
        arr.push(doc);
        if (arr !== xs) map.set(v, arr);
      });
    }
    lookupEq = (o) => {
      const local = (0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(o, localField) ?? null;
      if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(local)) {
        if (subQueryPipeline.length) {
          return [local.some((v) => map.has(v)), null];
        }
        const result2 = Array.from(
          new Set((0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(local.map((v) => map.get(v), options.hashFunction)))
        );
        return [result2.length > 0, result2];
      }
      const result = map.get(local) ?? null;
      return [result !== null, result ?? []];
    };
    if (subQueryPipeline.length === 0) {
      return collection.map((obj) => {
        return {
          ...obj,
          [expr.as]: lookupEq(obj).pop()
        };
      });
    }
  }
  const agg = new _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator(subQueryPipeline, options);
  const opts = { ...options };
  return collection.map((obj) => {
    const vars = (0,_core__WEBPACK_IMPORTED_MODULE_1__.computeValue)(obj, letExpr, null, options);
    opts.variables = { ...options.variables, ...vars };
    const [ok, res] = lookupEq(obj);
    return {
      ...obj,
      [expr.as]: ok ? agg.run(joinColl, opts) : res
    };
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/match.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/match.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $match: () => (/* binding */ $match)
/* harmony export */ });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../query */ "./node_modules/mingo/dist/esm/query.js");

const $match = (collection, expr, options) => {
  const q = new _query__WEBPACK_IMPORTED_MODULE_0__.Query(expr, options);
  return collection.filter((o) => q.test(o));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/merge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $merge: () => (/* binding */ $merge)
/* harmony export */ });
/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../aggregator */ "./node_modules/mingo/dist/esm/aggregator.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _expression__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../expression */ "./node_modules/mingo/dist/esm/operators/expression/index.js");




const $merge = (collection, expr, options) => {
  const output = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(expr.into) ? options?.collectionResolver(expr.into) : expr.into;
  (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(output), `$merge: option 'into' must resolve to an array`);
  const onField = expr.on || options.idKey;
  const getHash = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(onField) ? (o) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.hashCode)((0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(o, onField), options.hashFunction) : (o) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.hashCode)(onField.map((s) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(o, s), options.hashFunction));
  const map = _util__WEBPACK_IMPORTED_MODULE_2__.ValueMap.init();
  for (let i = 0; i < output.length; i++) {
    const obj = output[i];
    const k = getHash(obj);
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      !map.has(k),
      "$merge: 'into' collection must have unique entries for the 'on' field."
    );
    map.set(k, [obj, i]);
  }
  const copts = _core__WEBPACK_IMPORTED_MODULE_1__.ComputeOptions.init(options);
  return collection.map((o) => {
    const k = getHash(o);
    if (map.has(k)) {
      const [target, i] = map.get(k);
      const variables = (0,_core__WEBPACK_IMPORTED_MODULE_1__.computeValue)(
        target,
        expr.let || { new: "$$ROOT" },
        null,
        // 'root' is the item from the iteration.
        copts.update(o)
      );
      if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(expr.whenMatched)) {
        const aggregator = new _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator(expr.whenMatched, {
          ...options,
          variables
        });
        output[i] = aggregator.run([target])[0];
      } else {
        switch (expr.whenMatched) {
          case "replace":
            output[i] = o;
            break;
          case "fail":
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.MingoError(
              "$merge: failed due to matching as specified by 'whenMatched' option."
            );
          case "keepExisting":
            break;
          case "merge":
          default:
            output[i] = (0,_expression__WEBPACK_IMPORTED_MODULE_3__.$mergeObjects)(
              target,
              [target, o],
              // 'root' is the item from the iteration.
              copts.update(o, { variables })
            );
            break;
        }
      }
    } else {
      switch (expr.whenNotMatched) {
        case "discard":
          break;
        case "fail":
          throw new _util__WEBPACK_IMPORTED_MODULE_2__.MingoError(
            "$merge: failed due to matching as specified by 'whenMatched' option."
          );
        case "insert":
        default:
          output.push(o);
          break;
      }
    }
    return o;
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/out.js":
/*!***************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/out.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $out: () => (/* binding */ $out)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");

const $out = (collection, expr, options) => {
  const outputColl = (0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) ? options?.collectionResolver(expr) : expr;
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(outputColl), `expression must resolve to an array`);
  return collection.map((o) => {
    outputColl.push((0,_util__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(o));
    return o;
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/project.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/project.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $project: () => (/* binding */ $project)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $project = (collection, expr, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(expr)) return collection;
  validateExpression(expr, options);
  return collection.map(createHandler(expr, _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options)));
};
function createHandler(expr, options, isRoot = true) {
  const idKey = options.idKey;
  const expressionKeys = Object.keys(expr);
  const excludedKeys = new Array();
  const includedKeys = new Array();
  const handlers = {};
  for (const key of expressionKeys) {
    const subExpr = expr[key];
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(subExpr) || (0,_util__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(subExpr)) {
      if (subExpr) {
        includedKeys.push(key);
      } else {
        excludedKeys.push(key);
      }
    } else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(subExpr)) {
      handlers[key] = (o) => subExpr.map((v) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, v, null, options.update(o)) ?? null);
    } else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(subExpr)) {
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const projectFn = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)(
        "projection",
        operator,
        options
      );
      if (projectFn) {
        const foundSlice = operator === "$slice";
        if (foundSlice && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.ensureArray)(subExpr[operator]).every(_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)) {
          handlers[key] = (o) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, subExpr, key, options.update(o));
        } else {
          handlers[key] = (o) => projectFn(o, subExpr[operator], key, options.update(o));
        }
      } else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isOperator)(operator)) {
        handlers[key] = (o) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, subExpr[operator], operator, options);
      } else {
        validateExpression(subExpr, options);
        handlers[key] = (o) => {
          if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(o, key)) return (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, subExpr, null, options);
          if (isRoot) options.update(o);
          const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(o, key);
          const fn = createHandler(subExpr, options, false);
          if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(target)) return target.map(fn);
          if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(target)) return fn(target);
          return fn(o);
        };
      }
    } else {
      handlers[key] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(subExpr) && subExpr[0] === "$" ? (o) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(o, subExpr, key, options) : (_) => subExpr;
    }
  }
  const handlerKeys = Object.keys(handlers);
  const idKeyExcluded = excludedKeys.includes(idKey);
  const idKeyOnlyExcluded = isRoot && idKeyExcluded && excludedKeys.length === 1 && !includedKeys.length && !handlerKeys.length;
  if (idKeyOnlyExcluded) {
    return (o) => {
      const newObj = { ...o };
      delete newObj[idKey];
      return newObj;
    };
  }
  const idKeyImplicit = isRoot && !idKeyExcluded && !includedKeys.includes(idKey);
  const opts = {
    preserveMissing: true
  };
  return (o) => {
    const newObj = {};
    if (excludedKeys.length && !includedKeys.length) {
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.merge)(newObj, o);
      for (const k of excludedKeys) {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(newObj, k, { descendArray: true });
      }
    }
    for (const k of includedKeys) {
      const pathObj = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolveGraph)(o, k, opts) ?? {};
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.merge)(newObj, pathObj);
    }
    if (includedKeys.length) (0,_util__WEBPACK_IMPORTED_MODULE_1__.filterMissing)(newObj);
    for (const k of handlerKeys) {
      const value = handlers[k](o);
      if (value === void 0) {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(newObj, k, { descendArray: true });
      } else {
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.setValue)(newObj, k, value);
      }
    }
    if (idKeyImplicit && (0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(o, idKey)) {
      newObj[idKey] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(o, idKey);
    }
    return newObj;
  };
}
function validateExpression(expr, options) {
  let exclusions = false;
  let inclusions = false;
  for (const [k, v] of Object.entries(expr)) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!k.startsWith("$"), "Field names may not start with '$'.");
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !k.endsWith(".$"),
      "Positional projection operator '$' is not supported."
    );
    if (k === options?.idKey) continue;
    if (v === 0 || v === false) {
      exclusions = true;
    } else if (v === 1 || v === true) {
      inclusions = true;
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(exclusions && inclusions),
      "Projection cannot have a mix of inclusion and exclusion."
    );
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/redact.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/redact.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $redact: () => (/* binding */ $redact)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");

const $redact = (collection, expr, options) => {
  const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);
  return collection.map(
    (obj) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.redact)(obj, expr, copts.update(obj))
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/replaceRoot.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/replaceRoot.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $replaceRoot: () => (/* binding */ $replaceRoot)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $replaceRoot = (collection, expr, options) => {
  return collection.map((obj) => {
    obj = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr.newRoot, null, options);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj), "$replaceRoot expression must return an object");
    return obj;
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/replaceWith.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/replaceWith.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $replaceWith: () => (/* binding */ $replaceWith)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $replaceWith = (collection, expr, options) => {
  return collection.map((obj) => {
    obj = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj), "$replaceWith expression must return an object");
    return obj;
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/sample.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/sample.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sample: () => (/* binding */ $sample)
/* harmony export */ });
const $sample = (collection, expr, _options) => {
  return collection.transform((xs) => {
    const len = xs.length;
    let i = -1;
    return () => {
      if (++i === expr.size) return { done: true };
      const n = Math.floor(Math.random() * len);
      return { value: xs[n], done: false };
    };
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/set.js":
/*!***************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/set.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $set: () => (/* binding */ $set)
/* harmony export */ });
/* harmony import */ var _addFields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addFields */ "./node_modules/mingo/dist/esm/operators/pipeline/addFields.js");

const $set = _addFields__WEBPACK_IMPORTED_MODULE_0__.$addFields;



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $setWindowFields: () => (/* binding */ $setWindowFields)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _expression_custom_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../expression/custom/function */ "./node_modules/mingo/dist/esm/operators/expression/custom/function.js");
/* harmony import */ var _expression_date_dateAdd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../expression/date/dateAdd */ "./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/pipeline/_internal.js");
/* harmony import */ var _addFields__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./addFields */ "./node_modules/mingo/dist/esm/operators/pipeline/addFields.js");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./group */ "./node_modules/mingo/dist/esm/operators/pipeline/group.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");









const SORT_REQUIRED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$documentNumber",
  "$first",
  "$last",
  "$linearFill",
  "$rank",
  "$shift"
]);
const WINDOW_UNBOUNDED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$expMovingAvg",
  "$linearFill",
  "$locf",
  "$rank",
  "$shift"
]);
const $setWindowFields = (collection, expr, options) => {
  options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);
  options.context.addExpressionOps({ $function: _expression_custom_function__WEBPACK_IMPORTED_MODULE_3__.$function });
  for (const outputExpr of Object.values(expr.output)) {
    const keys = Object.keys(outputExpr);
    const op = keys.find(_util__WEBPACK_IMPORTED_MODULE_2__.isOperator);
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      !!(0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("window", op, options) || !!(0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("accumulator", op, options),
      `'${op}' is not a valid window operator`
    );
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      keys.length > 0 && keys.length <= 2 && (keys.length == 1 || keys.includes("window")),
      "'output' option should have a single window operator."
    );
    if (outputExpr?.window) {
      const { documents, range } = outputExpr.window;
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
        !!documents && !range || !documents && !!range || !documents && !range,
        "'window' option supports only one of 'documents' or 'range'."
      );
    }
  }
  if (expr.sortBy) {
    collection = (0,_sort__WEBPACK_IMPORTED_MODULE_8__.$sort)(collection, expr.sortBy, options);
  }
  collection = (0,_group__WEBPACK_IMPORTED_MODULE_7__.$group)(
    collection,
    {
      _id: expr.partitionBy,
      items: { $push: "$$CURRENT" }
    },
    options
  );
  return collection.transform((partitions) => {
    const iterators = [];
    const outputConfig = [];
    for (const [field, outputExpr] of Object.entries(expr.output)) {
      const op = Object.keys(outputExpr).find(_util__WEBPACK_IMPORTED_MODULE_2__.isOperator);
      const config = {
        operatorName: op,
        func: {
          left: (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("accumulator", op, options),
          right: (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("window", op, options)
        },
        args: outputExpr[op],
        field,
        window: outputExpr.window
      };
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
        !!expr.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config.window),
        `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : "bounded window operation"} requires a sortBy.`
      );
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
        !config.window || !WINDOW_UNBOUNDED_OPS.has(op),
        `${op} does not accept a 'window' field.`
      );
      outputConfig.push(config);
    }
    partitions.forEach((group) => {
      const items = group.items;
      let iterator = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(items);
      const windowResultMap = {};
      for (const config of outputConfig) {
        const { func, args, field, window } = config;
        const makeResultFunc = (getItemsFn) => {
          let index = -1;
          return (obj) => {
            ++index;
            if (func.left) {
              return func.left(getItemsFn(obj, index), args, options);
            } else if (func.right) {
              return func.right(
                obj,
                getItemsFn(obj, index),
                {
                  parentExpr: expr,
                  inputExpr: args,
                  documentNumber: index + 1,
                  field
                },
                // must use raw options only since it operates over a collection.
                options
              );
            }
          };
        };
        if (window) {
          const { documents, range, unit } = window;
          const boundary = documents || range;
          if (!(0,_internal__WEBPACK_IMPORTED_MODULE_5__.isUnbounded)(window)) {
            const [begin, end] = boundary;
            const toBeginIndex = (currentIndex) => {
              if (begin == "current") return currentIndex;
              if (begin == "unbounded") return 0;
              return Math.max(begin + currentIndex, 0);
            };
            const toEndIndex = (currentIndex) => {
              if (end == "current") return currentIndex + 1;
              if (end == "unbounded") return items.length;
              return end + currentIndex + 1;
            };
            const getItems = (current, index) => {
              if (!!documents || boundary.every(_util__WEBPACK_IMPORTED_MODULE_2__.isString)) {
                return items.slice(toBeginIndex(index), toEndIndex(index));
              }
              const sortKey = Object.keys(expr.sortBy)[0];
              let lower;
              let upper;
              if (unit) {
                const getTime = (amount) => {
                  return (0,_expression_date_dateAdd__WEBPACK_IMPORTED_MODULE_4__.$dateAdd)(
                    current,
                    {
                      startDate: new Date(current[sortKey]),
                      unit,
                      amount
                    },
                    options
                  ).getTime();
                };
                lower = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(begin) ? getTime(begin) : -Infinity;
                upper = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(end) ? getTime(end) : Infinity;
              } else {
                const currentValue = current[sortKey];
                lower = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(begin) ? currentValue + begin : -Infinity;
                upper = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(end) ? currentValue + end : Infinity;
              }
              let array = items;
              if (begin == "current") array = items.slice(index);
              if (end == "current") array = items.slice(0, index + 1);
              return array.filter((o) => {
                const n = +o[sortKey];
                return n >= lower && n <= upper;
              });
            };
            windowResultMap[field] = makeResultFunc(getItems);
          }
        }
        if (!windowResultMap[field]) {
          windowResultMap[field] = makeResultFunc((_) => items);
        }
        iterator = (0,_addFields__WEBPACK_IMPORTED_MODULE_6__.$addFields)(
          iterator,
          {
            [field]: {
              $function: {
                body: (obj) => windowResultMap[field](obj),
                args: ["$$CURRENT"]
              }
            }
          },
          options
        );
      }
      iterators.push(iterator);
    });
    return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.concat)(...iterators);
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/skip.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/skip.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $skip: () => (/* binding */ $skip)
/* harmony export */ });
const $skip = (collection, expr, _options) => {
  return collection.drop(expr);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/sort.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sort: () => (/* binding */ $sort)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");

const $sort = (collection, sortKeys, options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(sortKeys) || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sortKeys)) return collection;
  let cmp = _util__WEBPACK_IMPORTED_MODULE_0__.compare;
  const collationSpec = options.collation;
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(collationSpec) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(collationSpec.locale)) {
    cmp = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = (0,_util__WEBPACK_IMPORTED_MODULE_0__.groupBy)(
        coll,
        (obj) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(obj, key),
        options.hashFunction
      );
      const sortedKeys = Array.from(groups.keys()).sort(cmp);
      if (sortKeys[key] === -1) sortedKeys.reverse();
      let i = 0;
      for (const k of sortedKeys) for (const v of groups.get(k)) coll[i++] = v;
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(i == coll.length, "bug: counter must match collection size.");
    }
    return coll;
  });
};
const COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a  b, a  , a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a  b, a  , a  A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base") localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent") localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a, b) => {
    if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(a) || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(b)) return (0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(a, b);
    const i = collator.compare(a, b);
    if (i < 0) return -1;
    if (i > 0) return 1;
    return 0;
  };
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/sortByCount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/sortByCount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $sortByCount: () => (/* binding */ $sortByCount)
/* harmony export */ });
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group */ "./node_modules/mingo/dist/esm/operators/pipeline/group.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sort */ "./node_modules/mingo/dist/esm/operators/pipeline/sort.js");


const $sortByCount = (collection, expr, options) => {
  return (0,_sort__WEBPACK_IMPORTED_MODULE_1__.$sort)(
    (0,_group__WEBPACK_IMPORTED_MODULE_0__.$group)(collection, { _id: expr, count: { $sum: 1 } }, options),
    { count: -1 },
    options
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/unionWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/unionWith.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $unionWith: () => (/* binding */ $unionWith)
/* harmony export */ });
/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../aggregator */ "./node_modules/mingo/dist/esm/aggregator.js");
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");



const $unionWith = (collection, expr, options) => {
  const array = (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(expr.coll) ? options.collectionResolver(expr.coll) : expr.coll;
  const iterators = [collection];
  iterators.push(
    expr.pipeline ? new _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator(expr.pipeline, options).stream(array) : (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(array)
  );
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.concat)(...iterators);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/unset.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/unset.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $unset: () => (/* binding */ $unset)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./project */ "./node_modules/mingo/dist/esm/operators/pipeline/project.js");


const $unset = (collection, expr, options) => {
  expr = (0,_util__WEBPACK_IMPORTED_MODULE_0__.ensureArray)(expr);
  const doc = {};
  for (const k of expr) doc[k] = 0;
  return (0,_project__WEBPACK_IMPORTED_MODULE_1__.$project)(collection, doc, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/pipeline/unwind.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/pipeline/unwind.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $unwind: () => (/* binding */ $unwind)
/* harmony export */ });
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lazy */ "./node_modules/mingo/dist/esm/lazy.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");


const $unwind = (collection, expr, _options) => {
  if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(expr)) expr = { path: expr };
  const path = expr.path;
  const field = path.substring(1);
  const includeArrayIndex = expr?.includeArrayIndex || false;
  const preserveNullAndEmptyArrays = expr.preserveNullAndEmptyArrays || false;
  const format = (o, i) => {
    if (includeArrayIndex !== false) o[includeArrayIndex] = i;
    return o;
  };
  let value;
  return (0,_lazy__WEBPACK_IMPORTED_MODULE_0__.Lazy)(() => {
    for (; ; ) {
      if (value instanceof _lazy__WEBPACK_IMPORTED_MODULE_0__.Iterator) {
        const tmp = value.next();
        if (!tmp.done) return tmp;
      }
      const wrapper = collection.next();
      if (wrapper.done) return wrapper;
      const obj = wrapper.value;
      value = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(obj, field);
      if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        if (value.length === 0 && preserveNullAndEmptyArrays === true) {
          value = null;
          (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(obj, field);
          return { value: format(obj, null), done: false };
        } else {
          value = (0,_lazy__WEBPACK_IMPORTED_MODULE_0__.Lazy)(value).map((item, i) => {
            const newObj = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolveGraph)(obj, field, {
              preserveKeys: true
            });
            (0,_util__WEBPACK_IMPORTED_MODULE_1__.setValue)(newObj, field, item);
            return format(newObj, i);
          });
        }
      } else if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(value) || preserveNullAndEmptyArrays === true) {
        return { value: format(obj, null), done: false };
      }
    }
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/array/all.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/array/all.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $all: () => (/* binding */ $all)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $all = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$all);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/array/elemMatch.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/array/elemMatch.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $elemMatch: () => (/* binding */ $elemMatch)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $elemMatch = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$elemMatch);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/array/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/array/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $all: () => (/* reexport safe */ _all__WEBPACK_IMPORTED_MODULE_0__.$all),
/* harmony export */   $elemMatch: () => (/* reexport safe */ _elemMatch__WEBPACK_IMPORTED_MODULE_1__.$elemMatch),
/* harmony export */   $size: () => (/* reexport safe */ _size__WEBPACK_IMPORTED_MODULE_2__.$size)
/* harmony export */ });
/* harmony import */ var _all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./all */ "./node_modules/mingo/dist/esm/operators/query/array/all.js");
/* harmony import */ var _elemMatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elemMatch */ "./node_modules/mingo/dist/esm/operators/query/array/elemMatch.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./size */ "./node_modules/mingo/dist/esm/operators/query/array/size.js");





/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/array/size.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/array/size.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $size: () => (/* binding */ $size)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $size = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$size);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createBitwiseOperator: () => (/* binding */ createBitwiseOperator)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");


const createBitwiseOperator = (predicate) => {
  return (0,_predicates__WEBPACK_IMPORTED_MODULE_1__.createQueryOperator)(
    (value, mask, _options) => {
      let b = 0;
      if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(mask)) {
        for (const n of mask) b = b | 1 << n;
      } else {
        b = mask;
      }
      return predicate(value & b, b);
    }
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitsAllClear: () => (/* binding */ $bitsAllClear)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js");

const $bitsAllClear = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createBitwiseOperator)((result, _) => result == 0);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitsAllSet: () => (/* binding */ $bitsAllSet)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js");

const $bitsAllSet = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createBitwiseOperator)(
  (result, mask) => result == mask
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitsAnyClear: () => (/* binding */ $bitsAnyClear)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js");

const $bitsAnyClear = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createBitwiseOperator)(
  (result, mask) => result < mask
);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitsAnySet: () => (/* binding */ $bitsAnySet)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js");

const $bitsAnySet = (0,_internal__WEBPACK_IMPORTED_MODULE_0__.createBitwiseOperator)((result, _) => result > 0);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/bitwise/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/bitwise/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bitsAllClear: () => (/* reexport safe */ _bitsAllClear__WEBPACK_IMPORTED_MODULE_0__.$bitsAllClear),
/* harmony export */   $bitsAllSet: () => (/* reexport safe */ _bitsAllSet__WEBPACK_IMPORTED_MODULE_1__.$bitsAllSet),
/* harmony export */   $bitsAnyClear: () => (/* reexport safe */ _bitsAnyClear__WEBPACK_IMPORTED_MODULE_2__.$bitsAnyClear),
/* harmony export */   $bitsAnySet: () => (/* reexport safe */ _bitsAnySet__WEBPACK_IMPORTED_MODULE_3__.$bitsAnySet)
/* harmony export */ });
/* harmony import */ var _bitsAllClear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitsAllClear */ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js");
/* harmony import */ var _bitsAllSet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitsAllSet */ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js");
/* harmony import */ var _bitsAnyClear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bitsAnyClear */ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js");
/* harmony import */ var _bitsAnySet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bitsAnySet */ "./node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js");







/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/eq.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/eq.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $eq: () => (/* binding */ $eq)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $eq = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$eq);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/gt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/gt.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $gt: () => (/* binding */ $gt)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $gt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gt);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/gte.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/gte.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $gte: () => (/* binding */ $gte)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $gte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gte);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/in.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/in.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $in: () => (/* binding */ $in)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $in = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$in);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $eq: () => (/* reexport safe */ _eq__WEBPACK_IMPORTED_MODULE_0__.$eq),
/* harmony export */   $gt: () => (/* reexport safe */ _gt__WEBPACK_IMPORTED_MODULE_1__.$gt),
/* harmony export */   $gte: () => (/* reexport safe */ _gte__WEBPACK_IMPORTED_MODULE_2__.$gte),
/* harmony export */   $in: () => (/* reexport safe */ _in__WEBPACK_IMPORTED_MODULE_3__.$in),
/* harmony export */   $lt: () => (/* reexport safe */ _lt__WEBPACK_IMPORTED_MODULE_4__.$lt),
/* harmony export */   $lte: () => (/* reexport safe */ _lte__WEBPACK_IMPORTED_MODULE_5__.$lte),
/* harmony export */   $ne: () => (/* reexport safe */ _ne__WEBPACK_IMPORTED_MODULE_6__.$ne),
/* harmony export */   $nin: () => (/* reexport safe */ _nin__WEBPACK_IMPORTED_MODULE_7__.$nin)
/* harmony export */ });
/* harmony import */ var _eq__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq */ "./node_modules/mingo/dist/esm/operators/query/comparison/eq.js");
/* harmony import */ var _gt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gt */ "./node_modules/mingo/dist/esm/operators/query/comparison/gt.js");
/* harmony import */ var _gte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gte */ "./node_modules/mingo/dist/esm/operators/query/comparison/gte.js");
/* harmony import */ var _in__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./in */ "./node_modules/mingo/dist/esm/operators/query/comparison/in.js");
/* harmony import */ var _lt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lt */ "./node_modules/mingo/dist/esm/operators/query/comparison/lt.js");
/* harmony import */ var _lte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lte */ "./node_modules/mingo/dist/esm/operators/query/comparison/lte.js");
/* harmony import */ var _ne__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ne */ "./node_modules/mingo/dist/esm/operators/query/comparison/ne.js");
/* harmony import */ var _nin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nin */ "./node_modules/mingo/dist/esm/operators/query/comparison/nin.js");











/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/lt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/lt.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lt: () => (/* binding */ $lt)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $lt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lt);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/lte.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/lte.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $lte: () => (/* binding */ $lte)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $lte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lte);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/ne.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/ne.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ne: () => (/* binding */ $ne)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $ne = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$ne);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/comparison/nin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/comparison/nin.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $nin: () => (/* binding */ $nin)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $nin = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$nin);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/element/exists.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/element/exists.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $exists: () => (/* binding */ $exists)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");

const $exists = (selector, value, _options) => {
  const nested = selector.includes(".");
  const b = !!value;
  if (!nested || selector.match(/\.\d+$/)) {
    return (o) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(o, selector) !== void 0 === b;
  }
  return (o) => {
    const path = (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolveGraph)(o, selector, { preserveIndex: true });
    const val = (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(path, selector.substring(0, selector.lastIndexOf(".")));
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(val) ? val.some((v) => v !== void 0) === b : val !== void 0 === b;
  };
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/element/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/element/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $exists: () => (/* reexport safe */ _exists__WEBPACK_IMPORTED_MODULE_0__.$exists),
/* harmony export */   $type: () => (/* reexport safe */ _type__WEBPACK_IMPORTED_MODULE_1__.$type)
/* harmony export */ });
/* harmony import */ var _exists__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exists */ "./node_modules/mingo/dist/esm/operators/query/element/exists.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type */ "./node_modules/mingo/dist/esm/operators/query/element/type.js");




/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/element/type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/element/type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $type: () => (/* binding */ $type)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $type = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$type);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/expr.js":
/*!************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/expr.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $expr: () => (/* binding */ $expr)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core */ "./node_modules/mingo/dist/esm/core.js");

function $expr(_, rhs, options) {
  return (obj) => (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, rhs, null, options);
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $expr: () => (/* reexport safe */ _expr__WEBPACK_IMPORTED_MODULE_0__.$expr),
/* harmony export */   $jsonSchema: () => (/* reexport safe */ _jsonSchema__WEBPACK_IMPORTED_MODULE_1__.$jsonSchema),
/* harmony export */   $mod: () => (/* reexport safe */ _mod__WEBPACK_IMPORTED_MODULE_2__.$mod),
/* harmony export */   $regex: () => (/* reexport safe */ _regex__WEBPACK_IMPORTED_MODULE_3__.$regex),
/* harmony export */   $where: () => (/* reexport safe */ _where__WEBPACK_IMPORTED_MODULE_4__.$where)
/* harmony export */ });
/* harmony import */ var _expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expr */ "./node_modules/mingo/dist/esm/operators/query/evaluation/expr.js");
/* harmony import */ var _jsonSchema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jsonSchema */ "./node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js");
/* harmony import */ var _mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mod */ "./node_modules/mingo/dist/esm/operators/query/evaluation/mod.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./regex */ "./node_modules/mingo/dist/esm/operators/query/evaluation/regex.js");
/* harmony import */ var _where__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./where */ "./node_modules/mingo/dist/esm/operators/query/evaluation/where.js");







/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $jsonSchema: () => (/* binding */ $jsonSchema)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");

function $jsonSchema(_, schema, options) {
  if (!options?.jsonSchemaValidator) {
    throw new _util__WEBPACK_IMPORTED_MODULE_0__.MingoError(
      "Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator."
    );
  }
  const validate = options?.jsonSchemaValidator(schema);
  return (obj) => validate(obj);
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/mod.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/mod.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mod: () => (/* binding */ $mod)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $mod = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$mod);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $regex: () => (/* binding */ $regex)
/* harmony export */ });
/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ "./node_modules/mingo/dist/esm/operators/_predicates.js");

const $regex = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$regex);



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/evaluation/where.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/evaluation/where.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $where: () => (/* binding */ $where)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");

function $where(_, rhs, options) {
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
    options.scriptEnabled,
    "$where operator requires 'scriptEnabled' option to be true"
  );
  const f = rhs;
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(f), "$where only accepts a Function object");
  return (obj) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.truthy)(f.call(obj), options?.useStrictMode);
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $all: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_0__.$all),
/* harmony export */   $and: () => (/* reexport safe */ _logical__WEBPACK_IMPORTED_MODULE_5__.$and),
/* harmony export */   $bitsAllClear: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_1__.$bitsAllClear),
/* harmony export */   $bitsAllSet: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_1__.$bitsAllSet),
/* harmony export */   $bitsAnyClear: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_1__.$bitsAnyClear),
/* harmony export */   $bitsAnySet: () => (/* reexport safe */ _bitwise__WEBPACK_IMPORTED_MODULE_1__.$bitsAnySet),
/* harmony export */   $elemMatch: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_0__.$elemMatch),
/* harmony export */   $eq: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$eq),
/* harmony export */   $exists: () => (/* reexport safe */ _element__WEBPACK_IMPORTED_MODULE_3__.$exists),
/* harmony export */   $expr: () => (/* reexport safe */ _evaluation__WEBPACK_IMPORTED_MODULE_4__.$expr),
/* harmony export */   $gt: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$gt),
/* harmony export */   $gte: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$gte),
/* harmony export */   $in: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$in),
/* harmony export */   $jsonSchema: () => (/* reexport safe */ _evaluation__WEBPACK_IMPORTED_MODULE_4__.$jsonSchema),
/* harmony export */   $lt: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$lt),
/* harmony export */   $lte: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$lte),
/* harmony export */   $mod: () => (/* reexport safe */ _evaluation__WEBPACK_IMPORTED_MODULE_4__.$mod),
/* harmony export */   $ne: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$ne),
/* harmony export */   $nin: () => (/* reexport safe */ _comparison__WEBPACK_IMPORTED_MODULE_2__.$nin),
/* harmony export */   $nor: () => (/* reexport safe */ _logical__WEBPACK_IMPORTED_MODULE_5__.$nor),
/* harmony export */   $not: () => (/* reexport safe */ _logical__WEBPACK_IMPORTED_MODULE_5__.$not),
/* harmony export */   $or: () => (/* reexport safe */ _logical__WEBPACK_IMPORTED_MODULE_5__.$or),
/* harmony export */   $regex: () => (/* reexport safe */ _evaluation__WEBPACK_IMPORTED_MODULE_4__.$regex),
/* harmony export */   $size: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_0__.$size),
/* harmony export */   $type: () => (/* reexport safe */ _element__WEBPACK_IMPORTED_MODULE_3__.$type),
/* harmony export */   $where: () => (/* reexport safe */ _evaluation__WEBPACK_IMPORTED_MODULE_4__.$where)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/mingo/dist/esm/operators/query/array/index.js");
/* harmony import */ var _bitwise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitwise */ "./node_modules/mingo/dist/esm/operators/query/bitwise/index.js");
/* harmony import */ var _comparison__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comparison */ "./node_modules/mingo/dist/esm/operators/query/comparison/index.js");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./element */ "./node_modules/mingo/dist/esm/operators/query/element/index.js");
/* harmony import */ var _evaluation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./evaluation */ "./node_modules/mingo/dist/esm/operators/query/evaluation/index.js");
/* harmony import */ var _logical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logical */ "./node_modules/mingo/dist/esm/operators/query/logical/index.js");








/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/logical/and.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/logical/and.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $and: () => (/* binding */ $and)
/* harmony export */ });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $and = (_, rhs, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(rhs),
    "Invalid expression: $and expects value to be an Array."
  );
  const queries = rhs.map((expr) => new _query__WEBPACK_IMPORTED_MODULE_0__.Query(expr, options));
  return (obj) => queries.every((q) => q.test(obj));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/logical/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/logical/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $and: () => (/* reexport safe */ _and__WEBPACK_IMPORTED_MODULE_0__.$and),
/* harmony export */   $nor: () => (/* reexport safe */ _nor__WEBPACK_IMPORTED_MODULE_1__.$nor),
/* harmony export */   $not: () => (/* reexport safe */ _not__WEBPACK_IMPORTED_MODULE_2__.$not),
/* harmony export */   $or: () => (/* reexport safe */ _or__WEBPACK_IMPORTED_MODULE_3__.$or)
/* harmony export */ });
/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./and */ "./node_modules/mingo/dist/esm/operators/query/logical/and.js");
/* harmony import */ var _nor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nor */ "./node_modules/mingo/dist/esm/operators/query/logical/nor.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./not */ "./node_modules/mingo/dist/esm/operators/query/logical/not.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./or */ "./node_modules/mingo/dist/esm/operators/query/logical/or.js");






/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/logical/nor.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/logical/nor.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $nor: () => (/* binding */ $nor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./or */ "./node_modules/mingo/dist/esm/operators/query/logical/or.js");


const $nor = (_, rhs, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(rhs),
    "Invalid expression. $nor expects value to be an array."
  );
  const f = (0,_or__WEBPACK_IMPORTED_MODULE_1__.$or)("$or", rhs, options);
  return (obj) => !f(obj);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/logical/not.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/logical/not.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $not: () => (/* binding */ $not)
/* harmony export */ });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $not = (selector, rhs, options) => {
  const criteria = {};
  criteria[selector] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(rhs);
  const query = new _query__WEBPACK_IMPORTED_MODULE_0__.Query(criteria, options);
  return (obj) => !query.test(obj);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/query/logical/or.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/query/logical/or.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $or: () => (/* binding */ $or)
/* harmony export */ });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ "./node_modules/mingo/dist/esm/util.js");


const $or = (_, rhs, options) => {
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr) => new _query__WEBPACK_IMPORTED_MODULE_0__.Query(expr, options));
  return (obj) => queries.some((q) => q.test(obj));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/_internal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/_internal.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UPDATE_OPTIONS: () => (/* binding */ UPDATE_OPTIONS),
/* harmony export */   applyUpdate: () => (/* binding */ applyUpdate),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   tokenizePath: () => (/* binding */ tokenizePath),
/* harmony export */   walkExpression: () => (/* binding */ walkExpression)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _operators_expression_boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../operators/expression/boolean */ "./node_modules/mingo/dist/esm/operators/expression/boolean/index.js");
/* harmony import */ var _operators_expression_comparison__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../operators/expression/comparison */ "./node_modules/mingo/dist/esm/operators/expression/comparison/index.js");
/* harmony import */ var _operators_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../operators/query */ "./node_modules/mingo/dist/esm/operators/query/index.js");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");






const UPDATE_OPTIONS = {
  cloneMode: "copy",
  queryOptions: (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)({
    context: _core__WEBPACK_IMPORTED_MODULE_0__.Context.init().addQueryOps(_operators_query__WEBPACK_IMPORTED_MODULE_3__).addExpressionOps(_operators_expression_boolean__WEBPACK_IMPORTED_MODULE_1__).addExpressionOps(_operators_expression_comparison__WEBPACK_IMPORTED_MODULE_2__)
  })
};
const clone = (mode, val) => {
  switch (mode) {
    case "deep":
      return (0,_util__WEBPACK_IMPORTED_MODULE_5__.cloneDeep)(val);
    case "copy": {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_5__.isDate)(val)) return new Date(val);
      if ((0,_util__WEBPACK_IMPORTED_MODULE_5__.isArray)(val)) return [...val];
      if ((0,_util__WEBPACK_IMPORTED_MODULE_5__.isObject)(val)) return { ...val };
      if ((0,_util__WEBPACK_IMPORTED_MODULE_5__.isRegExp)(val)) return new RegExp(val);
      return val;
    }
    default:
      return val;
  }
};
const FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;
function tokenizePath(selector) {
  if (!selector.includes(".$")) {
    return [{ parent: selector, selector }, []];
  }
  const begin = selector.indexOf(".$");
  const end = selector.indexOf("]");
  const parent = selector.substring(0, begin);
  const child = selector.substring(begin + 3, end);
  (0,_util__WEBPACK_IMPORTED_MODULE_5__.assert)(
    child === "" || FILTER_IDENT_RE.test(child),
    "The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters."
  );
  const rest = selector.substring(end + 2);
  const [next, elems] = rest ? tokenizePath(rest) : [];
  return [
    { selector, parent, child: child || "$", next },
    [child, ...elems || []].filter(Boolean)
  ];
}
const applyUpdate = (o, n, q, f, opts) => {
  const { parent, child: c, next } = n;
  if (!c) {
    let b = false;
    const g = (u, k) => b = Boolean(f(u, k)) || b;
    (0,_util__WEBPACK_IMPORTED_MODULE_5__.walk)(o, parent, g, opts);
    return b;
  }
  const t = (0,_util__WEBPACK_IMPORTED_MODULE_5__.resolve)(o, parent);
  if (!(0,_util__WEBPACK_IMPORTED_MODULE_5__.isArray)(t)) return false;
  return t.map((e, i) => {
    if (q[c] && !q[c].test({ [c]: e })) return false;
    return next ? applyUpdate(e, next, q, f, opts) : f(t, i);
  }).some(Boolean);
};
function walkExpression(expr, arrayFilter, options, callback) {
  const res = [];
  for (const [selector, val] of Object.entries(expr)) {
    const [node, vars] = tokenizePath(selector);
    if (!vars.length) {
      if (callback(val, node, {})) res.push(node.parent);
    } else {
      const conditions = {};
      arrayFilter.forEach((o) => {
        Object.keys(o).forEach((k) => {
          vars.forEach((w) => {
            if (k === w || k.startsWith(w + ".")) {
              conditions[w] = conditions[w] || {};
              Object.assign(conditions[w], { [k]: o[k] });
            }
          });
        });
      });
      const queries = {};
      for (const [k, condition] of Object.entries(conditions)) {
        queries[k] = new _query__WEBPACK_IMPORTED_MODULE_4__.Query(condition, options.queryOptions);
      }
      if (callback(val, node, queries)) res.push(node.parent);
    }
  }
  return res;
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/addToSet.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/addToSet.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $addToSet: () => (/* binding */ $addToSet)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $addToSet = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    const args = { $each: [val] };
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(val, "$each")) {
      Object.assign(args, val);
    }
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k] ||= [];
        const common = (0,_util__WEBPACK_IMPORTED_MODULE_0__.intersection)([prev, args.$each]);
        if (common.length === args.$each.length) return false;
        o[k] = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.clone)(options.cloneMode, (0,_util__WEBPACK_IMPORTED_MODULE_0__.unique)(prev.concat(args.$each)));
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/bit.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/bit.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $bit: () => (/* binding */ $bit)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const BIT_OPS = /* @__PURE__ */ new Set(["and", "or", "xor"]);
const $bit = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    const op = Object.keys(val);
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
      op.length === 1 && BIT_OPS.has(op[0]),
      `Invalid bit operator '${op[0]}'. Must be one of 'and', 'or', or 'xor'.`
    );
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        let n = o[k];
        const v = val[op[0]];
        if (n !== void 0 && !((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(n) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(v))) return false;
        n = n || 0;
        switch (op[0]) {
          case "and":
            o[k] = n & v;
            break;
          case "or":
            o[k] = n | v;
            break;
          case "xor":
            o[k] = n ^ v;
            break;
        }
        return o[k] !== n;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/currentDate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/currentDate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $currentDate: () => (/* binding */ $currentDate)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");

const $currentDate = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_0__.UPDATE_OPTIONS) => {
  const now = Date.now();
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.walkExpression)(expr, arrayFilters, options, (_, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = now;
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/inc.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/inc.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $inc: () => (/* binding */ $inc)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $inc = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    if (!node.child) {
      const n = (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(obj, node.parent);
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
        n === void 0 || (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(n),
        `cannot apply $inc to a value of non-numeric type`
      );
    }
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = (o[k] ||= 0) + val;
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $addToSet: () => (/* reexport safe */ _addToSet__WEBPACK_IMPORTED_MODULE_0__.$addToSet),
/* harmony export */   $bit: () => (/* reexport safe */ _bit__WEBPACK_IMPORTED_MODULE_1__.$bit),
/* harmony export */   $currentDate: () => (/* reexport safe */ _currentDate__WEBPACK_IMPORTED_MODULE_2__.$currentDate),
/* harmony export */   $inc: () => (/* reexport safe */ _inc__WEBPACK_IMPORTED_MODULE_3__.$inc),
/* harmony export */   $max: () => (/* reexport safe */ _max__WEBPACK_IMPORTED_MODULE_4__.$max),
/* harmony export */   $min: () => (/* reexport safe */ _min__WEBPACK_IMPORTED_MODULE_5__.$min),
/* harmony export */   $mul: () => (/* reexport safe */ _mul__WEBPACK_IMPORTED_MODULE_6__.$mul),
/* harmony export */   $pop: () => (/* reexport safe */ _pop__WEBPACK_IMPORTED_MODULE_7__.$pop),
/* harmony export */   $pull: () => (/* reexport safe */ _pull__WEBPACK_IMPORTED_MODULE_8__.$pull),
/* harmony export */   $pullAll: () => (/* reexport safe */ _pullAll__WEBPACK_IMPORTED_MODULE_9__.$pullAll),
/* harmony export */   $push: () => (/* reexport safe */ _push__WEBPACK_IMPORTED_MODULE_10__.$push),
/* harmony export */   $rename: () => (/* reexport safe */ _rename__WEBPACK_IMPORTED_MODULE_11__.$rename),
/* harmony export */   $set: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_12__.$set),
/* harmony export */   $unset: () => (/* reexport safe */ _unset__WEBPACK_IMPORTED_MODULE_13__.$unset)
/* harmony export */ });
/* harmony import */ var _addToSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addToSet */ "./node_modules/mingo/dist/esm/operators/update/addToSet.js");
/* harmony import */ var _bit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bit */ "./node_modules/mingo/dist/esm/operators/update/bit.js");
/* harmony import */ var _currentDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currentDate */ "./node_modules/mingo/dist/esm/operators/update/currentDate.js");
/* harmony import */ var _inc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inc */ "./node_modules/mingo/dist/esm/operators/update/inc.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./max */ "./node_modules/mingo/dist/esm/operators/update/max.js");
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./min */ "./node_modules/mingo/dist/esm/operators/update/min.js");
/* harmony import */ var _mul__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mul */ "./node_modules/mingo/dist/esm/operators/update/mul.js");
/* harmony import */ var _pop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pop */ "./node_modules/mingo/dist/esm/operators/update/pop.js");
/* harmony import */ var _pull__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pull */ "./node_modules/mingo/dist/esm/operators/update/pull.js");
/* harmony import */ var _pullAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pullAll */ "./node_modules/mingo/dist/esm/operators/update/pullAll.js");
/* harmony import */ var _push__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./push */ "./node_modules/mingo/dist/esm/operators/update/push.js");
/* harmony import */ var _rename__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rename */ "./node_modules/mingo/dist/esm/operators/update/rename.js");
/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./set */ "./node_modules/mingo/dist/esm/operators/update/set.js");
/* harmony import */ var _unset__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./unset */ "./node_modules/mingo/dist/esm/operators/update/unset.js");
















/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/max.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/max.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $max: () => (/* binding */ $max)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $max = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && (0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(o[k], val) > -1) return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/min.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/min.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $min: () => (/* binding */ $min)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $min = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && (0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(o[k], val) < 1) return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/mul.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/mul.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $mul: () => (/* binding */ $mul)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");

const $mul = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_0__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_0__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k];
        o[k] = o[k] === void 0 ? 0 : o[k] * val;
        return o[k] !== prev;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/pop.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/pop.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $pop: () => (/* binding */ $pop)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $pop = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(obj, node, queries, (o, k) => {
      const arr = o[k];
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(
        (0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(arr),
        `path '${node.selector}' contains an element of non-array type.`
      );
      if (!arr.length) return false;
      if (val === -1) {
        arr.splice(0, 1);
      } else {
        arr.pop();
      }
      return true;
    });
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/pull.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/pull.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $pull: () => (/* binding */ $pull)
/* harmony export */ });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");



const $pull = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_2__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    const wrap = !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) || Object.keys(val).some(_util__WEBPACK_IMPORTED_MODULE_1__.isOperator);
    const query = new _query__WEBPACK_IMPORTED_MODULE_0__.Query(
      wrap ? { k: val } : val,
      options.queryOptions
    );
    const pred = wrap ? (v) => query.test({ k: v }) : (v) => query.test(v);
    return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.applyUpdate)(obj, node, queries, (o, k) => {
      const prev = o[k];
      const curr = new Array();
      const found = prev.map((v) => {
        const b = pred(v);
        if (!b) curr.push(v);
        return b;
      }).some(Boolean);
      if (!found) return false;
      o[k] = curr;
      return true;
    });
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/pullAll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/pullAll.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $pullAll: () => (/* binding */ $pullAll)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");
/* harmony import */ var _pull__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pull */ "./node_modules/mingo/dist/esm/operators/update/pull.js");


const $pullAll = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_0__.UPDATE_OPTIONS) => {
  const pullExpr = {};
  Object.entries(expr).forEach(([k, v]) => {
    pullExpr[k] = { $in: v };
  });
  return (0,_pull__WEBPACK_IMPORTED_MODULE_1__.$pull)(obj, pullExpr, arrayFilters, options);
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/push.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/push.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $push: () => (/* binding */ $push)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const OPERATOR_MODIFIERS = Object.freeze([
  "$each",
  "$slice",
  "$sort",
  "$position"
]);
const $push = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    const args = {
      $each: [val]
    };
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) && OPERATOR_MODIFIERS.some((m) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(val, m))) {
      Object.assign(args, val);
    }
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        const arr = o[k] ||= [];
        const prev = arr.slice(0, args.$slice || arr.length);
        const oldsize = arr.length;
        const pos = (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(args.$position) ? args.$position : arr.length;
        arr.splice(pos, 0, ...(0,_internal__WEBPACK_IMPORTED_MODULE_1__.clone)(options.cloneMode, args.$each));
        if (args.$sort) {
          const sortKey = (0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(args.$sort) ? Object.keys(args.$sort || {}).pop() : "";
          const order = !sortKey ? args.$sort : args.$sort[sortKey];
          const f = !sortKey ? (a) => a : (a) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(a, sortKey);
          arr.sort((a, b) => order * (0,_util__WEBPACK_IMPORTED_MODULE_0__.compare)(f(a), f(b)));
        }
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(args.$slice)) {
          if (args.$slice < 0) arr.splice(0, arr.length + args.$slice);
          else arr.splice(args.$slice);
        }
        return oldsize != arr.length || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isEqual)(prev, arr);
      },
      { descendArray: true, buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/rename.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/rename.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $rename: () => (/* binding */ $rename)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");
/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./set */ "./node_modules/mingo/dist/esm/operators/update/set.js");



const $rename = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  const res = [];
  const changed = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(obj, node, queries, (o, k) => {
      if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(o, k)) return false;
      res.push(...(0,_set__WEBPACK_IMPORTED_MODULE_2__.$set)(obj, { [val]: o[k] }, arrayFilters, options));
      delete o[k];
      return true;
    });
  });
  return Array.from(new Set(changed.concat(res)));
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/set.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/set.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $set: () => (/* binding */ $set)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $set = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (val, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(
      obj,
      node,
      queries,
      (o, k) => {
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEqual)(o[k], val)) return false;
        o[k] = (0,_internal__WEBPACK_IMPORTED_MODULE_1__.clone)(options.cloneMode, val);
        return true;
      },
      { buildGraph: true }
    );
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/update/unset.js":
/*!***************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/update/unset.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $unset: () => (/* binding */ $unset)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");


const $unset = (obj, expr, arrayFilters = [], options = _internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.walkExpression)(expr, arrayFilters, options, (_, node, queries) => {
    return (0,_internal__WEBPACK_IMPORTED_MODULE_1__.applyUpdate)(obj, node, queries, (o, k) => {
      if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(o, k)) return false;
      if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(o)) {
        o[k] = null;
      } else {
        delete o[k];
      }
      return true;
    });
  });
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/window/_internal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/window/_internal.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MILLIS_PER_UNIT: () => (/* binding */ MILLIS_PER_UNIT),
/* harmony export */   rank: () => (/* binding */ rank),
/* harmony export */   withMemo: () => (/* binding */ withMemo)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accumulator */ "./node_modules/mingo/dist/esm/operators/accumulator/index.js");
/* harmony import */ var _expression_date_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expression/date/_internal */ "./node_modules/mingo/dist/esm/operators/expression/date/_internal.js");
/* harmony import */ var _pipeline_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pipeline/_internal */ "./node_modules/mingo/dist/esm/operators/pipeline/_internal.js");




const MILLIS_PER_UNIT = {
  week: _expression_date_internal__WEBPACK_IMPORTED_MODULE_2__.MILLIS_PER_DAY * 7,
  day: _expression_date_internal__WEBPACK_IMPORTED_MODULE_2__.MILLIS_PER_DAY,
  hour: _expression_date_internal__WEBPACK_IMPORTED_MODULE_2__.MILLIS_PER_DAY / 24,
  minute: 6e4,
  second: 1e3,
  millisecond: 1
};
const memo = /* @__PURE__ */ new WeakMap();
function withMemo(collection, expr, cacheFn, fn) {
  if (!(0,_pipeline_internal__WEBPACK_IMPORTED_MODULE_3__.isUnbounded)(expr.parentExpr.output[expr.field].window)) {
    return fn(cacheFn());
  }
  if (!memo.has(collection)) {
    memo.set(collection, { [expr.field]: cacheFn() });
  }
  const data = memo.get(collection);
  if (data[expr.field] === void 0) {
    data[expr.field] = cacheFn();
  }
  let failed = false;
  try {
    return fn(data[expr.field]);
  } catch {
    failed = true;
  } finally {
    if (failed || expr.documentNumber === collection.length) {
      delete data[expr.field];
      if (Object.keys(data).length === 0) memo.delete(collection);
    }
  }
}
function rank(_, collection, expr, options, dense) {
  return withMemo(
    collection,
    expr,
    () => {
      const sortKey = "$" + Object.keys(expr.parentExpr.sortBy)[0];
      const values = (0,_accumulator__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, sortKey, options);
      const groups = (0,_util__WEBPACK_IMPORTED_MODULE_0__.groupBy)(
        values,
        (_2, n) => values[n],
        options.hashFunction
      );
      return { values, groups };
    },
    (input) => {
      const { values, groups: partitions } = input;
      if (partitions.size == collection.length) {
        return expr.documentNumber;
      }
      const current = values[expr.documentNumber - 1];
      let i = 0;
      let offset = 0;
      for (const key of partitions.keys()) {
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEqual)(current, key)) {
          return dense ? i + 1 : offset + 1;
        }
        i++;
        offset += partitions.get(key).length;
      }
      throw new _util__WEBPACK_IMPORTED_MODULE_0__.MingoError(
        "rank: invalid return value. please submit a bug report."
      );
    }
  );
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/window/linearFill.js":
/*!********************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/window/linearFill.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $linearFill: () => (/* binding */ $linearFill)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accumulator */ "./node_modules/mingo/dist/esm/operators/accumulator/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/window/_internal.js");



const interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));
const $linearFill = (_, collection, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.withMemo)(
    collection,
    expr,
    () => {
      const sortKey = "$" + Object.keys(expr.parentExpr.sortBy)[0];
      const points = (0,_accumulator__WEBPACK_IMPORTED_MODULE_1__.$push)(
        collection,
        [sortKey, expr.inputExpr],
        options
      ).filter(([x, _2]) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(+x));
      if (points.length !== collection.length) return null;
      let lindex = -1;
      let rindex = 0;
      while (rindex < points.length) {
        while (lindex + 1 < points.length && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(points[lindex + 1][1])) {
          lindex++;
          rindex = lindex;
        }
        while (rindex + 1 < points.length && !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(points[rindex + 1][1])) {
          rindex++;
        }
        if (rindex + 1 >= points.length) break;
        rindex++;
        while (lindex + 1 < rindex) {
          points[lindex + 1][1] = interpolate(
            points[lindex][0],
            points[lindex][1],
            points[rindex][0],
            points[rindex][1],
            points[lindex + 1][0]
          );
          lindex++;
        }
        lindex = rindex;
      }
      return points.map(([_2, y]) => y);
    },
    (values) => values[expr.documentNumber - 1]
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/operators/window/locf.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/dist/esm/operators/window/locf.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $locf: () => (/* binding */ $locf)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _accumulator_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accumulator/push */ "./node_modules/mingo/dist/esm/operators/accumulator/push.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_internal */ "./node_modules/mingo/dist/esm/operators/window/_internal.js");



const $locf = (_, collection, expr, options) => {
  return (0,_internal__WEBPACK_IMPORTED_MODULE_2__.withMemo)(
    collection,
    expr,
    () => {
      const values = (0,_accumulator_push__WEBPACK_IMPORTED_MODULE_1__.$push)(collection, expr.inputExpr, options);
      for (let i = 1; i < values.length; i++) {
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(values[i])) values[i] = values[i - 1];
      }
      return values;
    },
    (series) => series[expr.documentNumber - 1]
  );
};



/***/ }),

/***/ "./node_modules/mingo/dist/esm/query.js":
/*!**********************************************!*\
  !*** ./node_modules/mingo/dist/esm/query.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Query: () => (/* binding */ Query)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var _cursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursor */ "./node_modules/mingo/dist/esm/cursor.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");



const TOP_LEVEL_OPS = new Set(
  Array.from(["$and", "$or", "$nor", "$expr", "$jsonSchema"])
);
class Query {
  #compiled;
  #options;
  #condition;
  constructor(condition, options) {
    this.#condition = (0,_util__WEBPACK_IMPORTED_MODULE_2__.cloneDeep)(condition);
    this.#options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);
    this.#compiled = [];
    this.compile();
  }
  compile() {
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(this.#condition),
      `query criteria must be an object: ${JSON.stringify(this.#condition)}`
    );
    const whereOperator = {};
    for (const [field, expr] of Object.entries(this.#condition)) {
      if ("$where" === field) {
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(
          this.#options.scriptEnabled,
          "$where operator requires 'scriptEnabled' option to be true."
        );
        Object.assign(whereOperator, { field, expr });
      } else if (TOP_LEVEL_OPS.has(field)) {
        this.processOperator(field, field, expr);
      } else {
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isOperator)(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries(
          (0,_util__WEBPACK_IMPORTED_MODULE_2__.normalize)(expr)
        )) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(
          whereOperator.field,
          whereOperator.field,
          whereOperator.expr
        );
      }
    }
  }
  processOperator(field, operator, value) {
    const call = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)("query", operator, this.#options);
    (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!!call, `unknown query operator ${operator}`);
    this.#compiled.push(call(field, value, this.#options));
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean}
   */
  test(obj) {
    return this.#compiled.every((p) => p(obj));
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new _cursor__WEBPACK_IMPORTED_MODULE_1__.Cursor(
      collection,
      (o) => this.test(o),
      projection || {},
      this.#options
    );
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj)) acc.push(obj);
      return acc;
    }, []);
  }
}



/***/ }),

/***/ "./node_modules/mingo/dist/esm/types.js":
/*!**********************************************!*\
  !*** ./node_modules/mingo/dist/esm/types.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TIME_UNITS: () => (/* binding */ TIME_UNITS)
/* harmony export */ });
const TIME_UNITS = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];



/***/ }),

/***/ "./node_modules/mingo/dist/esm/updater.js":
/*!************************************************!*\
  !*** ./node_modules/mingo/dist/esm/updater.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUpdater: () => (/* binding */ createUpdater),
/* harmony export */   update: () => (/* binding */ update),
/* harmony export */   updateObject: () => (/* binding */ updateObject)
/* harmony export */ });
/* harmony import */ var _operators_update__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./operators/update */ "./node_modules/mingo/dist/esm/operators/update/index.js");
/* harmony import */ var _operators_update_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operators/update/_internal */ "./node_modules/mingo/dist/esm/operators/update/_internal.js");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/mingo/dist/esm/util.js");




function createUpdater(defaultOptions) {
  defaultOptions = defaultOptions ?? _operators_update_internal__WEBPACK_IMPORTED_MODULE_1__.UPDATE_OPTIONS;
  return (obj, expr, arrayFilters = [], condition = {}, options = defaultOptions) => {
    const entry = Object.entries(expr);
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      entry.length === 1,
      "Update expression must contain only one operator."
    );
    const [op, args] = entry[0];
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.assert)(
      (0,_util__WEBPACK_IMPORTED_MODULE_3__.has)(_operators_update__WEBPACK_IMPORTED_MODULE_0__, op),
      `Update operator '${op}' is not supported.`
    );
    const mutate = _operators_update__WEBPACK_IMPORTED_MODULE_0__[op];
    if (Object.keys(condition).length) {
      const q = new _query__WEBPACK_IMPORTED_MODULE_2__.Query(condition, options.queryOptions);
      if (!q.test(obj)) return [];
    }
    return mutate(obj, args, arrayFilters, options);
  };
}
const update = createUpdater();
const updateObject = update;



/***/ }),

/***/ "./node_modules/mingo/dist/esm/util.js":
/*!*********************************************!*\
  !*** ./node_modules/mingo/dist/esm/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MingoError: () => (/* binding */ MingoError),
/* harmony export */   ValueMap: () => (/* binding */ ValueMap),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   ensureArray: () => (/* binding */ ensureArray),
/* harmony export */   filterMissing: () => (/* binding */ filterMissing),
/* harmony export */   findInsertIndex: () => (/* binding */ findInsertIndex),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   hashCode: () => (/* binding */ hashCode),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   into: () => (/* binding */ into),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isEqual: () => (/* binding */ isEqual),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isNil: () => (/* binding */ isNil),
/* harmony export */   isNotNaN: () => (/* binding */ isNotNaN),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isObjectLike: () => (/* binding */ isObjectLike),
/* harmony export */   isOperator: () => (/* binding */ isOperator),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   removeValue: () => (/* binding */ removeValue),
/* harmony export */   resolve: () => (/* binding */ resolve),
/* harmony export */   resolveGraph: () => (/* binding */ resolveGraph),
/* harmony export */   setValue: () => (/* binding */ setValue),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   truthy: () => (/* binding */ truthy),
/* harmony export */   typeOf: () => (/* binding */ typeOf),
/* harmony export */   unique: () => (/* binding */ unique),
/* harmony export */   walk: () => (/* binding */ walk)
/* harmony export */ });
class MingoError extends Error {
}
const MISSING = Symbol("missing");
const CYCLE_FOUND_ERROR = Object.freeze(
  new Error("mingo: cycle detected while processing object/array")
);
const DEFAULT_HASH_FUNCTION = (value) => {
  const s = stringify(value);
  let hash = 0;
  let i = s.length;
  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);
  return hash >>> 0;
};
const isPrimitive = (v) => typeof v !== "object" && typeof v !== "function" || v === null;
const isScalar = (v) => isPrimitive(v) || isDate(v) || isRegExp(v);
const SORT_ORDER = {
  undefined: 1,
  null: 2,
  number: 3,
  string: 4,
  symbol: 5,
  object: 6,
  array: 7,
  arraybuffer: 8,
  boolean: 9,
  date: 10,
  regexp: 11,
  function: 12
};
const compare = (a, b) => {
  if (a === MISSING) a = void 0;
  if (b === MISSING) b = void 0;
  const [u, v] = [a, b].map((n) => SORT_ORDER[typeOf(n)] || 0);
  if (u !== v) return u - v;
  if (isEqual(a, b)) return 0;
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
};
class ValueMap extends Map {
  // The hash function
  #hashFn = DEFAULT_HASH_FUNCTION;
  // maps the hashcode to key set
  #keyMap = /* @__PURE__ */ new Map();
  // returns a tuple of [<masterKey>, <hash>]. Expects an object key.
  #unpack = (key) => {
    const hash = this.#hashFn(key);
    return [(this.#keyMap.get(hash) || []).find((k) => isEqual(k, key)), hash];
  };
  constructor() {
    super();
  }
  /**
   * Returns a new {@link ValueMap} object.
   * @param fn An optional custom hash function
   */
  static init(fn) {
    const m = new ValueMap();
    if (fn) m.#hashFn = fn;
    return m;
  }
  clear() {
    super.clear();
    this.#keyMap.clear();
  }
  /**
   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    if (isPrimitive(key)) return super.delete(key);
    const [masterKey, hash] = this.#unpack(key);
    if (!super.delete(masterKey)) return false;
    this.#keyMap.set(
      hash,
      this.#keyMap.get(hash).filter((k) => !isEqual(k, masterKey))
    );
    return true;
  }
  /**
   * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.
   * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.
   */
  get(key) {
    if (isPrimitive(key)) return super.get(key);
    const [masterKey, _] = this.#unpack(key);
    return super.get(masterKey);
  }
  /**
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  has(key) {
    if (isPrimitive(key)) return super.has(key);
    const [masterKey, _] = this.#unpack(key);
    return super.has(masterKey);
  }
  /**
   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
   */
  set(key, value) {
    if (isPrimitive(key)) return super.set(key, value);
    const [masterKey, hash] = this.#unpack(key);
    if (super.has(masterKey)) {
      super.set(masterKey, value);
    } else {
      super.set(key, value);
      const keys = this.#keyMap.get(hash) || [];
      keys.push(key);
      this.#keyMap.set(hash, keys);
    }
    return this;
  }
  /**
   * @returns the number of elements in the Map.
   */
  get size() {
    return super.size;
  }
}
function assert(condition, message) {
  if (!condition) throw new MingoError(message);
}
const STRING_REP = Object.keys(SORT_ORDER).reduce(
  (memo, k) => {
    memo["[object " + k[0].toUpperCase() + k.substring(1) + "]"] = k;
    return memo;
  },
  {}
);
function typeOf(v) {
  const s = Object.prototype.toString.call(v);
  return s === "[object Object]" ? v?.constructor?.name?.toLowerCase() || "object" : STRING_REP[s] || s.substring(8, s.length - 1).toLowerCase();
}
const isBoolean = (v) => typeof v === "boolean";
const isString = (v) => typeof v === "string";
const isSymbol = (v) => typeof v === "symbol";
const isNumber = (v) => !isNaN(v) && typeof v === "number";
const isNotNaN = (v) => !(isNaN(v) && typeof v === "number");
const isArray = Array.isArray;
function isObject(v) {
  if (!v) return false;
  const p = Object.getPrototypeOf(v);
  return (p === Object.prototype || p === null) && typeOf(v) === "object";
}
const isObjectLike = (v) => !isPrimitive(v);
const isDate = (v) => v instanceof Date;
const isRegExp = (v) => v instanceof RegExp;
const isFunction = (v) => typeof v === "function";
const isNil = (v) => v === null || v === void 0;
const truthy = (arg, strict = true) => !!arg || strict && arg === "";
const isEmpty = (x) => isNil(x) || isString(x) && !x || isArray(x) && x.length === 0 || isObject(x) && Object.keys(x).length === 0;
const ensureArray = (x) => isArray(x) ? x : [x];
const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
const isTypedArray = (v) => typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(v);
const cloneDeep = (v, refs) => {
  if (isNil(v) || isBoolean(v) || isNumber(v) || isString(v)) return v;
  if (isDate(v)) return new Date(v);
  if (isRegExp(v)) return new RegExp(v);
  if (isTypedArray(v)) {
    const ctor = v.constructor;
    return new ctor(v);
  }
  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();
  if (refs.has(v)) throw CYCLE_FOUND_ERROR;
  refs.add(v);
  try {
    if (isArray(v)) {
      const arr = new Array(v.length);
      for (let i = 0; i < v.length; i++) arr[i] = cloneDeep(v[i], refs);
      return arr;
    }
    if (isObject(v)) {
      const obj = {};
      for (const k of Object.keys(v)) obj[k] = cloneDeep(v[k], refs);
      return obj;
    }
  } finally {
    refs.delete(v);
  }
  return v;
};
const isMissing = (v) => v === MISSING;
function merge(target, input) {
  if (isMissing(target) || isNil(target)) return input;
  if (isMissing(input) || isNil(input)) return target;
  if (isPrimitive(target) || isPrimitive(input)) return input;
  if (isArray(target) && isArray(input)) {
    assert(
      target.length === input.length,
      "arrays must be of equal length to merge."
    );
  }
  for (const k of Object.keys(input)) {
    target[k] = merge(target[k], input[k]);
  }
  return target;
}
function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
  const vmaps = [ValueMap.init(hashFunction), ValueMap.init(hashFunction)];
  if (input.length === 0) return [];
  if (input.some((arr) => arr.length === 0)) return [];
  if (input.length === 1) return [...input];
  input[input.length - 1].forEach((v) => vmaps[0].set(v, true));
  for (let i = input.length - 2; i > -1; i--) {
    input[i].forEach((v) => {
      if (vmaps[0].has(v)) vmaps[1].set(v, true);
    });
    if (vmaps[1].size === 0) return [];
    vmaps.reverse();
    vmaps[1].clear();
  }
  return Array.from(vmaps[0].keys());
}
function flatten(xs, depth = 1) {
  const arr = new Array();
  function flatten2(ys, n) {
    for (let i = 0, len = ys.length; i < len; i++) {
      if (isArray(ys[i]) && (n > 0 || n < 0)) {
        flatten2(ys[i], Math.max(-1, n - 1));
      } else {
        arr.push(ys[i]);
      }
    }
  }
  flatten2(xs, depth);
  return arr;
}
function getMembersOf(o) {
  const props = {};
  while (o) {
    for (const k of Object.getOwnPropertyNames(o))
      if (!(k in props)) props[k] = o[k];
    o = Object.getPrototypeOf(o);
  }
  return props;
}
function hasCustomString(o) {
  while (o) {
    if (Object.getOwnPropertyNames(o).includes("toString"))
      return o["toString"] !== Object.prototype.toString;
    o = Object.getPrototypeOf(o);
  }
  return false;
}
function isEqual(a, b) {
  if (a === b || Object.is(a, b)) return true;
  if (a === null || b === null) return false;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object") return false;
  if (a.constructor !== b.constructor) return false;
  if (a instanceof Date) return +a === +b;
  if (a instanceof RegExp) return a.toString() === b.toString();
  const ctor = a.constructor;
  if (ctor === Array || ctor === Object) {
    const aKeys = Object.keys(a).sort();
    const bKeys = Object.keys(b).sort();
    if (aKeys.length !== bKeys.length) return false;
    for (let i = 0, k = aKeys[i]; i < aKeys.length; k = aKeys[++i]) {
      if (k !== bKeys[i] || !isEqual(a[k], b[k])) return false;
    }
    return true;
  }
  return hasCustomString(a) && a.toString() === b.toString();
}
function unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {
  const m = ValueMap.init(hashFunction);
  input.forEach((v) => m.set(v, true));
  return Array.from(m.keys());
}
const stringify = (v, refs) => {
  if (v === null) return "null";
  if (v === void 0) return "undefined";
  if (isString(v) || isNumber(v) || isBoolean(v)) return JSON.stringify(v);
  if (isDate(v)) return v.toISOString();
  if (isRegExp(v) || isSymbol(v) || isFunction(v))
    return v.toString();
  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();
  if (refs.has(v)) throw CYCLE_FOUND_ERROR;
  try {
    refs.add(v);
    if (isArray(v)) return "[" + v.map((s2) => stringify(s2, refs)).join(",") + "]";
    if (isObject(v)) {
      const keys = Object.keys(v).sort();
      return "{" + keys.map((k) => `${k}:${stringify(v[k], refs)}`).join() + "}";
    }
    const s = hasCustomString(v) ? v.toString() : stringify(getMembersOf(v), refs);
    return typeOf(v) + "(" + s + ")";
  } finally {
    refs.delete(v);
  }
};
function hashCode(value, hashFunction) {
  if (isNil(value)) return null;
  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
  return hashFunction(value);
}
function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (collection.length < 1) return /* @__PURE__ */ new Map();
  const lookup = /* @__PURE__ */ new Map();
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i < collection.length; i++) {
    const obj = collection[i];
    const key = keyFn(obj, i);
    const hash = hashCode(key, hashFunction);
    if (hash === null) {
      if (result.has(null)) {
        result.get(null).push(obj);
      } else {
        result.set(null, [obj]);
      }
    } else {
      const existingKey = lookup.has(hash) ? lookup.get(hash).find((k) => isEqual(k, key)) : null;
      if (isNil(existingKey)) {
        result.set(key, [obj]);
        if (lookup.has(hash)) {
          lookup.get(hash).push(key);
        } else {
          lookup.set(hash, [key]);
        }
      } else {
        result.get(existingKey).push(obj);
      }
    }
  }
  return result;
}
const MAX_ARRAY_PUSH = 5e4;
function into(target, ...rest) {
  if (isArray(target)) {
    for (const arr of rest) {
      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);
      let begin = 0;
      while (i-- > 0) {
        Array.prototype.push.apply(
          target,
          arr.slice(begin, begin + MAX_ARRAY_PUSH)
        );
        begin += MAX_ARRAY_PUSH;
      }
    }
    return target;
  } else {
    return rest.filter(isObjectLike).reduce((acc, item) => {
      Object.assign(acc, item);
      return acc;
    }, target);
  }
}
function getValue(obj, key) {
  return isObjectLike(obj) ? obj[key] : void 0;
}
function unwrap(arr, depth) {
  if (depth < 1) return arr;
  while (depth-- && arr.length === 1) arr = arr[0];
  return arr;
}
function resolve(obj, selector, options) {
  let depth = 0;
  function resolve2(o, path) {
    let value = o;
    for (let i = 0; i < path.length; i++) {
      const field = path[i];
      const isText = /^\d+$/.exec(field) === null;
      if (isText && isArray(value)) {
        if (i === 0 && depth > 0) break;
        depth += 1;
        const subpath = path.slice(i);
        value = value.reduce((acc, item) => {
          const v = resolve2(item, subpath);
          if (v !== void 0) acc.push(v);
          return acc;
        }, []);
        break;
      } else {
        value = getValue(value, field);
      }
      if (value === void 0) break;
    }
    return value;
  }
  const res = isScalar(obj) ? obj : resolve2(obj, selector.split("."));
  return isArray(res) && options?.unwrapArray ? unwrap(res, depth) : res;
}
function resolveGraph(obj, selector, options) {
  const sep = selector.indexOf(".");
  const key = sep == -1 ? selector : selector.substring(0, sep);
  const next = selector.substring(sep + 1);
  const hasNext = sep != -1;
  if (isArray(obj)) {
    const isIndex = /^\d+$/.test(key);
    const arr = isIndex && options?.preserveIndex ? [...obj] : [];
    if (isIndex) {
      const index = parseInt(key);
      let value2 = getValue(obj, index);
      if (hasNext) {
        value2 = resolveGraph(value2, next, options);
      }
      if (options?.preserveIndex) {
        arr[index] = value2;
      } else {
        arr.push(value2);
      }
    } else {
      for (const item of obj) {
        const value2 = resolveGraph(item, selector, options);
        if (options?.preserveMissing) {
          arr.push(value2 == void 0 ? MISSING : value2);
        } else if (value2 != void 0 || options?.preserveIndex) {
          arr.push(value2);
        }
      }
    }
    return arr;
  }
  const res = options?.preserveKeys ? { ...obj } : {};
  let value = getValue(obj, key);
  if (hasNext) {
    value = resolveGraph(value, next, options);
  }
  if (value === void 0) return void 0;
  res[key] = value;
  return res;
}
function filterMissing(obj) {
  if (isArray(obj)) {
    for (let i = obj.length - 1; i >= 0; i--) {
      if (obj[i] === MISSING) {
        obj.splice(i, 1);
      } else {
        filterMissing(obj[i]);
      }
    }
  } else if (isObject(obj)) {
    for (const k in obj) {
      if (has(obj, k)) {
        filterMissing(obj[k]);
      }
    }
  }
}
const NUMBER_RE = /^\d+$/;
function walk(obj, selector, fn, options) {
  const names = selector.split(".");
  const key = names[0];
  const next = names.slice(1).join(".");
  if (names.length === 1) {
    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {
      fn(obj, key);
    }
  } else {
    if (options?.buildGraph && isNil(obj[key])) {
      obj[key] = {};
    }
    const item = obj[key];
    if (!item) return;
    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
    if (isArray(item) && options?.descendArray && !isNextArrayIndex) {
      item.forEach((e) => walk(e, next, fn, options));
    } else {
      walk(item, next, fn, options);
    }
  }
}
function setValue(obj, selector, value) {
  walk(
    obj,
    selector,
    (item, key) => {
      item[key] = isFunction(value) ? value(item[key]) : value;
    },
    { buildGraph: true }
  );
}
function removeValue(obj, selector, options) {
  walk(
    obj,
    selector,
    (item, key) => {
      if (isArray(item)) {
        if (/^\d+$/.test(key)) {
          item.splice(parseInt(key), 1);
        } else if (options && options.descendArray) {
          for (const elem of item) {
            if (isObject(elem)) {
              delete elem[key];
            }
          }
        }
      } else if (isObject(item)) {
        delete item[key];
      }
    },
    options
  );
}
const OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
function isOperator(name) {
  return OPERATOR_NAME_PATTERN.test(name);
}
function normalize(expr) {
  if (isScalar(expr)) {
    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };
  }
  if (isObjectLike(expr)) {
    if (!Object.keys(expr).some(isOperator)) return { $eq: expr };
    if (has(expr, "$regex")) {
      const newExpr = { ...expr };
      newExpr["$regex"] = new RegExp(
        expr["$regex"],
        expr["$options"]
      );
      delete newExpr["$options"];
      return newExpr;
    }
  }
  return expr;
}
function findInsertIndex(sorted, item, comparator = compare) {
  let lo = 0;
  let hi = sorted.length - 1;
  while (lo <= hi) {
    const mid = Math.round(lo + (hi - lo) / 2);
    if (comparator(item, sorted[mid]) < 0) {
      hi = mid - 1;
    } else if (comparator(item, sorted[mid]) > 0) {
      lo = mid + 1;
    } else {
      return mid;
    }
  }
  return lo;
}



/***/ }),

/***/ "./node_modules/oblivious-set/dist/esm/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/oblivious-set/dist/esm/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObliviousSet: () => (/* binding */ ObliviousSet),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   removeTooOldValues: () => (/* binding */ removeTooOldValues)
/* harmony export */ });
/**
 * this is a set which automatically forgets
 * a given entry when a new entry is set and the ttl
 * of the old one is over
 */
class ObliviousSet {
    ttl;
    map = new Map();
    /**
     * Creating calls to setTimeout() is expensive,
     * so we only do that if there is not timeout already open.
     */
    _to = false;
    constructor(ttl) {
        this.ttl = ttl;
    }
    has(value) {
        return this.map.has(value);
    }
    add(value) {
        this.map.set(value, now());
        /**
         * When a new value is added,
         * start the cleanup at the next tick
         * to not block the cpu for more important stuff
         * that might happen.
         */
        if (!this._to) {
            this._to = true;
            setTimeout(() => {
                this._to = false;
                removeTooOldValues(this);
            }, 0);
        }
    }
    clear() {
        this.map.clear();
    }
}
/**
 * Removes all entries from the set
 * where the TTL has expired
 */
function removeTooOldValues(obliviousSet) {
    const olderThen = now() - obliviousSet.ttl;
    const iterator = obliviousSet.map[Symbol.iterator]();
    /**
     * Because we can assume the new values are added at the bottom,
     * we start from the top and stop as soon as we reach a non-too-old value.
     */
    while (true) {
        const next = iterator.next().value;
        if (!next) {
            return; // no more elements
        }
        const value = next[0];
        const time = next[1];
        if (time < olderThen) {
            obliviousSet.map.delete(value);
        }
        else {
            // We reached a value that is not old enough
            return;
        }
    }
}
function now() {
    return Date.now();
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/change-event-buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/change-event-buffer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChangeEventBuffer: () => (/* binding */ ChangeEventBuffer),
/* harmony export */   createChangeEventBuffer: () => (/* binding */ createChangeEventBuffer)
/* harmony export */ });
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/**
 * a buffer-cache which holds the last X changeEvents of the collection
 */




/**
 * This buffer rembemers previous change events
 * so that queries can use them on .exec()
 * to calculate the new result set via event-reduce instead
 * of running the query against the storage.
 */
var ChangeEventBuffer = /*#__PURE__*/function () {
  /**
   * These properties are private to ensure they cannot
   * be read without first processing the lazy tasks.
   */

  /**
   * array with changeEvents
   * starts with oldest known event, ends with newest
  */

  function ChangeEventBuffer(collection) {
    this.subs = [];
    this.counter = 0;
    this.eventCounterMap = new WeakMap();
    this.buffer = [];
    this.limit = 100;
    this.tasks = new Set();
    this.collection = collection;
    this.subs.push(this.collection.eventBulks$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.filter)(bulk => !bulk.isLocal)).subscribe(eventBulk => {
      this.tasks.add(() => this._handleChangeEvents(eventBulk.events));
      if (this.tasks.size <= 1) {
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.requestIdlePromiseNoQueue)().then(() => {
          this.processTasks();
        });
      }
    }));
  }
  var _proto = ChangeEventBuffer.prototype;
  _proto.processTasks = function processTasks() {
    if (this.tasks.size === 0) {
      return;
    }
    var tasks = Array.from(this.tasks);
    tasks.forEach(task => task());
    this.tasks.clear();
  };
  _proto._handleChangeEvents = function _handleChangeEvents(events) {
    var counterBefore = this.counter;
    this.counter = this.counter + events.length;
    if (events.length > this.limit) {
      this.buffer = events.slice(events.length * -1);
    } else {
      (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.appendToArray)(this.buffer, events);
      this.buffer = this.buffer.slice(this.limit * -1);
    }
    var counterBase = counterBefore + 1;
    var eventCounterMap = this.eventCounterMap;
    for (var index = 0; index < events.length; index++) {
      var event = events[index];
      eventCounterMap.set(event, counterBase + index);
    }
  };
  _proto.getCounter = function getCounter() {
    this.processTasks();
    return this.counter;
  };
  _proto.getBuffer = function getBuffer() {
    this.processTasks();
    return this.buffer;
  }

  /**
   * gets the array-index for the given pointer
   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound
   */;
  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
    this.processTasks();
    var oldestEvent = this.buffer[0];
    var oldestCounter = this.eventCounterMap.get(oldestEvent);
    if (pointer < oldestCounter) return null; // out of bounds

    var rest = pointer - oldestCounter;
    return rest;
  }

  /**
   * get all changeEvents which came in later than the pointer-event
   * @return array with change-events. If null, pointer out of bounds
   */;
  _proto.getFrom = function getFrom(pointer) {
    this.processTasks();
    var ret = [];
    var currentIndex = this.getArrayIndexByPointer(pointer);
    if (currentIndex === null)
      // out of bounds
      return null;
    while (true) {
      var nextEvent = this.buffer[currentIndex];
      currentIndex++;
      if (!nextEvent) {
        return ret;
      } else {
        ret.push(nextEvent);
      }
    }
  };
  _proto.runFrom = function runFrom(pointer, fn) {
    this.processTasks();
    var ret = this.getFrom(pointer);
    if (ret === null) {
      throw new Error('out of bounds');
    } else {
      ret.forEach(cE => fn(cE));
    }
  }

  /**
   * no matter how many operations are done on one document,
   * only the last operation has to be checked to calculate the new state
   * this function reduces the events to the last ChangeEvent of each doc.
   * This functionality is currently disabled. It is questionable if
   * pre-merging the events would really be faster or actually slower.
   */;
  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
    this.processTasks();
    return changeEvents.slice(0);
  };
  _proto.close = function close() {
    this.tasks.clear();
    this.subs.forEach(sub => sub.unsubscribe());
  };
  return ChangeEventBuffer;
}();
function createChangeEventBuffer(collection) {
  return new ChangeEventBuffer(collection);
}
//# sourceMappingURL=change-event-buffer.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/doc-cache.js":
/*!*************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/doc-cache.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DocumentCache: () => (/* binding */ DocumentCache),
/* harmony export */   mapDocumentsDataToCacheDocs: () => (/* binding */ mapDocumentsDataToCacheDocs)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");




/**
 * Because we have to create many cache items,
 * we use an array instead of an object with properties
 * for better performance and less memory usage.
 * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript
 */

/**
 * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
 */

/**
 * The DocumentCache stores RxDocument objects
 * by their primary key and revision.
 * This is useful on client side applications where
 * it is not known how much memory can be used, so
 * we de-duplicate RxDocument states to save memory.
 * To not fill up the memory with old document states, the DocumentCache
 * only contains weak references to the RxDocuments themself.
 * @link https://caniuse.com/?search=weakref
 */
var DocumentCache = /*#__PURE__*/function () {
  /**
   * Process stuff lazy to not block the CPU
   * on critical paths.
   */

  /**
   * Some JavaScript runtimes like QuickJS,
   * so not have a FinalizationRegistry or WeakRef.
   * Therefore we need a workaround which might waste a lot of memory,
   * but at least works.
   */

  function DocumentCache(primaryPath, changes$,
  /**
   * A method that can create a RxDocument by the given document data.
   */
  documentCreator) {
    this.cacheItemByDocId = new Map();
    this.tasks = new Set();
    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {
      var docId = docMeta.docId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        cacheItem[0].delete(docMeta.revisionHeight);
        if (cacheItem[0].size === 0) {
          /**
           * No state of the document is cached anymore,
           * so we can clean up.
           */
          this.cacheItemByDocId.delete(docId);
        }
      }
    }) : undefined;
    this.primaryPath = primaryPath;
    this.changes$ = changes$;
    this.documentCreator = documentCreator;
    changes$.subscribe(events => {
      this.tasks.add(() => {
        var cacheItemByDocId = this.cacheItemByDocId;
        for (var index = 0; index < events.length; index++) {
          var event = events[index];
          var cacheItem = cacheItemByDocId.get(event.documentId);
          if (cacheItem) {
            var documentData = event.documentData;
            if (!documentData) {
              documentData = event.previousDocumentData;
            }
            cacheItem[1] = documentData;
          }
        }
      });
      if (this.tasks.size <= 1) {
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.requestIdlePromiseNoQueue)().then(() => {
          this.processTasks();
        });
      }
    });
  }
  var _proto = DocumentCache.prototype;
  _proto.processTasks = function processTasks() {
    if (this.tasks.size === 0) {
      return;
    }
    var tasks = Array.from(this.tasks);
    tasks.forEach(task => task());
    this.tasks.clear();
  }

  /**
   * Get the RxDocument from the cache
   * and create a new one if not exits before.
   * @overwrites itself with the actual function
   * because this is @performance relevant.
   * It is called on each document row for each write and read.
   */;
  /**
   * Throws if not exists
   */
  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
    this.processTasks();
    var cacheItem = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getFromMapOrThrow)(this.cacheItemByDocId, docId);
    return cacheItem[1];
  };
  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
    this.processTasks();
    var cacheItem = this.cacheItemByDocId.get(docId);
    if (cacheItem) {
      return cacheItem[1];
    }
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(DocumentCache, [{
    key: "getCachedRxDocuments",
    get: function () {
      var fn = getCachedRxDocumentMonad(this);
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.overwriteGetterForCaching)(this, 'getCachedRxDocuments', fn);
    }
  }, {
    key: "getCachedRxDocument",
    get: function () {
      var fn = getCachedRxDocumentMonad(this);
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.overwriteGetterForCaching)(this, 'getCachedRxDocument', doc => fn([doc])[0]);
    }
  }]);
}();

/**
 * This function is called very very often.
 * This is likely the most important function for RxDB overall performance
 * @hotPath This is one of the most important methods for performance.
 * It is used in many places to transform the raw document data into RxDocuments.
 */
function getCachedRxDocumentMonad(docCache) {
  var primaryPath = docCache.primaryPath;
  var cacheItemByDocId = docCache.cacheItemByDocId;
  var registry = docCache.registry;
  var deepFreezeWhenDevMode = _overwritable_js__WEBPACK_IMPORTED_MODULE_4__.overwritable.deepFreezeWhenDevMode;
  var documentCreator = docCache.documentCreator;
  var fn = docsData => {
    var ret = new Array(docsData.length);
    var registryTasks = [];
    for (var index = 0; index < docsData.length; index++) {
      var docData = docsData[index];
      var docId = docData[primaryPath];
      var revisionHeight = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getHeightOfRevision)(docData._rev);
      var byRev = void 0;
      var cachedRxDocumentWeakRef = void 0;
      var cacheItem = cacheItemByDocId.get(docId);
      if (!cacheItem) {
        byRev = new Map();
        cacheItem = [byRev, docData];
        cacheItemByDocId.set(docId, cacheItem);
      } else {
        byRev = cacheItem[0];
        cachedRxDocumentWeakRef = byRev.get(revisionHeight);
      }
      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;
      if (!cachedRxDocument) {
        docData = deepFreezeWhenDevMode(docData);
        cachedRxDocument = documentCreator(docData);
        byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
        if (registry) {
          registryTasks.push(cachedRxDocument);
        }
      }
      ret[index] = cachedRxDocument;
    }
    if (registryTasks.length > 0 && registry) {
      /**
       * Calling registry.register() has shown to have
       * really bad performance. So we add the cached documents
       * lazily.
       */
      docCache.tasks.add(() => {
        for (var _index = 0; _index < registryTasks.length; _index++) {
          var doc = registryTasks[_index];
          registry.register(doc, {
            docId: doc.primary,
            revisionHeight: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getHeightOfRevision)(doc.revision)
          });
        }
      });
      if (docCache.tasks.size <= 1) {
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.requestIdlePromiseNoQueue)().then(() => {
          docCache.processTasks();
        });
      }
    }
    return ret;
  };
  return fn;
}
function mapDocumentsDataToCacheDocs(docCache, docsData) {
  var getCachedRxDocuments = docCache.getCachedRxDocuments;
  return getCachedRxDocuments(docsData);
}

/**
 * Fallback for JavaScript runtimes that do not support WeakRef.
 * The fallback will keep the items in cache forever,
 * but at least works.
 */
var HAS_WEAK_REF = typeof WeakRef === 'function';
var createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;
function createWeakRef(obj) {
  return new WeakRef(obj);
}
function createWeakRefFallback(obj) {
  return {
    deref() {
      return obj;
    }
  };
}
//# sourceMappingURL=doc-cache.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/event-reduce.js":
/*!****************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/event-reduce.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RXQUERY_QUERY_PARAMS_CACHE: () => (/* binding */ RXQUERY_QUERY_PARAMS_CACHE),
/* harmony export */   calculateNewResults: () => (/* binding */ calculateNewResults),
/* harmony export */   getQueryParams: () => (/* binding */ getQueryParams),
/* harmony export */   getSortFieldsOfQuery: () => (/* binding */ getSortFieldsOfQuery)
/* harmony export */ });
/* harmony import */ var event_reduce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! event-reduce-js */ "./node_modules/event-reduce-js/dist/esm/src/index.js");
/* harmony import */ var _rx_change_event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-change-event.js */ "./node_modules/rxdb/dist/esm/rx-change-event.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");




function getSortFieldsOfQuery(primaryKey, query) {
  if (!query.sort || query.sort.length === 0) {
    return [primaryKey];
  } else {
    return query.sort.map(part => Object.keys(part)[0]);
  }
}
var RXQUERY_QUERY_PARAMS_CACHE = new WeakMap();
function getQueryParams(rxQuery) {
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrCreate)(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {
    var collection = rxQuery.collection;
    var normalizedMangoQuery = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.normalizeMangoQuery)(collection.storageInstance.schema, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.clone)(rxQuery.mangoQuery));
    var primaryKey = collection.schema.primaryPath;

    /**
     * Create a custom sort comparator
     * that uses the hooks to ensure
     * we send for example compressed documents to be sorted by compressed queries.
     */
    var sortComparator = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.getSortComparator)(collection.schema.jsonSchema, normalizedMangoQuery);
    var useSortComparator = (docA, docB) => {
      var sortComparatorData = {
        docA,
        docB,
        rxQuery
      };
      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
    };

    /**
     * Create a custom query matcher
     * that uses the hooks to ensure
     * we send for example compressed documents to match compressed queries.
     */
    var queryMatcher = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.getQueryMatcher)(collection.schema.jsonSchema, normalizedMangoQuery);
    var useQueryMatcher = doc => {
      var queryMatcherData = {
        doc,
        rxQuery
      };
      return queryMatcher(queryMatcherData.doc);
    };
    var ret = {
      primaryKey: rxQuery.collection.schema.primaryPath,
      skip: normalizedMangoQuery.skip,
      limit: normalizedMangoQuery.limit,
      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
      sortComparator: useSortComparator,
      queryMatcher: useQueryMatcher
    };
    return ret;
  });
}
function calculateNewResults(rxQuery, rxChangeEvents) {
  if (!rxQuery.collection.database.eventReduce) {
    return {
      runFullQueryAgain: true
    };
  }
  var queryParams = getQueryParams(rxQuery);
  var previousResults = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(rxQuery._result).docsData.slice(0);
  var previousResultsMap = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(rxQuery._result).docsDataMap;
  var changed = false;
  var eventReduceEvents = [];
  for (var index = 0; index < rxChangeEvents.length; index++) {
    var cE = rxChangeEvents[index];
    var eventReduceEvent = (0,_rx_change_event_js__WEBPACK_IMPORTED_MODULE_4__.rxChangeEventToEventReduceChangeEvent)(cE);
    if (eventReduceEvent) {
      eventReduceEvents.push(eventReduceEvent);
    }
  }
  var foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {
    var stateResolveFunctionInput = {
      queryParams,
      changeEvent: eventReduceEvent,
      previousResults,
      keyDocumentMap: previousResultsMap
    };
    var actionName = (0,event_reduce_js__WEBPACK_IMPORTED_MODULE_5__.calculateActionName)(stateResolveFunctionInput);
    if (actionName === 'runFullQueryAgain') {
      return true;
    } else if (actionName !== 'doNothing') {
      changed = true;
      (0,event_reduce_js__WEBPACK_IMPORTED_MODULE_5__.runAction)(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
      return false;
    }
  });
  if (foundNonOptimizeable) {
    return {
      runFullQueryAgain: true
    };
  } else {
    return {
      runFullQueryAgain: false,
      changed,
      newResults: previousResults
    };
  }
}
//# sourceMappingURL=event-reduce.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/rxdb/dist/esm/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HOOKS: () => (/* binding */ HOOKS),
/* harmony export */   _clearHook: () => (/* binding */ _clearHook),
/* harmony export */   runAsyncPluginHooks: () => (/* binding */ runAsyncPluginHooks),
/* harmony export */   runPluginHooks: () => (/* binding */ runPluginHooks)
/* harmony export */ });
/**
 * hook-functions that can be extended by the plugin
 */
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  createRxState: [],
  /**
  * runs at the end of the close-process of a collection
  * @async
  */
  postCloseRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  prePrepareRxQuery: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  preStorageWrite: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the close-process of a database
   */
  preCloseRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  postCleanup: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey].length > 0) {
    HOOKS[hookKey].forEach(fun => fun(obj));
  }
}

/**
 * We do intentionally not run the hooks in parallel
 * because that makes stuff unpredictable and we use runAsyncPluginHooks()
 * only in places that are not that relevant for performance.
 */
async function runAsyncPluginHooks(hookKey, obj) {
  for (var fn of HOOKS[hookKey]) {
    await fn(obj);
  }
}

/**
 * used in tests to remove hooks
 */
function _clearHook(type, fun) {
  HOOKS[type] = HOOKS[type].filter(h => h !== fun);
}
//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/incremental-write.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/incremental-write.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncrementalWriteQueue: () => (/* binding */ IncrementalWriteQueue),
/* harmony export */   findNewestOfDocumentStates: () => (/* binding */ findNewestOfDocumentStates),
/* harmony export */   modifierFromPublicToInternal: () => (/* binding */ modifierFromPublicToInternal)
/* harmony export */ });
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");



/**
 * The incremental write queue
 * batches up all incremental writes to a collection
 * so that performance can be improved by:
 * - Running only one write even when there are multiple modifications to the same document.
 * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.
 */
var IncrementalWriteQueue = /*#__PURE__*/function () {
  function IncrementalWriteQueue(storageInstance, primaryPath,
  // can be used to run hooks etc.
  preWrite, postWrite) {
    this.queueByDocId = new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve,
        reject
      };
      (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      // already running
      return;
    }
    this.isRunning = true;
    var writeRows = [];

    /**
     * 'take over' so that while the async functions runs,
     * new incremental updates could be added from the outside.
     */
    var itemsById = this.queueByDocId;
    this.queueByDocId = new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
          /**
           * We have to clone() each time because the modifier
           * might throw while it already changed some properties
           * of the document.
           */
          (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.clone)(newData));
        } catch (err) {
          item.reject(err);
          item.reject = () => {};
          item.resolve = () => {};
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        /**
         * If the before-hooks fail,
         * we reject all of the writes because it is
         * not possible to determine which one is to blame.
         */
        items.forEach(item => item.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {
      error: []
    };

    // process success
    await Promise.all((0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.getWrittenDocumentsFromBulkWriteResponse)(this.primaryPath, writeRows, writeResult).map(result => {
      var docId = result[this.primaryPath];
      this.postWrite(result);
      var items = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrThrow)(itemsById, docId);
      items.forEach(item => item.resolve(result));
    }));

    // process errors
    writeResult.error.forEach(error => {
      var docId = error.documentId;
      var items = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrThrow)(itemsById, docId);
      var isConflict = (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.isBulkWriteConflictError)(error);
      if (isConflict) {
        // had conflict -> retry afterwards
        var ar = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
        /**
         * Add the items back to this.queueByDocId
         * by maintaining the original order.
         */
        items.reverse().forEach(item => {
          item.lastKnownDocumentState = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(isConflict.documentInDb);
          (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(ar).unshift(item);
        });
      } else {
        // other error -> must be thrown
        var rxError = (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.rxStorageWriteErrorToRxError)(error);
        items.forEach(item => item.reject(rxError));
      }
    });
    this.isRunning = false;

    /**
     * Always trigger another run
     * because in between there might be new items
     * been added to the queue.
     */
    return this.triggerRun();
  };
  return IncrementalWriteQueue;
}();
function modifierFromPublicToInternal(publicModifier) {
  var ret = async docData => {
    var withoutMeta = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.stripMetaDataFromDocument)(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === 'undefined') {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getHeightOfRevision)(newest._rev);
  docs.forEach(doc => {
    var height = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getHeightOfRevision)(doc._rev);
    if (height > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height;
    }
  });
  return newest;
}
//# sourceMappingURL=incremental-write.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/overwritable.js":
/*!****************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/overwritable.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   overwritable: () => (/* binding */ overwritable)
/* harmony export */ });
/**
 * functions that can or should be overwritten by plugins
 * IMPORTANT: Do not import any big stuff from RxDB here!
 * An 'overwritable' can be used inside WebWorkers for RxStorage only,
 * and we do not want to have the full RxDB lib bundled in them.
 */

var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "\n        RxDB Error-Code: " + message + ".\n        Hint: Error messages are not included in RxDB core to reduce build size.\n        To show the full error messages and to ensure that you do not make any mistakes when using RxDB,\n        use the dev-mode plugin when you are in development mode: https://rxdb.info/dev-mode.html?console=error\n        ";
  }
};
//# sourceMappingURL=overwritable.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugin.js":
/*!**********************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugin.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRxPlugin: () => (/* binding */ addRxPlugin)
/* harmony export */ });
/* harmony import */ var _rx_schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema.js */ "./node_modules/rxdb/dist/esm/rx-schema.js");
/* harmony import */ var _rx_document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-document.js */ "./node_modules/rxdb/dist/esm/rx-document.js");
/* harmony import */ var _rx_query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-query.js */ "./node_modules/rxdb/dist/esm/rx-query.js");
/* harmony import */ var _rx_collection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-collection.js */ "./node_modules/rxdb/dist/esm/rx-collection.js");
/* harmony import */ var _rx_database_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-database.js */ "./node_modules/rxdb/dist/esm/rx-database.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/**
 * this handles how plugins are added to rxdb
 * basically it changes the internal prototypes
 * by passing them to the plugins-functions
 */









/**
 * prototypes that can be manipulated with a plugin
 */
var PROTOTYPES = {
  RxSchema: _rx_schema_js__WEBPACK_IMPORTED_MODULE_0__.RxSchema.prototype,
  RxDocument: _rx_document_js__WEBPACK_IMPORTED_MODULE_1__.basePrototype,
  RxQuery: _rx_query_js__WEBPACK_IMPORTED_MODULE_2__.RxQueryBase.prototype,
  RxCollection: _rx_collection_js__WEBPACK_IMPORTED_MODULE_3__.RxCollectionBase.prototype,
  RxDatabase: _rx_database_js__WEBPACK_IMPORTED_MODULE_4__.RxDatabaseBase.prototype
};
var ADDED_PLUGINS = new Set();
var ADDED_PLUGIN_NAMES = new Set();

/**
 * Add a plugin to the RxDB library.
 * Plugins are added globally and cannot be removed.
 */
function addRxPlugin(plugin) {
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_5__.runPluginHooks)('preAddRxPlugin', {
    plugin,
    plugins: ADDED_PLUGINS
  });

  // do nothing if added before
  if (ADDED_PLUGINS.has(plugin)) {
    return;
  } else {
    // ensure no other plugin with the same name was already added
    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('PL3', {
        name: plugin.name,
        plugin
      });
    }
    ADDED_PLUGINS.add(plugin);
    ADDED_PLUGIN_NAMES.add(plugin.name);
  }

  /**
   * To identify broken configurations,
   * we only allow RxDB plugins to be passed into addRxPlugin().
   */
  if (!plugin.rxdb) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxTypeError)('PL1', {
      plugin
    });
  }
  if (plugin.init) {
    plugin.init();
  }

  // prototype-overwrites
  if (plugin.prototypes) {
    Object.entries(plugin.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  // overwritable-overwrites
  if (plugin.overwritable) {
    Object.assign(_overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable, plugin.overwritable);
  }
  // extend-hooks
  if (plugin.hooks) {
    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        _hooks_js__WEBPACK_IMPORTED_MODULE_5__.HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        _hooks_js__WEBPACK_IMPORTED_MODULE_5__.HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}
//# sourceMappingURL=plugin.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignMethodsToAttachment: () => (/* binding */ assignMethodsToAttachment),
/* harmony export */   ensureSchemaSupportsAttachments: () => (/* binding */ ensureSchemaSupportsAttachments),
/* harmony export */   fillWriteDataForAttachmentsChange: () => (/* binding */ fillWriteDataForAttachmentsChange)
/* harmony export */ });
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");


function ensureSchemaSupportsAttachments(doc) {
  var schemaJson = doc.collection.schema.jsonSchema;
  if (!schemaJson.attachments) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_0__.newRxError)('AT1', {
      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'
    });
  }
}
function assignMethodsToAttachment(attachment) {
  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {
    Object.defineProperty(attachment, funName, {
      get: () => fun.bind(attachment)
    });
  });
}

/**
 * Fill up the missing attachment.data of the newDocument
 * so that the new document can be send to somewhere else
 * which could then receive all required attachments data
 * that it did not have before.
 */
async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {
  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {
    throw new Error('_attachments missing');
  }
  var docId = newDocument[primaryPath];
  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);
  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {
    if ((!originalAttachmentsIds.has(key) || originalDocument && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {
      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);
      value.data = attachmentDataString;
    }
  }));
  return newDocument;
}
//# sourceMappingURL=attachments-utils.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/local-documents/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/local-documents/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCAL_DOC_STATE_BY_PARENT: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.LOCAL_DOC_STATE_BY_PARENT),
/* harmony export */   LOCAL_DOC_STATE_BY_PARENT_RESOLVED: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.LOCAL_DOC_STATE_BY_PARENT_RESOLVED),
/* harmony export */   RX_LOCAL_DOCUMENT_SCHEMA: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.RX_LOCAL_DOCUMENT_SCHEMA),
/* harmony export */   RxDBLocalDocumentsPlugin: () => (/* binding */ RxDBLocalDocumentsPlugin),
/* harmony export */   closeStateByParent: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent),
/* harmony export */   createLocalDocStateByParent: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent),
/* harmony export */   createLocalDocumentStorageInstance: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.createLocalDocumentStorageInstance),
/* harmony export */   createRxLocalDocument: () => (/* reexport safe */ _rx_local_document_js__WEBPACK_IMPORTED_MODULE_2__.createRxLocalDocument),
/* harmony export */   getCollectionLocalInstanceName: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.getCollectionLocalInstanceName),
/* harmony export */   getLocal: () => (/* reexport safe */ _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal),
/* harmony export */   getLocal$: () => (/* reexport safe */ _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal$),
/* harmony export */   getLocalDocStateByParent: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent),
/* harmony export */   getRxDatabaseFromLocalDocument: () => (/* reexport safe */ _rx_local_document_js__WEBPACK_IMPORTED_MODULE_2__.getRxDatabaseFromLocalDocument),
/* harmony export */   insertLocal: () => (/* reexport safe */ _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.insertLocal),
/* harmony export */   removeLocalDocumentsStorageInstance: () => (/* reexport safe */ _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance),
/* harmony export */   upsertLocal: () => (/* reexport safe */ _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.upsertLocal)
/* harmony export */ });
/* harmony import */ var _local_documents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./local-documents.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents.js");
/* harmony import */ var _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./local-documents-helper.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents-helper.js");
/* harmony import */ var _rx_local_document_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-local-document.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/rx-local-document.js");





var RxDBLocalDocumentsPlugin = {
  name: 'local-documents',
  rxdb: true,
  prototypes: {
    RxCollection: proto => {
      proto.insertLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.insertLocal;
      proto.upsertLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.upsertLocal;
      proto.getLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal;
      proto.getLocal$ = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal$;
    },
    RxDatabase: proto => {
      proto.insertLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.insertLocal;
      proto.upsertLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.upsertLocal;
      proto.getLocal = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal;
      proto.getLocal$ = _local_documents_js__WEBPACK_IMPORTED_MODULE_1__.getLocal$;
    }
  },
  hooks: {
    createRxDatabase: {
      before: args => {
        if (args.creator.localDocuments) {
          /**
           * We do not have to await
           * the creation to speed up initial page load.
           */
          /* await */
          (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent)(args.database);
        }
      }
    },
    createRxCollection: {
      before: args => {
        if (args.creator.localDocuments) {
          /**
           * We do not have to await
           * the creation to speed up initial page load.
           */
          /* await */
          (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent)(args.collection);
        }
      }
    },
    preCloseRxDatabase: {
      after: db => {
        return (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent)(db);
      }
    },
    postCloseRxCollection: {
      after: collection => (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent)(collection)
    },
    postRemoveRxDatabase: {
      after: args => {
        return (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance)(args.storage, args.databaseName, '');
      }
    },
    postRemoveRxCollection: {
      after: args => {
        return (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance)(args.storage, args.databaseName, args.collectionName);
      }
    }
  },
  overwritable: {}
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents-helper.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents-helper.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCAL_DOC_STATE_BY_PARENT: () => (/* binding */ LOCAL_DOC_STATE_BY_PARENT),
/* harmony export */   LOCAL_DOC_STATE_BY_PARENT_RESOLVED: () => (/* binding */ LOCAL_DOC_STATE_BY_PARENT_RESOLVED),
/* harmony export */   RX_LOCAL_DOCUMENT_SCHEMA: () => (/* binding */ RX_LOCAL_DOCUMENT_SCHEMA),
/* harmony export */   closeStateByParent: () => (/* binding */ closeStateByParent),
/* harmony export */   createLocalDocStateByParent: () => (/* binding */ createLocalDocStateByParent),
/* harmony export */   createLocalDocumentStorageInstance: () => (/* binding */ createLocalDocumentStorageInstance),
/* harmony export */   getCollectionLocalInstanceName: () => (/* binding */ getCollectionLocalInstanceName),
/* harmony export */   getLocalDocStateByParent: () => (/* binding */ getLocalDocStateByParent),
/* harmony export */   removeLocalDocumentsStorageInstance: () => (/* binding */ removeLocalDocumentsStorageInstance)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _doc_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../doc-cache.js */ "./node_modules/rxdb/dist/esm/doc-cache.js");
/* harmony import */ var _incremental_write_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../incremental-write.js */ "./node_modules/rxdb/dist/esm/incremental-write.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _rx_local_document_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-local-document.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/rx-local-document.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");









var LOCAL_DOC_STATE_BY_PARENT = new WeakMap();
var LOCAL_DOC_STATE_BY_PARENT_RESOLVED = new WeakMap();
function createLocalDocStateByParent(parent) {
  var database = parent.database ? parent.database : parent;
  var collectionName = parent.database ? parent.name : '';
  var statePromise = (async () => {
    var storageInstance = await createLocalDocumentStorageInstance(database.token, database.storage, database.name, collectionName, database.instanceCreationOptions, database.multiInstance);
    storageInstance = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_0__.getWrappedStorageInstance)(database, storageInstance, RX_LOCAL_DOCUMENT_SCHEMA);
    var docCache = new _doc_cache_js__WEBPACK_IMPORTED_MODULE_1__.DocumentCache('id', database.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.filter)(changeEventBulk => {
      var ret = false;
      if (
      // parent is database
      collectionName === '' && !changeEventBulk.collectionName ||
      // parent is collection

      collectionName !== '' && changeEventBulk.collectionName === collectionName) {
        ret = true;
      }
      return ret && changeEventBulk.isLocal;
    }), (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(b => b.events)), docData => (0,_rx_local_document_js__WEBPACK_IMPORTED_MODULE_4__.createRxLocalDocument)(docData, parent));
    var incrementalWriteQueue = new _incremental_write_js__WEBPACK_IMPORTED_MODULE_5__.IncrementalWriteQueue(storageInstance, 'id', () => {}, () => {});

    /**
     * Emit the changestream into the collections change stream
     */
    var databaseStorageToken = await database.storageToken;
    var subLocalDocs = storageInstance.changeStream().subscribe(eventBulk => {
      var events = new Array(eventBulk.events.length);
      var rawEvents = eventBulk.events;
      var collectionName = parent.database ? parent.name : undefined;
      for (var index = 0; index < rawEvents.length; index++) {
        var event = rawEvents[index];
        events[index] = {
          documentId: event.documentId,
          collectionName,
          isLocal: true,
          operation: event.operation,
          documentData: _overwritable_js__WEBPACK_IMPORTED_MODULE_6__.overwritable.deepFreezeWhenDevMode(event.documentData),
          previousDocumentData: _overwritable_js__WEBPACK_IMPORTED_MODULE_6__.overwritable.deepFreezeWhenDevMode(event.previousDocumentData)
        };
      }
      var changeEventBulk = {
        id: eventBulk.id,
        isLocal: true,
        internal: false,
        collectionName: parent.database ? parent.name : undefined,
        storageToken: databaseStorageToken,
        events,
        databaseToken: database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context
      };
      database.$emit(changeEventBulk);
    });
    parent._subs.push(subLocalDocs);
    var state = {
      database,
      parent,
      storageInstance,
      docCache,
      incrementalWriteQueue
    };
    LOCAL_DOC_STATE_BY_PARENT_RESOLVED.set(parent, state);
    return state;
  })();
  LOCAL_DOC_STATE_BY_PARENT.set(parent, statePromise);
}
function getLocalDocStateByParent(parent) {
  var statePromise = LOCAL_DOC_STATE_BY_PARENT.get(parent);
  if (!statePromise) {
    var database = parent.database ? parent.database : parent;
    var collectionName = parent.database ? parent.name : '';
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_7__.newRxError)('LD8', {
      database: database.name,
      collection: collectionName
    });
  }
  return statePromise;
}
function createLocalDocumentStorageInstance(databaseInstanceToken, storage, databaseName, collectionName, instanceCreationOptions, multiInstance) {
  return storage.createStorageInstance({
    databaseInstanceToken,
    databaseName: databaseName,
    /**
     * Use a different collection name for the local documents instance
     * so that the local docs can be kept while deleting the normal instance
     * after migration.
     */
    collectionName: getCollectionLocalInstanceName(collectionName),
    schema: RX_LOCAL_DOCUMENT_SCHEMA,
    options: instanceCreationOptions,
    multiInstance,
    devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_6__.overwritable.isDevMode()
  });
}
function closeStateByParent(parent) {
  var statePromise = LOCAL_DOC_STATE_BY_PARENT.get(parent);
  if (statePromise) {
    LOCAL_DOC_STATE_BY_PARENT.delete(parent);
    return statePromise.then(state => state.storageInstance.close());
  }
}
async function removeLocalDocumentsStorageInstance(storage, databaseName, collectionName) {
  var databaseInstanceToken = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.randomToken)(10);
  var storageInstance = await createLocalDocumentStorageInstance(databaseInstanceToken, storage, databaseName, collectionName, {}, false);
  await storageInstance.remove();
}
function getCollectionLocalInstanceName(collectionName) {
  return 'plugin-local-documents-' + collectionName;
}
var RX_LOCAL_DOCUMENT_SCHEMA = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_9__.fillWithDefaultSettings)({
  title: 'RxLocalDocument',
  version: 0,
  primaryKey: 'id',
  type: 'object',
  properties: {
    id: {
      type: 'string',
      maxLength: 128
    },
    data: {
      type: 'object',
      additionalProperties: true
    }
  },
  required: ['id', 'data']
});
//# sourceMappingURL=local-documents-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLocal: () => (/* binding */ getLocal),
/* harmony export */   getLocal$: () => (/* binding */ getLocal$),
/* harmony export */   insertLocal: () => (/* binding */ insertLocal),
/* harmony export */   upsertLocal: () => (/* binding */ upsertLocal)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./local-documents-helper.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");





/**
 * save the local-document-data
 * throws if already exists
 */
async function insertLocal(id, data) {
  var state = await (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent)(this);

  // create new one
  var docData = {
    id: id,
    data,
    _deleted: false,
    _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRxDocumentMeta)(),
    _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRevision)(),
    _attachments: {}
  };
  return (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__.writeSingle)(state.storageInstance, {
    document: docData
  }, 'local-document-insert').then(newDocData => state.docCache.getCachedRxDocument(newDocData));
}

/**
 * save the local-document-data
 * overwrites existing if exists
 */
function upsertLocal(id, data) {
  return this.getLocal(id).then(existing => {
    if (!existing) {
      // create new one
      var docPromise = this.insertLocal(id, data);
      return docPromise;
    } else {
      // update existing
      return existing.incrementalModify(() => {
        return data;
      });
    }
  });
}
async function getLocal(id) {
  var state = await (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent)(this);
  var docCache = state.docCache;

  // check in doc-cache
  var found = docCache.getLatestDocumentDataIfExists(id);
  if (found) {
    return Promise.resolve(docCache.getCachedRxDocument(found));
  }

  // if not found, check in storage instance
  return (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__.getSingleDocument)(state.storageInstance, id).then(docData => {
    if (!docData) {
      return null;
    }
    return state.docCache.getCachedRxDocument(docData);
  });
}
function getLocal$(id) {
  return this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.startWith)(null), (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(async cE => {
    if (cE) {
      return {
        changeEvent: cE
      };
    } else {
      var doc = await this.getLocal(id);
      return {
        doc: doc
      };
    }
  }), (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(async changeEventOrDoc => {
    if (changeEventOrDoc.changeEvent) {
      var cE = changeEventOrDoc.changeEvent;
      if (!cE.isLocal || cE.documentId !== id) {
        return {
          use: false
        };
      } else {
        var doc = await this.getLocal(id);
        return {
          use: true,
          doc: doc
        };
      }
    } else {
      return {
        use: true,
        doc: changeEventOrDoc.doc
      };
    }
  }), (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(filterFlagged => filterFlagged.use), (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(filterFlagged => {
    return filterFlagged.doc;
  }));
}
//# sourceMappingURL=local-documents.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/local-documents/rx-local-document.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/local-documents/rx-local-document.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRxLocalDocument: () => (/* binding */ createRxLocalDocument),
/* harmony export */   getRxDatabaseFromLocalDocument: () => (/* binding */ getRxDatabaseFromLocalDocument)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_change_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../rx-change-event.js */ "./node_modules/rxdb/dist/esm/rx-change-event.js");
/* harmony import */ var _rx_document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-document.js */ "./node_modules/rxdb/dist/esm/rx-document.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./local-documents-helper.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/local-documents-helper.js");
/* harmony import */ var _rx_database_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../rx-database.js */ "./node_modules/rxdb/dist/esm/rx-database.js");










var RxDocumentParent = (0,_rx_document_js__WEBPACK_IMPORTED_MODULE_1__.createRxDocumentConstructor)();
var RxLocalDocumentClass = /*#__PURE__*/function (_RxDocumentParent) {
  function RxLocalDocumentClass(id, jsonData, parent) {
    var _this2;
    _this2 = _RxDocumentParent.call(this, null, jsonData) || this;
    _this2.id = id;
    _this2.parent = parent;
    return _this2;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(RxLocalDocumentClass, _RxDocumentParent);
  return RxLocalDocumentClass;
}(RxDocumentParent);
var RxLocalDocumentPrototype = {
  get isLocal() {
    return true;
  },
  //
  // overwrites
  //
  get allAttachments$() {
    // this is overwritten here because we cannot re-set getters on the prototype
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD1', {
      document: this
    });
  },
  get primaryPath() {
    return 'id';
  },
  get primary() {
    return this.id;
  },
  get $() {
    var _this = this;
    var state = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getFromMapOrThrow)(_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__.LOCAL_DOC_STATE_BY_PARENT_RESOLVED, this.parent);
    var id = this.primary;
    return _this.parent.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(bulk => !!bulk.isLocal), (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(bulk => bulk.events.find(ev => ev.documentId === id)), (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(event => !!event), (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(changeEvent => (0,_rx_change_event_js__WEBPACK_IMPORTED_MODULE_7__.getDocumentDataOfRxChangeEvent)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.ensureNotFalsy)(changeEvent))), (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.startWith)(state.docCache.getLatestDocumentData(this.primary)), (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(docData => state.docCache.getCachedRxDocument(docData)), (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.shareReplay)(_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.RXJS_SHARE_REPLAY_DEFAULTS));
    ;
  },
  get $$() {
    var _this = this;
    var db = getRxDatabaseFromLocalDocument(_this);
    var reactivity = db.getReactivityFactory();
    return reactivity.fromObservable(_this.$, _this.getLatest()._data, db);
  },
  get deleted$$() {
    var _this = this;
    var db = getRxDatabaseFromLocalDocument(_this);
    var reactivity = db.getReactivityFactory();
    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, db);
  },
  getLatest() {
    var state = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getFromMapOrThrow)(_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__.LOCAL_DOC_STATE_BY_PARENT_RESOLVED, this.parent);
    var latestDocData = state.docCache.getLatestDocumentData(this.primary);
    return state.docCache.getCachedRxDocument(latestDocData);
  },
  get(objPath) {
    objPath = 'data.' + objPath;
    if (!this._data) {
      return undefined;
    }
    if (typeof objPath !== 'string') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxTypeError)('LD2', {
        objPath
      });
    }
    var valueObj = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getProperty)(this._data, objPath);
    valueObj = _overwritable_js__WEBPACK_IMPORTED_MODULE_13__.overwritable.deepFreezeWhenDevMode(valueObj);
    return valueObj;
  },
  get$(objPath) {
    objPath = 'data.' + objPath;
    if (_overwritable_js__WEBPACK_IMPORTED_MODULE_13__.overwritable.isDevMode()) {
      if (objPath.includes('.item.')) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD3', {
          objPath
        });
      }
      if (objPath === this.primaryPath) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD4');
      }
    }
    return this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(localDocument => localDocument._data), (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.map)(data => (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getProperty)(data, objPath)), (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.distinctUntilChanged)());
  },
  get$$(objPath) {
    var db = getRxDatabaseFromLocalDocument(this);
    var reactivity = db.getReactivityFactory();
    return reactivity.fromObservable(this.get$(objPath), this.getLatest().get(objPath), db);
  },
  async incrementalModify(mutationFunction) {
    var state = await (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__.getLocalDocStateByParent)(this.parent);
    return state.incrementalWriteQueue.addWrite(this._data, async docData => {
      docData.data = await mutationFunction(docData.data, this);
      return docData;
    }).then(result => state.docCache.getCachedRxDocument(result));
  },
  incrementalPatch(patch) {
    return this.incrementalModify(docData => {
      Object.entries(patch).forEach(([k, v]) => {
        docData[k] = v;
      });
      return docData;
    });
  },
  async _saveData(newData) {
    var state = await (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__.getLocalDocStateByParent)(this.parent);
    var oldData = this._data;
    newData.id = this.id;
    var writeRows = [{
      previous: oldData,
      document: newData
    }];
    return state.storageInstance.bulkWrite(writeRows, 'local-document-save-data').then(res => {
      if (res.error[0]) {
        throw res.error[0];
      }
      var success = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_14__.getWrittenDocumentsFromBulkWriteResponse)(this.collection.schema.primaryPath, writeRows, res)[0];
      newData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.flatClone)(newData);
      newData._rev = success._rev;
    });
  },
  async remove() {
    var state = await (0,_local_documents_helper_js__WEBPACK_IMPORTED_MODULE_4__.getLocalDocStateByParent)(this.parent);
    var writeData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.flatClone)(this._data);
    writeData._deleted = true;
    return (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_14__.writeSingle)(state.storageInstance, {
      previous: this._data,
      document: writeData
    }, 'local-document-remove').then(writeResult => state.docCache.getCachedRxDocument(writeResult));
  }
};
var INIT_DONE = false;
var _init = () => {
  if (INIT_DONE) return;else INIT_DONE = true;

  // add functions of RxDocument
  var docBaseProto = _rx_document_js__WEBPACK_IMPORTED_MODULE_1__.basePrototype;
  var props = Object.getOwnPropertyNames(docBaseProto);
  props.forEach(key => {
    var exists = Object.getOwnPropertyDescriptor(RxLocalDocumentPrototype, key);
    if (exists) return;
    var desc = Object.getOwnPropertyDescriptor(docBaseProto, key);
    Object.defineProperty(RxLocalDocumentPrototype, key, desc);
  });

  /**
   * Overwrite things that do not work on local documents
   * with a throwing function.
   */
  var getThrowingFun = k => () => {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD6', {
      functionName: k
    });
  };
  ['populate', 'update', 'putAttachment', 'getAttachment', 'allAttachments'].forEach(k => RxLocalDocumentPrototype[k] = getThrowingFun(k));
};
function createRxLocalDocument(data, parent) {
  _init();
  var newDoc = new RxLocalDocumentClass(data.id, data, parent);
  Object.setPrototypeOf(newDoc, RxLocalDocumentPrototype);
  newDoc.prototype = RxLocalDocumentPrototype;
  return newDoc;
}
function getRxDatabaseFromLocalDocument(doc) {
  var parent = doc.parent;
  if ((0,_rx_database_js__WEBPACK_IMPORTED_MODULE_16__.isRxDatabase)(parent)) {
    return parent;
  } else {
    return parent.database;
  }
}
//# sourceMappingURL=rx-local-document.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/migration-schema/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/migration-schema/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE),
/* harmony export */   DATA_MIGRATOR_BY_COLLECTION: () => (/* binding */ DATA_MIGRATOR_BY_COLLECTION),
/* harmony export */   MIGRATION_DEFAULT_BATCH_SIZE: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.MIGRATION_DEFAULT_BATCH_SIZE),
/* harmony export */   RxDBMigrationPlugin: () => (/* binding */ RxDBMigrationPlugin),
/* harmony export */   RxDBMigrationSchemaPlugin: () => (/* binding */ RxDBMigrationSchemaPlugin),
/* harmony export */   RxMigrationState: () => (/* reexport safe */ _rx_migration_state_js__WEBPACK_IMPORTED_MODULE_6__.RxMigrationState),
/* harmony export */   addMigrationStateToDatabase: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.addMigrationStateToDatabase),
/* harmony export */   getMigrationStateByDatabase: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getMigrationStateByDatabase),
/* harmony export */   getOldCollectionMeta: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getOldCollectionMeta),
/* harmony export */   migrateDocumentData: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.migrateDocumentData),
/* harmony export */   mustMigrate: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.mustMigrate),
/* harmony export */   onDatabaseClose: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.onDatabaseClose),
/* harmony export */   runStrategyIfNotNull: () => (/* reexport safe */ _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.runStrategyIfNotNull)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _rx_migration_state_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-migration-state.js */ "./node_modules/rxdb/dist/esm/plugins/migration-schema/rx-migration-state.js");
/* harmony import */ var _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./migration-helpers.js */ "./node_modules/rxdb/dist/esm/plugins/migration-schema/migration-helpers.js");
/* harmony import */ var _plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin.js */ "./node_modules/rxdb/dist/esm/plugin.js");
/* harmony import */ var _local_documents_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../local-documents/index.js */ "./node_modules/rxdb/dist/esm/plugins/local-documents/index.js");






var DATA_MIGRATOR_BY_COLLECTION = new WeakMap();
var RxDBMigrationPlugin = {
  name: 'migration-schema',
  rxdb: true,
  init() {
    (0,_plugin_js__WEBPACK_IMPORTED_MODULE_0__.addRxPlugin)(_local_documents_index_js__WEBPACK_IMPORTED_MODULE_1__.RxDBLocalDocumentsPlugin);
  },
  hooks: {
    preCloseRxDatabase: {
      after: _migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.onDatabaseClose
    }
  },
  prototypes: {
    RxDatabase: proto => {
      proto.migrationStates = function () {
        return (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getMigrationStateByDatabase)(this).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.shareReplay)(_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.RXJS_SHARE_REPLAY_DEFAULTS));
      };
    },
    RxCollection: proto => {
      proto.getMigrationState = function () {
        return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getFromMapOrCreate)(DATA_MIGRATOR_BY_COLLECTION, this, () => new _rx_migration_state_js__WEBPACK_IMPORTED_MODULE_6__.RxMigrationState(this.asRxCollection, this.migrationStrategies));
      };
      proto.migrationNeeded = function () {
        if (this.schema.version === 0) {
          return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.PROMISE_RESOLVE_FALSE;
        }
        return (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_2__.mustMigrate)(this.getMigrationState());
      };
    }
  }
};
var RxDBMigrationSchemaPlugin = RxDBMigrationPlugin;



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/migration-schema/migration-helpers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/migration-schema/migration-helpers.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE: () => (/* binding */ DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE),
/* harmony export */   MIGRATION_DEFAULT_BATCH_SIZE: () => (/* binding */ MIGRATION_DEFAULT_BATCH_SIZE),
/* harmony export */   addMigrationStateToDatabase: () => (/* binding */ addMigrationStateToDatabase),
/* harmony export */   getMigrationStateByDatabase: () => (/* binding */ getMigrationStateByDatabase),
/* harmony export */   getOldCollectionMeta: () => (/* binding */ getOldCollectionMeta),
/* harmony export */   migrateDocumentData: () => (/* binding */ migrateDocumentData),
/* harmony export */   mustMigrate: () => (/* binding */ mustMigrate),
/* harmony export */   onDatabaseClose: () => (/* binding */ onDatabaseClose),
/* harmony export */   runStrategyIfNotNull: () => (/* binding */ runStrategyIfNotNull)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js");
/* harmony import */ var _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-database-internal-store.js */ "./node_modules/rxdb/dist/esm/rx-database-internal-store.js");
/* harmony import */ var _rx_schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rx-schema.js */ "./node_modules/rxdb/dist/esm/rx-schema.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");




async function getOldCollectionMeta(migrationState) {
  var collectionDocKeys = (0,_rx_schema_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousVersions)(migrationState.collection.schema.jsonSchema).map(version => migrationState.collection.name + '-' + version);
  var found = await migrationState.database.internalStore.findDocumentsById(collectionDocKeys.map(key => (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_1__.getPrimaryKeyOfInternalDocument)(key, _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_CONTEXT_COLLECTION)), false);
  if (found.length > 1) {
    throw new Error('more than one old collection meta found');
  }
  return found[0];
}

/**
 * runs the doc-data through all following migrationStrategies
 * so it will match the newest schema.
 * @throws Error if final doc does not match final schema or migrationStrategy crashes
 * @return final object or null if migrationStrategy deleted it
 */
function migrateDocumentData(collection, docSchemaVersion, docData) {
  /**
   * We cannot deep-clone Blob or Buffer
   * so we just flat clone it here
   * and attach it to the deep cloned document data.
   */
  var attachmentsBefore = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.flatClone)(docData._attachments);
  var mutateableDocData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.clone)(docData);
  var meta = mutateableDocData._meta;
  delete mutateableDocData._meta;
  mutateableDocData._attachments = attachmentsBefore;
  var nextVersion = docSchemaVersion + 1;

  // run the document through migrationStrategies
  var currentPromise = Promise.resolve(mutateableDocData);
  var _loop = function () {
    var version = nextVersion;
    currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(collection, version, docOrNull));
    nextVersion++;
  };
  while (nextVersion <= collection.schema.version) {
    _loop();
  }
  return currentPromise.then(doc => {
    if (doc === null) {
      return _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_NULL;
    }
    doc._meta = meta;
    return doc;
  });
}
function runStrategyIfNotNull(collection, version, docOrNull) {
  if (docOrNull === null) {
    return _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_NULL;
  } else {
    var ret = collection.migrationStrategies[version](docOrNull, collection);
    var retPromise = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toPromise)(ret);
    return retPromise;
  }
}

/**
 * returns true if a migration is needed
 */
async function mustMigrate(migrationState) {
  if (migrationState.collection.schema.version === 0) {
    return _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;
  }
  var oldColDoc = await getOldCollectionMeta(migrationState);
  return !!oldColDoc;
}
var MIGRATION_DEFAULT_BATCH_SIZE = 200;
var DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE = new WeakMap();
function addMigrationStateToDatabase(migrationState) {
  var allSubject = getMigrationStateByDatabase(migrationState.database);
  var allList = allSubject.getValue().slice(0);
  allList.push(migrationState);
  allSubject.next(allList);
}
function getMigrationStateByDatabase(database) {
  return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getFromMapOrCreate)(DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE, database, () => new rxjs__WEBPACK_IMPORTED_MODULE_5__.BehaviorSubject([]));
}

/**
 * Complete on database close
 * so people do not have to unsubscribe
 */
function onDatabaseClose(database) {
  var subject = DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE.get(database);
  if (subject) {
    subject.complete();
  }
}
//# sourceMappingURL=migration-helpers.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/migration-schema/rx-migration-state.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/migration-schema/rx-migration-state.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxMigrationState: () => (/* binding */ RxMigrationState)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./migration-helpers.js */ "./node_modules/rxdb/dist/esm/plugins/migration-schema/migration-helpers.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var broadcast_channel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! broadcast-channel */ "./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js");
/* harmony import */ var broadcast_channel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! broadcast-channel */ "./node_modules/broadcast-channel/dist/esbrowser/leader-election.js");
/* harmony import */ var _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../replication-protocol/index.js */ "./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js");
/* harmony import */ var _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../replication-protocol/index.js */ "./node_modules/rxdb/dist/esm/replication-protocol/index.js");
/* harmony import */ var _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../replication-protocol/index.js */ "./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-database-internal-store.js */ "./node_modules/rxdb/dist/esm/rx-database-internal-store.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");










var RxMigrationState = /*#__PURE__*/function () {
  function RxMigrationState(collection, migrationStrategies, statusDocKey = [collection.name, 'v', collection.schema.version].join('-')) {
    this.started = false;
    this.updateStatusHandlers = [];
    this.updateStatusQueue = _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVE_TRUE;
    this.collection = collection;
    this.migrationStrategies = migrationStrategies;
    this.statusDocKey = statusDocKey;
    this.database = collection.database;
    this.oldCollectionMeta = (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getOldCollectionMeta)(this);
    this.mustMigrate = (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mustMigrate)(this);
    this.statusDocId = (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__.getPrimaryKeyOfInternalDocument)(this.statusDocKey, _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_CONTEXT_MIGRATION_STATUS);
    (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addMigrationStateToDatabase)(this);
    this.$ = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.observeSingle)(this.database.internalStore, this.statusDocId).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.filter)(d => !!d), (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.map)(d => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(d).data), (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.shareReplay)(_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.RXJS_SHARE_REPLAY_DEFAULTS));
  }
  var _proto = RxMigrationState.prototype;
  _proto.getStatus = function getStatus() {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.firstValueFrom)(this.$);
  }

  /**
   * Starts the migration.
   * Returns void so that people to not get the idea to await
   * this function.
   * Instead use migratePromise() if you want to await
   * the migration. This ensures it works even if the migration
   * is run on a different browser tab.
   */;
  _proto.startMigration = async function startMigration(batchSize = _migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__.MIGRATION_DEFAULT_BATCH_SIZE) {
    var must = await this.mustMigrate;
    if (!must) {
      return;
    }
    if (this.started) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_9__.newRxError)('DM1');
    }
    this.started = true;
    var broadcastChannel = undefined;
    /**
     * To ensure that multiple tabs do not migrate the same collection,
     * we use a new broadcastChannel/leaderElector for each collection.
     * This is required because collections can be added dynamically and
     * not all tabs might know about this collection.
     */
    if (this.database.multiInstance) {
      broadcastChannel = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(['rx-migration-state', this.database.name, this.collection.name, this.collection.schema.version].join('|'));
      var leaderElector = (0,broadcast_channel__WEBPACK_IMPORTED_MODULE_11__.createLeaderElection)(broadcastChannel);
      await leaderElector.awaitLeadership();
    }

    /**
     * Instead of writing a custom migration protocol,
     * we do a push-only replication from the old collection data to the new one.
     * This also ensure that restarting the replication works without problems.
     */
    var oldCollectionMeta = await this.oldCollectionMeta;
    var oldStorageInstance = await this.database.storage.createStorageInstance({
      databaseName: this.database.name,
      collectionName: this.collection.name,
      databaseInstanceToken: this.database.token,
      multiInstance: this.database.multiInstance,
      options: {},
      schema: oldCollectionMeta.data.schema,
      password: this.database.password,
      devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_12__.overwritable.isDevMode()
    });
    var connectedInstances = await this.getConnectedStorageInstances();

    /**
     * Initially write the migration status into a meta document.
     */
    var totalCount = await this.countAllDoucments([oldStorageInstance].concat(connectedInstances.map(r => r.oldStorage)));
    await this.updateStatus(s => {
      s.count.total = totalCount;
      return s;
    });
    try {
      /**
       * First migrate the connected storages,
       * afterwards migrate the normal collection.
       */
      await Promise.all(connectedInstances.map(async connectedInstance => {
        await (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__.addConnectedStorageToCollection)(this.collection, connectedInstance.newStorage.collectionName, connectedInstance.newStorage.schema);
        await this.migrateStorage(connectedInstance.oldStorage, connectedInstance.newStorage, batchSize);
        await connectedInstance.newStorage.close();
      }));
      await this.migrateStorage(oldStorageInstance,
      /**
       * Use the originalStorageInstance here
       * so that the _meta.lwt time keeps the same
       * and our replication checkpoints still point to the
       * correct checkpoint.
       */
      this.collection.storageInstance.originalStorageInstance, batchSize);
    } catch (err) {
      await oldStorageInstance.close();
      await this.updateStatus(s => {
        s.status = 'ERROR';
        s.error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.errorToPlainJson)(err);
        return s;
      });
      return;
    }

    // remove old collection meta doc
    await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.writeSingle)(this.database.internalStore, {
      previous: oldCollectionMeta,
      document: Object.assign({}, oldCollectionMeta, {
        _deleted: true
      })
    }, 'rx-migration-remove-collection-meta');
    await this.updateStatus(s => {
      s.status = 'DONE';
      return s;
    });
    if (broadcastChannel) {
      await broadcastChannel.close();
    }
  };
  _proto.updateStatus = function updateStatus(handler) {
    this.updateStatusHandlers.push(handler);
    this.updateStatusQueue = this.updateStatusQueue.then(async () => {
      if (this.updateStatusHandlers.length === 0) {
        return;
      }
      // re-run until no conflict
      var useHandlers = this.updateStatusHandlers;
      this.updateStatusHandlers = [];
      while (true) {
        var previous = await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.getSingleDocument)(this.database.internalStore, this.statusDocId);
        var newDoc = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_14__.clone)(previous);
        if (!previous) {
          newDoc = {
            id: this.statusDocId,
            key: this.statusDocKey,
            context: _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_CONTEXT_MIGRATION_STATUS,
            data: {
              collectionName: this.collection.name,
              status: 'RUNNING',
              count: {
                total: 0,
                handled: 0,
                percent: 0
              }
            },
            _deleted: false,
            _meta: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.getDefaultRxDocumentMeta)(),
            _rev: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.getDefaultRevision)(),
            _attachments: {}
          };
        }
        var status = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(newDoc).data;
        for (var oneHandler of useHandlers) {
          status = oneHandler(status);
        }
        status.count.percent = Math.round(status.count.handled / status.count.total * 100);
        if (newDoc && previous && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_16__.deepEqual)(newDoc.data, previous.data)) {
          break;
        }
        try {
          await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.writeSingle)(this.database.internalStore, {
            previous,
            document: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(newDoc)
          }, _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_CONTEXT_MIGRATION_STATUS);

          // write successful
          break;
        } catch (err) {
          // ignore conflicts
          if (!(0,_rx_error_js__WEBPACK_IMPORTED_MODULE_9__.isBulkWriteConflictError)(err)) {
            throw err;
          }
        }
      }
    });
    return this.updateStatusQueue;
  };
  _proto.migrateStorage = async function migrateStorage(oldStorage, newStorage, batchSize) {
    var replicationMetaStorageInstance = await this.database.storage.createStorageInstance({
      databaseName: this.database.name,
      collectionName: 'rx-migration-state-meta-' + oldStorage.collectionName + '-' + oldStorage.schema.version,
      databaseInstanceToken: this.database.token,
      multiInstance: this.database.multiInstance,
      options: {},
      schema: (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__.getRxReplicationMetaInstanceSchema)(oldStorage.schema, (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.hasEncryption)(oldStorage.schema)),
      password: this.database.password,
      devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_12__.overwritable.isDevMode()
    });
    var replicationHandlerBase = (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__.rxStorageInstanceToReplicationHandler)(newStorage,
    /**
     * Ignore push-conflicts.
     * If this happens we drop the 'old' document state.
     */
    _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_19__.defaultConflictHandler, this.database.token, true);
    var replicationState = (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__.replicateRxStorageInstance)({
      keepMeta: true,
      identifier: ['rx-migration-state', oldStorage.collectionName, oldStorage.schema.version, this.collection.schema.version].join('-'),
      replicationHandler: {
        masterChangesSince() {
          return Promise.resolve({
            checkpoint: null,
            documents: []
          });
        },
        masterWrite: async rows => {
          rows = await Promise.all(rows.map(async row => {
            var newDocData = row.newDocumentState;
            if (newStorage.schema.title === _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__.META_INSTANCE_SCHEMA_TITLE) {
              newDocData = row.newDocumentState.docData;
              if (row.newDocumentState.isCheckpoint === '1') {
                return {
                  assumedMasterState: undefined,
                  newDocumentState: row.newDocumentState
                };
              }
            }
            var migratedDocData = await (0,_migration_helpers_js__WEBPACK_IMPORTED_MODULE_1__.migrateDocumentData)(this.collection, oldStorage.schema.version, newDocData);
            var newRow = {
              // drop the assumed master state, we do not have to care about conflicts here.
              assumedMasterState: undefined,
              newDocumentState: newStorage.schema.title === _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__.META_INSTANCE_SCHEMA_TITLE ? Object.assign({}, row.newDocumentState, {
                docData: migratedDocData
              }) : migratedDocData
            };
            return newRow;
          }));

          // filter out the documents where the migration strategy returned null
          rows = rows.filter(row => !!row.newDocumentState);
          var result = await replicationHandlerBase.masterWrite(rows);
          return result;
        },
        masterChangeStream$: new rxjs__WEBPACK_IMPORTED_MODULE_20__.Subject().asObservable()
      },
      forkInstance: oldStorage,
      metaInstance: replicationMetaStorageInstance,
      pushBatchSize: batchSize,
      pullBatchSize: 0,
      conflictHandler: _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_19__.defaultConflictHandler,
      hashFunction: this.database.hashFunction
    });
    var hasError = false;
    replicationState.events.error.subscribe(err => hasError = err);

    // update replication status on each change
    replicationState.events.processed.up.subscribe(() => {
      this.updateStatus(status => {
        status.count.handled = status.count.handled + 1;
        return status;
      });
    });
    await (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__.awaitRxStorageReplicationFirstInSync)(replicationState);
    await (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__.awaitRxStorageReplicationInSync)(replicationState);
    await (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_18__.cancelRxStorageReplication)(replicationState);
    await this.updateStatusQueue;
    if (hasError) {
      await replicationMetaStorageInstance.close();
      throw hasError;
    }

    // cleanup old storages
    await Promise.all([oldStorage.remove(), replicationMetaStorageInstance.remove()]);
  };
  _proto.countAllDoucments = async function countAllDoucments(storageInstances) {
    var ret = 0;
    await Promise.all(storageInstances.map(async instance => {
      var preparedQuery = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_21__.prepareQuery)(instance.schema, (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_21__.normalizeMangoQuery)(instance.schema, {
        selector: {}
      }));
      var countResult = await instance.count(preparedQuery);
      ret += countResult.count;
    }));
    return ret;
  };
  _proto.getConnectedStorageInstances = async function getConnectedStorageInstances() {
    var oldCollectionMeta = await this.oldCollectionMeta;
    var ret = [];
    await Promise.all(await Promise.all(oldCollectionMeta.data.connectedStorages.map(async connectedStorage => {
      // atm we can only migrate replication states.
      if (connectedStorage.schema.title !== _replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__.META_INSTANCE_SCHEMA_TITLE) {
        throw new Error('unknown migration handling for schema');
      }
      var newSchema = (0,_replication_protocol_index_js__WEBPACK_IMPORTED_MODULE_17__.getRxReplicationMetaInstanceSchema)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_14__.clone)(this.collection.schema.jsonSchema), (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_3__.hasEncryption)(connectedStorage.schema));
      newSchema.version = this.collection.schema.version;
      var [oldStorage, newStorage] = await Promise.all([this.database.storage.createStorageInstance({
        databaseInstanceToken: this.database.token,
        databaseName: this.database.name,
        devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_12__.overwritable.isDevMode(),
        multiInstance: this.database.multiInstance,
        options: {},
        schema: connectedStorage.schema,
        password: this.database.password,
        collectionName: connectedStorage.collectionName
      }), this.database.storage.createStorageInstance({
        databaseInstanceToken: this.database.token,
        databaseName: this.database.name,
        devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_12__.overwritable.isDevMode(),
        multiInstance: this.database.multiInstance,
        options: {},
        schema: newSchema,
        password: this.database.password,
        collectionName: connectedStorage.collectionName
      })]);
      ret.push({
        oldStorage,
        newStorage
      });
    })));
    return ret;
  };
  _proto.migratePromise = async function migratePromise(batchSize) {
    this.startMigration(batchSize);
    var must = await this.mustMigrate;
    if (!must) {
      return {
        status: 'DONE',
        collectionName: this.collection.name,
        count: {
          handled: 0,
          percent: 0,
          total: 0
        }
      };
    }
    var result = await Promise.race([(0,rxjs__WEBPACK_IMPORTED_MODULE_8__.firstValueFrom)(this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.filter)(d => d.status === 'DONE'))), (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.firstValueFrom)(this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.filter)(d => d.status === 'ERROR')))]);
    if (result.status === 'ERROR') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_9__.newRxError)('DM4', {
        collection: this.collection.name,
        error: result.error
      });
    } else {
      return result;
    }
  };
  return RxMigrationState;
}();
//# sourceMappingURL=rx-migration-state.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/query-builder/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/query-builder/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoSqlQueryBuilderClass: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.NoSqlQueryBuilderClass),
/* harmony export */   OTHER_MANGO_ATTRIBUTES: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.OTHER_MANGO_ATTRIBUTES),
/* harmony export */   OTHER_MANGO_OPERATORS: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.OTHER_MANGO_OPERATORS),
/* harmony export */   RxDBQueryBuilderPlugin: () => (/* binding */ RxDBQueryBuilderPlugin),
/* harmony export */   applyBuildingStep: () => (/* binding */ applyBuildingStep),
/* harmony export */   canMerge: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.canMerge),
/* harmony export */   createQueryBuilder: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.createQueryBuilder),
/* harmony export */   mQuerySortToRxDBSort: () => (/* reexport safe */ _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.mQuerySortToRxDBSort),
/* harmony export */   runBuildingStep: () => (/* binding */ runBuildingStep)
/* harmony export */ });
/* harmony import */ var _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mquery/nosql-query-builder.js */ "./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/nosql-query-builder.js");
/* harmony import */ var _rx_query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-query.js */ "./node_modules/rxdb/dist/esm/rx-query.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");






// if the query-builder plugin is used, we have to save its last path
var RXQUERY_OTHER_FLAG = 'queryBuilderPath';
function runBuildingStep(rxQuery, functionName, value) {
  var queryBuilder = (0,_mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.createQueryBuilder)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.clone)(rxQuery.mangoQuery), rxQuery.other[RXQUERY_OTHER_FLAG]);
  queryBuilder[functionName](value); // run

  var queryBuilderJson = queryBuilder.toJSON();
  return (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_2__.createRxQuery)(rxQuery.op, queryBuilderJson.query, rxQuery.collection, {
    ...rxQuery.other,
    [RXQUERY_OTHER_FLAG]: queryBuilderJson.path
  });
}
function applyBuildingStep(proto, functionName) {
  proto[functionName] = function (value) {
    if (_overwritable_js__WEBPACK_IMPORTED_MODULE_3__.overwritable.isDevMode() && this.op === 'findByIds') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU17', {
        collection: this.collection.name,
        query: this.mangoQuery
      });
    }
    return runBuildingStep(this, functionName, value);
  };
}

var RxDBQueryBuilderPlugin = {
  name: 'query-builder',
  rxdb: true,
  prototypes: {
    RxQuery(proto) {
      ['where', 'equals', 'eq', 'or', 'nor', 'and', 'mod', 'exists', 'elemMatch', 'sort'].forEach(attribute => {
        applyBuildingStep(proto, attribute);
      });
      _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.OTHER_MANGO_ATTRIBUTES.forEach(attribute => {
        applyBuildingStep(proto, attribute);
      });
      _mquery_nosql_query_builder_js__WEBPACK_IMPORTED_MODULE_0__.OTHER_MANGO_OPERATORS.forEach(operator => {
        applyBuildingStep(proto, operator);
      });
    }
  }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/mquery-utils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/mquery-utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   merge: () => (/* binding */ merge)
/* harmony export */ });
/**
 * this is copied from
 * @link https://github.com/aheckmann/mquery/blob/master/lib/utils.js
 */

/**
 * @link https://github.com/aheckmann/mquery/commit/792e69fd0a7281a0300be5cade5a6d7c1d468ad4
 */
var SPECIAL_PROPERTIES = ['__proto__', 'constructor', 'prototype'];

/**
 * Merges 'from' into 'to' without overwriting existing properties.
 */
function merge(to, from) {
  Object.keys(from).forEach(key => {
    if (SPECIAL_PROPERTIES.includes(key)) {
      return;
    }
    if (typeof to[key] === 'undefined') {
      to[key] = from[key];
    } else {
      if (isObject(from[key])) merge(to[key], from[key]);else to[key] = from[key];
    }
  });
}

/**
 * Determines if `arg` is an object.
 */
function isObject(arg) {
  return '[object Object]' === arg.toString();
}
//# sourceMappingURL=mquery-utils.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/nosql-query-builder.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/nosql-query-builder.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoSqlQueryBuilderClass: () => (/* binding */ NoSqlQueryBuilderClass),
/* harmony export */   OTHER_MANGO_ATTRIBUTES: () => (/* binding */ OTHER_MANGO_ATTRIBUTES),
/* harmony export */   OTHER_MANGO_OPERATORS: () => (/* binding */ OTHER_MANGO_OPERATORS),
/* harmony export */   canMerge: () => (/* binding */ canMerge),
/* harmony export */   createQueryBuilder: () => (/* binding */ createQueryBuilder),
/* harmony export */   mQuerySortToRxDBSort: () => (/* binding */ mQuerySortToRxDBSort)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_readOnlyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/readOnlyError */ "./node_modules/@babel/runtime/helpers/esm/readOnlyError.js");
/* harmony import */ var _mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mquery-utils.js */ "./node_modules/rxdb/dist/esm/plugins/query-builder/mquery/mquery-utils.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");

/**
 * this is based on
 * @link https://github.com/aheckmann/mquery/blob/master/lib/mquery.js
 */


var NoSqlQueryBuilderClass = /*#__PURE__*/function () {
  /**
   * MQuery constructor used for building queries.
   *
   * ####Example:
   *     var query = new MQuery({ name: 'mquery' });
   *     query.where('age').gte(21).exec(callback);
   *
   */
  function NoSqlQueryBuilderClass(mangoQuery, _path) {
    this.options = {};
    this._conditions = {};
    this._fields = {};
    this._path = _path;
    if (mangoQuery) {
      var queryBuilder = this;
      if (mangoQuery.selector) {
        queryBuilder.find(mangoQuery.selector);
      }
      if (mangoQuery.limit) {
        queryBuilder.limit(mangoQuery.limit);
      }
      if (mangoQuery.skip) {
        queryBuilder.skip(mangoQuery.skip);
      }
      if (mangoQuery.sort) {
        mangoQuery.sort.forEach(s => queryBuilder.sort(s));
      }
    }
  }

  /**
   * Specifies a `path` for use with chaining.
   */
  var _proto = NoSqlQueryBuilderClass.prototype;
  _proto.where = function where(_path, _val) {
    if (!arguments.length) return this;
    var type = typeof arguments[0];
    if ('string' === type) {
      this._path = arguments[0];
      if (2 === arguments.length) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if ('object' === type && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ1', {
      path: arguments[0]
    });
  }

  /**
   * Specifies the complementary comparison value for paths specified with `where()`
   * ####Example
   *     User.where('age').equals(49);
   */;
  _proto.equals = function equals(val) {
    this._ensurePath('equals');
    var path = this._path;
    this._conditions[path] = val;
    return this;
  }

  /**
   * Specifies the complementary comparison value for paths specified with `where()`
   * This is alias of `equals`
   */;
  _proto.eq = function eq(val) {
    this._ensurePath('eq');
    var path = this._path;
    this._conditions[path] = val;
    return this;
  }

  /**
   * Specifies arguments for an `$or` condition.
   * ####Example
   *     query.or([{ color: 'red' }, { status: 'emergency' }])
   */;
  _proto.or = function or(array) {
    var or = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array)) array = [array];
    or.push.apply(or, array);
    return this;
  }

  /**
   * Specifies arguments for a `$nor` condition.
   * ####Example
   *     query.nor([{ color: 'green' }, { status: 'ok' }])
   */;
  _proto.nor = function nor(array) {
    var nor = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array)) array = [array];
    nor.push.apply(nor, array);
    return this;
  }

  /**
   * Specifies arguments for a `$and` condition.
   * ####Example
   *     query.and([{ color: 'green' }, { status: 'ok' }])
   * @see $and http://docs.mongodb.org/manual/reference/operator/and/
   */;
  _proto.and = function and(array) {
    var and = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array)) array = [array];
    and.push.apply(and, array);
    return this;
  }

  /**
   * Specifies a `$mod` condition
   */;
  _proto.mod = function mod(_path, _val) {
    var val;
    var path;
    if (1 === arguments.length) {
      this._ensurePath('mod');
      val = arguments[0];
      path = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
      this._ensurePath('mod');
      val = arguments.slice();
      path = this._path;
    } else if (3 === arguments.length) {
      val = arguments.slice(1);
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  }

  /**
   * Specifies an `$exists` condition
   * ####Example
   *     // { name: { $exists: true }}
   *     Thing.where('name').exists()
   *     Thing.where('name').exists(true)
   *     Thing.find().exists('name')
   */;
  _proto.exists = function exists(_path, _val) {
    var path;
    var val;
    if (0 === arguments.length) {
      this._ensurePath('exists');
      path = this._path;
      val = true;
    } else if (1 === arguments.length) {
      if ('boolean' === typeof arguments[0]) {
        this._ensurePath('exists');
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (2 === arguments.length) {
      path = arguments[0];
      val = arguments[1];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  }

  /**
   * Specifies an `$elemMatch` condition
   * ####Example
   *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
   *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
   *     query.elemMatch('comment', function (elem) {
   *       elem.where('author').equals('autobot');
   *       elem.where('votes').gte(5);
   *     })
   *     query.where('comment').elemMatch(function (elem) {
   *       elem.where({ author: 'autobot' });
   *       elem.where('votes').gte(5);
   *     })
   */;
  _proto.elemMatch = function elemMatch(_path, _criteria) {
    if (null === arguments[0]) throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ2');
    var fn;
    var path;
    var criteria;
    if ('function' === typeof arguments[0]) {
      this._ensurePath('elemMatch');
      path = this._path;
      fn = arguments[0];
    } else if ((0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(arguments[0])) {
      this._ensurePath('elemMatch');
      path = this._path;
      criteria = arguments[0];
    } else if ('function' === typeof arguments[1]) {
      path = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ2');
    if (fn) {
      criteria = new NoSqlQueryBuilderClass();
      fn(criteria);
      criteria = criteria._conditions;
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  }

  /**
   * Sets the sort order
   * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
   * If a string is passed, it must be a space delimited list of path names.
   * The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
   * ####Example
   *     query.sort({ field: 'asc', test: -1 });
   *     query.sort('field -test');
   *     query.sort([['field', 1], ['test', -1]]);
   */;
  _proto.sort = function sort(arg) {
    if (!arg) return this;
    var len;
    var type = typeof arg;
    // .sort([['field', 1], ['test', -1]])
    if (Array.isArray(arg)) {
      len = arg.length;
      for (var i = 0; i < arg.length; ++i) {
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }

    // .sort('field -test')
    if (1 === arguments.length && 'string' === type) {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (var _i = 0; _i < len; ++_i) {
        var field = arg[_i];
        if (!field) continue;
        var ascend = '-' === field[0] ? -1 : 1;
        if (ascend === -1) field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }

    // .sort({ field: 1, test: -1 })
    if ((0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(arg)) {
      var keys = Object.keys(arg);
      keys.forEach(field => push(this.options, field, arg[field]));
      return this;
    }
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ3', {
      args: arguments
    });
  }

  /**
   * Merges another MQuery or conditions object into this one.
   *
   * When a MQuery is passed, conditions, field selection and options are merged.
   *
   */;
  _proto.merge = function merge(source) {
    if (!source) {
      return this;
    }
    if (!canMerge(source)) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ4', {
        source
      });
    }
    if (source instanceof NoSqlQueryBuilderClass) {
      // if source has a feature, apply it to ourselves

      if (source._conditions) (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.merge)(this._conditions, source._conditions);
      if (source._fields) {
        if (!this._fields) this._fields = {};
        (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.merge)(this._fields, source._fields);
      }
      if (source.options) {
        if (!this.options) this.options = {};
        (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.merge)(this.options, source.options);
      }
      if (source._distinct) this._distinct = source._distinct;
      return this;
    }

    // plain object
    (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.merge)(this._conditions, source);
    return this;
  }

  /**
   * Finds documents.
   * ####Example
   *     query.find()
   *     query.find({ name: 'Burning Lights' })
   */;
  _proto.find = function find(criteria) {
    if (canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  }

  /**
   * Make sure _path is set.
   *
   * @param {String} method
   */;
  _proto._ensurePath = function _ensurePath(method) {
    if (!this._path) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxError)('MQ5', {
        method
      });
    }
  };
  _proto.toJSON = function toJSON() {
    var query = {
      selector: this._conditions
    };
    if (this.options.skip) {
      query.skip = this.options.skip;
    }
    if (this.options.limit) {
      query.limit = this.options.limit;
    }
    if (this.options.sort) {
      query.sort = mQuerySortToRxDBSort(this.options.sort);
    }
    return {
      query,
      path: this._path
    };
  };
  return NoSqlQueryBuilderClass;
}();
function mQuerySortToRxDBSort(sort) {
  return Object.entries(sort).map(([k, v]) => {
    var direction = v === 1 ? 'asc' : 'desc';
    var part = {
      [k]: direction
    };
    return part;
  });
}

/**
 * Because some prototype-methods are generated,
 * we have to define the type of NoSqlQueryBuilder here
 */

/**
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */
var OTHER_MANGO_ATTRIBUTES = ['limit', 'skip', 'maxScan', 'batchSize', 'comment'];
OTHER_MANGO_ATTRIBUTES.forEach(function (method) {
  NoSqlQueryBuilderClass.prototype[method] = function (v) {
    this.options[method] = v;
    return this;
  };
});

/**
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */
var OTHER_MANGO_OPERATORS = ['gt', 'gte', 'lt', 'lte', 'ne', 'in', 'nin', 'all', 'regex', 'size'];
OTHER_MANGO_OPERATORS.forEach(function ($conditional) {
  NoSqlQueryBuilderClass.prototype[$conditional] = function () {
    var path;
    var val;
    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path = this._path;
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ? this._conditions[path] : this._conditions[path] = {};
    if ($conditional === 'regex') {
      if (val instanceof RegExp) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxError)('QU16', {
          field: path,
          query: this._conditions
        });
      }
      if (typeof val === 'string') {
        conds['$' + $conditional] = val;
      } else {
        conds['$' + $conditional] = val.$regex;
        if (val.$options) {
          conds.$options = val.$options;
        }
      }
    } else {
      conds['$' + $conditional] = val;
    }
    return this;
  };
});
function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ6', {
      opts,
      field,
      value
    });
  }
  if (value && value.$meta) {
    var sort = opts.sort || (opts.sort = {});
    sort[field] = {
      $meta: value.$meta
    };
    return;
  }
  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
    if (Array.isArray(value)) value = '[' + value + ']';
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ7', {
      field,
      value
    });
  }
  // store `sort` in a sane format
  var s = opts.sort || (opts.sort = {});
  var valueStr = value.toString().replace('asc', '1').replace('ascending', '1').replace('desc', '-1').replace('descending', '-1');
  s[field] = parseInt(valueStr, 10);
}
function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxTypeError)('MQ8', {
      opts,
      field,
      value
    });
  }

  /*    const valueStr = value.toString()
          .replace('asc', '1')
          .replace('ascending', '1')
          .replace('desc', '-1')
          .replace('descending', '-1');*/
  opts.sort.push([field, value]);
}

/**
 * Determines if `conds` can be merged using `mquery().merge()`
 */
function canMerge(conds) {
  return conds instanceof NoSqlQueryBuilderClass || (0,_mquery_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(conds);
}
function createQueryBuilder(query, path) {
  return new NoSqlQueryBuilderClass(query, path);
}
//# sourceMappingURL=nosql-query-builder.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEXIE_ATTACHMENTS_TABLE_NAME: () => (/* binding */ DEXIE_ATTACHMENTS_TABLE_NAME),
/* harmony export */   DEXIE_CHANGES_TABLE_NAME: () => (/* binding */ DEXIE_CHANGES_TABLE_NAME),
/* harmony export */   DEXIE_DOCS_TABLE_NAME: () => (/* binding */ DEXIE_DOCS_TABLE_NAME),
/* harmony export */   DEXIE_PIPE_SUBSTITUTE: () => (/* binding */ DEXIE_PIPE_SUBSTITUTE),
/* harmony export */   RX_STORAGE_NAME_DEXIE: () => (/* binding */ RX_STORAGE_NAME_DEXIE),
/* harmony export */   attachmentObjectId: () => (/* binding */ attachmentObjectId),
/* harmony export */   closeDexieDb: () => (/* binding */ closeDexieDb),
/* harmony export */   dexieReplaceIfStartsWithPipe: () => (/* binding */ dexieReplaceIfStartsWithPipe),
/* harmony export */   dexieReplaceIfStartsWithPipeRevert: () => (/* binding */ dexieReplaceIfStartsWithPipeRevert),
/* harmony export */   fromDexieToStorage: () => (/* binding */ fromDexieToStorage),
/* harmony export */   fromDexieToStorageField: () => (/* binding */ fromDexieToStorageField),
/* harmony export */   fromStorageToDexie: () => (/* binding */ fromStorageToDexie),
/* harmony export */   fromStorageToDexieField: () => (/* binding */ fromStorageToDexieField),
/* harmony export */   getBooleanIndexes: () => (/* binding */ getBooleanIndexes),
/* harmony export */   getDexieDbWithTables: () => (/* binding */ getDexieDbWithTables),
/* harmony export */   getDexieStoreSchema: () => (/* binding */ getDexieStoreSchema),
/* harmony export */   getDocsInDb: () => (/* binding */ getDocsInDb)
/* harmony export */ });
/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ "./node_modules/dexie/import-wrapper.mjs");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");



var DEXIE_DOCS_TABLE_NAME = 'docs';
var DEXIE_CHANGES_TABLE_NAME = 'changes';
var DEXIE_ATTACHMENTS_TABLE_NAME = 'attachments';
var RX_STORAGE_NAME_DEXIE = 'dexie';
var DEXIE_STATE_DB_BY_NAME = new Map();
var REF_COUNT_PER_DEXIE_DB = new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var dexieDbName = 'rxdb-dexie-' + databaseName + '--' + schema.version + '--' + collectionName;
  var state = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getFromMapOrCreate)(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      /**
       * IndexedDB was not designed for dynamically adding tables on the fly,
       * so we create one dexie database per RxDB storage instance.
       * @link https://github.com/dexie/Dexie.js/issues/684#issuecomment-373224696
       */
      var useSettings = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.flatClone)(settings);
      useSettings.autoOpen = false;
      var dexieDb = new dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie(dexieDbName, useSettings);
      if (settings.onCreate) {
        await settings.onCreate(dexieDb, dexieDbName);
      }
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: '++sequence, id',
        [DEXIE_ATTACHMENTS_TABLE_NAME]: 'id'
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieAttachmentsTable: dexieDb[DEXIE_ATTACHMENTS_TABLE_NAME],
        booleanIndexes: getBooleanIndexes(schema)
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);
    REF_COUNT_PER_DEXIE_DB.set(state, 0);
    return value;
  });
  return state;
}
async function closeDexieDb(statePromise) {
  var state = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}

/**
 * It is not possible to set non-javascript-variable-syntax
 * keys as IndexedDB indexes. So we have to substitute the pipe-char
 * which comes from the key-compression plugin.
 */
var DEXIE_PIPE_SUBSTITUTE = '__';
function dexieReplaceIfStartsWithPipe(str) {
  var split = str.split('.');
  if (split.length > 1) {
    return split.map(part => dexieReplaceIfStartsWithPipe(part)).join('.');
  }
  if (str.startsWith('|')) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split = str.split('.');
  if (split.length > 1) {
    return split.map(part => dexieReplaceIfStartsWithPipeRevert(part)).join('.');
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return '|' + withoutFirst;
  } else {
    return str;
  }
}

/**
 * IndexedDB does not support boolean indexing.
 * So we have to replace true/false with '1'/'0'
 * @param d 
 */
function fromStorageToDexie(booleanIndexes, inputDoc) {
  if (!inputDoc) {
    return inputDoc;
  }
  var d = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.flatClone)(inputDoc);
  d = fromStorageToDexieField(d);
  booleanIndexes.forEach(idx => {
    var val = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getProperty)(inputDoc, idx);
    var newVal = val ? '1' : '0';
    var useIndex = dexieReplaceIfStartsWithPipe(idx);
    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.setProperty)(d, useIndex, newVal);
  });
  return d;
}
function fromDexieToStorage(booleanIndexes, d) {
  if (!d) {
    return d;
  }
  d = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.flatClone)(d);
  d = fromDexieToStorageField(d);
  booleanIndexes.forEach(idx => {
    var val = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getProperty)(d, idx);
    var newVal = val === '1' ? true : false;
    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.setProperty)(d, idx, newVal);
  });
  return d;
}

/**
 * @recursive
 */
function fromStorageToDexieField(documentData) {
  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map(row => fromStorageToDexieField(row));
  } else if (typeof documentData === 'object') {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === 'object') {
        value = fromStorageToDexieField(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorageField(documentData) {
  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map(row => fromDexieToStorageField(row));
  } else if (typeof documentData === 'object') {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === 'object' || Array.isArray(documentData)) {
        value = fromDexieToStorageField(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}

/**
 * Creates a string that can be used to create the dexie store.
 * @link https://dexie.org/docs/API-Reference#quick-reference
 */
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];

  /**
   * First part must be the primary key
   * @link https://github.com/dexie/Dexie.js/issues/1307#issuecomment-846590912
   */
  var primaryKey = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_4__.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  parts.push(['_deleted', primaryKey]);

  // add other indexes
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach(index => {
      var arIndex = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toArray)(index);
      parts.push(arIndex);
    });
  }

  // we also need the _meta.lwt+primaryKey index for the getChangedDocumentsSince() method.
  parts.push(['_meta.lwt', primaryKey]);

  // and this one for the cleanup()
  parts.push(['_meta.lwt']);

  /**
   * It is not possible to set non-javascript-variable-syntax
   * keys as IndexedDB indexes. So we have to substitute the pipe-char
   * which comes from the key-compression plugin.
   */
  parts = parts.map(part => {
    return part.map(str => dexieReplaceIfStartsWithPipe(str));
  });
  var dexieSchemaRows = parts.map(part => {
    if (part.length === 1) {
      return part[0];
    } else {
      return '[' + part.join('+') + ']';
    }
  });
  dexieSchemaRows = dexieSchemaRows.filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique;

  var dexieSchema = dexieSchemaRows.join(', ');
  return dexieSchema;
}

/**
 * Returns all documents in the database.
 * Non-deleted plus deleted ones.
 */
async function getDocsInDb(internals, docIds) {
  var state = await internals;
  var docsInDb = await state.dexieTable.bulkGet(docIds);
  return docsInDb.map(d => fromDexieToStorage(state.booleanIndexes, d));
}
function attachmentObjectId(documentId, attachmentId) {
  return documentId + '||' + attachmentId;
}
function getBooleanIndexes(schema) {
  var checkedFields = new Set();
  var ret = [];
  if (!schema.indexes) {
    return ret;
  }
  schema.indexes.forEach(index => {
    var fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toArray)(index);
    fields.forEach(field => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_4__.getSchemaByObjectPath)(schema, field);
      if (schemaObj.type === 'boolean') {
        ret.push(field);
      }
    });
  });
  ret.push('_deleted');
  return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.uniqueArray)(ret);
}
//# sourceMappingURL=dexie-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-query.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-query.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dexieCount: () => (/* binding */ dexieCount),
/* harmony export */   dexieQuery: () => (/* binding */ dexieQuery),
/* harmony export */   getKeyRangeByQueryPlan: () => (/* binding */ getKeyRangeByQueryPlan),
/* harmony export */   mapKeyForKeyRange: () => (/* binding */ mapKeyForKeyRange)
/* harmony export */ });
/* harmony import */ var _query_planner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../query-planner.js */ "./node_modules/rxdb/dist/esm/query-planner.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");
/* harmony import */ var _dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dexie-helper.js */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js");



function mapKeyForKeyRange(k) {
  if (k === _query_planner_js__WEBPACK_IMPORTED_MODULE_0__.INDEX_MIN) {
    return -Infinity;
  } else {
    return k;
  }
}
function rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, value) {
  if (booleanIndexes.includes(fieldName)) {
    var newValue = value === _query_planner_js__WEBPACK_IMPORTED_MODULE_0__.INDEX_MAX || value === true ? '1' : '0';
    return newValue;
  } else {
    return value;
  }
}
function getKeyRangeByQueryPlan(booleanIndexes, queryPlan, IDBKeyRange) {
  if (!IDBKeyRange) {
    if (typeof window === 'undefined') {
      throw new Error('IDBKeyRange missing');
    } else {
      IDBKeyRange = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map((v, i) => {
    var fieldName = queryPlan.index[i];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);
  }).map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map((v, i) => {
    var fieldName = queryPlan.index[i];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);
  }).map(mapKeyForKeyRange);
  var keyRange = IDBKeyRange.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  return keyRange;
}

/**
 * Runs mango queries over the Dexie.js database.
 */
async function dexieQuery(instance, preparedQuery) {
  var state = await instance.internals;
  var query = preparedQuery.query;
  var skip = query.skip ? query.skip : 0;
  var limit = query.limit ? query.limit : Infinity;
  var skipPlusLimit = skip + limit;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.getQueryMatcher)(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows = [];
  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {
    /**
     * Here we use the native IndexedDB transaction
     * to get the cursor.
     * Maybe we should not leave Dexie.js API and find
     * a way to create the cursor with Dexie.js.
     */
    var tx = dexieTx.idbtrans;

    // const nativeIndexedDB = state.dexieDb.backendDB();
    // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');

    var store = tx.objectStore(_dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__.DEXIE_DOCS_TABLE_NAME);
    var index;
    var indexName;
    indexName = '[' + queryPlanFields.map(field => (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__.dexieReplaceIfStartsWithPipe)(field)).join('+') + ']';
    index = store.index(indexName);
    var cursorReq = index.openCursor(keyRange);
    await new Promise(res => {
      cursorReq.onsuccess = function (e) {
        var cursor = e.target.result;
        if (cursor) {
          // We have a record in cursor.value
          var docData = (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__.fromDexieToStorage)(state.booleanIndexes, cursor.value);
          if (!queryMatcher || queryMatcher(docData)) {
            rows.push(docData);
          }

          /**
           * If we do not have to manually sort
           * and have enough documents,
           * we can abort iterating over the cursor
           * because we already have every relevant document.
           */
          if (queryPlan.sortSatisfiedByIndex && rows.length === skipPlusLimit) {
            res();
          } else {
            cursor.continue();
          }
        } else {
          // Iteration complete
          res();
        }
      };
    });
  });
  if (!queryPlan.sortSatisfiedByIndex) {
    var sortComparator = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.getSortComparator)(instance.schema, preparedQuery.query);
    rows = rows.sort(sortComparator);
  }

  // apply skip and limit boundaries.
  rows = rows.slice(skip, skipPlusLimit);

  /**
   * Comment this in for debugging to check all fields in the database.
   */
  // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();
  // let documents = docsInDb
  //     .map(docData => stripDexieKey(docData))
  //     .sort(sortComparator);
  // if (preparedQuery.skip) {
  //     documents = documents.slice(preparedQuery.skip);
  // }
  // if (preparedQuery.limit && documents.length > preparedQuery.limit) {
  //     documents = documents.slice(0, preparedQuery.limit);
  // }

  return {
    documents: rows
  };
}
async function dexieCount(instance, preparedQuery) {
  var state = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);
  var count = -1;
  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(_dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__.DEXIE_DOCS_TABLE_NAME);
    var index;
    var indexName;
    indexName = '[' + queryPlanFields.map(field => (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_2__.dexieReplaceIfStartsWithPipe)(field)).join('+') + ']';
    index = store.index(indexName);
    var request = index.count(keyRange);
    count = await new Promise((res, rej) => {
      request.onsuccess = function () {
        res(request.result);
      };
      request.onerror = err => rej(err);
    });
  });
  return count;
}
//# sourceMappingURL=dexie-query.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-dexie.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-dexie.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxStorageDexie: () => (/* binding */ RxStorageDexie),
/* harmony export */   getRxStorageDexie: () => (/* binding */ getRxStorageDexie)
/* harmony export */ });
/* harmony import */ var _dexie_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dexie-helper.js */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js");
/* harmony import */ var _rx_storage_instance_dexie_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-storage-instance-dexie.js */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-instance-dexie.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _utils_utils_rxdb_version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils-rxdb-version.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");





var RxStorageDexie = /*#__PURE__*/function () {
  function RxStorageDexie(settings) {
    this.name = _dexie_helper_js__WEBPACK_IMPORTED_MODULE_0__.RX_STORAGE_NAME_DEXIE;
    this.rxdbVersion = _utils_utils_rxdb_version_js__WEBPACK_IMPORTED_MODULE_1__.RXDB_VERSION;
    this.settings = settings;
  }
  var _proto = RxStorageDexie.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__.ensureRxStorageInstanceParamsAreCorrect)(params);

    /**
     * Dexie does not support non-required indexes and must throw if that is used.
     * @link https://github.com/pubkey/rxdb/pull/6643#issuecomment-2505310082
     */
    if (params.schema.indexes) {
      var indexFields = params.schema.indexes.flat();
      indexFields.filter(indexField => !indexField.includes('.')).forEach(indexField => {
        if (!params.schema.required || !params.schema.required.includes(indexField)) {
          throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DXE1', {
            field: indexField,
            schema: params.schema
          });
        }
      });
    }
    return (0,_rx_storage_instance_dexie_js__WEBPACK_IMPORTED_MODULE_4__.createDexieStorageInstance)(this, params, this.settings);
  };
  return RxStorageDexie;
}();
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}
//# sourceMappingURL=rx-storage-dexie.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-instance-dexie.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-instance-dexie.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxStorageInstanceDexie: () => (/* binding */ RxStorageInstanceDexie),
/* harmony export */   createDexieStorageInstance: () => (/* binding */ createDexieStorageInstance)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-premium.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dexie-helper.js */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js");
/* harmony import */ var _dexie_query_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dexie-query.js */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-query.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _rx_storage_multiinstance_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../rx-storage-multiinstance.js */ "./node_modules/rxdb/dist/esm/rx-storage-multiinstance.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");








var instanceId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.now)();
var shownNonPremiumLog = false;
var RxStorageInstanceDexie = /*#__PURE__*/function () {
  function RxStorageInstanceDexie(storage, databaseName, collectionName, schema, internals, options, settings, devMode) {
    this.changes$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
    this.instanceId = instanceId++;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options;
    this.settings = settings;
    this.devMode = devMode;
    this.primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_2__.getPrimaryFieldOfPrimaryKey)(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context) {
    ensureNotClosed(this);
    if (!shownNonPremiumLog && !(await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.hasPremiumFlag)())) {
      console.warn(['-------------- RxDB Open Core RxStorage -------------------------------', 'You are using the free Dexie.js based RxStorage implementation from RxDB https://rxdb.info/rx-storage-dexie.html?console=dexie ', 'While this is a great option, we want to let you know that there are faster storage solutions available in our premium plugins.', 'For professional users and production environments, we highly recommend considering these premium options to enhance performance and reliability.', ' https://rxdb.info/premium/?console=dexie ', 'If you already purchased premium access you can disable this log by calling the setPremiumFlag() function from rxdb-premium/plugins/shared.', '---------------------------------------------------------------------'].join('\n'));
      shownNonPremiumLog = true;
    } else {
      shownNonPremiumLog = true;
    }

    /**
     * Check some assumptions to ensure RxDB
     * does not call the storage with an invalid write.
     */
    documentWrites.forEach(row => {
      // ensure revision is set
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.newRxError)('SNH', {
          args: {
            row
          }
        });
      }
    });
    var state = await this.internals;
    var ret = {
      error: []
    };

    /**
     * Some storages might add any _meta fields
     * internally. To ensure RxDB can work with that in the
     * test suite, we add a random field here.
     * To ensure 
     */
    if (this.devMode) {
      documentWrites = documentWrites.map(row => {
        var doc = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__.flatCloneDocWithMeta)(row.document);
        return {
          previous: row.previous,
          document: doc
        };
      });
    }
    var documentKeys = documentWrites.map(writeRow => writeRow.document[this.primaryPath]);
    var categorized;
    await state.dexieDb.transaction('rw', state.dexieTable, state.dexieAttachmentsTable, async () => {
      var docsInDbMap = new Map();
      var docsInDbWithInternals = await (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.getDocsInDb)(this.internals, documentKeys);
      docsInDbWithInternals.forEach(docWithDexieInternals => {
        var doc = docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__.categorizeBulkWriteRows)(this, this.primaryPath, docsInDbMap, documentWrites, context);
      ret.error = categorized.errors;

      /**
       * Batch up the database operations
       * so we can later run them in bulk.
       */
      var bulkPutDocs = [];
      categorized.bulkInsertDocs.forEach(row => {
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach(row => {
        bulkPutDocs.push(row.document);
      });
      bulkPutDocs = bulkPutDocs.map(d => (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.fromStorageToDexie)(state.booleanIndexes, d));
      if (bulkPutDocs.length > 0) {
        await state.dexieTable.bulkPut(bulkPutDocs);
      }

      // handle attachments
      var putAttachments = [];
      categorized.attachmentsAdd.forEach(attachment => {
        putAttachments.push({
          id: (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.attachmentObjectId)(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      categorized.attachmentsUpdate.forEach(attachment => {
        putAttachments.push({
          id: (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.attachmentObjectId)(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      await state.dexieAttachmentsTable.bulkPut(putAttachments);
      await state.dexieAttachmentsTable.bulkDelete(categorized.attachmentsRemove.map(attachment => (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.attachmentObjectId)(attachment.documentId, attachment.attachmentId)));
    });
    categorized = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.ensureNotFalsy)(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.ensureNotFalsy)(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state = await this.internals;
    var ret = [];
    await state.dexieDb.transaction('r', state.dexieTable, async () => {
      var docsInDb = await (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.getDocsInDb)(this.internals, ids);
      docsInDb.forEach(documentInDb => {
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret.push(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query(preparedQuery) {
    ensureNotClosed(this);
    return (0,_dexie_query_js__WEBPACK_IMPORTED_MODULE_8__.dexieQuery)(this, preparedQuery);
  };
  _proto.count = async function count(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await (0,_dexie_query_js__WEBPACK_IMPORTED_MODULE_8__.dexieCount)(this, preparedQuery);
      return {
        count: result,
        mode: 'fast'
      };
    } else {
      var _result = await (0,_dexie_query_js__WEBPACK_IMPORTED_MODULE_8__.dexieQuery)(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: 'slow'
      };
    }
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieDb.transaction('rw', state.dexieTable, async () => {
      var maxDeletionTime = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.now)() - minimumDeletedTime;
      var toRemove = await state.dexieTable.where('_meta.lwt').below(maxDeletionTime).toArray();
      var removeIds = [];
      toRemove.forEach(doc => {
        if (doc._deleted === '1') {
          removeIds.push(doc[this.primaryPath]);
        }
      });
      await state.dexieTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = async function getAttachmentData(documentId, attachmentId, _digest) {
    ensureNotClosed(this);
    var state = await this.internals;
    var id = (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.attachmentObjectId)(documentId, attachmentId);
    return await state.dexieDb.transaction('r', state.dexieAttachmentsTable, async () => {
      var attachment = await state.dexieAttachmentsTable.get(id);
      if (attachment) {
        return attachment.data;
      } else {
        throw new Error('attachment missing documentId: ' + documentId + ' attachmentId: ' + attachmentId);
      }
    });
  };
  _proto.remove = async function remove() {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieTable.clear();
    return this.close();
  };
  _proto.close = function close() {
    if (this.closed) {
      return this.closed;
    }
    this.closed = (async () => {
      this.changes$.complete();
      await (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.closeDexieDb)(this.internals);
    })();
    return this.closed;
  };
  return RxStorageInstanceDexie;
}();
async function createDexieStorageInstance(storage, params, settings) {
  var internals = (0,_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.getDexieDbWithTables)(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings, params.devMode);
  await (0,_rx_storage_multiinstance_js__WEBPACK_IMPORTED_MODULE_9__.addRxStorageMultiInstanceSupport)(_dexie_helper_js__WEBPACK_IMPORTED_MODULE_6__.RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);
  }
}
//# sourceMappingURL=rx-storage-instance-dexie.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/update/index.js":
/*!************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/update/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxDBUpdatePlugin: () => (/* binding */ RxDBUpdatePlugin),
/* harmony export */   RxQueryUpdate: () => (/* binding */ RxQueryUpdate),
/* harmony export */   incrementalUpdate: () => (/* binding */ incrementalUpdate),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");
/* harmony import */ var _mingo_updater_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mingo-updater.js */ "./node_modules/rxdb/dist/esm/plugins/update/mingo-updater.js");
/**
 * this plugin allows delta-updates with mongo-like-syntax
 * It's using mingo internally
 * @link https://github.com/kofrasa/mingo
 */


function incrementalUpdate(updateObj) {
  return this.incrementalModify(docData => {
    var newDocData = (0,_mingo_updater_js__WEBPACK_IMPORTED_MODULE_0__.mingoUpdater)(docData, updateObj);
    return newDocData;
  });
}
function update(updateObj) {
  var oldDocData = this._data;
  var newDocData = (0,_mingo_updater_js__WEBPACK_IMPORTED_MODULE_0__.mingoUpdater)(oldDocData, updateObj);
  return this._saveData(newDocData, oldDocData);
}
async function RxQueryUpdate(updateObj) {
  return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.update(updateObj));
}
var RxDBUpdatePlugin = {
  name: 'update',
  rxdb: true,
  prototypes: {
    RxDocument: proto => {
      proto.update = update;
      proto.incrementalUpdate = incrementalUpdate;
    },
    RxQuery: proto => {
      proto.update = RxQueryUpdate;
    }
  }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/update/mingo-updater.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/update/mingo-updater.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mingoUpdater: () => (/* binding */ mingoUpdater)
/* harmony export */ });
/* harmony import */ var mingo_updater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mingo/updater */ "./node_modules/mingo/dist/esm/updater.js");
/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/**
 * Custom build of the mingo updater for smaller build size
 */



var updater;
function mingoUpdater(d, op) {
  if (!updater) {
    var updateObject = (0,mingo_updater__WEBPACK_IMPORTED_MODULE_0__.createUpdater)({
      cloneMode: "none"
    });
    updater = (d, op) => {
      var cloned = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.clone)(d);
      updateObject(cloned, op);
      return cloned;
    };
  }
  return updater(d, op);
}
//# sourceMappingURL=mingo-updater.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendToArray: () => (/* binding */ appendToArray),
/* harmony export */   arrayFilterNotEmpty: () => (/* binding */ arrayFilterNotEmpty),
/* harmony export */   asyncFilter: () => (/* binding */ asyncFilter),
/* harmony export */   batchArray: () => (/* binding */ batchArray),
/* harmony export */   countUntilNotMatching: () => (/* binding */ countUntilNotMatching),
/* harmony export */   isMaybeReadonlyArray: () => (/* binding */ isMaybeReadonlyArray),
/* harmony export */   isOneItemOfArrayInOtherArray: () => (/* binding */ isOneItemOfArrayInOtherArray),
/* harmony export */   lastOfArray: () => (/* binding */ lastOfArray),
/* harmony export */   maxOfNumbers: () => (/* binding */ maxOfNumbers),
/* harmony export */   randomOfArray: () => (/* binding */ randomOfArray),
/* harmony export */   removeOneFromArrayIfMatches: () => (/* binding */ removeOneFromArrayIfMatches),
/* harmony export */   shuffleArray: () => (/* binding */ shuffleArray),
/* harmony export */   sortByObjectNumberProperty: () => (/* binding */ sortByObjectNumberProperty),
/* harmony export */   sumNumberArray: () => (/* binding */ sumNumberArray),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   uniqueArray: () => (/* binding */ uniqueArray)
/* harmony export */ });
function lastOfArray(ar) {
  return ar[ar.length - 1];
}

/**
 * shuffle the given array
 */
function shuffleArray(arr) {
  return arr.slice(0).sort(() => Math.random() - 0.5);
}
function randomOfArray(arr) {
  var randomElement = arr[Math.floor(Math.random() * arr.length)];
  return randomElement;
}
function toArray(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}

/**
 * Split array with items into smaller arrays with items
 * @link https://stackoverflow.com/a/7273794/3443137
 */
function batchArray(array, batchSize) {
  array = array.slice(0);
  var ret = [];
  while (array.length) {
    var batch = array.splice(0, batchSize);
    ret.push(batch);
  }
  return ret;
}

/**
 * @link https://stackoverflow.com/a/15996017
 */
function removeOneFromArrayIfMatches(ar, condition) {
  ar = ar.slice();
  var i = ar.length;
  var done = false;
  while (i-- && !done) {
    if (condition(ar[i])) {
      done = true;
      ar.splice(i, 1);
    }
  }
  return ar;
}

/**
 * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>
 */
function isMaybeReadonlyArray(x) {
  // While this looks strange, it's a workaround for an issue in TypeScript:
  // https://github.com/microsoft/TypeScript/issues/17002
  //
  // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,
  // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.
  // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while
  // still performing runtime type inspection.
  return Array.isArray(x);
}
function isOneItemOfArrayInOtherArray(ar1, ar2) {
  for (var i = 0; i < ar1.length; i++) {
    var el = ar1[i];
    var has = ar2.includes(el);
    if (has) {
      return true;
    }
  }
  return false;
}

/**
 * Use this in array.filter() to remove all empty slots
 * and have the correct typings afterwards.
 * @link https://stackoverflow.com/a/46700791/3443137
 */
function arrayFilterNotEmpty(value) {
  if (value === null || value === undefined) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count = 0;
  var idx = -1;
  for (var item of ar) {
    idx = idx + 1;
    var matching = matchingFn(item, idx);
    if (matching) {
      count = count + 1;
    } else {
      break;
    }
  }
  return count;
}
async function asyncFilter(array, predicate) {
  var filters = await Promise.all(array.map(predicate));
  return array.filter((...[, index]) => filters[index]);
}

/**
 * @link https://stackoverflow.com/a/3762735
 */
function sumNumberArray(array) {
  var count = 0;
  for (var i = array.length; i--;) {
    count += array[i];
  }
  return count;
}
function maxOfNumbers(arr) {
  return Math.max(...arr);
}

/**
 * Appends the given documents to the given array.
 * This will mutate the first given array.
 * Mostly used as faster alternative to Array.concat()
 * because .concat() is so slow.
 * @link https://www.measurethat.net/Benchmarks/Show/4223/0/array-concat-vs-spread-operator-vs-push#latest_results_block
 * 
 * TODO it turns out that in mid 2024 v8 has optimized Array.concat()
 * so it might be faster to just use concat() again:
 * @link https://jsperf.app/qiqawa/10
 */
function appendToArray(ar, add) {
  /**
   * Pre-increasing the array size has turned out
   * to be way faster when big arrays must be handled.
   * @link https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki
   */
  var addSize = add.length;
  if (addSize === 0) {
    return;
  }
  var baseSize = ar.length;
  ar.length = baseSize + add.length;
  for (var i = 0; i < addSize; ++i) {
    ar[baseSize + i] = add[i];
  }
}

/**
 * @link https://gist.github.com/telekosmos/3b62a31a5c43f40849bb
 */
function uniqueArray(arrArg) {
  return arrArg.filter(function (elem, pos, arr) {
    return arr.indexOf(elem) === pos;
  });
}
function sortByObjectNumberProperty(property) {
  return (a, b) => {
    return b[property] - a[property];
  };
}
//# sourceMappingURL=utils-array.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RX_META_LWT_MINIMUM: () => (/* binding */ RX_META_LWT_MINIMUM),
/* harmony export */   areRxDocumentArraysEqual: () => (/* binding */ areRxDocumentArraysEqual),
/* harmony export */   getDefaultRevision: () => (/* binding */ getDefaultRevision),
/* harmony export */   getDefaultRxDocumentMeta: () => (/* binding */ getDefaultRxDocumentMeta),
/* harmony export */   getSortDocumentsByLastWriteTimeComparator: () => (/* binding */ getSortDocumentsByLastWriteTimeComparator),
/* harmony export */   sortDocumentsByLastWriteTime: () => (/* binding */ sortDocumentsByLastWriteTime),
/* harmony export */   stripMetaDataFromDocument: () => (/* binding */ stripMetaDataFromDocument),
/* harmony export */   toWithDeleted: () => (/* binding */ toWithDeleted)
/* harmony export */ });
/* harmony import */ var _utils_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-object.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");

/**
 * We use 1 as minimum so that the value is never falsy.
 * This const is used in several places because querying
 * with a value lower then the minimum could give false results.
 */
var RX_META_LWT_MINIMUM = 1;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}

/**
 * Returns a revision that is not valid.
 * Use this to have correct typings
 * while the storage wrapper anyway will overwrite the revision.
 */
function getDefaultRevision() {
  /**
   * Use a non-valid revision format,
   * to ensure that the RxStorage will throw
   * when the revision is not replaced downstream.
   */
  return '';
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: undefined,
    _deleted: undefined,
    _rev: undefined
  });
}

/**
 * Faster way to check the equality of document lists
 * compared to doing a deep-equal.
 * Here we only check the ids and revisions.
 */
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i = 0;
  var len = ar1.length;
  while (i < len) {
    var row1 = ar1[i];
    var row2 = ar2[i];
    i++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}
function getSortDocumentsByLastWriteTimeComparator(primaryPath) {
  return (a, b) => {
    if (a._meta.lwt === b._meta.lwt) {
      if (b[primaryPath] < a[primaryPath]) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a._meta.lwt - b._meta.lwt;
    }
  };
}
function sortDocumentsByLastWriteTime(primaryPath, docs) {
  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));
}
function toWithDeleted(docData) {
  docData = (0,_utils_object_js__WEBPACK_IMPORTED_MODULE_0__.flatClone)(docData);
  docData._deleted = !!docData._deleted;
  return Object.assign(docData, {
    _attachments: undefined,
    _meta: undefined,
    _rev: undefined
  });
}
//# sourceMappingURL=utils-document.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   errorToPlainJson: () => (/* binding */ errorToPlainJson),
/* harmony export */   pluginMissing: () => (/* binding */ pluginMissing)
/* harmony export */ });
/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-string.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");


/**
 * Returns an error that indicates that a plugin is missing
 * We do not throw a RxError because this should not be handled
 * programmatically but by using the correct import
 */
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split('-');
  var pluginName = 'RxDB';
  keyParts.forEach(part => {
    pluginName += (0,_utils_string_js__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(part);
  });
  pluginName += 'Plugin';
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}
function errorToPlainJson(err) {
  var ret = {
    name: err.name,
    message: err.message,
    rxdb: err.rxdb,
    parameters: err.parameters,
    extensions: err.extensions,
    code: err.code,
    url: err.url,
    /**
     * stack must be last to make it easier to read the json in a console.
     * Also we ensure that each linebreak is spaced so that the chrome devtools
     * shows urls to the source code that can be clicked to inspect
     * the correct place in the code.
     */
    stack: !err.stack ? undefined : err.stack.replace(/\n/g, ' \n ')
  };
  return ret;
}
//# sourceMappingURL=utils-error.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-global.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-global.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RXDB_UTILS_GLOBAL: () => (/* binding */ RXDB_UTILS_GLOBAL)
/* harmony export */ });
/**
 * Can be used by some plugins to have a "global" object that
 * can be imported and mutated at will.
 */
var RXDB_UTILS_GLOBAL = {};
//# sourceMappingURL=utils-global.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultHashSha256: () => (/* binding */ defaultHashSha256),
/* harmony export */   hashStringToNumber: () => (/* binding */ hashStringToNumber),
/* harmony export */   nativeSha256: () => (/* binding */ nativeSha256)
/* harmony export */ });
async function nativeSha256(input) {
  var data = new TextEncoder().encode(input);
  /**
   * If your JavaScript runtime does not support crypto.subtle.digest,
   * provide your own hash function when calling createRxDatabase().
   */

  var hashBuffer = await crypto.subtle.digest('SHA-256', data);
  /**
   * @link https://jameshfisher.com/2017/10/30/web-cryptography-api-hello-world/
   */
  var hash = Array.prototype.map.call(new Uint8Array(hashBuffer), x => ('00' + x.toString(16)).slice(-2)).join('');
  return hash;
}
var defaultHashSha256 = nativeSha256;
function hashStringToNumber(str) {
  var nr = 0;
  var len = str.length;
  for (var i = 0; i < len; i++) {
    nr = nr + str.charCodeAt(i);
    nr |= 0; // Convert to 32bit integer, improves performance
  }
  return nr;
}
//# sourceMappingURL=utils-hash.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFromMapOrCreate: () => (/* binding */ getFromMapOrCreate),
/* harmony export */   getFromMapOrThrow: () => (/* binding */ getFromMapOrThrow)
/* harmony export */ });
function getFromMapOrThrow(map, key) {
  var val = map.get(key);
  if (typeof val === 'undefined') {
    throw new Error('missing value from map ' + key);
  }
  return val;
}
function getFromMapOrCreate(map, index, creator, ifWasThere) {
  var value = map.get(index);
  if (typeof value === 'undefined') {
    value = creator();
    map.set(index, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}
//# sourceMappingURL=utils-map.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepEqual: () => (/* binding */ deepEqual)
/* harmony export */ });
/**
 * Copied from the fast-deep-equal package
 * because it does not support es modules and causes optimization bailouts.
 * TODO use the npm package again when this is merged:
 * @link https://github.com/epoberezkin/fast-deep-equal/pull/105
 */
function deepEqual(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;
    var length;
    var i;
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;
      return true;
    }
    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    for (i = length; i-- !== 0;) {
      var key = keys[i];
      if (!deepEqual(a[key], b[key])) return false;
    }
    return true;
  }

  // true if both NaN, false otherwise
  return a !== a && b !== b;
}
//# sourceMappingURL=utils-object-deep-equal.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepKeys: () => (/* binding */ deepKeys),
/* harmony export */   deleteProperty: () => (/* binding */ deleteProperty),
/* harmony export */   getProperty: () => (/* binding */ getProperty),
/* harmony export */   hasProperty: () => (/* binding */ hasProperty),
/* harmony export */   setProperty: () => (/* binding */ setProperty)
/* harmony export */ });
/**
 * Copied from
 * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js
 * because it is currently an esm only module.
 * TODO use the npm package again when RxDB is also fully esm.
 */

var isObject = value => {
  var type = typeof value;
  return value !== null && (type === 'object' || type === 'function');
};
var disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);
var digits = new Set('0123456789');
function getPathSegments(path) {
  var parts = [];
  var currentSegment = '';
  var currentPart = 'start';
  var isIgnoring = false;
  for (var character of path) {
    switch (character) {
      case '\\':
        {
          if (currentPart === 'index') {
            throw new Error('Invalid character in an index');
          }
          if (currentPart === 'indexEnd') {
            throw new Error('Invalid character after an index');
          }
          if (isIgnoring) {
            currentSegment += character;
          }
          currentPart = 'property';
          isIgnoring = !isIgnoring;
          break;
        }
      case '.':
        {
          if (currentPart === 'index') {
            throw new Error('Invalid character in an index');
          }
          if (currentPart === 'indexEnd') {
            currentPart = 'property';
            break;
          }
          if (isIgnoring) {
            isIgnoring = false;
            currentSegment += character;
            break;
          }
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = '';
          currentPart = 'property';
          break;
        }
      case '[':
        {
          if (currentPart === 'index') {
            throw new Error('Invalid character in an index');
          }
          if (currentPart === 'indexEnd') {
            currentPart = 'index';
            break;
          }
          if (isIgnoring) {
            isIgnoring = false;
            currentSegment += character;
            break;
          }
          if (currentPart === 'property') {
            if (disallowedKeys.has(currentSegment)) {
              return [];
            }
            parts.push(currentSegment);
            currentSegment = '';
          }
          currentPart = 'index';
          break;
        }
      case ']':
        {
          if (currentPart === 'index') {
            parts.push(Number.parseInt(currentSegment, 10));
            currentSegment = '';
            currentPart = 'indexEnd';
            break;
          }
          if (currentPart === 'indexEnd') {
            throw new Error('Invalid character after an index');
          }

          // Falls through
        }
      default:
        {
          if (currentPart === 'index' && !digits.has(character)) {
            throw new Error('Invalid character in an index');
          }
          if (currentPart === 'indexEnd') {
            throw new Error('Invalid character after an index');
          }
          if (currentPart === 'start') {
            currentPart = 'property';
          }
          if (isIgnoring) {
            isIgnoring = false;
            currentSegment += '\\';
          }
          currentSegment += character;
        }
    }
  }
  if (isIgnoring) {
    currentSegment += '\\';
  }
  switch (currentPart) {
    case 'property':
      {
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        break;
      }
    case 'index':
      {
        throw new Error('Index was not closed');
      }
    case 'start':
      {
        parts.push('');
        break;
      }
    // No default
  }
  return parts;
}
function isStringIndex(object, key) {
  if (typeof key !== 'number' && Array.isArray(object)) {
    var index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object[index] === object[key];
  }
  return false;
}
function assertNotStringIndex(object, key) {
  if (isStringIndex(object, key)) {
    throw new Error('Cannot use string index');
  }
}

/**
 * TODO we need some performance tests and improvements here.
 */
function getProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join('.');
  }

  /**
   * Performance shortcut.
   * In most cases we just have a simple property name
   * so we can directly return it.
   */
  if (!path.includes('.') && !path.includes('[')) {
    return object[path];
  }
  if (!isObject(object) || typeof path !== 'string') {
    return value === undefined ? object : value;
  }
  var pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    if (isStringIndex(object, key)) {
      object = index === pathArray.length - 1 ? undefined : null;
    } else {
      object = object[key];
    }
    if (object === undefined || object === null) {
      // `object` is either `undefined` or `null` so we want to stop the loop, and
      // if this is not the last bit of the path, and
      // if it didn't return `undefined`
      // it would return `null` if `object` is `null`
      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === undefined ? value : object;
}
function setProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join('.');
  }
  if (!isObject(object) || typeof path !== 'string') {
    return object;
  }
  var root = object;
  var pathArray = getPathSegments(path);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object, key);
    if (index === pathArray.length - 1) {
      object[key] = value;
    } else if (!isObject(object[key])) {
      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};
    }
    object = object[key];
  }
  return root;
}
function deleteProperty(object, path) {
  if (!isObject(object) || typeof path !== 'string') {
    return false;
  }
  var pathArray = getPathSegments(path);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object, key);
    if (index === pathArray.length - 1) {
      delete object[key];
      return true;
    }
    object = object[key];
    if (!isObject(object)) {
      return false;
    }
  }
}
function hasProperty(object, path) {
  if (!isObject(object) || typeof path !== 'string') {
    return false;
  }
  var pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return false;
  }
  for (var key of pathArray) {
    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {
      return false;
    }
    object = object[key];
  }
  return true;
}

// TODO: Backslashes with no effect should not be escaped
function escapePath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Expected a string');
  }
  return path.replace(/[\\.[]/g, '\\$&');
}

// The keys returned by Object.entries() for arrays are strings
function entries(value) {
  if (Array.isArray(value)) {
    return value.map((v, index) => [index, v]);
  }
  return Object.entries(value);
}
function stringifyPath(pathSegments) {
  var result = '';

  // eslint-disable-next-line prefer-const
  for (var [index, segment] of entries(pathSegments)) {
    if (typeof segment === 'number') {
      result += "[" + segment + "]";
    } else {
      segment = escapePath(segment);
      result += index === 0 ? segment : "." + segment;
    }
  }
  return result;
}
function* deepKeysIterator(object, currentPath = []) {
  if (!isObject(object)) {
    if (currentPath.length > 0) {
      yield stringifyPath(currentPath);
    }
    return;
  }
  for (var [key, value] of entries(object)) {
    yield* deepKeysIterator(value, [...currentPath, key]);
  }
}
function deepKeys(object) {
  return [...deepKeysIterator(object)];
}
//# sourceMappingURL=utils-object-dot-prop.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),
/* harmony export */   findUndefinedPath: () => (/* binding */ findUndefinedPath),
/* harmony export */   firstPropertyNameOfObject: () => (/* binding */ firstPropertyNameOfObject),
/* harmony export */   firstPropertyValueOfObject: () => (/* binding */ firstPropertyValueOfObject),
/* harmony export */   flatClone: () => (/* binding */ flatClone),
/* harmony export */   flattenObject: () => (/* binding */ flattenObject),
/* harmony export */   getFromObjectOrThrow: () => (/* binding */ getFromObjectOrThrow),
/* harmony export */   hasDeepProperty: () => (/* binding */ hasDeepProperty),
/* harmony export */   objectPathMonad: () => (/* binding */ objectPathMonad),
/* harmony export */   overwriteGetterForCaching: () => (/* binding */ overwriteGetterForCaching),
/* harmony export */   sortObject: () => (/* binding */ sortObject)
/* harmony export */ });
function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (Object.prototype.hasOwnProperty.call(o, prop) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}

/**
 * To get specific nested path values from objects,
 * RxDB normally uses the 'dot-prop' npm module.
 * But when performance is really relevant, this is not fast enough.
 * Instead we use a monad that can prepare some stuff up front
 * and we can reuse the generated function.
 */

function objectPathMonad(objectPath) {
  var split = objectPath.split('.');

  // reuse this variable for better performance.
  var splitLength = split.length;

  /**
   * Performance shortcut,
   * if no nested path is used,
   * directly return the field of the object.
   */
  if (splitLength === 1) {
    return obj => obj[objectPath];
  }
  return obj => {
    var currentVal = obj;
    for (var i = 0; i < splitLength; ++i) {
      var subPath = split[i];
      currentVal = currentVal[subPath];
      if (typeof currentVal === 'undefined') {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function getFromObjectOrThrow(obj, key) {
  var val = obj[key];
  if (!val) {
    throw new Error('missing value from object ' + key);
  }
  return val;
}

/**
 * returns a flattened object
 * @link https://gist.github.com/penguinboy/762197
 */
function flattenObject(ob) {
  var toReturn = {};
  for (var i in ob) {
    if (!Object.prototype.hasOwnProperty.call(ob, i)) continue;
    if (typeof ob[i] === 'object') {
      var flatObject = flattenObject(ob[i]);
      for (var x in flatObject) {
        if (!Object.prototype.hasOwnProperty.call(flatObject, x)) continue;
        toReturn[i + '.' + x] = flatObject[x];
      }
    } else {
      toReturn[i] = ob[i];
    }
  }
  return toReturn;
}

/**
 * does a flat copy on the objects,
 * is about 3 times faster then using deepClone
 * @link https://jsperf.com/object-rest-spread-vs-clone/2
 */
function flatClone(obj) {
  return Object.assign({}, obj);
}

/**
 * @link https://stackoverflow.com/a/11509718/3443137
 */
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function firstPropertyValueOfObject(obj) {
  var key = Object.keys(obj)[0];
  return obj[key];
}

/**
 * deep-sort an object so its attributes are in lexical order.
 * Also sorts the arrays inside of the object if no-array-sort not set
 */
function sortObject(obj, noArraySort = false) {
  if (!obj) return obj; // do not sort null, false or undefined

  // array
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a, b) => {
      if (typeof a === 'string' && typeof b === 'string') return a.localeCompare(b);
      if (typeof a === 'object') return 1;else return -1;
    }).map(i => sortObject(i, noArraySort));
  }

  // object
  // array is also of type object
  if (typeof obj === 'object' && !Array.isArray(obj)) {
    var out = {};
    Object.keys(obj).sort((a, b) => a.localeCompare(b)).forEach(key => {
      out[key] = sortObject(obj[key], noArraySort);
    });
    return out;
  }

  // everything else
  return obj;
}

/**
 * Deep clone a plain json object.
 * Does not work with recursive stuff
 * or non-plain-json.
 * IMPORTANT: Performance of this is very important,
 * do not change it without running performance tests!
 *
 * @link https://github.com/zxdong262/deep-copy/blob/master/src/index.ts
 */
function deepClone(src) {
  if (!src) {
    return src;
  }
  if (src === null || typeof src !== 'object') {
    return src;
  }
  if (Array.isArray(src)) {
    var ret = new Array(src.length);
    var i = ret.length;
    while (i--) {
      ret[i] = deepClone(src[i]);
    }
    return ret;
  }
  var dest = {};
  // eslint-disable-next-line guard-for-in
  for (var key in src) {
    dest[key] = deepClone(src[key]);
  }
  return dest;
}
var clone = deepClone;

/**
 * overwrites the getter with the actual value
 * Mostly used for caching stuff on the first run
 */
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function () {
      return value;
    }
  });
  return value;
}
function hasDeepProperty(obj, property) {
  if (obj.hasOwnProperty(property)) {
    return true;
  }
  if (Array.isArray(obj)) {
    var has = !!obj.find(item => hasDeepProperty(item, property));
    return has;
  }

  // Recursively check for property in nested objects
  for (var key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      if (hasDeepProperty(obj[key], property)) {
        return true;
      }
    }
  }

  // Return false if 'foobar' is not found at any level
  return false;
}

/**
 * Deeply checks if an object contains any property
 * with the value of undefined
 * If yes, returns the path to it.
 */
function findUndefinedPath(obj, parentPath = '') {
  // If `obj` is not an object or is null, we can't go deeper, so return false
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (var key of Object.keys(obj)) {
    var value = obj[key];
    // Build the full path. For the root level, it's just the key;
    // for nested levels, prepend the parent path followed by a dot.
    var currentPath = parentPath ? parentPath + "." + key : key;

    // If the value is undefined, return the path
    if (typeof value === 'undefined') {
      return currentPath;
    }

    // If the value is an object, recurse to check deeper
    if (typeof value === "object" && value !== null) {
      var result = findUndefinedPath(value, currentPath);
      // If a path was found in the nested object, return it
      if (result) {
        return result;
      }
    }
  }

  // If no property with undefined was found
  return false;
}
//# sourceMappingURL=utils-object.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RXJS_SHARE_REPLAY_DEFAULTS: () => (/* binding */ RXJS_SHARE_REPLAY_DEFAULTS),
/* harmony export */   customFetchWithFixedHeaders: () => (/* binding */ customFetchWithFixedHeaders),
/* harmony export */   ensureInteger: () => (/* binding */ ensureInteger),
/* harmony export */   ensureNotFalsy: () => (/* binding */ ensureNotFalsy),
/* harmony export */   nameFunction: () => (/* binding */ nameFunction),
/* harmony export */   runXTimes: () => (/* binding */ runXTimes)
/* harmony export */ });
function runXTimes(xTimes, fn) {
  new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));
}
function ensureNotFalsy(obj, message) {
  if (!obj) {
    if (!message) {
      message = '';
    }
    throw new Error('ensureNotFalsy() is falsy: ' + message);
  }
  return obj;
}
function ensureInteger(obj) {
  if (!Number.isInteger(obj)) {
    throw new Error('ensureInteger() is falsy');
  }
  return obj;
}

/**
 * Using shareReplay() without settings will not unsubscribe
 * if there are no more subscribers.
 * So we use these defaults.
 * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95
 */
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};

/**
 * Dynamically add a name to a function
 * so that it can later be found in the stack.
 * @link https://stackoverflow.com/a/41854075/3443137
 */
function nameFunction(name, body) {
  // @ts-ignore
  return {
    [name](...args) {
      return body.apply(this, args);
    }
  }[name];
}
function customFetchWithFixedHeaders(headers) {
  function customFetch(url, options = {}) {
    // Ensure options object exists and headers property is initialized
    options.headers = {
      ...headers,
      // include default custom headers
      ...(options.headers || {}) // merge any headers passed in the function call
    };

    // Call the original fetch with the modified options
    return fetch(url, options);
  }
  return customFetch;
}
//# sourceMappingURL=utils-other.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-premium.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-premium.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NON_PREMIUM_COLLECTION_LIMIT: () => (/* binding */ NON_PREMIUM_COLLECTION_LIMIT),
/* harmony export */   PREMIUM_FLAG_HASH: () => (/* binding */ PREMIUM_FLAG_HASH),
/* harmony export */   hasPremiumFlag: () => (/* binding */ hasPremiumFlag)
/* harmony export */ });
/* harmony import */ var _utils_global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-global.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-global.js");
/* harmony import */ var _utils_hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-hash.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-promise.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");



var PREMIUM_FLAG_HASH = '6da4936d1425ff3a5c44c02342c6daf791d266be3ae8479b8ec59e261df41b93';
var NON_PREMIUM_COLLECTION_LIMIT = 16;
var hasPremiumPromise = _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVE_FALSE;
var premiumChecked = false;

/**
 * Here we check if the premium flag has been set.
 * This code exists in the open source version of RxDB.
 * Yes you are allowed to fork the repo and just overwrite this function.
 * However you might better spend this time developing your real project
 * and supporting the RxDB efforts by buying premium.
 */
async function hasPremiumFlag() {
  if (premiumChecked) {
    return hasPremiumPromise;
  }
  premiumChecked = true;
  hasPremiumPromise = (async () => {
    if (_utils_global_js__WEBPACK_IMPORTED_MODULE_1__.RXDB_UTILS_GLOBAL.premium && typeof _utils_global_js__WEBPACK_IMPORTED_MODULE_1__.RXDB_UTILS_GLOBAL.premium === 'string' && (await (0,_utils_hash_js__WEBPACK_IMPORTED_MODULE_2__.defaultHashSha256)(_utils_global_js__WEBPACK_IMPORTED_MODULE_1__.RXDB_UTILS_GLOBAL.premium)) === PREMIUM_FLAG_HASH) {
      return true;
    } else {
      return false;
    }
  })();
  return hasPremiumPromise;
}
//# sourceMappingURL=utils-premium.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PROMISE_RESOLVE_FALSE: () => (/* binding */ PROMISE_RESOLVE_FALSE),
/* harmony export */   PROMISE_RESOLVE_NULL: () => (/* binding */ PROMISE_RESOLVE_NULL),
/* harmony export */   PROMISE_RESOLVE_TRUE: () => (/* binding */ PROMISE_RESOLVE_TRUE),
/* harmony export */   PROMISE_RESOLVE_VOID: () => (/* binding */ PROMISE_RESOLVE_VOID),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   promiseSeries: () => (/* binding */ promiseSeries),
/* harmony export */   promiseWait: () => (/* binding */ promiseWait),
/* harmony export */   requestIdleCallbackIfAvailable: () => (/* binding */ requestIdleCallbackIfAvailable),
/* harmony export */   requestIdlePromise: () => (/* binding */ requestIdlePromise),
/* harmony export */   requestIdlePromiseNoQueue: () => (/* binding */ requestIdlePromiseNoQueue),
/* harmony export */   toPromise: () => (/* binding */ toPromise)
/* harmony export */ });
/**
 * returns a promise that resolves on the next tick
 */
function nextTick() {
  return new Promise(res => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise(res => setTimeout(res, ms));
}
function toPromise(maybePromise) {
  if (maybePromise && typeof maybePromise.then === 'function') {
    // is promise
    return maybePromise;
  } else {
    return Promise.resolve(maybePromise);
  }
}

/**
 * returns true if promise is given
 */
function isPromise(value) {
  if (typeof value !== 'undefined' && typeof value.then === 'function') {
    return true;
  }
  return false;
}

/**
 * Reusing resolved promises has a better
 * performance than creating new ones each time.
 */
var PROMISE_RESOLVE_TRUE = Promise.resolve(true);
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
var PROMISE_RESOLVE_VOID = Promise.resolve();
function requestIdlePromiseNoQueue(
/**
 * We always set a timeout!
 * RxDB might be used on the server side where the
 * server runs 24/4 on 99% CPU. So without a timeout
 * this would never resolve which could cause a memory leak.
 */
timeout = 10000) {
  /**
   * Do not use window.requestIdleCallback
   * because some javascript runtimes like react-native,
   * do not have a window object, but still have a global
   * requestIdleCallback function.
   * @link https://github.com/pubkey/rxdb/issues/4804
  */
  if (typeof requestIdleCallback === 'function') {
    return new Promise(res => {
      requestIdleCallback(() => res(), {
        timeout
      });
    });
  } else {
    return promiseWait(0);
  }
}

/**
 * If multiple operations wait for an requestIdlePromise
 * we do not want them to resolve all at the same time.
 * So we have to queue the calls.
 */
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout = undefined) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    return requestIdlePromiseNoQueue(timeout);
  });
  return idlePromiseQueue;
}

/**
 * run the callback if requestIdleCallback available
 * do nothing if not
 * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback
 */
function requestIdleCallbackIfAvailable(fun) {
  /**
   * Do not use window.requestIdleCallback
   * because some javascript runtimes like react-native,
   * do not have a window object, but still have a global
   * requestIdleCallback function.
   * @link https://github.com/pubkey/rxdb/issues/4804
  */
  if (typeof requestIdleCallback === 'function') {
    requestIdleCallback(() => {
      fun();
    });
  }
}

/**
 * like Promise.all() but runs in series instead of parallel
 * @link https://github.com/egoist/promise.series/blob/master/index.js
 * @param tasks array with functions that return a promise
 */
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));
}
//# sourceMappingURL=utils-promise.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-regex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-regex.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   REGEX_ALL_DOTS: () => (/* binding */ REGEX_ALL_DOTS),
/* harmony export */   REGEX_ALL_PIPES: () => (/* binding */ REGEX_ALL_PIPES)
/* harmony export */ });
var REGEX_ALL_DOTS = /\./g;
var REGEX_ALL_PIPES = /\|/g;
//# sourceMappingURL=utils-regex.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRevision: () => (/* binding */ createRevision),
/* harmony export */   getHeightOfRevision: () => (/* binding */ getHeightOfRevision),
/* harmony export */   parseRevision: () => (/* binding */ parseRevision)
/* harmony export */ });
/**
 * Parses the full revision.
 * Do NOT use this if you only need the revision height,
 * then use getHeightOfRevision() instead which is faster.
 */
function parseRevision(revision) {
  var split = revision.split('-');
  if (split.length !== 2) {
    throw new Error('malformatted revision: ' + revision);
  }
  return {
    height: parseInt(split[0], 10),
    hash: split[1]
  };
}

/**
 * @hotPath Performance is very important here
 * because we need to parse the revision height very often.
 * Do not use `parseInt(revision.split('-')[0], 10)` because
 * only fetching the start-number chars is faster.
 */
function getHeightOfRevision(revision) {
  var useChars = '';
  for (var index = 0; index < revision.length; index++) {
    var char = revision[index];
    if (char === '-') {
      return parseInt(useChars, 10);
    }
    useChars += char;
  }
  throw new Error('malformatted revision: ' + revision);
}

/**
 * Creates the next write revision for a given document.
 */
function createRevision(databaseInstanceToken, previousDocData) {
  var newRevisionHeight = !previousDocData ? 1 : getHeightOfRevision(previousDocData._rev) + 1;
  return newRevisionHeight + '-' + databaseInstanceToken;
}
//# sourceMappingURL=utils-revision.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RXDB_VERSION: () => (/* binding */ RXDB_VERSION)
/* harmony export */ });
/**
 * This file is replaced in the 'npm run build:version' script.
 */
var RXDB_VERSION = '16.11.0';
//# sourceMappingURL=utils-rxdb-version.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RANDOM_STRING: () => (/* binding */ RANDOM_STRING),
/* harmony export */   arrayBufferToString: () => (/* binding */ arrayBufferToString),
/* harmony export */   isFolderPath: () => (/* binding */ isFolderPath),
/* harmony export */   lastCharOfString: () => (/* binding */ lastCharOfString),
/* harmony export */   normalizeString: () => (/* binding */ normalizeString),
/* harmony export */   randomToken: () => (/* binding */ randomToken),
/* harmony export */   stringToArrayBuffer: () => (/* binding */ stringToArrayBuffer),
/* harmony export */   trimDots: () => (/* binding */ trimDots),
/* harmony export */   ucfirst: () => (/* binding */ ucfirst)
/* harmony export */ });
var COUCH_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';

/**
 * Get a random string which can be used for many things in RxDB.
 * The returned string is guaranteed to be a valid database name or collection name
 * and also to be a valid JavaScript variable name.
 * 
 * @link http://stackoverflow.com/a/1349426/3443137
 */
function randomToken(length = 10) {
  var text = '';
  for (var i = 0; i < length; i++) {
    text += COUCH_NAME_CHARS.charAt(Math.floor(Math.random() * COUCH_NAME_CHARS.length));
  }
  return text;
}

/**
 * A random string that is never inside of any storage
 */
var RANDOM_STRING = 'Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX';

/**
 * uppercase first char
 */
function ucfirst(str) {
  str += '';
  var f = str.charAt(0).toUpperCase();
  return f + str.substr(1);
}

/**
 * removes trailing and ending dots from the string
 */
function trimDots(str) {
  // start
  while (str.charAt(0) === '.') {
    str = str.substr(1);
  }

  // end
  while (str.slice(-1) === '.') {
    str = str.slice(0, -1);
  }
  return str;
}

/**
 * @link https://stackoverflow.com/a/44950500/3443137
 */
function lastCharOfString(str) {
  return str.charAt(str.length - 1);
}

/**
 * returns true if the given name is likely a folder path
 */
function isFolderPath(name) {
  // do not check, if foldername is given
  if (name.includes('/') ||
  // unix
  name.includes('\\') // windows
  ) {
    return true;
  } else {
    return false;
  }
}

/**
 * @link https://gist.github.com/andreburgaud/6f73fd2d690b629346b8
 * @link https://stackoverflow.com/a/76240378/3443137
 */
function arrayBufferToString(arrayBuffer) {
  return new TextDecoder().decode(arrayBuffer);
}
function stringToArrayBuffer(str) {
  return new TextEncoder().encode(str);
}
function normalizeString(str) {
  return str.trim().replace(/[\n\s]+/g, '');
}
//# sourceMappingURL=utils-string.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   now: () => (/* binding */ now)
/* harmony export */ });
/**
 * Returns the current unix time in milliseconds (with two decimals!)
 * Because the accuracy of getTime() in javascript is bad,
 * and we cannot rely on performance.now() on all platforms,
 * this method implements a way to never return the same value twice.
 * This ensures that when now() is called often, we do not loose the information
 * about which call came first and which came after.
 *
 * We had to move from having no decimals, to having two decimal
 * because it turned out that some storages are such fast that
 * calling this method too often would return 'the future'.
 */
var _lastNow = 0;
/**
 * Returns the current time in milliseconds,
 * also ensures to not return the same value twice.
 */
function now() {
  var ret = Date.now();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }

  /**
   * Strip the returned number to max two decimals.
   * In theory we would not need this but
   * in practice JavaScript has no such good number precision
   * so rounding errors could add another decimal place.
   */
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}
//# sourceMappingURL=utils-time.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/query-cache.js":
/*!***************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/query-cache.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COLLECTIONS_WITH_RUNNING_CLEANUP: () => (/* binding */ COLLECTIONS_WITH_RUNNING_CLEANUP),
/* harmony export */   DEFAULT_TRY_TO_KEEP_MAX: () => (/* binding */ DEFAULT_TRY_TO_KEEP_MAX),
/* harmony export */   DEFAULT_UNEXECUTED_LIFETIME: () => (/* binding */ DEFAULT_UNEXECUTED_LIFETIME),
/* harmony export */   QueryCache: () => (/* binding */ QueryCache),
/* harmony export */   countRxQuerySubscribers: () => (/* binding */ countRxQuerySubscribers),
/* harmony export */   createQueryCache: () => (/* binding */ createQueryCache),
/* harmony export */   defaultCacheReplacementPolicy: () => (/* binding */ defaultCacheReplacementPolicy),
/* harmony export */   defaultCacheReplacementPolicyMonad: () => (/* binding */ defaultCacheReplacementPolicyMonad),
/* harmony export */   triggerCacheReplacement: () => (/* binding */ triggerCacheReplacement),
/* harmony export */   uncacheRxQuery: () => (/* binding */ uncacheRxQuery)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/**
 * the query-cache makes sure that on every query-state, exactly one instance can exist
 * if you use the same mango-query more then once, it will reuse the first RxQuery
 */


var QueryCache = /*#__PURE__*/function () {
  function QueryCache() {
    this._map = new Map();
  }
  var _proto = QueryCache.prototype;
  /**
   * check if an equal query is in the cache,
   * if true, return the cached one,
   * if false, save the given one and return it
   */
  _proto.getByQuery = function getByQuery(rxQuery) {
    var stringRep = rxQuery.toString();
    var ret = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrCreate)(this._map, stringRep, () => rxQuery);
    return ret;
  };
  return QueryCache;
}();
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache, rxQuery) {
  rxQuery.uncached = true;
  var stringRep = rxQuery.toString();
  queryCache._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery) {
  return rxQuery.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;

/**
 * The default cache replacement policy
 * See docs-src/query-cache.md to learn how it should work.
 * Notice that this runs often and should block the cpu as less as possible
 * This is a monad which makes it easier to unit test
 */
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {
  if (queryCache._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.now)() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache._map.values());
  for (var rxQuery of queriesInCache) {
    // filter out queries with subscribers
    if (countRxQuerySubscribers(rxQuery) > 0) {
      continue;
    }
    // directly uncache queries that never executed and are older than unExecutedLifetime
    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache, rxQuery);
      continue;
    }
    maybeUncache.push(rxQuery);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));
};
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();

/**
 * Triggers the cache replacement policy after waitTime has passed.
 * We do not run this directly because at exactly the time a query is created,
 * we need all CPU to minimize latency.
 * Also this should not be triggered multiple times when waitTime is still waiting.
 */
function triggerCacheReplacement(rxCollection) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {
    // already started
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);

  /**
   * Do not run directly to not reduce result latency of a new query
   */
  (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.nextTick)() // wait at least one tick
  .then(() => (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.requestIdlePromise)(200)) // and then wait for the CPU to be idle
  .then(() => {
    if (!rxCollection.closed) {
      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);
  });
}
//# sourceMappingURL=query-cache.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/query-planner.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/query-planner.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INDEX_MAX: () => (/* binding */ INDEX_MAX),
/* harmony export */   INDEX_MIN: () => (/* binding */ INDEX_MIN),
/* harmony export */   LOGICAL_OPERATORS: () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   LOWER_BOUND_LOGICAL_OPERATORS: () => (/* binding */ LOWER_BOUND_LOGICAL_OPERATORS),
/* harmony export */   UPPER_BOUND_LOGICAL_OPERATORS: () => (/* binding */ UPPER_BOUND_LOGICAL_OPERATORS),
/* harmony export */   getMatcherQueryOpts: () => (/* binding */ getMatcherQueryOpts),
/* harmony export */   getQueryPlan: () => (/* binding */ getQueryPlan),
/* harmony export */   isSelectorSatisfiedByIndex: () => (/* binding */ isSelectorSatisfiedByIndex),
/* harmony export */   rateQueryPlan: () => (/* binding */ rateQueryPlan)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");



var INDEX_MAX = String.fromCharCode(65535);

/**
 * Do not use -Infinity here because it would be
 * transformed to null on JSON.stringify() which can break things
 * when the query plan is send to the storage as json.
 * @link https://stackoverflow.com/a/16644751
 * Notice that for IndexedDB IDBKeyRange we have
 * to transform the value back to -Infinity
 * before we can use it in IDBKeyRange.bound.
 */
var INDEX_MIN = Number.MIN_SAFE_INTEGER;

/**
 * Returns the query plan which contains
 * information about how to run the query
 * and which indexes to use.
 *
 * This is used in some storage like Memory, dexie.js and IndexedDB.
 */
function getQueryPlan(schema, query) {
  var selector = query.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query.index) {
    indexes = [query.index];
  }

  /**
   * Most storages do not support descending indexes
   * so having a 'desc' in the sorting, means we always have to re-sort the results.
   */
  var hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');

  /**
   * Some fields can be part of the selector while not being relevant for sorting
   * because their selector operators specify that in all cases all matching docs
   * would have the same value.
   * For example the boolean field _deleted.
   * TODO similar thing could be done for enums.
   */
  var sortIrrelevevantFields = new Set();
  Object.keys(selector).forEach(fieldName => {
    var schemaPart = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaByObjectPath)(schema, fieldName);
    if (schemaPart && schemaPart.type === 'boolean' && Object.prototype.hasOwnProperty.call(selector[fieldName], '$eq')) {
      sortIrrelevevantFields.add(fieldName);
    }
  });
  var optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.filter(f => !sortIrrelevevantFields.has(f)).join(',');
  var currentBestQuality = -1;
  var currentBestQueryPlan;

  /**
   * Calculate one query plan for each index
   * and then test which of the plans is best.
   */
  indexes.forEach(index => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index.map(indexField => {
      var matcher = selector[indexField];
      var operators = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators.forEach(operator => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }

      // fill missing attributes
      if (typeof matcherOpts.startKey === 'undefined') {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === 'undefined') {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === 'undefined') {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === 'undefined') {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var startKeys = opts.map(opt => opt.startKey);
    var endKeys = opts.map(opt => opt.endKey);
    var queryPlan = {
      index,
      startKeys,
      endKeys,
      inclusiveEnd,
      inclusiveStart,
      sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter(f => !sortIrrelevevantFields.has(f)).join(','),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)
    };
    var quality = rateQueryPlan(schema, query, queryPlan);
    if (quality >= currentBestQuality || query.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });

  /**
   * In all cases and index must be found
   */
  if (!currentBestQueryPlan) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_1__.newRxError)('SNH', {
      query
    });
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);
var LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);
var UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);
function isSelectorSatisfiedByIndex(index, selector, startKeys, endKeys) {
  /**
   * Not satisfied if one or more operators are non-logical
   * operators that can never be satisfied by an index.
   */
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {
    if (!index.includes(fieldName)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }

  /**
   * Not satisfied if contains $and or $or operations.
   */
  if (selector.$and || selector.$or) {
    return false;
  }

  // ensure all lower bound in index
  var satisfieldLowerBound = [];
  var lowerOperatorFieldNames = new Set();
  for (var [fieldName, operation] of Object.entries(selector)) {
    if (!index.includes(fieldName)) {
      return false;
    }

    // If more then one logic op on the same field, we have to selector-match.
    var lowerLogicOps = Object.keys(operation).filter(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (lowerLogicOps.length > 1) {
      return false;
    }
    var hasLowerLogicOp = lowerLogicOps[0];
    if (hasLowerLogicOp) {
      lowerOperatorFieldNames.add(fieldName);
    }
    if (hasLowerLogicOp !== '$eq') {
      if (satisfieldLowerBound.length > 0) {
        return false;
      } else {
        satisfieldLowerBound.push(hasLowerLogicOp);
      }
    }
  }

  // ensure all upper bound in index
  var satisfieldUpperBound = [];
  var upperOperatorFieldNames = new Set();
  for (var [_fieldName, _operation] of Object.entries(selector)) {
    if (!index.includes(_fieldName)) {
      return false;
    }

    // If more then one logic op on the same field, we have to selector-match.
    var upperLogicOps = Object.keys(_operation).filter(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (upperLogicOps.length > 1) {
      return false;
    }
    var hasUperLogicOp = upperLogicOps[0];
    if (hasUperLogicOp) {
      upperOperatorFieldNames.add(_fieldName);
    }
    if (hasUperLogicOp !== '$eq') {
      if (satisfieldUpperBound.length > 0) {
        return false;
      } else {
        satisfieldUpperBound.push(hasUperLogicOp);
      }
    }
  }

  /**
   * If the index contains a non-relevant field between
   * the relevant fields, then the index is not satisfying.
   */
  var i = 0;
  for (var _fieldName2 of index) {
    for (var set of [lowerOperatorFieldNames, upperOperatorFieldNames]) {
      if (!set.has(_fieldName2) && set.size > 0) {
        return false;
      }
      set.delete(_fieldName2);
    }
    var startKey = startKeys[i];
    var endKey = endKeys[i];
    if (startKey !== endKey && lowerOperatorFieldNames.size > 0 && upperOperatorFieldNames.size > 0) {
      return false;
    }
    i++;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case '$eq':
      return {
        startKey: operatorValue,
        endKey: operatorValue,
        inclusiveEnd: true,
        inclusiveStart: true
      };
    case '$lte':
      return {
        endKey: operatorValue,
        inclusiveEnd: true
      };
    case '$gte':
      return {
        startKey: operatorValue,
        inclusiveStart: true
      };
    case '$lt':
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case '$gt':
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error('SNH');
  }
}

/**
 * Returns a number that determines the quality of the query plan.
 * Higher number means better query plan.
 */
function rateQueryPlan(schema, query, queryPlan) {
  var quality = 0;
  var addQuality = value => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.countUntilNotMatching)(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.countUntilNotMatching)(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.countUntilNotMatching)(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}
//# sourceMappingURL=query-planner.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCheckpointKey: () => (/* binding */ getCheckpointKey),
/* harmony export */   getLastCheckpointDoc: () => (/* binding */ getLastCheckpointDoc),
/* harmony export */   setCheckpoint: () => (/* binding */ setCheckpoint)
/* harmony export */ });
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");



async function getLastCheckpointDoc(state, direction) {
  var checkpointDocId = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
    isCheckpoint: '1',
    itemId: direction
  });
  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);
  var checkpointDoc = checkpointResult[0];
  state.lastCheckpointDoc[direction] = checkpointDoc;
  if (checkpointDoc) {
    return checkpointDoc.checkpointData;
  } else {
    return undefined;
  }
}

/**
 * Sets the checkpoint,
 * automatically resolves conflicts that appear.
 */
async function setCheckpoint(state, direction, checkpoint) {
  state.checkpointQueue = state.checkpointQueue.then(async () => {
    var previousCheckpointDoc = state.lastCheckpointDoc[direction];
    if (checkpoint &&
    /**
     * If the replication is already canceled,
     * we do not write a checkpoint
     * because that could mean we write a checkpoint
     * for data that has been fetched from the master
     * but not been written to the child.
     */
    !state.events.canceled.getValue() && (
    /**
     * Only write checkpoint if it is different from before
     * to have less writes to the storage.
     */

    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {
      var newDoc = {
        id: '',
        isCheckpoint: '1',
        itemId: direction,
        _deleted: false,
        _attachments: {},
        checkpointData: checkpoint,
        _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRxDocumentMeta)(),
        _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRevision)()
      };
      newDoc.id = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newDoc);
      while (!state.events.canceled.getValue()) {
        /**
         * Instead of just storing the new checkpoint,
         * we have to stack up the checkpoint with the previous one.
         * This is required for plugins like the sharding RxStorage
         * where the changeStream events only contain a Partial of the
         * checkpoint.
         */
        if (previousCheckpointDoc) {
          newDoc.checkpointData = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__.stackCheckpoints)([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);
        }
        newDoc._meta.lwt = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.now)();
        newDoc._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.createRevision)(await state.checkpointKey, previousCheckpointDoc);
        if (state.events.canceled.getValue()) {
          return;
        }
        var writeRows = [{
          previous: previousCheckpointDoc,
          document: newDoc
        }];
        var result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');
        var successDoc = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_2__.getWrittenDocumentsFromBulkWriteResponse)(state.primaryPath, writeRows, result)[0];
        if (successDoc) {
          state.lastCheckpointDoc[direction] = successDoc;
          return;
        } else {
          var error = result.error[0];
          if (error.status !== 409) {
            throw error;
          } else {
            previousCheckpointDoc = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(error.documentInDb);
            newDoc._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.createRevision)(await state.checkpointKey, previousCheckpointDoc);
          }
        }
      }
    }
  });
  await state.checkpointQueue;
}
async function getCheckpointKey(input) {
  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));
  return 'rx_storage_replication_' + hash;
}
//# sourceMappingURL=checkpoint.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/conflicts.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/conflicts.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveConflictError: () => (/* binding */ resolveConflictError)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");


/**
 * Resolves a conflict error or determines that the given document states are equal.
 * Returns the resolved document that must be written to the fork.
 * Then the new document state can be pushed upstream.
 * If document is not in conflict, returns undefined.
 * If error is non-409, it throws an error.
 * Conflicts are only solved in the upstream, never in the downstream.
 */
async function resolveConflictError(state, input, forkState) {
  var conflictHandler = state.input.conflictHandler;
  var isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');
  if (isEqual) {
    /**
     * Documents are equal,
     * so this is not a conflict -> do nothing.
     */
    return undefined;
  } else {
    var resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');
    /**
     * We have a resolved conflict,
     * use the resolved document data.
     */
    var resolvedDoc = Object.assign({}, resolved, {
      /**
       * Because the resolved conflict is written to the fork,
       * we have to keep/update the forks _meta data, not the masters.
       */
      _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.flatClone)(forkState._meta),
      _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRevision)(),
      _attachments: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.flatClone)(forkState._attachments)
    });
    resolvedDoc._meta.lwt = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.now)();
    resolvedDoc._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.createRevision)(await state.checkpointKey, forkState);
    return resolvedDoc;
  }
}
//# sourceMappingURL=conflicts.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultConflictHandler: () => (/* binding */ defaultConflictHandler)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");


var defaultConflictHandler = {
  isEqual(a, b) {
    /**
     * If the documents are deep equal,
     * we have no conflict.
     * On your custom conflict handler you might only
     * check some properties, like the updatedAt time,
     * for better performance, because deepEqual is expensive.
     */
    return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.deepEqual)((0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_1__.stripAttachmentsDataFromDocument)(a), (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_1__.stripAttachmentsDataFromDocument)(b));
  },
  resolve(i) {
    /**
     * The default conflict handler will always
     * drop the fork state and use the master state instead.
     */
    return i.realMasterState;
  }
};
//# sourceMappingURL=default-conflict-handler.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/downstream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/downstream.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startReplicationDownstream: () => (/* binding */ startReplicationDownstream)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkpoint.js */ "./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helper.js */ "./node_modules/rxdb/dist/esm/replication-protocol/helper.js");
/* harmony import */ var _meta_instance_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./meta-instance.js */ "./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js");








/**
 * Writes all documents from the master to the fork.
 * The downstream has two operation modes
 * - Sync by iterating over the checkpoints via downstreamResyncOnce()
 * - Sync by listening to the changestream via downstreamProcessChanges()
 * We need this to be able to do initial syncs
 * and still can have fast event based sync when the client is not offline.
 */
async function startReplicationDownstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {
    var checkpointDoc = await (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getLastCheckpointDoc)(state, 'down');
    if (!checkpointDoc) {
      await (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.setCheckpoint)(state, 'down', state.input.initialCheckpoint.downstream);
    }
  }
  var identifierHash = await state.input.hashFunction(state.input.identifier);
  var replicationHandler = state.input.replicationHandler;

  // used to detect which tasks etc can in it at which order.
  var timer = 0;
  var openTasks = [];
  function addNewTask(task) {
    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;
    var taskWithTime = {
      time: timer++,
      task
    };
    openTasks.push(taskWithTime);
    state.streamQueue.down = state.streamQueue.down.then(() => {
      var useTasks = [];
      while (openTasks.length > 0) {
        state.events.active.down.next(true);
        var innerTaskWithTime = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(openTasks.shift());

        /**
         * If the task came in before the last time we started the pull
         * from the master, then we can drop the task.
         */
        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {
          continue;
        }
        if (innerTaskWithTime.task === 'RESYNC') {
          if (useTasks.length === 0) {
            useTasks.push(innerTaskWithTime.task);
            break;
          } else {
            break;
          }
        }
        useTasks.push(innerTaskWithTime.task);
      }
      if (useTasks.length === 0) {
        return;
      }
      if (useTasks[0] === 'RESYNC') {
        return downstreamResyncOnce();
      } else {
        return downstreamProcessChanges(useTasks);
      }
    }).then(() => {
      state.events.active.down.next(false);
      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {
        state.firstSyncDone.down.next(true);
      }
    });
  }
  addNewTask('RESYNC');

  /**
   * If a write on the master happens, we have to trigger the downstream.
   * Only do this if not canceled yet, otherwise firstValueFrom errors
   * when running on a completed observable.
   */
  if (!state.events.canceled.getValue()) {
    var sub = replicationHandler.masterChangeStream$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.mergeMap)(async ev => {
      /**
       * While a push is running, we have to delay all incoming
       * events from the server to not mix up the replication state.
       */
      await (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.firstValueFrom)(state.events.active.up.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.filter)(s => !s)));
      return ev;
    })).subscribe(task => {
      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;
      addNewTask(task);
    });
    // unsubscribe when replication is canceled
    (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.firstValueFrom)(state.events.canceled.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.filter)(canceled => !!canceled))).then(() => sub.unsubscribe());
  }

  /**
   * For faster performance, we directly start each write
   * and then await all writes at the end.
   */
  var lastTimeMasterChangesRequested = -1;
  async function downstreamResyncOnce() {
    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getLastCheckpointDoc)(state, 'down'));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      lastTimeMasterChangesRequested = timer++;
      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);
      if (downResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__.stackCheckpoints)([lastCheckpoint, downResult.checkpoint]);
      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));

      /**
       * By definition we stop pull when the pulled documents
       * do not fill up the pullBatchSize because we
       * can assume that the remote has no more documents.
       */
      if (downResult.documents.length < state.input.pullBatchSize) {
        break;
      }
    }
    await Promise.all(promises);
  }
  function downstreamProcessChanges(tasks) {
    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;
    var docsOfAllTasks = [];
    var lastCheckpoint = null;
    tasks.forEach(task => {
      if (task === 'RESYNC') {
        throw new Error('SNH');
      }
      (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.appendToArray)(docsOfAllTasks, task.documents);
      lastCheckpoint = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__.stackCheckpoints)([lastCheckpoint, task.checkpoint]);
    });
    return persistFromMaster(docsOfAllTasks, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(lastCheckpoint));
  }

  /**
   * It can happen that the calls to masterChangesSince() or the changeStream()
   * are way faster then how fast the documents can be persisted.
   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object
   * and process them together if possible.
   * This often bundles up single writes and improves performance
   * by processing the documents in bulks.
   */
  var persistenceQueue = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.PROMISE_RESOLVE_VOID;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistFromMaster(docs, checkpoint) {
    var primaryPath = state.primaryPath;
    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;

    /**
     * Add the new docs to the non-persistent list
     */
    docs.forEach(docData => {
      var docId = docData[primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint;

    /**
     * Run in the queue
     * with all open documents from nonPersistedFromMaster.
     */
    persistenceQueue = persistenceQueue.then(() => {
      var downDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(downDocsById);
      if (state.events.canceled.getValue() || docIds.length === 0) {
        return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.PROMISE_RESOLVE_VOID;
      }
      var writeRowsToFork = [];
      var writeRowsToForkById = {};
      var writeRowsToMeta = {};
      var useMetaWriteRows = [];
      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_8__.getAssumedMasterState)(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {
        var currentForkState = new Map();
        currentForkStateList.forEach(doc => currentForkState.set(doc[primaryPath], doc));
        return Promise.all(docIds.map(async docId => {
          var forkStateFullDoc = currentForkState.get(docId);
          var forkStateDocData = forkStateFullDoc ? (0,_helper_js__WEBPACK_IMPORTED_MODULE_9__.writeDocToDocState)(forkStateFullDoc, state.hasAttachments, false) : undefined;
          var masterState = downDocsById[docId];
          var assumedMaster = assumedMasterState[docId];
          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {
            /**
             * The current fork state represents a resolved conflict
             * that first must be send to the master in the upstream.
             * All conflicts are resolved by the upstream.
             */
            // return PROMISE_RESOLVE_VOID;
            await state.streamQueue.up;
          }
          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : state.input.conflictHandler.isEqual(assumedMaster.docData, forkStateDocData, 'downstream-check-if-equal-0');
          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getHeightOfRevision)(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {
            isAssumedMasterEqualToForkState = true;
          }
          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {
            /**
             * We have a non-upstream-replicated
             * local write to the fork.
             * This means we ignore the downstream of this document
             * because anyway the upstream will first resolve the conflict.
             */
            return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.PROMISE_RESOLVE_VOID;
          }
          var areStatesExactlyEqual = !forkStateDocData ? false : state.input.conflictHandler.isEqual(masterState, forkStateDocData, 'downstream-check-if-equal-1');
          if (forkStateDocData && areStatesExactlyEqual) {
            /**
             * Document states are exactly equal.
             * This can happen when the replication is shut down
             * unexpected like when the user goes offline.
             *
             * Only when the assumedMaster is different from the forkState,
             * we have to patch the document in the meta instance.
             */
            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {
              useMetaWriteRows.push(await (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_8__.getMetaWriteRow)(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));
            }
            return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.PROMISE_RESOLVE_VOID;
          }

          /**
           * All other master states need to be written to the forkInstance
           * and metaInstance.
           */
          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {
            _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.flatClone)(forkStateFullDoc._meta),
            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},
            _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getDefaultRevision)()
          } : {
            _meta: {
              lwt: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.now)()
            },
            _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getDefaultRevision)(),
            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}
          });
          /**
           * If the remote works with revisions,
           * we store the height of the next fork-state revision
           * inside of the documents meta data.
           * By doing so we can filter it out in the upstream
           * and detect the document as being equal to master or not.
           * This is used for example in the CouchDB replication plugin.
           */
          if (masterState._rev) {
            var nextRevisionHeight = !forkStateFullDoc ? 1 : (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getHeightOfRevision)(forkStateFullDoc._rev) + 1;
            newForkState._meta[state.input.identifier] = nextRevisionHeight;
            if (state.input.keepMeta) {
              newForkState._rev = masterState._rev;
            }
          }
          if (state.input.keepMeta && masterState._meta) {
            newForkState._meta = masterState._meta;
          }
          var forkWriteRow = {
            previous: forkStateFullDoc,
            document: newForkState
          };
          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.createRevision)(identifierHash, forkWriteRow.previous);
          writeRowsToFork.push(forkWriteRow);
          writeRowsToForkById[docId] = forkWriteRow;
          writeRowsToMeta[docId] = await (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_8__.getMetaWriteRow)(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);
        }));
      }).then(async () => {
        if (writeRowsToFork.length > 0) {
          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then(forkWriteResult => {
            var success = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_5__.getWrittenDocumentsFromBulkWriteResponse)(state.primaryPath, writeRowsToFork, forkWriteResult);
            success.forEach(doc => {
              var docId = doc[primaryPath];
              state.events.processed.down.next(writeRowsToForkById[docId]);
              useMetaWriteRows.push(writeRowsToMeta[docId]);
            });
            var mustThrow;
            forkWriteResult.error.forEach(error => {
              /**
               * We do not have to care about downstream conflict errors here
               * because on conflict, it will be solved locally and result in another write.
               */
              if (error.status === 409) {
                return;
              }
              // other non-conflict errors must be handled
              var throwMe = (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_14__.newRxError)('RC_PULL', {
                writeError: error
              });
              state.events.error.next(throwMe);
              mustThrow = throwMe;
            });
            if (mustThrow) {
              throw mustThrow;
            }
          });
        }
      }).then(() => {
        if (useMetaWriteRows.length > 0) {
          return state.input.metaInstance.bulkWrite((0,_helper_js__WEBPACK_IMPORTED_MODULE_9__.stripAttachmentsDataFromMetaWriteRows)(state, useMetaWriteRows), 'replication-down-write-meta').then(metaWriteResult => {
            metaWriteResult.error.forEach(writeError => {
              state.events.error.next((0,_rx_error_js__WEBPACK_IMPORTED_MODULE_14__.newRxError)('RC_PULL', {
                id: writeError.documentId,
                writeError
              }));
            });
          });
        }
      }).then(() => {
        /**
         * For better performance we do not await checkpoint writes,
         * but to ensure order on parallel checkpoint writes,
         * we have to use a queue.
         */
        (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.setCheckpoint)(state, 'down', useCheckpoint);
      });
    }).catch(unhandledError => state.events.error.next(unhandledError));
    return persistenceQueue;
  }
}
//# sourceMappingURL=downstream.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   docStateToWriteDoc: () => (/* binding */ docStateToWriteDoc),
/* harmony export */   getUnderlyingPersistentStorage: () => (/* binding */ getUnderlyingPersistentStorage),
/* harmony export */   stripAttachmentsDataFromMetaWriteRows: () => (/* binding */ stripAttachmentsDataFromMetaWriteRows),
/* harmony export */   writeDocToDocState: () => (/* binding */ writeDocToDocState)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");


function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {
  var docData = Object.assign({}, docState, {
    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},
    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {
      lwt: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.now)()
    }),
    _rev: keepMeta ? docState._rev : (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultRevision)()
  });
  if (!docData._rev) {
    docData._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.createRevision)(databaseInstanceToken, previous);
  }
  return docData;
}
function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {
  var ret = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.flatClone)(writeDoc);
  if (!keepAttachments) {
    delete ret._attachments;
  }
  if (!keepMeta) {
    delete ret._meta;
    delete ret._rev;
  }
  return ret;
}
function stripAttachmentsDataFromMetaWriteRows(state, rows) {
  if (!state.hasAttachments) {
    return rows;
  }
  return rows.map(row => {
    var document = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.clone)(row.document);
    document.docData = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.stripAttachmentsDataFromDocument)(document.docData);
    return {
      document,
      previous: row.previous
    };
  });
}
function getUnderlyingPersistentStorage(instance) {
  while (true) {
    if (instance.underlyingPersistentStorage) {
      instance = instance.underlyingPersistentStorage;
    } else {
      return instance;
    }
  }
}
//# sourceMappingURL=helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   META_INSTANCE_SCHEMA_TITLE: () => (/* reexport safe */ _meta_instance_js__WEBPACK_IMPORTED_MODULE_3__.META_INSTANCE_SCHEMA_TITLE),
/* harmony export */   awaitRxStorageReplicationFirstInSync: () => (/* binding */ awaitRxStorageReplicationFirstInSync),
/* harmony export */   awaitRxStorageReplicationIdle: () => (/* binding */ awaitRxStorageReplicationIdle),
/* harmony export */   awaitRxStorageReplicationInSync: () => (/* binding */ awaitRxStorageReplicationInSync),
/* harmony export */   cancelRxStorageReplication: () => (/* binding */ cancelRxStorageReplication),
/* harmony export */   defaultConflictHandler: () => (/* reexport safe */ _default_conflict_handler_js__WEBPACK_IMPORTED_MODULE_6__.defaultConflictHandler),
/* harmony export */   docStateToWriteDoc: () => (/* reexport safe */ _helper_js__WEBPACK_IMPORTED_MODULE_5__.docStateToWriteDoc),
/* harmony export */   getAssumedMasterState: () => (/* reexport safe */ _meta_instance_js__WEBPACK_IMPORTED_MODULE_3__.getAssumedMasterState),
/* harmony export */   getCheckpointKey: () => (/* reexport safe */ _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getCheckpointKey),
/* harmony export */   getLastCheckpointDoc: () => (/* reexport safe */ _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getLastCheckpointDoc),
/* harmony export */   getMetaWriteRow: () => (/* reexport safe */ _meta_instance_js__WEBPACK_IMPORTED_MODULE_3__.getMetaWriteRow),
/* harmony export */   getRxReplicationMetaInstanceSchema: () => (/* reexport safe */ _meta_instance_js__WEBPACK_IMPORTED_MODULE_3__.getRxReplicationMetaInstanceSchema),
/* harmony export */   getUnderlyingPersistentStorage: () => (/* reexport safe */ _helper_js__WEBPACK_IMPORTED_MODULE_5__.getUnderlyingPersistentStorage),
/* harmony export */   replicateRxStorageInstance: () => (/* binding */ replicateRxStorageInstance),
/* harmony export */   resolveConflictError: () => (/* reexport safe */ _conflicts_js__WEBPACK_IMPORTED_MODULE_4__.resolveConflictError),
/* harmony export */   rxStorageInstanceToReplicationHandler: () => (/* binding */ rxStorageInstanceToReplicationHandler),
/* harmony export */   setCheckpoint: () => (/* reexport safe */ _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.setCheckpoint),
/* harmony export */   startReplicationDownstream: () => (/* reexport safe */ _downstream_js__WEBPACK_IMPORTED_MODULE_1__.startReplicationDownstream),
/* harmony export */   startReplicationUpstream: () => (/* reexport safe */ _upstream_js__WEBPACK_IMPORTED_MODULE_2__.startReplicationUpstream),
/* harmony export */   stripAttachmentsDataFromMetaWriteRows: () => (/* reexport safe */ _helper_js__WEBPACK_IMPORTED_MODULE_5__.stripAttachmentsDataFromMetaWriteRows),
/* harmony export */   writeDocToDocState: () => (/* reexport safe */ _helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkpoint.js */ "./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js");
/* harmony import */ var _downstream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./downstream.js */ "./node_modules/rxdb/dist/esm/replication-protocol/downstream.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper.js */ "./node_modules/rxdb/dist/esm/replication-protocol/helper.js");
/* harmony import */ var _upstream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./upstream.js */ "./node_modules/rxdb/dist/esm/replication-protocol/upstream.js");
/* harmony import */ var _plugins_attachments_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../plugins/attachments/index.js */ "./node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _meta_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./meta-instance.js */ "./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js");
/* harmony import */ var _conflicts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./conflicts.js */ "./node_modules/rxdb/dist/esm/replication-protocol/conflicts.js");
/* harmony import */ var _default_conflict_handler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./default-conflict-handler.js */ "./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js");
/**
 * These files contain the replication protocol.
 * It can be used to replicated RxStorageInstances or RxCollections
 * or even to do a client(s)-server replication.
 */


















function replicateRxStorageInstance(input) {
  input = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.flatClone)(input);
  input.forkInstance = (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.getUnderlyingPersistentStorage)(input.forkInstance);
  input.metaInstance = (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.getUnderlyingPersistentStorage)(input.metaInstance);
  var checkpointKeyPromise = (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getCheckpointKey)(input);
  var state = {
    primaryPath: (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_8__.getPrimaryFieldOfPrimaryKey)(input.forkInstance.schema.primaryKey),
    hasAttachments: !!input.forkInstance.schema.attachments,
    input,
    checkpointKey: checkpointKeyPromise,
    downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),
    events: {
      canceled: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(false),
      paused: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(false),
      active: {
        down: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(true),
        up: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(true)
      },
      processed: {
        down: new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject(),
        up: new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject()
      },
      resolvedConflicts: new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject(),
      error: new rxjs__WEBPACK_IMPORTED_MODULE_10__.Subject()
    },
    stats: {
      down: {
        addNewTask: 0,
        downstreamProcessChanges: 0,
        downstreamResyncOnce: 0,
        masterChangeStreamEmit: 0,
        persistFromMaster: 0
      },
      up: {
        forkChangeStreamEmit: 0,
        persistToMaster: 0,
        persistToMasterConflictWrites: 0,
        persistToMasterHadConflicts: 0,
        processTasks: 0,
        upstreamInitialSync: 0
      }
    },
    firstSyncDone: {
      down: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(false),
      up: new rxjs__WEBPACK_IMPORTED_MODULE_9__.BehaviorSubject(false)
    },
    streamQueue: {
      down: _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID,
      up: _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID
    },
    checkpointQueue: _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID,
    lastCheckpointDoc: {}
  };
  (0,_downstream_js__WEBPACK_IMPORTED_MODULE_1__.startReplicationDownstream)(state);
  (0,_upstream_js__WEBPACK_IMPORTED_MODULE_2__.startReplicationUpstream)(state);
  return state;
}
function awaitRxStorageReplicationFirstInSync(state) {
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.firstValueFrom)((0,rxjs__WEBPACK_IMPORTED_MODULE_13__.combineLatest)([state.firstSyncDone.down.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_14__.filter)(v => !!v)), state.firstSyncDone.up.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_14__.filter)(v => !!v))])).then(() => {});
}
function awaitRxStorageReplicationInSync(replicationState) {
  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);
}
async function awaitRxStorageReplicationIdle(state) {
  await awaitRxStorageReplicationFirstInSync(state);
  while (true) {
    var {
      down,
      up
    } = state.streamQueue;
    await Promise.all([up, down]);
    /**
     * If the Promises have not been reassigned
     * after awaiting them, we know that the replication
     * is in idle state at this point in time.
     */
    if (down === state.streamQueue.down && up === state.streamQueue.up) {
      return;
    }
  }
}
function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken,
/**
 * If set to true,
 * the _meta.lwt from the pushed documents is kept.
 * (Used in the migration to ensure checkpoints are still valid)
 */
keepMeta = false) {
  instance = (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.getUnderlyingPersistentStorage)(instance);
  var hasAttachments = !!instance.schema.attachments;
  var primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_8__.getPrimaryFieldOfPrimaryKey)(instance.schema.primaryKey);
  var replicationHandler = {
    masterChangeStream$: instance.changeStream().pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_15__.mergeMap)(async eventBulk => {
      var ret = {
        checkpoint: eventBulk.checkpoint,
        documents: await Promise.all(eventBulk.events.map(async event => {
          var docData = (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)(event.documentData, hasAttachments, keepMeta);
          if (hasAttachments) {
            docData = await (0,_plugins_attachments_index_js__WEBPACK_IMPORTED_MODULE_16__.fillWriteDataForAttachmentsChange)(primaryPath, instance, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.clone)(docData),
            /**
             * Notice that the master never knows
             * the client state of the document.
             * Therefore we always send all attachments data.
             */
            undefined);
          }
          return docData;
        }))
      };
      return ret;
    })),
    masterChangesSince(checkpoint, batchSize) {
      return (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_17__.getChangedDocumentsSince)(instance, batchSize, checkpoint).then(async result => {
        return {
          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,
          documents: await Promise.all(result.documents.map(async plainDocumentData => {
            var docData = (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)(plainDocumentData, hasAttachments, keepMeta);
            if (hasAttachments) {
              docData = await (0,_plugins_attachments_index_js__WEBPACK_IMPORTED_MODULE_16__.fillWriteDataForAttachmentsChange)(primaryPath, instance, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.clone)(docData),
              /**
               * Notice the the master never knows
               * the client state of the document.
               * Therefore we always send all attachments data.
               */
              undefined);
            }
            return docData;
          }))
        };
      });
    },
    async masterWrite(rows) {
      var rowById = {};
      rows.forEach(row => {
        var docId = row.newDocumentState[primaryPath];
        rowById[docId] = row;
      });
      var ids = Object.keys(rowById);
      var masterDocsStateList = await instance.findDocumentsById(ids, true);
      var masterDocsState = new Map();
      masterDocsStateList.forEach(doc => masterDocsState.set(doc[primaryPath], doc));
      var conflicts = [];
      var writeRows = [];
      await Promise.all(Object.entries(rowById).map(([id, row]) => {
        var masterState = masterDocsState.get(id);
        if (!masterState) {
          writeRows.push({
            document: (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.docStateToWriteDoc)(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)
          });
        } else if (masterState && !row.assumedMasterState) {
          conflicts.push((0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)(masterState, hasAttachments, keepMeta));
        } else if (conflictHandler.isEqual((0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)(masterState, hasAttachments, keepMeta), (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.ensureNotFalsy)(row.assumedMasterState), 'rxStorageInstanceToReplicationHandler-masterWrite') === true) {
          writeRows.push({
            previous: masterState,
            document: (0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.docStateToWriteDoc)(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)
          });
        } else {
          conflicts.push((0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)(masterState, hasAttachments, keepMeta));
        }
      }));
      if (writeRows.length > 0) {
        var result = await instance.bulkWrite(writeRows, 'replication-master-write');
        result.error.forEach(err => {
          if (err.status !== 409) {
            throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_19__.newRxError)('SNH', {
              name: 'non conflict error',
              error: err
            });
          } else {
            conflicts.push((0,_helper_js__WEBPACK_IMPORTED_MODULE_5__.writeDocToDocState)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.ensureNotFalsy)(err.documentInDb), hasAttachments, keepMeta));
          }
        });
      }
      return conflicts;
    }
  };
  return replicationHandler;
}
async function cancelRxStorageReplication(replicationState) {
  replicationState.events.canceled.next(true);
  replicationState.events.active.up.complete();
  replicationState.events.active.down.complete();
  replicationState.events.processed.up.complete();
  replicationState.events.processed.down.complete();
  replicationState.events.resolvedConflicts.complete();
  replicationState.events.canceled.complete();
  await replicationState.checkpointQueue;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   META_INSTANCE_SCHEMA_TITLE: () => (/* binding */ META_INSTANCE_SCHEMA_TITLE),
/* harmony export */   getAssumedMasterState: () => (/* binding */ getAssumedMasterState),
/* harmony export */   getMetaWriteRow: () => (/* binding */ getMetaWriteRow),
/* harmony export */   getRxReplicationMetaInstanceSchema: () => (/* binding */ getRxReplicationMetaInstanceSchema)
/* harmony export */ });
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");



var META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';
function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {
  var parentPrimaryKeyLength = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getLengthOfPrimaryKey)(replicatedDocumentsSchema);
  var baseSchema = {
    title: META_INSTANCE_SCHEMA_TITLE,
    primaryKey: {
      key: 'id',
      fields: ['itemId', 'isCheckpoint'],
      separator: '|'
    },
    type: 'object',
    version: replicatedDocumentsSchema.version,
    additionalProperties: false,
    properties: {
      id: {
        type: 'string',
        minLength: 1,
        // add +1 for the '|' and +1 for the 'isCheckpoint' flag
        maxLength: parentPrimaryKeyLength + 2
      },
      isCheckpoint: {
        type: 'string',
        enum: ['0', '1'],
        minLength: 1,
        maxLength: 1
      },
      itemId: {
        type: 'string',
        /**
         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it
         * because checkpoints use the itemId field for that.
         */
        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4
      },
      checkpointData: {
        type: 'object',
        additionalProperties: true
      },
      docData: {
        type: 'object',
        properties: replicatedDocumentsSchema.properties
      },
      isResolvedConflict: {
        type: 'string'
      }
    },
    keyCompression: replicatedDocumentsSchema.keyCompression,
    required: ['id', 'isCheckpoint', 'itemId']
  };
  if (encrypted) {
    baseSchema.encrypted = ['docData'];
  }
  var metaInstanceSchema = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.fillWithDefaultSettings)(baseSchema);
  return metaInstanceSchema;
}

/**
 * Returns the document states of what the fork instance
 * assumes to be the latest state on the master instance.
 */
function getAssumedMasterState(state, docIds) {
  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {
    var useId = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
      itemId: docId,
      isCheckpoint: '0'
    });
    return useId;
  }), true).then(metaDocs => {
    var ret = {};
    Object.values(metaDocs).forEach(metaDoc => {
      ret[metaDoc.itemId] = {
        docData: metaDoc.docData,
        metaDocument: metaDoc
      };
    });
    return ret;
  });
}
async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {
  var docId = newMasterDocState[state.primaryPath];
  var newMeta = previous ? (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_1__.flatCloneDocWithMeta)(previous) : {
    id: '',
    isCheckpoint: '0',
    itemId: docId,
    docData: newMasterDocState,
    _attachments: {},
    _deleted: false,
    _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultRevision)(),
    _meta: {
      lwt: 0
    }
  };
  newMeta.docData = newMasterDocState;

  /**
   * Sending isResolvedConflict with the value undefined
   * will throw a schema validation error because it must be either
   * not set or have a string.
   */
  if (isResolvedConflict) {
    newMeta.isResolvedConflict = isResolvedConflict;
  }
  newMeta._meta.lwt = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.now)();
  newMeta.id = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newMeta);
  newMeta._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.createRevision)(await state.checkpointKey, previous);
  var ret = {
    previous,
    document: newMeta
  };
  return ret;
}
//# sourceMappingURL=meta-instance.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/replication-protocol/upstream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/replication-protocol/upstream.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startReplicationUpstream: () => (/* binding */ startReplicationUpstream)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _checkpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkpoint.js */ "./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js");
/* harmony import */ var _conflicts_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./conflicts.js */ "./node_modules/rxdb/dist/esm/replication-protocol/conflicts.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helper.js */ "./node_modules/rxdb/dist/esm/replication-protocol/helper.js");
/* harmony import */ var _meta_instance_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./meta-instance.js */ "./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js");
/* harmony import */ var _plugins_attachments_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../plugins/attachments/index.js */ "./node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");










/**
 * Writes all document changes from the fork to the master.
 * The upstream runs on two modes:
 * - For initial replication, a checkpoint-iteration is used
 * - For ongoing local writes, we just subscribe to the changeStream of the fork.
 *   In contrast to the master, the fork can be assumed to never loose connection,
 *   so we do not have to prepare for missed out events.
 */
async function startReplicationUpstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {
    var checkpointDoc = await (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getLastCheckpointDoc)(state, 'up');
    if (!checkpointDoc) {
      await (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.setCheckpoint)(state, 'up', state.input.initialCheckpoint.upstream);
    }
  }
  var replicationHandler = state.input.replicationHandler;
  state.streamQueue.up = state.streamQueue.up.then(() => {
    return upstreamInitialSync().then(() => {
      return processTasks();
    });
  });

  // used to detect which tasks etc can in it at which order.
  var timer = 0;
  var initialSyncStartTime = -1;
  var openTasks = [];
  var persistenceQueue = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.PROMISE_RESOLVE_FALSE;
  var nonPersistedFromMaster = {
    docs: {}
  };
  var sub = state.input.forkInstance.changeStream().subscribe(eventBulk => {
    if (state.events.paused.getValue()) {
      return;
    }
    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;
    openTasks.push({
      task: eventBulk,
      time: timer++
    });
    if (!state.events.active.up.getValue()) {
      state.events.active.up.next(true);
    }
    if (state.input.waitBeforePersist) {
      return state.input.waitBeforePersist().then(() => processTasks());
    } else {
      return processTasks();
    }
  });
  var subResync = replicationHandler.masterChangeStream$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.filter)(ev => ev === 'RESYNC')).subscribe(() => {
    openTasks.push({
      task: 'RESYNC',
      time: timer++
    });
    processTasks();
  });

  // unsubscribe when replication is canceled
  (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.firstValueFrom)(state.events.canceled.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.filter)(canceled => !!canceled))).then(() => {
    sub.unsubscribe();
    subResync.unsubscribe();
  });
  async function upstreamInitialSync() {
    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.getLastCheckpointDoc)(state, 'up'));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = new Set();
    var _loop = async function () {
      initialSyncStartTime = timer++;

      /**
       * Throttle the calls to
       * forkInstance.getChangedDocumentsSince() so that
       * if the pushing to the remote is slower compared to the
       * pulling out of forkInstance, we do not block the UI too much
       * and have a big memory spike with all forkInstance documents.
       */
      if (promises.size > 3) {
        await Promise.race(Array.from(promises));
      }
      var upResult = await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.getChangedDocumentsSince)(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);
      if (upResult.documents.length === 0) {
        return 1; // break
      }
      lastCheckpoint = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.stackCheckpoints)([lastCheckpoint, upResult.checkpoint]);
      var promise = persistToMaster(upResult.documents, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(lastCheckpoint));
      promises.add(promise);
      promise.catch().then(() => promises.delete(promise));
    };
    while (!state.events.canceled.getValue()) {
      if (await _loop()) break;
    }

    /**
     * If we had conflicts during the initial sync,
     * it means that we likely have new writes to the fork
     * and so we have to run the initial sync again to upstream these new writes.
     */
    var resolvedPromises = await Promise.all(promises);
    var hadConflicts = resolvedPromises.find(r => !!r);
    if (hadConflicts) {
      await upstreamInitialSync();
    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {
      state.firstSyncDone.up.next(true);
    }
  }

  /**
   * Takes all open tasks an processes them at once.
   */
  function processTasks() {
    if (state.events.canceled.getValue() || openTasks.length === 0) {
      state.events.active.up.next(false);
      return;
    }
    state.stats.up.processTasks = state.stats.up.processTasks + 1;
    state.events.active.up.next(true);
    state.streamQueue.up = state.streamQueue.up.then(async () => {
      /**
       * Merge/filter all open tasks
       */
      var docs = [];
      var checkpoint = {};
      while (openTasks.length > 0) {
        var taskWithTime = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(openTasks.shift());
        /**
         * If the task came in before the last time the initial sync fetching
         * has run, we can ignore the task because the initial sync already processed
         * these documents.
         */
        if (taskWithTime.time < initialSyncStartTime) {
          continue;
        }
        if (taskWithTime.task === 'RESYNC') {
          state.events.active.up.next(false);
          await upstreamInitialSync();
          return;
        }

        /**
         * If the task came from the downstream, we can ignore these documents
         * because we know they are replicated already.
         * But even if they can be ignored, we later have to call persistToMaster()
         * to have the correct checkpoint set.
         */
        if (taskWithTime.task.context !== (await state.downstreamBulkWriteFlag)) {
          (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.appendToArray)(docs, taskWithTime.task.events.map(r => {
            return r.documentData;
          }));
        }
        checkpoint = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.stackCheckpoints)([checkpoint, taskWithTime.task.checkpoint]);
      }
      await persistToMaster(docs, checkpoint);

      // might have got more tasks while running persistToMaster()
      if (openTasks.length === 0) {
        state.events.active.up.next(false);
      } else {
        return processTasks();
      }
    });
  }

  /**
   * Returns true if had conflicts,
   * false if not.
   */
  function persistToMaster(docs, checkpoint) {
    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;

    /**
     * Add the new docs to the non-persistent list
     */
    docs.forEach(docData => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint;
    persistenceQueue = persistenceQueue.then(async () => {
      if (state.events.canceled.getValue()) {
        return false;
      }
      var upDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(upDocsById);
      /**
       * Even if we do not have anything to push,
       * we still have to store the up-checkpoint.
       * This ensures that when many documents have been pulled
       * from the remote (that do not have to be pushed again),
       * we continue at the correct position and do not have to load
       * these documents from the storage again when the replication is restarted.
       */
      function rememberCheckpointBeforeReturn() {
        return (0,_checkpoint_js__WEBPACK_IMPORTED_MODULE_0__.setCheckpoint)(state, 'up', useCheckpoint);
      }
      ;
      if (docIds.length === 0) {
        rememberCheckpointBeforeReturn();
        return false;
      }
      var assumedMasterState = await (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_7__.getAssumedMasterState)(state, docIds);
      var writeRowsToMaster = {};
      var writeRowsToMasterIds = [];
      var writeRowsToMeta = {};
      var forkStateById = {};
      await Promise.all(docIds.map(async docId => {
        var fullDocData = upDocsById[docId];
        forkStateById[docId] = fullDocData;
        var docData = (0,_helper_js__WEBPACK_IMPORTED_MODULE_8__.writeDocToDocState)(fullDocData, state.hasAttachments, !!state.input.keepMeta);
        var assumedMasterDoc = assumedMasterState[docId];

        /**
         * If the master state is equal to the
         * fork state, we can assume that the document state is already
         * replicated.
         */
        if (assumedMasterDoc &&
        // if the isResolvedConflict is correct, we do not have to compare the documents.
        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && state.input.conflictHandler.isEqual(assumedMasterDoc.docData, docData, 'upstream-check-if-equal') || (
        /**
         * If the master works with _rev fields,
         * we use that to check if our current doc state
         * is different from the assumedMasterDoc.
         */

        assumedMasterDoc && assumedMasterDoc.docData._rev && (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getHeightOfRevision)(fullDocData._rev) === fullDocData._meta[state.input.identifier])) {
          return;
        }
        writeRowsToMasterIds.push(docId);
        writeRowsToMaster[docId] = {
          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,
          newDocumentState: docData
        };
        writeRowsToMeta[docId] = await (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_7__.getMetaWriteRow)(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);
      }));
      if (writeRowsToMasterIds.length === 0) {
        rememberCheckpointBeforeReturn();
        return false;
      }
      var writeRowsArray = Object.values(writeRowsToMaster);
      var conflictIds = new Set();
      var conflictsById = {};

      /**
       * To always respect the push.batchSize,
       * we have to split the write rows into batches
       * to ensure that replicationHandler.masterWrite() is never
       * called with more documents than what the batchSize limits.
       */
      var writeBatches = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.batchArray)(writeRowsArray, state.input.pushBatchSize);
      await Promise.all(writeBatches.map(async writeBatch => {
        // enhance docs with attachments
        if (state.hasAttachments) {
          await Promise.all(writeBatch.map(async row => {
            row.newDocumentState = await (0,_plugins_attachments_index_js__WEBPACK_IMPORTED_MODULE_10__.fillWriteDataForAttachmentsChange)(state.primaryPath, state.input.forkInstance, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.clone)(row.newDocumentState), row.assumedMasterState);
          }));
        }
        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);
        masterWriteResult.forEach(conflictDoc => {
          var id = conflictDoc[state.primaryPath];
          conflictIds.add(id);
          conflictsById[id] = conflictDoc;
        });
      }));
      var useWriteRowsToMeta = [];
      writeRowsToMasterIds.forEach(docId => {
        if (!conflictIds.has(docId)) {
          state.events.processed.up.next(writeRowsToMaster[docId]);
          useWriteRowsToMeta.push(writeRowsToMeta[docId]);
        }
      });
      if (state.events.canceled.getValue()) {
        return false;
      }
      if (useWriteRowsToMeta.length > 0) {
        await state.input.metaInstance.bulkWrite((0,_helper_js__WEBPACK_IMPORTED_MODULE_8__.stripAttachmentsDataFromMetaWriteRows)(state, useWriteRowsToMeta), 'replication-up-write-meta');
        // TODO what happens when we have conflicts here?
      }

      /**
       * Resolve conflicts by writing a new document
       * state to the fork instance and the 'real' master state
       * to the meta instance.
       * Non-409 errors will be detected by resolveConflictError()
       */
      var hadConflictWrites = false;
      if (conflictIds.size > 0) {
        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;
        var conflictWriteFork = [];
        var conflictWriteMeta = {};
        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {
          var writeToMasterRow = writeRowsToMaster[docId];
          var input = {
            newDocumentState: writeToMasterRow.newDocumentState,
            assumedMasterState: writeToMasterRow.assumedMasterState,
            realMasterState
          };
          return (0,_conflicts_js__WEBPACK_IMPORTED_MODULE_12__.resolveConflictError)(state, input, forkStateById[docId]).then(async resolved => {
            if (resolved) {
              state.events.resolvedConflicts.next({
                input,
                output: resolved
              });
              conflictWriteFork.push({
                previous: forkStateById[docId],
                document: resolved
              });
              var assumedMasterDoc = assumedMasterState[docId];
              conflictWriteMeta[docId] = await (0,_meta_instance_js__WEBPACK_IMPORTED_MODULE_7__.getMetaWriteRow)(state, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved._rev);
            }
          });
        }));
        if (conflictWriteFork.length > 0) {
          hadConflictWrites = true;
          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;
          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');
          var mustThrow;
          forkWriteResult.error.forEach(error => {
            /**
             * Conflict-Errors in the forkWriteResult must not be handled
             * because they have been caused by a write to the forkInstance
             * in between which will anyway trigger a new upstream cycle
             * that will then resolved the conflict again.
             */
            if (error.status === 409) {
              return;
            }
            // other non-conflict errors must be handled
            var throwMe = (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_13__.newRxError)('RC_PUSH', {
              writeError: error
            });
            state.events.error.next(throwMe);
            mustThrow = throwMe;
          });
          if (mustThrow) {
            throw mustThrow;
          }
          var useMetaWrites = [];
          var success = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.getWrittenDocumentsFromBulkWriteResponse)(state.primaryPath, conflictWriteFork, forkWriteResult);
          success.forEach(docData => {
            var docId = docData[state.primaryPath];
            useMetaWrites.push(conflictWriteMeta[docId]);
          });
          if (useMetaWrites.length > 0) {
            await state.input.metaInstance.bulkWrite((0,_helper_js__WEBPACK_IMPORTED_MODULE_8__.stripAttachmentsDataFromMetaWriteRows)(state, useMetaWrites), 'replication-up-write-conflict-meta');
          }
          // TODO what to do with conflicts while writing to the metaInstance?
        }
      }

      /**
       * For better performance we do not await checkpoint writes,
       * but to ensure order on parallel checkpoint writes,
       * we have to use a queue.
       */
      rememberCheckpointBeforeReturn();
      return hadConflictWrites;
    }).catch(unhandledError => {
      state.events.error.next(unhandledError);
      return false;
    });
    return persistenceQueue;
  }
}
//# sourceMappingURL=upstream.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-change-event.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-change-event.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flattenEvents: () => (/* binding */ flattenEvents),
/* harmony export */   getDocumentDataOfRxChangeEvent: () => (/* binding */ getDocumentDataOfRxChangeEvent),
/* harmony export */   rxChangeEventBulkToRxChangeEvents: () => (/* binding */ rxChangeEventBulkToRxChangeEvents),
/* harmony export */   rxChangeEventToEventReduceChangeEvent: () => (/* binding */ rxChangeEventToEventReduceChangeEvent)
/* harmony export */ });
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/**
 * RxChangeEvents a emitted when something in the database changes
 * they can be grabbed by the observables of database, collection and document
 */



function getDocumentDataOfRxChangeEvent(rxChangeEvent) {
  if (rxChangeEvent.documentData) {
    return rxChangeEvent.documentData;
  } else {
    return rxChangeEvent.previousDocumentData;
  }
}

/**
 * Might return null which means an
 * already deleted document got modified but still is deleted.
 * These kind of events are not relevant for the event-reduce algorithm
 * and must be filtered out.
 */
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {
  switch (rxChangeEvent.operation) {
    case 'INSERT':
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: rxChangeEvent.documentData,
        previous: null
      };
    case 'UPDATE':
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: _overwritable_js__WEBPACK_IMPORTED_MODULE_0__.overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),
        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : 'UNKNOWN'
      };
    case 'DELETE':
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: null,
        previous: rxChangeEvent.previousDocumentData
      };
  }
}

/**
 * Flattens the given events into a single array of events.
 * Used mostly in tests.
 */
function flattenEvents(input) {
  var output = [];
  if (Array.isArray(input)) {
    input.forEach(inputItem => {
      var add = flattenEvents(inputItem);
      (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.appendToArray)(output, add);
    });
  } else {
    if (input.id && input.events) {
      // is bulk
      input.events.forEach(ev => output.push(ev));
    } else {
      output.push(input);
    }
  }
  var usedIds = new Set();
  var nonDuplicate = [];
  function getEventId(ev) {
    return [ev.documentId, ev.documentData ? ev.documentData._rev : '', ev.previousDocumentData ? ev.previousDocumentData._rev : ''].join('|');
  }
  output.forEach(ev => {
    var eventId = getEventId(ev);
    if (!usedIds.has(eventId)) {
      usedIds.add(eventId);
      nonDuplicate.push(ev);
    }
  });
  return nonDuplicate;
}
var EVENT_BULK_CACHE = new Map();
function rxChangeEventBulkToRxChangeEvents(eventBulk) {
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getFromMapOrCreate)(EVENT_BULK_CACHE, eventBulk, () => {
    var events = new Array(eventBulk.events.length);
    var rawEvents = eventBulk.events;
    var collectionName = eventBulk.collectionName;
    var isLocal = eventBulk.isLocal;
    var deepFreezeWhenDevMode = _overwritable_js__WEBPACK_IMPORTED_MODULE_0__.overwritable.deepFreezeWhenDevMode;
    for (var index = 0; index < rawEvents.length; index++) {
      var event = rawEvents[index];
      events[index] = {
        documentId: event.documentId,
        collectionName,
        isLocal,
        operation: event.operation,
        documentData: deepFreezeWhenDevMode(event.documentData),
        previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData)
      };
    }
    return events;
  });
}
//# sourceMappingURL=rx-change-event.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-collection-helper.js":
/*!************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-collection-helper.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRxCollectionStorageInstance: () => (/* binding */ createRxCollectionStorageInstance),
/* harmony export */   ensureRxCollectionIsNotClosed: () => (/* binding */ ensureRxCollectionIsNotClosed),
/* harmony export */   fillObjectDataBeforeInsert: () => (/* binding */ fillObjectDataBeforeInsert),
/* harmony export */   removeCollectionStorages: () => (/* binding */ removeCollectionStorages)
/* harmony export */ });
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-database-internal-store.js */ "./node_modules/rxdb/dist/esm/rx-database-internal-store.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");








/**
 * fills in the default data.
 * This also clones the data.
 */
function fillObjectDataBeforeInsert(schema, data) {
  data = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.flatClone)(data);
  data = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.fillObjectWithDefaults)(schema, data);
  if (typeof schema.jsonSchema.primaryKey !== 'string') {
    data = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.fillPrimaryKey)(schema.primaryPath, schema.jsonSchema, data);
  }
  data._meta = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultRxDocumentMeta)();
  if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {
    data._deleted = false;
  }
  if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {
    data._attachments = {};
  }
  if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {
    data._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultRevision)();
  }
  return data;
}

/**
 * Creates the storage instances that are used internally in the collection
 */
async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;
  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}

/**
 * Removes the main storage of the collection
 * and all connected storages like the ones from the replication meta etc.
 */
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, multiInstance, password,
/**
 * If no hash function is provided,
 * we assume that the whole internal store is removed anyway
 * so we do not have to delete the meta documents.
 */
hashFunction) {
  var allCollectionMetaDocs = await (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_3__.getAllCollectionDocuments)(databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach(metaDoc => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });

  // ensure uniqueness
  var alreadyAdded = new Set();
  removeStorages = removeStorages.filter(row => {
    var key = row.collectionName + '||' + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });

  // remove all the storages
  await Promise.all(removeStorages.map(async row => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      /**
       * multiInstance must be set to true if multiInstance
       * was true on the database
       * so that the storageInstance can inform other
       * instances about being removed.
       */
      multiInstance,
      options: {},
      schema: row.schema,
      password,
      devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_4__.overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await (0,_hooks_js__WEBPACK_IMPORTED_MODULE_5__.runAsyncPluginHooks)('postRemoveRxCollection', {
        storage,
        databaseName: databaseName,
        collectionName
      });
    }
  }));

  // remove the meta documents
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map(doc => {
      var writeDoc = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.flatCloneDocWithMeta)(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.now)();
      writeDoc._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.createRevision)(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');
  }
}
function ensureRxCollectionIsNotClosed(collection) {
  if (collection.closed) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_9__.newRxError)('COL21', {
      collection: collection.name,
      version: collection.schema.version
    });
  }
}
//# sourceMappingURL=rx-collection-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-collection.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OPEN_COLLECTIONS: () => (/* binding */ OPEN_COLLECTIONS),
/* harmony export */   RxCollectionBase: () => (/* binding */ RxCollectionBase),
/* harmony export */   createRxCollection: () => (/* binding */ createRxCollection),
/* harmony export */   isRxCollection: () => (/* binding */ isRxCollection)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-premium.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./rx-collection-helper.js */ "./node_modules/rxdb/dist/esm/rx-collection-helper.js");
/* harmony import */ var _rx_query_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./rx-query.js */ "./node_modules/rxdb/dist/esm/rx-query.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _doc_cache_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./doc-cache.js */ "./node_modules/rxdb/dist/esm/doc-cache.js");
/* harmony import */ var _query_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query-cache.js */ "./node_modules/rxdb/dist/esm/query-cache.js");
/* harmony import */ var _change_event_buffer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./change-event-buffer.js */ "./node_modules/rxdb/dist/esm/change-event-buffer.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _rx_document_prototype_merge_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rx-document-prototype-merge.js */ "./node_modules/rxdb/dist/esm/rx-document-prototype-merge.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _incremental_write_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./incremental-write.js */ "./node_modules/rxdb/dist/esm/incremental-write.js");
/* harmony import */ var _rx_document_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-document.js */ "./node_modules/rxdb/dist/esm/rx-document.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _replication_protocol_default_conflict_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./replication-protocol/default-conflict-handler.js */ "./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js");
/* harmony import */ var _rx_change_event_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rx-change-event.js */ "./node_modules/rxdb/dist/esm/rx-change-event.js");

















var HOOKS_WHEN = ['pre', 'post'];
var HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];
var hooksApplied = false;
var OPEN_COLLECTIONS = new Set();
var RxCollectionBase = /*#__PURE__*/function () {
  /**
   * Stores all 'normal' documents
   */

  /**
   * Before reads, all these methods are awaited. Used to "block" reads
   * depending on other processes, like when the RxPipeline is running.
   */

  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = _query_cache_js__WEBPACK_IMPORTED_MODULE_1__.defaultCacheReplacementPolicy, statics = {}, conflictHandler = _replication_protocol_default_conflict_handler_js__WEBPACK_IMPORTED_MODULE_2__.defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = new Set();
    this.incrementalWriteQueue = {};
    this.awaitBeforeReads = new Set();
    this._incrementalUpsertQueues = new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = (0,_query_cache_js__WEBPACK_IMPORTED_MODULE_1__.createQueryCache)();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.eventBulks$ = {};
    this.onClose = [];
    this.closed = false;
    this.onRemove = [];
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
    if (database) {
      // might be falsy on pseudoInstance
      this.eventBulks$ = database.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(changeEventBulk => changeEventBulk.collectionName === this.name));
    } else {}

    /**
     * Must be last because the hooks might throw on dev-mode
     * checks and we do not want to have broken collections here.
     * RxCollection instances created for testings do not have a database
     * so we do not add these to the list.
     */
    if (this.database) {
      OPEN_COLLECTIONS.add(this);
    }
  }
  var _proto = RxCollectionBase.prototype;
  _proto.prepare = async function prepare() {
    if (!(await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hasPremiumFlag)())) {
      /**
       * When used in a test suite, we often open and close many databases with collections
       * while not awaiting the database.close() call to improve the test times.
       * So when reopening collections and the OPEN_COLLECTIONS size is full,
       * we retry after some times to account for this.
       */
      var count = 0;
      while (count < 10 && OPEN_COLLECTIONS.size > _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.NON_PREMIUM_COLLECTION_LIMIT) {
        count++;
        await this.promiseWait(30);
      }
      if (OPEN_COLLECTIONS.size > _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.NON_PREMIUM_COLLECTION_LIMIT) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL23', {
          database: this.database.name,
          collection: this.name,
          args: {
            existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({
              db: c.database ? c.database.name : '',
              c: c.name
            }))
          }
        });
      }
    }
    this.storageInstance = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.getWrappedStorageInstance)(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new _incremental_write_js__WEBPACK_IMPORTED_MODULE_7__.IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => (0,_rx_document_js__WEBPACK_IMPORTED_MODULE_8__.beforeDocumentUpdateWrite)(this, newData, oldData), result => this._runHooks('post', 'save', result));
    this.$ = this.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_9__.mergeMap)(changeEventBulk => (0,_rx_change_event_js__WEBPACK_IMPORTED_MODULE_10__.rxChangeEventBulkToRxChangeEvents)(changeEventBulk)));
    this.checkpoint$ = this.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_11__.map)(changeEventBulk => changeEventBulk.checkpoint));
    this._changeEventBuffer = (0,_change_event_buffer_js__WEBPACK_IMPORTED_MODULE_12__.createChangeEventBuffer)(this.asRxCollection);
    var documentConstructor;
    this._docCache = new _doc_cache_js__WEBPACK_IMPORTED_MODULE_13__.DocumentCache(this.schema.primaryPath, this.eventBulks$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(bulk => !bulk.isLocal), (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.map)(bulk => bulk.events)), docData => {
      if (!documentConstructor) {
        documentConstructor = (0,_rx_document_prototype_merge_js__WEBPACK_IMPORTED_MODULE_14__.getRxDocumentConstructor)(this.asRxCollection);
      }
      return (0,_rx_document_prototype_merge_js__WEBPACK_IMPORTED_MODULE_14__.createNewRxDocument)(this.asRxCollection, documentConstructor, docData);
    });
    var listenToRemoveSub = this.database.internalStore.changeStream().pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(bulk => {
      var key = this.name + '-' + this.schema.version;
      var found = bulk.events.find(event => {
        return event.documentData.context === 'collection' && event.documentData.key === key && event.operation === 'DELETE';
      });
      return !!found;
    })).subscribe(async () => {
      await this.close();
      await Promise.all(this.onRemove.map(fn => fn()));
    });
    this._subs.push(listenToRemoveSub);
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {
      var changeEventBulk = {
        id: eventBulk.id,
        isLocal: false,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events: eventBulk.events,
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.PROMISE_RESOLVE_VOID;
  }

  /**
   * Manually call the cleanup function of the storage.
   * @link https://rxdb.info/cleanup.html
   */;
  _proto.cleanup = function cleanup(_minimumDeletedTime) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('cleanup');
  }

  // overwritten by migration-plugin
  ;
  _proto.migrationNeeded = function migrationNeeded() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('migration-schema');
  };
  _proto.getMigrationState = function getMigrationState() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('migration-schema');
  };
  _proto.startMigration = function startMigration(batchSize = 10) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    return this.getMigrationState().startMigration(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getMigrationState().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.throwIfIsStorageWriteError)(this, json[this.schema.primaryPath], json, isError);
    var insertResult = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.ensureNotFalsy)(writeResult.success[0]);
    return insertResult;
  };
  _proto.insertIfNotExists = async function insertIfNotExists(json) {
    var writeResult = await this.bulkInsert([json]);
    if (writeResult.error.length > 0) {
      var error = writeResult.error[0];
      if (error.status === 409) {
        var conflictDocData = error.documentInDb;
        return (0,_doc_cache_js__WEBPACK_IMPORTED_MODULE_13__.mapDocumentsDataToCacheDocs)(this._docCache, [conflictDocData])[0];
      } else {
        throw error;
      }
    }
    return writeResult.success[0];
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    /**
     * Optimization shortcut,
     * do nothing when called with an empty array
    */
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var ids = new Set();

    /**
     * This code is a bit redundant for better performance.
     * Instead of iterating multiple times,
     * we directly transform the input to a write-row array.
     */
    var insertRows;
    if (this.hasHooks('pre', 'insert')) {
      insertRows = await Promise.all(docsData.map(docData => {
        var useDocData = (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.fillObjectDataBeforeInsert)(this.schema, docData);
        return this._runHooks('pre', 'insert', useDocData).then(() => {
          ids.add(useDocData[primaryPath]);
          return {
            document: useDocData
          };
        });
      }));
    } else {
      insertRows = new Array(docsData.length);
      var _schema = this.schema;
      for (var index = 0; index < docsData.length; index++) {
        var docData = docsData[index];
        var useDocData = (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.fillObjectDataBeforeInsert)(_schema, docData);
        ids.add(useDocData[primaryPath]);
        insertRows[index] = {
          document: useDocData
        };
      }
    }
    if (ids.size !== docsData.length) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL22', {
        collection: this.name,
        args: {
          documents: docsData
        }
      });
    }
    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');

    /**
     * Often the user does not need to access the RxDocuments of the bulkInsert() call.
     * So we transform the data to RxDocuments only if needed to use less CPU performance.
     */
    var rxDocuments;
    var collection = this;
    var ret = {
      get success() {
        if (!rxDocuments) {
          var success = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.getWrittenDocumentsFromBulkWriteResponse)(collection.schema.primaryPath, insertRows, results);
          rxDocuments = (0,_doc_cache_js__WEBPACK_IMPORTED_MODULE_13__.mapDocumentsDataToCacheDocs)(collection._docCache, success);
        }
        return rxDocuments;
      },
      error: results.error
    };
    if (this.hasHooks('post', 'insert')) {
      var docsMap = new Map();
      insertRows.forEach(row => {
        var doc = row.document;
        docsMap.set(doc[primaryPath], doc);
      });
      await Promise.all(ret.success.map(doc => {
        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);
      }));
    }
    return ret;
  };
  _proto.bulkRemove = async function bulkRemove(
  /**
   * You can either remove the documents by their ids
   * or by directly providing the RxDocument instances
   * if you have them already. This improves performance a bit.
   */
  idsOrDocs) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var primaryPath = this.schema.primaryPath;
    /**
     * Optimization shortcut,
     * do nothing when called with an empty array
     */
    if (idsOrDocs.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap;
    if (typeof idsOrDocs[0] === 'string') {
      rxDocumentMap = await this.findByIds(idsOrDocs).exec();
    } else {
      rxDocumentMap = new Map();
      idsOrDocs.forEach(d => rxDocumentMap.set(d.primary, d));
    }
    var docsData = [];
    var docsMap = new Map();
    Array.from(rxDocumentMap.values()).forEach(rxDocument => {
      var data = rxDocument.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument.primary, data);
    });
    await Promise.all(docsData.map(doc => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map(doc => {
      var writeDoc = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_19__.flatClone)(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');
    var success = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.getWrittenDocumentsFromBulkWriteResponse)(this.schema.primaryPath, removeDocs, results);
    var deletedRxDocuments = [];
    var successIds = success.map(d => {
      var id = d[primaryPath];
      var doc = this._docCache.getCachedRxDocument(d);
      deletedRxDocuments.push(doc);
      return id;
    });

    // run hooks
    await Promise.all(successIds.map(id => {
      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));
    }));
    return {
      success: deletedRxDocuments,
      error: results.error
    };
  }

  /**
   * same as bulkInsert but overwrites existing document with same primary
   */;
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var insertData = [];
    var useJsonByDocId = new Map();
    docsData.forEach(docData => {
      var useJson = (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.fillObjectDataBeforeInsert)(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL3', {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var success = insertResult.success.slice(0);
    var error = [];

    // update the ones that existed already
    await Promise.all(insertResult.error.map(async err => {
      if (err.status !== 409) {
        error.push(err);
      } else {
        var id = err.documentId;
        var writeData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__.getFromMapOrThrow)(useJsonByDocId, id);
        var docDataInDb = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.ensureNotFalsy)(err.documentInDb);
        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];
        var newDoc = await doc.incrementalModify(() => writeData);
        success.push(newDoc);
      }
    }));
    return {
      error,
      success
    };
  }

  /**
   * same as insert but overwrites existing document with same primary
   */;
  _proto.upsert = async function upsert(json) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var bulkResult = await this.bulkUpsert([json]);
    (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_6__.throwIfIsStorageWriteError)(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);
    return bulkResult.success[0];
  }

  /**
   * upserts to a RxDocument, uses incrementalModify if document already exists
   */;
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var useJson = (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.fillObjectDataBeforeInsert)(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL4', {
        data: json
      });
    }

    // ensure that it won't try 2 parallel runs
    var queue = this._incrementalUpsertQueues.get(primary);
    if (!queue) {
      queue = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.PROMISE_RESOLVE_VOID;
    }
    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue);
    return queue;
  };
  _proto.find = function find(queryObj) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    (0,_hooks_js__WEBPACK_IMPORTED_MODULE_21__.runPluginHooks)('prePrepareRxQuery', {
      op: 'find',
      queryObj,
      collection: this
    });
    if (!queryObj) {
      queryObj = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__._getDefaultQuery)();
    }
    var query = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__.createRxQuery)('find', queryObj, this);
    return query;
  };
  _proto.findOne = function findOne(queryObj) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    (0,_hooks_js__WEBPACK_IMPORTED_MODULE_21__.runPluginHooks)('prePrepareRxQuery', {
      op: 'findOne',
      queryObj,
      collection: this
    });
    var query;
    if (typeof queryObj === 'string') {
      query = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__.createRxQuery)('findOne', {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__._getDefaultQuery)();
      }

      // cannot have limit on findOne queries because it will be overwritten
      if (queryObj.limit) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('QU6');
      }
      queryObj = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_19__.flatClone)(queryObj);
      queryObj.limit = 1;
      query = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__.createRxQuery)('findOne', queryObj, this);
    }
    return query;
  };
  _proto.count = function count(queryObj) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    if (!queryObj) {
      queryObj = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__._getDefaultQuery)();
    }
    var query = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__.createRxQuery)('count', queryObj, this);
    return query;
  }

  /**
   * find a list documents by their primary key
   * has way better performance then running multiple findOne() or a find() with a complex $or-selected
   */;
  _proto.findByIds = function findByIds(ids) {
    (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.ensureRxCollectionIsNotClosed)(this);
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query = (0,_rx_query_js__WEBPACK_IMPORTED_MODULE_22__.createRxQuery)('findByIds', mangoQuery, this);
    return query;
  }

  /**
   * Export collection to a JSON friendly format.
   */;
  _proto.exportJSON = function exportJSON() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('json-dump');
  }

  /**
   * Import the parsed JSON export into the collection.
   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.
   */;
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('json-dump');
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('crdt');
  };
  _proto.addPipeline = function addPipeline(_options) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('pipeline');
  }

  /**
   * HOOKS
   */;
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== 'function') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxTypeError)('COL7', {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxTypeError)('COL8', {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL9', {
        key
      });
    }
    if (when === 'post' && key === 'create' && parallel === true) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('COL10', {
        when,
        key,
        parallel
      });
    }

    // bind this-scope to hook-function
    var boundFun = fun.bind(this);
    var runName = parallel ? 'parallel' : 'series';
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    /**
     * Performance shortcut
     * so that we not have to build the empty object.
     */
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return false;
    }
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return false;
    }
    return hooks.series.length > 0 || hooks.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.PROMISE_RESOLVE_VOID;
    }

    // run parallel: false
    var tasks = hooks.series.map(hook => () => hook(data, instance));
    return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.promiseSeries)(tasks)
    // run parallel: true
    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));
  }

  /**
   * does the same as ._runHooks() but with non-async-functions
   */;
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    if (!this.hasHooks(when, key)) {
      return;
    }
    var hooks = this.getHooks(when, key);
    if (!hooks) return;
    hooks.series.forEach(hook => hook(data, instance));
  }

  /**
   * Returns a promise that resolves after the given time.
   * Ensures that is properly cleans up when the collection is closed
   * so that no running timeouts prevent the exit of the JavaScript process.
   */;
  _proto.promiseWait = function promiseWait(time) {
    var ret = new Promise(res => {
      var timeout = setTimeout(() => {
        this.timeouts.delete(timeout);
        res();
      }, time);
      this.timeouts.add(timeout);
    });
    return ret;
  };
  _proto.close = async function close() {
    if (this.closed) {
      return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.PROMISE_RESOLVE_FALSE;
    }
    OPEN_COLLECTIONS.delete(this);
    await Promise.all(this.onClose.map(fn => fn()));

    /**
     * Settings closed = true
     * must be the first thing to do,
     * so for example the replication can directly stop
     * instead of sending requests to a closed storage.
     */
    this.closed = true;
    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.close();
    }
    /**
     * First wait until the whole database is idle.
     * This ensures that the storage does not get closed
     * while some operation is running.
     * It is important that we do not intercept a running call
     * because it might lead to undefined behavior like when a doc is written
     * but the change is not added to the changes collection.
     */
    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {
      /**
       * Unsubscribing must be done AFTER the storageInstance.close()
       * Because the conflict handling is part of the subscriptions and
       * otherwise there might be open conflicts to be resolved which
       * will then stuck and never resolve.
       */
      this._subs.forEach(sub => sub.unsubscribe());
      delete this.database.collections[this.name];
      return (0,_hooks_js__WEBPACK_IMPORTED_MODULE_21__.runAsyncPluginHooks)('postCloseRxCollection', this).then(() => true);
    });
  }

  /**
   * remove all data of the collection
   */;
  _proto.remove = async function remove() {
    await this.close();
    await Promise.all(this.onRemove.map(fn => fn()));
    /**
     * TODO here we should pass the already existing
     * storage instances instead of creating new ones.
     */
    await (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.removeCollectionStorages)(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.multiInstance, this.database.password, this.database.hashFunction);
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxCollectionBase, [{
    key: "insert$",
    get: function () {
      return this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(cE => cE.operation === 'INSERT'));
    }
  }, {
    key: "update$",
    get: function () {
      return this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(cE => cE.operation === 'UPDATE'));
    }
  }, {
    key: "remove$",
    get: function () {
      return this.$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.filter)(cE => cE.operation === 'DELETE'));
    }

    // defaults

    /**
     * Internally only use eventBulks$
     * Do not use .$ or .observable$ because that has to transform
     * the events which decreases performance.
     */

    /**
     * When the collection is closed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
    */
  }, {
    key: "asRxCollection",
    get: function () {
      return this;
    }
  }]);
}();

/**
 * adds the hook-functions to the collections prototype
 * this runs only once
 */
function _applyHookFunctions(collection) {
  if (hooksApplied) return; // already run
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach(key => {
    HOOKS_WHEN.map(when => {
      var fnName = when + (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_23__.ucfirst)(key);
      colProto[fnName] = function (fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify(_innerDoc => {
    return json;
  });
}

/**
 * ensures that the given document exists
 * @return promise that resolves with new doc and flag if inserted
 */
function _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {
  /**
   * Optimisation shortcut,
   * first try to find the document in the doc-cache
   */
  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],
      inserted: false
    });
  }
  return rxCollection.findOne(primary).exec().then(doc => {
    if (!doc) {
      return rxCollection.insert(json).then(newDoc => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}

/**
 * creates and prepares a new collection
 */
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options = {},
  localDocuments = false,
  cacheReplacementPolicy = _query_cache_js__WEBPACK_IMPORTED_MODULE_1__.defaultCacheReplacementPolicy,
  conflictHandler = _replication_protocol_default_conflict_handler_js__WEBPACK_IMPORTED_MODULE_2__.defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_24__.overwritable.isDevMode()
  };
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_21__.runPluginHooks)('preCreateRxStorageInstance', storageInstanceCreationParams);
  return (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_16__.createRxCollectionStorageInstance)(database, storageInstanceCreationParams).then(storageInstance => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      // ORM add statics
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      (0,_hooks_js__WEBPACK_IMPORTED_MODULE_21__.runPluginHooks)('createRxCollection', {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    })
    /**
     * If the collection creation fails,
     * we yet have to close the storage instances.
     */.catch(err => {
      OPEN_COLLECTIONS.delete(collection);
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}
function isRxCollection(obj) {
  return obj instanceof RxCollectionBase;
}
//# sourceMappingURL=rx-collection.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-database-internal-store.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-database-internal-store.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INTERNAL_CONTEXT_COLLECTION: () => (/* binding */ INTERNAL_CONTEXT_COLLECTION),
/* harmony export */   INTERNAL_CONTEXT_MIGRATION_STATUS: () => (/* binding */ INTERNAL_CONTEXT_MIGRATION_STATUS),
/* harmony export */   INTERNAL_CONTEXT_PIPELINE_CHECKPOINT: () => (/* binding */ INTERNAL_CONTEXT_PIPELINE_CHECKPOINT),
/* harmony export */   INTERNAL_CONTEXT_STORAGE_TOKEN: () => (/* binding */ INTERNAL_CONTEXT_STORAGE_TOKEN),
/* harmony export */   INTERNAL_STORE_SCHEMA: () => (/* binding */ INTERNAL_STORE_SCHEMA),
/* harmony export */   INTERNAL_STORE_SCHEMA_TITLE: () => (/* binding */ INTERNAL_STORE_SCHEMA_TITLE),
/* harmony export */   STORAGE_TOKEN_DOCUMENT_ID: () => (/* binding */ STORAGE_TOKEN_DOCUMENT_ID),
/* harmony export */   STORAGE_TOKEN_DOCUMENT_KEY: () => (/* binding */ STORAGE_TOKEN_DOCUMENT_KEY),
/* harmony export */   _collectionNamePrimary: () => (/* binding */ _collectionNamePrimary),
/* harmony export */   addConnectedStorageToCollection: () => (/* binding */ addConnectedStorageToCollection),
/* harmony export */   ensureStorageTokenDocumentExists: () => (/* binding */ ensureStorageTokenDocumentExists),
/* harmony export */   getAllCollectionDocuments: () => (/* binding */ getAllCollectionDocuments),
/* harmony export */   getPrimaryKeyOfInternalDocument: () => (/* binding */ getPrimaryKeyOfInternalDocument),
/* harmony export */   isDatabaseStateVersionCompatibleWithDatabaseCode: () => (/* binding */ isDatabaseStateVersionCompatibleWithDatabaseCode),
/* harmony export */   removeConnectedStorageFromCollection: () => (/* binding */ removeConnectedStorageFromCollection)
/* harmony export */ });
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");





var INTERNAL_CONTEXT_COLLECTION = 'collection';
var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';
var INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';
var INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';

/**
 * Do not change the title,
 * we have to flag the internal schema so that
 * some RxStorage implementations are able
 * to detect if the created RxStorageInstance
 * is from the internals or not,
 * to do some optimizations in some cases.
 */
var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';
var INTERNAL_STORE_SCHEMA = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.fillWithDefaultSettings)({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: 'id',
    fields: ['context', 'key'],
    separator: '|'
  },
  type: 'object',
  properties: {
    id: {
      type: 'string',
      maxLength: 200
    },
    key: {
      type: 'string'
    },
    context: {
      type: 'string',
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, INTERNAL_CONTEXT_PIPELINE_CHECKPOINT, 'OTHER']
    },
    data: {
      type: 'object',
      additionalProperties: true
    }
  },
  indexes: [],
  required: ['key', 'context', 'data'],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: 'collection'
  }
});
function getPrimaryKeyOfInternalDocument(key, context) {
  return (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(INTERNAL_STORE_SCHEMA, {
    key,
    context
  });
}

/**
 * Returns all internal documents
 * with context 'collection'
 */
async function getAllCollectionDocuments(storageInstance) {
  var getAllQueryPrepared = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_1__.prepareQuery)(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION,
      _deleted: {
        $eq: false
      }
    },
    sort: [{
      id: 'asc'
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}

/**
 * to not confuse multiInstance-messages with other databases that have the same
 * name and adapter, but do not share state with this one (for example in-memory-instances),
 * we set a storage-token and use it in the broadcast-channel
 */
var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
async function ensureStorageTokenDocumentExists(rxDatabase) {
  /**
   * To have less read-write cycles,
   * we just try to insert a new document
   * and only fetch the existing one if a conflict happened.
   */
  var storageToken = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randomToken)(10);
  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      rxdbVersion: rxDatabase.rxdbVersion,
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase.token,
      passwordHash
    },
    _deleted: false,
    _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultRxDocumentMeta)(),
    _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultRevision)(),
    _attachments: {}
  };
  var writeRows = [{
    document: docData
  }];
  var writeResult = await rxDatabase.internalStore.bulkWrite(writeRows, 'internal-add-storage-token');
  if (!writeResult.error[0]) {
    return (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.getWrittenDocumentsFromBulkWriteResponse)('id', writeRows, writeResult)[0];
  }

  /**
   * If we get a 409 error,
   * it means another instance already inserted the storage token.
   * So we get that token from the database and return that one.
   */
  var error = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(writeResult.error[0]);
  if (error.isError && (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.isBulkWriteConflictError)(error)) {
    var conflictError = error;
    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('DM5', {
        args: {
          database: rxDatabase.name,
          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,
          codeVersion: rxDatabase.rxdbVersion
        }
      });
    }
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('DB1', {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(storageTokenDocInDb);
  }
  throw error;
}
function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {
  if (!databaseStateVersion) {
    return false;
  }
  var stateMajor = databaseStateVersion.split('.')[0];
  var codeMajor = codeVersion.split('.')[0];

  /**
   * Version v15 data must be upwards compatible to v16
   */
  if (stateMajor === '15' && codeMajor === '16') {
    return true;
  }
  if (stateMajor !== codeMajor) {
    return false;
  }
  return true;
}
async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {
  if (collection.schema.version !== schema.version) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('SNH', {
      schema,
      version: collection.schema.version,
      name: collection.name,
      collection,
      args: {
        storageCollectionName
      }
    });
  }
  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);
  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);
  while (true) {
    var collectionDoc = await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.getSingleDocument)(collection.database.internalStore, collectionDocId);
    var saveData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.clone)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(collectionDoc));

    // do nothing if already in array
    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);
    if (alreadyThere) {
      return;
    }

    // otherwise add to array and save
    saveData.data.connectedStorages.push({
      collectionName: storageCollectionName,
      schema
    });
    try {
      await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.writeSingle)(collection.database.internalStore, {
        previous: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(collectionDoc),
        document: saveData
      }, 'add-connected-storage-to-collection');
    } catch (err) {
      if (!(0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.isBulkWriteConflictError)(err)) {
        throw err;
      }
      // retry on conflict
    }
  }
}
async function removeConnectedStorageFromCollection(collection, storageCollectionName, schema) {
  if (collection.schema.version !== schema.version) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('SNH', {
      schema,
      version: collection.schema.version,
      name: collection.name,
      collection,
      args: {
        storageCollectionName
      }
    });
  }
  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);
  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);
  while (true) {
    var collectionDoc = await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.getSingleDocument)(collection.database.internalStore, collectionDocId);
    var saveData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.clone)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(collectionDoc));

    // do nothing if not there
    var isThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);
    if (!isThere) {
      return;
    }

    // otherwise remove from array and save
    saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);
    try {
      await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_4__.writeSingle)(collection.database.internalStore, {
        previous: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(collectionDoc),
        document: saveData
      }, 'remove-connected-storage-from-collection');
    } catch (err) {
      if (!(0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.isBulkWriteConflictError)(err)) {
        throw err;
      }
      // retry on conflict
    }
  }
}

/**
 * returns the primary for a given collection-data
 * used in the internal store of a RxDatabase
 */
function _collectionNamePrimary(name, schema) {
  return name + '-' + schema.version;
}
//# sourceMappingURL=rx-database-internal-store.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-database.js":
/*!***************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-database.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxDatabaseBase: () => (/* binding */ RxDatabaseBase),
/* harmony export */   createRxDatabase: () => (/* binding */ createRxDatabase),
/* harmony export */   createRxDatabaseStorageInstance: () => (/* binding */ createRxDatabaseStorageInstance),
/* harmony export */   dbCount: () => (/* binding */ dbCount),
/* harmony export */   ensureNoStartupErrors: () => (/* binding */ ensureNoStartupErrors),
/* harmony export */   isRxDatabase: () => (/* binding */ isRxDatabase),
/* harmony export */   isRxDatabaseFirstTimeInstantiated: () => (/* binding */ isRxDatabaseFirstTimeInstantiated),
/* harmony export */   removeRxDatabase: () => (/* binding */ removeRxDatabase)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var custom_idle_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! custom-idle-queue */ "./node_modules/custom-idle-queue/dist/es/index.js");
/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! oblivious-set */ "./node_modules/oblivious-set/dist/esm/src/index.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_schema_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rx-schema.js */ "./node_modules/rxdb/dist/esm/rx-schema.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var _rx_collection_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./rx-collection.js */ "./node_modules/rxdb/dist/esm/rx-collection.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rx-database-internal-store.js */ "./node_modules/rxdb/dist/esm/rx-database-internal-store.js");
/* harmony import */ var _rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./rx-collection-helper.js */ "./node_modules/rxdb/dist/esm/rx-collection-helper.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_change_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-change-event.js */ "./node_modules/rxdb/dist/esm/rx-change-event.js");
















/**
 * stores the used database names+storage names
 * so we can throw when the same database is created more then once.
 */
var USED_DATABASE_NAMES = new Set();
var DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP = new Map();
var DB_COUNT = 0;
var RxDatabaseBase = /*#__PURE__*/function () {
  /**
   * Contains all known non-closed storage instances
   * that belong to this database.
   * Used in plugins and unit tests.
   */

  function RxDatabaseBase(name,
  /**
   * Uniquely identifies the instance
   * of this RxDatabase.
   */
  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},
  /**
   * Stores information documents about the collections of the database
   */
  internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onClosed) {
    this.idleQueue = new custom_idle_queue__WEBPACK_IMPORTED_MODULE_1__.IdleQueue();
    this.rxdbVersion = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.RXDB_VERSION;
    this.storageInstances = new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onClose = [];
    this.closed = false;
    this.collections = {};
    this.states = {};
    this.eventBulks$ = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
    this.closePromise = null;
    this.observable$ = this.eventBulks$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(changeEventBulk => (0,_rx_change_event_js__WEBPACK_IMPORTED_MODULE_5__.rxChangeEventBulkToRxChangeEvents)(changeEventBulk)));
    this.storageToken = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new oblivious_set__WEBPACK_IMPORTED_MODULE_7__.ObliviousSet(60 * 1000);
    this.name = name;
    this.token = token;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce;
    this.options = options;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    this.reactivity = reactivity;
    this.onClosed = onClosed;
    DB_COUNT++;

    /**
     * In the dev-mode, we create a pseudoInstance
     * to get all properties of RxDatabase and ensure they do not
     * conflict with the collection names etc.
     * So only if it is not pseudoInstance,
     * we have all values to prepare a real RxDatabase.
     *
     * TODO this is ugly, we should use a different way in the dev-mode
     * so that all non-dev-mode code can be cleaner.
     */
    if (this.name !== 'pseudoInstance') {
      /**
       * Wrap the internal store
       * to ensure that calls to it also end up in
       * calculation of the idle state and the hooks.
       */
      this.internalStore = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_8__.getWrappedStorageInstance)(this.asRxDatabase, internalStore, _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.INTERNAL_STORE_SCHEMA);

      /**
       * Start writing the storage token.
       * Do not await the creation because it would run
       * in a critical path that increases startup time.
       *
       * Writing the token takes about 20 milliseconds
       * even on a fast adapter, so this is worth it.
       */
      this.storageTokenDocument = (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.ensureStorageTokenDocumentExists)(this.asRxDatabase).catch(err => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase.prototype;
  _proto.getReactivityFactory = function getReactivityFactory() {
    if (!this.reactivity) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB14', {
        database: this.name
      });
    }
    return this.reactivity;
  }

  /**
   * Because having unhandled exceptions would fail,
   * we have to store the async errors of the constructor here
   * so we can throw them later.
   */

  /**
   * When the database is closed,
   * these functions will be called an awaited.
   * Used to automatically clean up stuff that
   * belongs to this collection.
   */

  /**
   * Internally only use eventBulks$
   * Do not use .$ or .observable$ because that has to transform
   * the events which decreases performance.
   */

  /**
   * Unique token that is stored with the data.
   * Used to detect if the dataset has been deleted
   * and if two RxDatabase instances work on the same dataset or not.
   *
   * Because reading and writing the storageToken runs in the hot path
   * of database creation, we do not await the storageWrites but instead
   * work with the promise when we need the value.
   */

  /**
   * Stores the whole state of the internal storage token document.
   * We need this in some plugins.
   */

  /**
   * Contains the ids of all event bulks that have been emitted
   * by the database.
   * Used to detect duplicates that come in again via BroadcastChannel
   * or other streams.
   * In the past we tried to remove this and to ensure
   * all storages only emit the same event bulks only once
   * but it turns out this is just not possible for all storages.
   * JavaScript processes, workers and browser tabs can be closed and started at any time
   * which can cause cases where it is not possible to know if an event bulk has been emitted already.
   */;
  /**
   * This is the main handle-point for all change events
   * ChangeEvents created by this instance go:
   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance
   * ChangeEvents created by other instances go:
   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase
   */
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  }

  /**
   * removes the collection-doc from the internalStore
   */;
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_8__.getSingleDocument)(this.internalStore, (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.getPrimaryKeyOfInternalDocument)((0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__._collectionNamePrimary)(name, schema), _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('SNH', {
        name,
        schema
      });
    }
    var writeDoc = (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_8__.flatCloneDocWithMeta)(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], 'rx-database-remove-collection');
  }

  /**
   * creates multiple RxCollections at once
   * to be much faster by saving db txs and doing stuff in bulk-operations
   * This function is not called often, but mostly in the critical path at the initial page load
   * So it must be as fast as possible.
   */;
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {
      var collectionName = name;
      var rxJsonSchema = args.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = (0,_rx_schema_js__WEBPACK_IMPORTED_MODULE_11__.createRxSchema)(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;

      // collection already exists
      if (this.collections[name]) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB3', {
          name
        });
      }
      var collectionNameWithVersion = (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__._collectionNamePrimary)(name, rxJsonSchema);
      var collectionDocData = {
        id: (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.getPrimaryKeyOfInternalDocument)(collectionNameWithVersion, _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: await schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getDefaultRxDocumentMeta)(),
        _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.getDefaultRevision)(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args, {
        name: collectionName,
        schema,
        database: this
      });

      // run hooks
      var hookData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.flatClone)(args);
      hookData.database = this;
      hookData.name = name;
      (0,_hooks_js__WEBPACK_IMPORTED_MODULE_14__.runPluginHooks)('preCreateRxCollection', hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    }));
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');
    await ensureNoStartupErrors(this);
    await Promise.all(putDocsResult.error.map(async error => {
      if (error.status !== 409) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB12', {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.ensureNotFalsy)(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      // collection already exists but has different schema
      if (docInDb.data.schemaHash !== (await schema.hash)) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB6', {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: await schema.hash,
          previousSchema: docInDb.data.schema,
          schema: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_15__.ensureNotFalsy)(jsonSchemas[collectionName])
        });
      }
    }));
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await (0,_rx_collection_js__WEBPACK_IMPORTED_MODULE_16__.createRxCollection)(useArgs);
      ret[collectionName] = collection;

      // set as getter to the database
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  }

  /**
   * runs the given function between idleQueue-locking
   */;
  _proto.lockedRun = function lockedRun(fn) {
    return this.idleQueue.wrapCall(fn);
  };
  _proto.requestIdlePromise = function requestIdlePromise() {
    return this.idleQueue.requestIdlePromise();
  }

  /**
   * Export database to a JSON friendly format.
   */;
  _proto.exportJSON = function exportJSON(_collections) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('json-dump');
  };
  _proto.addState = function addState(_name) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('state');
  }

  /**
   * Import the parsed JSON export into the collection.
   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.
   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`
   * since data could be encrypted.
   */;
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('json-dump');
  };
  _proto.backup = function backup(_options) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('backup');
  };
  _proto.leaderElector = function leaderElector() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('leader-election');
  };
  _proto.isLeader = function isLeader() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('leader-election');
  }
  /**
   * returns a promise which resolves when the instance becomes leader
   */;
  _proto.waitForLeadership = function waitForLeadership() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('leader-election');
  };
  _proto.migrationStates = function migrationStates() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.pluginMissing)('migration-schema');
  }

  /**
   * closes the database-instance and all collections
   */;
  _proto.close = function close() {
    if (this.closePromise) {
      return this.closePromise;
    }
    var {
      promise,
      resolve
    } = createPromiseWithResolvers();
    var resolveClosePromise = result => {
      if (this.onClosed) {
        this.onClosed();
      }
      this.closed = true;
      resolve(result);
    };
    this.closePromise = promise;
    (async () => {
      await (0,_hooks_js__WEBPACK_IMPORTED_MODULE_14__.runAsyncPluginHooks)('preCloseRxDatabase', this);
      /**
       * Complete the event stream
       * to stop all subscribers who forgot to unsubscribe.
       */
      this.eventBulks$.complete();
      DB_COUNT--;
      this._subs.map(sub => sub.unsubscribe());

      /**
       * closing the pseudo instance will throw
       * because stuff is missing
       * TODO we should not need the pseudo instance on runtime.
       * we should generate the property list on build time.
       */
      if (this.name === 'pseudoInstance') {
        resolveClosePromise(false);
        return;
      }

      /**
       * First wait until the database is idle
       */
      return this.requestIdlePromise().then(() => Promise.all(this.onClose.map(fn => fn())))
      // close all collections
      .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.close())))
      // close internal storage instances
      .then(() => this.internalStore.close()).then(() => resolveClosePromise(true));
    })();
    return promise;
  }

  /**
   * deletes the database and its stored data.
   * Returns the names of all removed collections.
   */;
  _proto.remove = function remove() {
    return this.close().then(() => removeRxDatabase(this.name, this.storage, this.multiInstance, this.password));
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxDatabaseBase, [{
    key: "$",
    get: function () {
      return this.observable$;
    }
  }, {
    key: "asRxDatabase",
    get: function () {
      return this;
    }
  }]);
}();

/**
 * checks if an instance with same name and storage already exists
 * @throws {RxError} if used
 */
function throwIfDatabaseNameUsed(name, storage) {
  if (USED_DATABASE_NAMES.has(getDatabaseNameKey(name, storage))) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB8', {
      name,
      storage: storage.name,
      link: 'https://rxdb.info/rx-database.html#ignoreduplicate'
    });
  }
}

/**
 * ponyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers
 */
function createPromiseWithResolvers() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}
function getDatabaseNameKey(name, storage) {
  return storage.name + '|' + name;
}

/**
 * Creates the storage instances that are used internally in the database
 * to store schemas and other configuration stuff.
 */
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_8__.INTERNAL_STORAGE_NAME,
    schema: _rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.INTERNAL_STORE_SCHEMA,
    options,
    multiInstance,
    password,
    devMode: _overwritable_js__WEBPACK_IMPORTED_MODULE_18__.overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce = true,
  ignoreDuplicate = false,
  options = {},
  cleanupPolicy,
  closeDuplicates = false,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_19__.defaultHashSha256,
  reactivity
}) {
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_14__.runPluginHooks)('preCreateRxDatabase', {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce,
    ignoreDuplicate,
    options,
    localDocuments
  });
  var databaseNameKey = getDatabaseNameKey(name, storage);
  var databaseNameKeyUnclosedInstancesSet = DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.get(databaseNameKey) || new Set();
  var instancePromiseWithResolvers = createPromiseWithResolvers();
  var closeDuplicatesPromises = Array.from(databaseNameKeyUnclosedInstancesSet);
  var onInstanceClosed = () => {
    databaseNameKeyUnclosedInstancesSet.delete(instancePromiseWithResolvers.promise);
    USED_DATABASE_NAMES.delete(databaseNameKey);
  };
  databaseNameKeyUnclosedInstancesSet.add(instancePromiseWithResolvers.promise);
  DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.set(databaseNameKey, databaseNameKeyUnclosedInstancesSet);
  (async () => {
    if (closeDuplicates) {
      await Promise.all(closeDuplicatesPromises.map(unclosedInstancePromise => unclosedInstancePromise.catch(() => null).then(instance => instance && instance.close())));
    }
    if (ignoreDuplicate) {
      if (!_overwritable_js__WEBPACK_IMPORTED_MODULE_18__.overwritable.isDevMode()) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_10__.newRxError)('DB9', {
          database: name
        });
      }
    } else {
      // check if combination already used
      throwIfDatabaseNameUsed(name, storage);
    }
    USED_DATABASE_NAMES.add(databaseNameKey);
    var databaseInstanceToken = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__.randomToken)(10);
    var storageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password);
    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onInstanceClosed);
    await (0,_hooks_js__WEBPACK_IMPORTED_MODULE_14__.runAsyncPluginHooks)('createRxDatabase', {
      database: rxDatabase,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce,
        ignoreDuplicate,
        options,
        localDocuments
      }
    });
    return rxDatabase;
  })().then(rxDatabase => {
    instancePromiseWithResolvers.resolve(rxDatabase);
  }).catch(err => {
    instancePromiseWithResolvers.reject(err);
    onInstanceClosed();
  });
  return instancePromiseWithResolvers.promise;
}

/**
 * Removes the database and all its known data
 * with all known collections and all internal meta data.
 *
 * Returns the names of the removed collections.
 */
async function removeRxDatabase(databaseName, storage, multiInstance = true, password) {
  var databaseInstanceToken = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__.randomToken)(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, multiInstance, password);
  var collectionDocs = await (0,_rx_database_internal_store_js__WEBPACK_IMPORTED_MODULE_9__.getAllCollectionDocuments)(dbInternalsStorageInstance);
  var collectionNames = new Set();
  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map(collectionName => (0,_rx_collection_helper_js__WEBPACK_IMPORTED_MODULE_21__.removeCollectionStorages)(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, multiInstance, password)));
  await (0,_hooks_js__WEBPACK_IMPORTED_MODULE_14__.runAsyncPluginHooks)('postRemoveRxDatabase', {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
function isRxDatabase(obj) {
  return obj instanceof RxDatabaseBase;
}
function dbCount() {
  return DB_COUNT;
}

/**
 * Returns true if the given RxDatabase was the first
 * instance that was created on the storage with this name.
 *
 * Can be used for some optimizations because on the first instantiation,
 * we can assume that no data was written before.
 */
async function isRxDatabaseFirstTimeInstantiated(database) {
  var tokenDoc = await database.storageTokenDocument;
  return tokenDoc.data.instanceToken === database.token;
}

/**
 * For better performance some tasks run async
 * and are awaited later.
 * But we still have to ensure that there have been no errors
 * on database creation.
 */
async function ensureNoStartupErrors(rxDatabase) {
  await rxDatabase.storageToken;
  if (rxDatabase.startupErrors[0]) {
    throw rxDatabase.startupErrors[0];
  }
}
//# sourceMappingURL=rx-database.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-document-prototype-merge.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-document-prototype-merge.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createNewRxDocument: () => (/* binding */ createNewRxDocument),
/* harmony export */   getDocumentOrmPrototype: () => (/* binding */ getDocumentOrmPrototype),
/* harmony export */   getDocumentPrototype: () => (/* binding */ getDocumentPrototype),
/* harmony export */   getRxDocumentConstructor: () => (/* binding */ getRxDocumentConstructor)
/* harmony export */ });
/* harmony import */ var _rx_document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-document.js */ "./node_modules/rxdb/dist/esm/rx-document.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/**
 * For the ORM capabilities,
 * we have to merge the document prototype
 * with the ORM functions and the data
 * We do this iterating over the properties and
 * adding them to a new object.
 * In the future we should do this by chaining the __proto__ objects
 */





var constructorForCollection = new WeakMap();
function getDocumentPrototype(rxCollection) {
  var schemaProto = rxCollection.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection);
  var baseProto = _rx_document_js__WEBPACK_IMPORTED_MODULE_0__.basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach(obj => {
    var props = Object.getOwnPropertyNames(obj);
    props.forEach(key => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      /**
       * When enumerable is true, it will show on console dir(instance)
       * To not pollute the output, only getters and methods are enumerable
       */
      var enumerable = true;
      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;
      if (typeof desc.value === 'function') {
        // when getting a function, we automatically do a .bind(this)
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable) desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection) {
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getFromMapOrCreate)(constructorForCollection, rxCollection, () => (0,_rx_document_js__WEBPACK_IMPORTED_MODULE_0__.createRxDocumentConstructor)(getDocumentPrototype(rxCollection)));
}

/**
 * Create a RxDocument-instance from the jsonData
 * and the prototype merge.
 * You should never call this method directly,
 * instead you should get the document from collection._docCache.getCachedRxDocument().
 */
function createNewRxDocument(rxCollection, documentConstructor, docData) {
  var doc = (0,_rx_document_js__WEBPACK_IMPORTED_MODULE_0__.createWithConstructor)(documentConstructor, rxCollection, _overwritable_js__WEBPACK_IMPORTED_MODULE_2__.overwritable.deepFreezeWhenDevMode(docData));
  rxCollection._runHooksSync('post', 'create', docData, doc);
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_3__.runPluginHooks)('postCreateRxDocument', doc);
  return doc;
}

/**
 * returns the prototype-object
 * that contains the orm-methods,
 * used in the proto-merge
 */
function getDocumentOrmPrototype(rxCollection) {
  var proto = {};
  Object.entries(rxCollection.methods).forEach(([k, v]) => {
    proto[k] = v;
  });
  return proto;
}
//# sourceMappingURL=rx-document-prototype-merge.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-document.js":
/*!***************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-document.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basePrototype: () => (/* binding */ basePrototype),
/* harmony export */   beforeDocumentUpdateWrite: () => (/* binding */ beforeDocumentUpdateWrite),
/* harmony export */   createRxDocumentConstructor: () => (/* binding */ createRxDocumentConstructor),
/* harmony export */   createWithConstructor: () => (/* binding */ createWithConstructor),
/* harmony export */   isRxDocument: () => (/* binding */ isRxDocument)
/* harmony export */ });
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _rx_change_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-change-event.js */ "./node_modules/rxdb/dist/esm/rx-change-event.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rx-storage-helper.js */ "./node_modules/rxdb/dist/esm/rx-storage-helper.js");
/* harmony import */ var _incremental_write_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./incremental-write.js */ "./node_modules/rxdb/dist/esm/incremental-write.js");









var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return undefined;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return undefined;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return undefined;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return undefined;
    }
    return _this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(d => d._data._deleted));
  },
  get deleted$$() {
    var _this = this;
    var reactivity = _this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return undefined;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    var id = this.primary;
    return _this.collection.eventBulks$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(bulk => !bulk.isLocal), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(bulk => bulk.events.find(ev => ev.documentId === id)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(event => !!event), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(changeEvent => (0,_rx_change_event_js__WEBPACK_IMPORTED_MODULE_2__.getDocumentDataOfRxChangeEvent)((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(changeEvent))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.startWith)(_this.collection._docCache.getLatestDocumentData(id)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(docData => this.collection._docCache.getCachedRxDocument(docData)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.shareReplay)(_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.RXJS_SHARE_REPLAY_DEFAULTS));
  },
  get $$() {
    var _this = this;
    var reactivity = _this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path) {
    if (_overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.isDevMode()) {
      if (path.includes('.item.')) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC1', {
          path
        });
      }
      if (path === this.primaryPath) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC2');
      }

      // final fields cannot be modified and so also not observed
      if (this.collection.schema.finalFields.includes(path)) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC3', {
          path
        });
      }
      var schemaObj = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_9__.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path);
      if (!schemaObj) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC4', {
          path
        });
      }
    }
    return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(data => (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getProperty)(data, path)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.distinctUntilChanged)());
  },
  get$$(path) {
    var obs = this.get$(path);
    var reactivity = this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);
  },
  /**
   * populate the given path
   */
  populate(path) {
    var schemaObj = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_9__.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path);
    var value = this.get(path);
    if (!value) {
      return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC5', {
        path
      });
    }
    if (!schemaObj.ref) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC6', {
        path,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC7', {
        ref: schemaObj.ref,
        path,
        schemaObj
      });
    }
    if (schemaObj.type === 'array') {
      return refCollection.findByIds(value).exec().then(res => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   * @hotPath Performance here is really important,
   * run some tests before changing anything.
   */
  get(objPath) {
    return getDocumentProperty(this, objPath);
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.flatClone)(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return _overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(data);
    } else {
      return _overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.clone)(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('update');
  },
  incrementalUpdate(_updateObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('update');
  },
  updateCRDT(_updateObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('crdt');
  },
  putAttachment() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');
  },
  getAttachment() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');
  },
  allAttachments() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');
  },
  get allAttachments$() {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');
  },
  async modify(mutationFunction,
  // used by some plugins that wrap the method
  _context) {
    var oldData = this._data;
    var newData = await (0,_incremental_write_js__WEBPACK_IMPORTED_MODULE_14__.modifierFromPublicToInternal)(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction,
  // used by some plugins that wrap the method
  _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, (0,_incremental_write_js__WEBPACK_IMPORTED_MODULE_14__.modifierFromPublicToInternal)(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch) {
    var oldData = this._data;
    var newData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.clone)(oldData);
    Object.entries(patch).forEach(([k, v]) => {
      newData[k] = v;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch) {
    return this.incrementalModify(docData => {
      Object.entries(patch).forEach(([k, v]) => {
        docData[k] = v;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.flatClone)(newData);

    // deleted documents cannot be changed
    if (this._data._deleted) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC11', {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeRows = [{
      previous: oldData,
      document: newData
    }];
    var writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');
    var isError = writeResult.error[0];
    (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_15__.throwIfIsStorageWriteError)(this.collection, this.primary, newData, isError);
    await this.collection._runHooks('post', 'save', newData, this);
    return this.collection._docCache.getCachedRxDocument((0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_15__.getWrittenDocumentsFromBulkWriteResponse)(this.collection.schema.primaryPath, writeRows, writeResult)[0]);
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  async remove() {
    if (this.deleted) {
      return Promise.reject((0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC13', {
        document: this,
        id: this.primary
      }));
    }
    var removeResult = await this.collection.bulkRemove([this]);
    if (removeResult.error.length > 0) {
      var error = removeResult.error[0];
      (0,_rx_storage_helper_js__WEBPACK_IMPORTED_MODULE_15__.throwIfIsStorageWriteError)(this.collection, this.primary, this._data, error);
    }
    return removeResult.success[0];
  },
  incrementalRemove() {
    return this.incrementalModify(async docData => {
      await this.collection._runHooks('pre', 'remove', docData, this);
      docData._deleted = true;
      return docData;
    }).then(async newDoc => {
      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);
      return newDoc;
    });
  },
  close() {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC14');
  }
};
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;

    // assume that this is always equal to the doc-data in the database
    this._data = docData;
    this._propertyCache = new Map();

    /**
     * because of the prototype-merge,
     * we can not use the native instanceof operator
     */
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_16__.runPluginHooks)('createRxDocument', doc);
  return doc;
}
function isRxDocument(obj) {
  return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  /**
   * Meta values must always be merged
   * instead of overwritten.
   * This ensures that different plugins do not overwrite
   * each others meta properties.
   */
  newData._meta = Object.assign({}, oldData._meta, newData._meta);

  // ensure modifications are ok
  if (_overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks('pre', 'save', newData, oldData);
}
function getDocumentProperty(doc, objPath) {
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.getFromMapOrCreate)(doc._propertyCache, objPath, () => {
    var valueObj = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getProperty)(doc._data, objPath);

    // direct return if array or non-object
    if (typeof valueObj !== 'object' || valueObj === null || Array.isArray(valueObj)) {
      return _overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(valueObj);
    }
    var proxy = new Proxy(
    /**
     * In dev-mode, the _data is deep-frozen
     * so we have to flat clone here so that
     * the proxy can work.
     */
    (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_12__.flatClone)(valueObj), {
      /**
       * @performance is really important here
       * because people access nested properties very often
       * and might not be aware that this is internally using a Proxy
       */
      get(target, property) {
        if (typeof property !== 'string') {
          return target[property];
        }
        var lastChar = property.charAt(property.length - 1);
        if (lastChar === '$') {
          if (property.endsWith('$$')) {
            var key = property.slice(0, -2);
            return doc.get$$((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.trimDots)(objPath + '.' + key));
          } else {
            var _key = property.slice(0, -1);
            return doc.get$((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.trimDots)(objPath + '.' + _key));
          }
        } else if (lastChar === '_') {
          var _key2 = property.slice(0, -1);
          return doc.populate((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.trimDots)(objPath + '.' + _key2));
        } else {
          /**
           * Performance shortcut
           * In most cases access to nested properties
           * will only access simple values which can be directly returned
           * without creating a new Proxy or utilizing the cache.
           */
          var plainValue = target[property];
          if (typeof plainValue === 'number' || typeof plainValue === 'string' || typeof plainValue === 'boolean') {
            return plainValue;
          }
          return getDocumentProperty(doc, (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.trimDots)(objPath + '.' + property));
        }
      }
    });
    return proxy;
  });
}
;
//# sourceMappingURL=rx-document.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-error.js":
/*!************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-error.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxError: () => (/* binding */ RxError),
/* harmony export */   RxTypeError: () => (/* binding */ RxTypeError),
/* harmony export */   errorUrlHint: () => (/* binding */ errorUrlHint),
/* harmony export */   getErrorUrl: () => (/* binding */ getErrorUrl),
/* harmony export */   isBulkWriteConflictError: () => (/* binding */ isBulkWriteConflictError),
/* harmony export */   newRxError: () => (/* binding */ newRxError),
/* harmony export */   newRxTypeError: () => (/* binding */ newRxTypeError),
/* harmony export */   rxStorageWriteErrorToRxError: () => (/* binding */ rxStorageWriteErrorToRxError)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");



/**
 * here we use custom errors with the additional field 'parameters'
 */


/**
 * transform an object of parameters to a presentable string
 */
function parametersToString(parameters) {
  var ret = '';
  if (Object.keys(parameters).length === 0) return ret;
  ret += '-'.repeat(20) + '\n';
  ret += 'Parameters:\n';
  ret += Object.keys(parameters).map(k => {
    var paramStr = '[object Object]';
    try {
      if (k === 'errors') {
        paramStr = parameters[k].map(err => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k], function (_k, v) {
          return v === undefined ? null : v;
        }, 2);
      }
    } catch (e) {}
    return k + ': ' + paramStr;
  }).join('\n');
  ret += '\n';
  return ret;
}
function messageForError(message, code, parameters) {
  return '' + '\n' + message + '\n' + parametersToString(parameters);
}
var RxError = /*#__PURE__*/function (_Error) {
  // always true, use this to detect if its an rxdb-error

  function RxError(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.url = getErrorUrl(code);
    _this.parameters = parameters;
    _this.rxdb = true; // tag them as internal
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(RxError, _Error);
  var _proto = RxError.prototype;
  _proto.toString = function toString() {
    return this.message;
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxError, [{
    key: "name",
    get: function () {
      return 'RxError (' + this.code + ')';
    }
  }, {
    key: "typeError",
    get: function () {
      return false;
    }
  }]);
}(/*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Error));
var RxTypeError = /*#__PURE__*/function (_TypeError) {
  // always true, use this to detect if its an rxdb-error

  function RxTypeError(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.url = getErrorUrl(code);
    _this2.parameters = parameters;
    _this2.rxdb = true; // tag them as internal
    return _this2;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(RxTypeError, _TypeError);
  var _proto2 = RxTypeError.prototype;
  _proto2.toString = function toString() {
    return this.message;
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxTypeError, [{
    key: "name",
    get: function () {
      return 'RxTypeError (' + this.code + ')';
    }
  }, {
    key: "typeError",
    get: function () {
      return true;
    }
  }]);
}(/*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(TypeError));
function getErrorUrl(code) {
  return 'https://rxdb.info/errors.html?console=errors#' + code;
}
function errorUrlHint(code) {
  return '\nFind out more about this error here: ' + getErrorUrl(code) + ' \n';
}
function newRxError(code, parameters) {
  return new RxError(code, _overwritable_js__WEBPACK_IMPORTED_MODULE_3__.overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, _overwritable_js__WEBPACK_IMPORTED_MODULE_3__.overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);
}

/**
 * Returns the error if it is a 409 conflict,
 * return false if it is another error.
 */
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: 'document write conflict',
  422: 'schema validation error',
  510: 'attachment data missing'
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError('COL20', {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}
//# sourceMappingURL=rx-error.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-query-helper.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-query-helper.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getQueryMatcher: () => (/* binding */ getQueryMatcher),
/* harmony export */   getSortComparator: () => (/* binding */ getSortComparator),
/* harmony export */   normalizeMangoQuery: () => (/* binding */ normalizeMangoQuery),
/* harmony export */   prepareQuery: () => (/* binding */ prepareQuery),
/* harmony export */   runQueryUpdateFunction: () => (/* binding */ runQueryUpdateFunction)
/* harmony export */ });
/* harmony import */ var _query_planner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query-planner.js */ "./node_modules/rxdb/dist/esm/query-planner.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var mingo_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mingo/util */ "./node_modules/mingo/dist/esm/util.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_query_mingo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-query-mingo.js */ "./node_modules/rxdb/dist/esm/rx-query-mingo.js");







/**
 * Normalize the query to ensure we have all fields set
 * and queries that represent the same query logic are detected as equal by the caching.
 */
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  mangoQuery = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.flatClone)(mangoQuery);
  var normalizedMangoQuery = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.clone)(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== 'number') {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    /**
     * In mango query, it is possible to have an
     * equals comparison by directly assigning a value
     * to a property, without the '$eq' operator.
     * Like:
     * selector: {
     *   foo: 'bar'
     * }
     * For normalization, we have to normalize this
     * so our checks can perform properly.
     *
     *
     * TODO this must work recursive with nested queries that
     * contain multiple selectors via $and or $or etc.
     */
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== 'object' || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }

  /**
   * Ensure that if an index is specified,
   * the primaryKey is inside of it.
   */
  if (normalizedMangoQuery.index) {
    var indexAr = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }

  /**
   * To ensure a deterministic sorting,
   * we have to ensure the primary key is always part
   * of the sort query.
   * Primary sorting is added as last sort parameter,
   * similar to how we add the primary key to indexes that do not have it.
   *
   */
  if (!normalizedMangoQuery.sort) {
    /**
     * If no sort is given at all,
     * we can assume that the user does not care about sort order at al.
     *
     * we cannot just use the primary key as sort parameter
     * because it would likely cause the query to run over the primary key index
     * which has a bad performance in most cases.
     */
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map(field => {
        return {
          [field]: 'asc'
        };
      });
    } else {
      /**
       * Find the index that best matches the fields with the logical operators
       */
      if (schema.indexes) {
        var fieldsWithLogicalOperator = new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === 'object' && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find(operator => _query_planner_js__WEBPACK_IMPORTED_MODULE_4__.LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach(index => {
          var useIndex = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isMaybeReadonlyArray)(index) ? index : [index];
          var firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map(field => {
            return {
              [field]: 'asc'
            };
          });
        }
      }

      /**
       * If no good index was found as default sort-order,
       * just use the first index of the schema.
       * If no index is in the schema, use the default-index which
       * is created by RxDB ONLY if there is no other index defined.
       */
      if (!normalizedMangoQuery.sort) {
        if (schema.indexes && schema.indexes.length > 0) {
          var firstIndex = schema.indexes[0];
          var useIndex = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isMaybeReadonlyArray)(firstIndex) ? firstIndex : [firstIndex];
          normalizedMangoQuery.sort = useIndex.map(field => ({
            [field]: 'asc'
          }));
        } else {
          normalizedMangoQuery.sort = [{
            [primaryKey]: 'asc'
          }];
        }
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find(p => (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.firstPropertyNameOfObject)(p) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: 'asc'
      });
    }
  }
  return normalizedMangoQuery;
}

/**
 * Returns the sort-comparator,
 * which is able to sort documents in the same way
 * a query over the db would do.
 */
function getSortComparator(schema, query) {
  if (!query.sort) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('SNH', {
      query
    });
  }
  var sortParts = [];
  query.sort.forEach(sortBlock => {
    var key = Object.keys(sortBlock)[0];
    var direction = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction,
      getValueFn: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.objectPathMonad)(key)
    });
  });
  var fun = (a, b) => {
    for (var i = 0; i < sortParts.length; ++i) {
      var sortPart = sortParts[i];
      var valueA = sortPart.getValueFn(a);
      var valueB = sortPart.getValueFn(b);
      if (valueA !== valueB) {
        var ret = sortPart.direction === 'asc' ? (0,mingo_util__WEBPACK_IMPORTED_MODULE_0__.compare)(valueA, valueB) : (0,mingo_util__WEBPACK_IMPORTED_MODULE_0__.compare)(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}

/**
 * Returns a function
 * that can be used to check if a document
 * matches the query.
 */
function getQueryMatcher(_schema, query) {
  if (!query.sort) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('SNH', {
      query
    });
  }
  var mingoQuery = (0,_rx_query_mingo_js__WEBPACK_IMPORTED_MODULE_6__.getMingoQuery)(query.selector);
  var fun = doc => {
    return mingoQuery.test(doc);
  };
  return fun;
}
async function runQueryUpdateFunction(rxQuery, fn) {
  var docs = await rxQuery.exec();
  if (!docs) {
    // only findOne() queries can return null
    return null;
  }
  if (Array.isArray(docs)) {
    return Promise.all(docs.map(doc => fn(doc)));
  } else if (docs instanceof Map) {
    return Promise.all([...docs.values()].map(doc => fn(doc)));
  } else {
    // via findOne()
    var result = await fn(docs);
    return result;
  }
}

/**
 * @returns a format of the query that can be used with the storage
 * when calling RxStorageInstance().query()
 */
function prepareQuery(schema, mutateableQuery) {
  if (!mutateableQuery.sort) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_5__.newRxError)('SNH', {
      query: mutateableQuery
    });
  }

  /**
   * Store the query plan together with the
   * prepared query to save performance.
   */
  var queryPlan = (0,_query_planner_js__WEBPACK_IMPORTED_MODULE_4__.getQueryPlan)(schema, mutateableQuery);
  return {
    query: mutateableQuery,
    queryPlan
  };
}
//# sourceMappingURL=rx-query-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-query-mingo.js":
/*!******************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-query-mingo.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMingoQuery: () => (/* binding */ getMingoQuery)
/* harmony export */ });
/* harmony import */ var mingo_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mingo/core */ "./node_modules/mingo/dist/esm/core.js");
/* harmony import */ var mingo_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mingo/query */ "./node_modules/mingo/dist/esm/query.js");
/* harmony import */ var mingo_operators_pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mingo/operators/pipeline */ "./node_modules/mingo/dist/esm/operators/pipeline/index.js");
/* harmony import */ var mingo_operators_query_logical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mingo/operators/query/logical */ "./node_modules/mingo/dist/esm/operators/query/logical/index.js");
/* harmony import */ var mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mingo/operators/query/comparison */ "./node_modules/mingo/dist/esm/operators/query/comparison/index.js");
/* harmony import */ var mingo_operators_query_evaluation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mingo/operators/query/evaluation */ "./node_modules/mingo/dist/esm/operators/query/evaluation/index.js");
/* harmony import */ var mingo_operators_query_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mingo/operators/query/array */ "./node_modules/mingo/dist/esm/operators/query/array/index.js");
/* harmony import */ var mingo_operators_query_element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! mingo/operators/query/element */ "./node_modules/mingo/dist/esm/operators/query/element/index.js");








var mingoInitDone = false;

/**
 * The MongoDB query library is huge and we do not need all the operators.
 * If you add an operator here, make sure that you properly add a test in
 * the file /test/unit/rx-storage-query-correctness.test.ts
 *
 * @link https://github.com/kofrasa/mingo#es6
 */
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    (0,mingo_core__WEBPACK_IMPORTED_MODULE_0__.useOperators)(mingo_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.PIPELINE, {
      $sort: mingo_operators_pipeline__WEBPACK_IMPORTED_MODULE_2__.$sort,
      $project: mingo_operators_pipeline__WEBPACK_IMPORTED_MODULE_2__.$project
    });
    (0,mingo_core__WEBPACK_IMPORTED_MODULE_0__.useOperators)(mingo_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.QUERY, {
      $and: mingo_operators_query_logical__WEBPACK_IMPORTED_MODULE_3__.$and,
      $eq: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$eq,
      $elemMatch: mingo_operators_query_array__WEBPACK_IMPORTED_MODULE_6__.$elemMatch,
      $exists: mingo_operators_query_element__WEBPACK_IMPORTED_MODULE_7__.$exists,
      $gt: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$gt,
      $gte: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$gte,
      $in: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$in,
      $lt: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$lt,
      $lte: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$lte,
      $ne: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$ne,
      $nin: mingo_operators_query_comparison__WEBPACK_IMPORTED_MODULE_4__.$nin,
      $mod: mingo_operators_query_evaluation__WEBPACK_IMPORTED_MODULE_5__.$mod,
      $nor: mingo_operators_query_logical__WEBPACK_IMPORTED_MODULE_3__.$nor,
      $not: mingo_operators_query_logical__WEBPACK_IMPORTED_MODULE_3__.$not,
      $or: mingo_operators_query_logical__WEBPACK_IMPORTED_MODULE_3__.$or,
      $regex: mingo_operators_query_evaluation__WEBPACK_IMPORTED_MODULE_5__.$regex,
      $size: mingo_operators_query_array__WEBPACK_IMPORTED_MODULE_6__.$size,
      $type: mingo_operators_query_element__WEBPACK_IMPORTED_MODULE_7__.$type
    });
    mingoInitDone = true;
  }
  return new mingo_query__WEBPACK_IMPORTED_MODULE_1__.Query(selector);
}
//# sourceMappingURL=rx-query-mingo.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-query-single-result.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-query-single-result.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxQuerySingleResult: () => (/* binding */ RxQuerySingleResult)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _doc_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./doc-cache.js */ "./node_modules/rxdb/dist/esm/doc-cache.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");




/**
 * RxDB needs the query results in multiple formats.
 * Sometimes as a Map or an array with only the documentData.
 * For better performance we work with this class
 * that initializes stuff lazily so that
 * we can directly work with the query results after RxQuery.exec()
 */
var RxQuerySingleResult = /*#__PURE__*/function () {
  /**
   * Time at which the current _result state was created.
   * Used to determine if the result set has changed since X
   * so that we do not emit the same result multiple times on subscription.
   */

  function RxQuerySingleResult(query,
  // only used internally, do not use outside, use this.docsData instead
  docsDataFromStorageInstance,
  // can be overwritten for count-queries
  count) {
    this.time = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.now)();
    this.query = query;
    this.count = count;
    this.documents = (0,_doc_cache_js__WEBPACK_IMPORTED_MODULE_2__.mapDocumentsDataToCacheDocs)(this.query.collection._docCache, docsDataFromStorageInstance);
  }

  /**
   * Instead of using the newResultData in the result cache,
   * we directly use the objects that are stored in the RxDocument
   * to ensure we do not store the same data twice and fill up the memory.
   * @overwrites itself with the actual value
   */
  var _proto = RxQuerySingleResult.prototype;
  _proto.getValue = function getValue(throwIfMissing) {
    var op = this.query.op;
    if (op === 'count') {
      return this.count;
    } else if (op === 'findOne') {
      // findOne()-queries emit RxDocument or null
      var doc = this.documents.length === 0 ? null : this.documents[0];
      if (!doc && throwIfMissing) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_3__.newRxError)('QU10', {
          collection: this.query.collection.name,
          query: this.query.mangoQuery,
          op
        });
      } else {
        return doc;
      }
    } else if (op === 'findByIds') {
      return this.docsMap;
    } else {
      // find()-queries emit RxDocument[]
      // Flat copy the array so it won't matter if the user modifies it.
      return this.documents.slice(0);
    }
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxQuerySingleResult, [{
    key: "docsData",
    get: function () {
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'docsData', this.documents.map(d => d._data));
    }

    // A key->document map, used in the event reduce optimization.
  }, {
    key: "docsDataMap",
    get: function () {
      var map = new Map();
      this.documents.forEach(d => {
        map.set(d.primary, d._data);
      });
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'docsDataMap', map);
    }
  }, {
    key: "docsMap",
    get: function () {
      var map = new Map();
      var documents = this.documents;
      for (var i = 0; i < documents.length; i++) {
        var doc = documents[i];
        map.set(doc.primary, doc);
      }
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'docsMap', map);
    }
  }]);
}();
//# sourceMappingURL=rx-query-single-result.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-query.js":
/*!************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-query.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxQueryBase: () => (/* binding */ RxQueryBase),
/* harmony export */   _getDefaultQuery: () => (/* binding */ _getDefaultQuery),
/* harmony export */   createRxQuery: () => (/* binding */ createRxQuery),
/* harmony export */   isFindOneByIdQuery: () => (/* binding */ isFindOneByIdQuery),
/* harmony export */   isRxQuery: () => (/* binding */ isRxQuery),
/* harmony export */   queryCollection: () => (/* binding */ queryCollection),
/* harmony export */   tunnelQueryCache: () => (/* binding */ tunnelQueryCache)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _event_reduce_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./event-reduce.js */ "./node_modules/rxdb/dist/esm/event-reduce.js");
/* harmony import */ var _query_cache_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./query-cache.js */ "./node_modules/rxdb/dist/esm/query-cache.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");
/* harmony import */ var _rx_query_single_result_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-query-single-result.js */ "./node_modules/rxdb/dist/esm/rx-query-single-result.js");










var _queryCount = 0;
var newQueryID = function () {
  return ++_queryCount;
};
var RxQueryBase = /*#__PURE__*/function () {
  /**
   * Some stats then are used for debugging and cache replacement policies
   */

  // used in the query-cache to determine if the RxQuery can be cleaned up.

  // used to count the subscribers to the query

  /**
   * Contains the current result state
   * or null if query has not run yet.
   */

  function RxQueryBase(op, mangoQuery, collection,
  // used by some plugins
  other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.now)();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._ensureEqualQueue = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase.prototype;
  /**
   * Returns an observable that emits the results
   * This should behave like an rxjs-BehaviorSubject which means:
   * - Emit the current result-set on subscribe
   * - Emit the new result-set when an RxChangeEvent comes in
   * - Do not emit anything before the first result-set was created (no null)
   */
  /**
   * set the new result-data as result-docs of the query
   * @param newResultData json-docs that were received from the storage
   */
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === 'undefined') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU18', {
        database: this.collection.database.name,
        collection: this.collection.name
      });
    }
    if (typeof newResultData === 'number') {
      this._result = new _rx_query_single_result_js__WEBPACK_IMPORTED_MODULE_5__.RxQuerySingleResult(this, [], newResultData);
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var newQueryResult = new _rx_query_single_result_js__WEBPACK_IMPORTED_MODULE_5__.RxQuerySingleResult(this, newResultData, newResultData.length);
    this._result = newQueryResult;
  }

  /**
   * executes the query on the database
   * @return results-array with document-data
   */;
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    if (this.op === 'count') {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU14', {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === 'findByIds') {
      var ids = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = new Map();
      var mustBeQueried = [];
      // first try to fill from docCache
      ids.forEach(id => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id, doc);
          }
        } else {
          mustBeQueried.push(id);
        }
      });
      // everything which was not in docCache must be fetched from the storage
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        docs.forEach(docData => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then(docs => {
      return docs;
    });
  }

  /**
   * Execute the query
   * To have an easier implementations,
   * just subscribe and use the first result
   */;
  _proto.exec = async function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== 'findOne') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU9', {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }

    /**
     * run _ensureEqual() here,
     * this will make sure that errors in the query which throw inside of the RxStorage,
     * will be thrown at this execution context and not in the background.
     */
    await _ensureEqual(this);
    var useResult = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(this._result);
    return useResult.getValue(throwIfMissing);
  }

  /**
   * cached call to get the queryMatcher
   * @overwrites itself with the actual value
   */;
  /**
   * returns a string that is used for equal-comparisons
   * @overwrites itself with the actual value
   */
  _proto.toString = function toString() {
    var stringObj = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.sortObject)({
      op: this.op,
      query: (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery),
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj);
    this.toString = () => value;
    return value;
  }

  /**
   * returns the prepared query
   * which can be send to the storage instance to query for documents.
   * @overwrites itself with the actual value.
   */;
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    hookInput.mangoQuery.selector._deleted = {
      $eq: false
    };
    if (hookInput.mangoQuery.index) {
      hookInput.mangoQuery.index.unshift('_deleted');
    }
    (0,_hooks_js__WEBPACK_IMPORTED_MODULE_9__.runPluginHooks)('prePrepareQuery', hookInput);
    var value = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.prepareQuery)(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  }

  /**
   * returns true if the document matches the query,
   * does not use the 'skip' and 'limit'
   */;
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    // if doc is deleted, it cannot match
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  }

  /**
   * deletes all found documents
   * @return promise with deleted documents
   */;
  _proto.remove = async function remove() {
    var docs = await this.exec();
    if (Array.isArray(docs)) {
      var result = await this.collection.bulkRemove(docs);
      if (result.error.length > 0) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_4__.rxStorageWriteErrorToRxError)(result.error[0]);
      } else {
        return result.success;
      }
    } else {
      return docs.remove();
    }
  };
  _proto.incrementalRemove = function incrementalRemove() {
    return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.incrementalRemove());
  }

  /**
   * helper function to transform RxQueryBase to RxQuery type
   */;
  /**
   * updates all found documents
   * @overwritten by plugin (optional)
   */
  _proto.update = function update(_updateObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('update');
  };
  _proto.patch = function patch(_patch) {
    return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.patch(_patch));
  };
  _proto.incrementalPatch = function incrementalPatch(patch) {
    return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.incrementalPatch(patch));
  };
  _proto.modify = function modify(mutationFunction) {
    return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.modify(mutationFunction));
  };
  _proto.incrementalModify = function incrementalModify(mutationFunction) {
    return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.runQueryUpdateFunction)(this.asRxQuery, doc => doc.incrementalModify(mutationFunction));
  }

  // we only set some methods of query-builder here
  // because the others depend on these ones
  ;
  _proto.where = function where(_queryObj) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');
  };
  _proto.sort = function sort(_params) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');
  };
  _proto.skip = function skip(_amount) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');
  };
  _proto.limit = function limit(_amount) {
    throw (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxQueryBase, [{
    key: "$",
    get: function () {
      if (!this._$) {
        var results$ = this.collection.eventBulks$.pipe(
        /**
         * Performance shortcut.
         * Changes to local documents are not relevant for the query.
         */
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(bulk => !bulk.isLocal),
        /**
         * Start once to ensure the querying also starts
         * when there where no changes.
         */
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.startWith)(null),
        // ensure query results are up to date.
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.mergeMap)(() => _ensureEqual(this)),
        // use the current result set, written by _ensureEqual().
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(() => this._result),
        // do not run stuff above for each new subscriber, only once.
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.shareReplay)(_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.RXJS_SHARE_REPLAY_DEFAULTS),
        // do not proceed if result set has not changed.
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.distinctUntilChanged)((prev, curr) => {
          if (prev && prev.time === (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(curr).time) {
            return true;
          } else {
            return false;
          }
        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(result => !!result),
        /**
         * Map the result set to a single RxDocument or an array,
         * depending on query type
         */
        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(result => {
          return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(result).getValue();
        }));
        this._$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.merge)(results$,
        /**
         * Also add the refCount$ to the query observable
         * to allow us to count the amount of subscribers.
         */
        this.refCount$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(() => false)));
      }
      return this._$;
    }
  }, {
    key: "$$",
    get: function () {
      var reactivity = this.collection.database.getReactivityFactory();
      return reactivity.fromObservable(this.$, undefined, this.collection.database);
    }

    // stores the changeEvent-number of the last handled change-event

    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function () {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery);
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.overwriteGetterForCaching)(this, 'queryMatcher', (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_8__.getQueryMatcher)(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function () {
      return this;
    }
  }]);
}();
function _getDefaultQuery() {
  return {
    selector: {}
  };
}

/**
 * run this query through the QueryCache
 */
function tunnelQueryCache(rxQuery) {
  return rxQuery.collection._queryCache.getByQuery(rxQuery);
}
function createRxQuery(op, queryObj, collection, other) {
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_9__.runPluginHooks)('preCreateRxQuery', {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);

  // ensure when created with same params, only one is created
  ret = tunnelQueryCache(ret);
  (0,_query_cache_js__WEBPACK_IMPORTED_MODULE_18__.triggerCacheReplacement)(collection);
  return ret;
}

/**
 * Check if the current results-state is in sync with the database
 * which means that no write event happened since the last run.
 * @return false if not which means it should re-execute
 */
function _isResultsInSync(rxQuery) {
  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();
  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}

/**
 * wraps __ensureEqual()
 * to ensure it does not run in parallel
 * @return true if has changed, false if not
 */
async function _ensureEqual(rxQuery) {
  if (rxQuery.collection.awaitBeforeReads.size > 0) {
    await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));
  }

  // Optimisation shortcut
  if (rxQuery.collection.database.closed || _isResultsInSync(rxQuery)) {
    return false;
  }
  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));
  return rxQuery._ensureEqualQueue;
}

/**
 * ensures that the results of this query is equal to the results which a query over the database would give
 * @return true if results have changed
 */
function __ensureEqual(rxQuery) {
  rxQuery._lastEnsureEqual = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.now)();

  /**
   * Optimisation shortcuts
   */
  if (
  // db is closed
  rxQuery.collection.database.closed ||
  // nothing happened since last run
  _isResultsInSync(rxQuery)) {
    return _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false; // if this becomes true, a whole execution over the database is made
  if (rxQuery._latestChangeEvent === -1) {
    // have not executed yet -> must run
    mustReExec = true;
  }

  /**
   * try to use EventReduce to calculate the new results
   */
  if (!mustReExec) {
    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      // changeEventBuffer is of bounds -> we must re-execute over the database
      mustReExec = true;
    } else {
      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();
      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery.op === 'count') {
        // 'count' query
        var previousCount = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.ensureNotFalsy)(rxQuery._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach(cE => {
          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true; // true because results changed
          rxQuery._setResultData(newCount);
        }
      } else {
        // 'find' or 'findOne' query
        var eventReduceResult = (0,_event_reduce_js__WEBPACK_IMPORTED_MODULE_19__.calculateNewResults)(rxQuery, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          // could not calculate the new results, execute must be done
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          // we got the new results, we do not have to re-execute, mustReExec stays false
          ret = true; // true because results changed
          rxQuery._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }

  // oh no we have to re-execute the whole query over the database
  if (mustReExec) {
    return rxQuery._execOverDatabase().then(newResultData => {
      /**
       * The RxStorage is defined to always first emit events and then return
       * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()
       * has been run, not the one from before.
       */
      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();

      // A count query needs a different has-changed check.
      if (typeof newResultData === 'number') {
        if (!rxQuery._result || newResultData !== rxQuery._result.count) {
          ret = true;
          rxQuery._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery._result || !(0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_20__.areRxDocumentArraysEqual)(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {
        ret = true; // true because results changed
        rxQuery._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret); // true if results have changed
}

/**
 * Runs the query over the storage instance
 * of the collection.
 * Does some optimizations to ensure findById is used
 * when specific queries are used.
 */
async function queryCollection(rxQuery) {
  var docs = [];
  var collection = rxQuery.collection;

  /**
   * Optimizations shortcut.
   * If query is find-one-document-by-id,
   * then we do not have to use the slow query() method
   * but instead can use findDocumentsById()
   */
  if (rxQuery.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {
      var docIds = rxQuery.isFindOneByIdQuery;
      docIds = docIds.filter(docId => {
        // first try to fill from docCache
        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);
        if (docData) {
          if (!docData._deleted) {
            docs.push(docData);
          }
          return false;
        } else {
          return true;
        }
      });
      // otherwise get from storage
      if (docIds.length > 0) {
        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_21__.appendToArray)(docs, docsFromStorage);
      }
    } else {
      var docId = rxQuery.isFindOneByIdQuery;

      // first try to fill from docCache
      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        // otherwise get from storage
        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);
        if (fromStorageList[0]) {
          docData = fromStorageList[0];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}

/**
 * Returns true if the given query
 * selects exactly one document by its id.
 * Used to optimize performance because these kind of
 * queries do not have to run over an index and can use get-by-id instead.
 * Returns false if no query of that kind.
 * Returns the document id otherwise.
 */
function isFindOneByIdQuery(primaryPath, query) {
  // must have exactly one operator which must be $eq || $in
  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {
    var value = query.selector[primaryPath];
    if (typeof value === 'string') {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {
      return value.$eq;
    }

    // same with $in string arrays
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&
    // must only contain strings
    !value.$eq.find(r => typeof r !== 'string')) {
      return value.$eq;
    }
  }
  return false;
}
function isRxQuery(obj) {
  return obj instanceof RxQueryBase;
}
//# sourceMappingURL=rx-query.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-schema-helper.js":
/*!********************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-schema-helper.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_CHECKPOINT_SCHEMA: () => (/* binding */ DEFAULT_CHECKPOINT_SCHEMA),
/* harmony export */   RX_META_SCHEMA: () => (/* binding */ RX_META_SCHEMA),
/* harmony export */   fillObjectWithDefaults: () => (/* binding */ fillObjectWithDefaults),
/* harmony export */   fillPrimaryKey: () => (/* binding */ fillPrimaryKey),
/* harmony export */   fillWithDefaultSettings: () => (/* binding */ fillWithDefaultSettings),
/* harmony export */   getComposedPrimaryKeyOfDocumentData: () => (/* binding */ getComposedPrimaryKeyOfDocumentData),
/* harmony export */   getDefaultIndex: () => (/* binding */ getDefaultIndex),
/* harmony export */   getFinalFields: () => (/* binding */ getFinalFields),
/* harmony export */   getLengthOfPrimaryKey: () => (/* binding */ getLengthOfPrimaryKey),
/* harmony export */   getPrimaryFieldOfPrimaryKey: () => (/* binding */ getPrimaryFieldOfPrimaryKey),
/* harmony export */   getPseudoSchemaForVersion: () => (/* binding */ getPseudoSchemaForVersion),
/* harmony export */   getSchemaByObjectPath: () => (/* binding */ getSchemaByObjectPath),
/* harmony export */   normalizeRxJsonSchema: () => (/* binding */ normalizeRxJsonSchema)
/* harmony export */ });
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-regex.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");


/**
 * Helper function to create a valid RxJsonSchema
 * with a given version.
 */
function getPseudoSchemaForVersion(version, primaryKey) {
  var pseudoSchema = fillWithDefaultSettings({
    version,
    type: 'object',
    primaryKey: primaryKey,
    properties: {
      [primaryKey]: {
        type: 'string',
        maxLength: 100
      },
      value: {
        type: 'string'
      }
    },
    indexes: [[primaryKey]],
    required: [primaryKey]
  });
  return pseudoSchema;
}

/**
 * Returns the sub-schema for a given path
 */
function getSchemaByObjectPath(rxJsonSchema, path) {
  var usePath = path;
  usePath = usePath.replace(_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.REGEX_ALL_DOTS, '.properties.');
  usePath = 'properties.' + usePath;
  usePath = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.trimDots)(usePath);
  var ret = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getProperty)(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema, documentData) {
  // optimization shortcut.
  if (typeof jsonSchema.primaryKey === 'string') {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DOC19', {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === 'string') {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getLengthOfPrimaryKey(schema) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  var schemaPart = getSchemaByObjectPath(schema, primaryPath);
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.ensureNotFalsy)(schemaPart.maxLength);
}

/**
 * Returns the composed primaryKey of a document by its data.
 */
function getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === 'string') {
    return documentData[jsonSchema.primaryKey];
  }
  var compositePrimary = jsonSchema.primaryKey;
  return compositePrimary.fields.map(field => {
    var value = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getProperty)(documentData, field);
    if (typeof value === 'undefined') {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DOC18', {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}

/**
 * Normalize the RxJsonSchema.
 * We need this to ensure everything is set up properly
 * and we have the same hash on schemas that represent the same value but
 * have different json.
 *
 * - Orders the schemas attributes by alphabetical order
 * - Adds the primaryKey to all indexes that do not contain the primaryKey
 * - We need this for deterministic sort order on all queries, which is required for event-reduce to work.
 *
 * @return RxJsonSchema - ordered and filled
 */
function normalizeRxJsonSchema(jsonSchema) {
  var normalizedSchema = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.sortObject)(jsonSchema, true);
  return normalizedSchema;
}

/**
 * If the schema does not specify any index,
 * we add this index so we at least can run RxQuery()
 * and only select non-deleted fields.
 */
function getDefaultIndex(primaryPath) {
  return ['_deleted', primaryPath];
}

/**
 * fills the schema-json with default-settings
 * @return cloned schemaObj
 */
function fillWithDefaultSettings(schemaObj) {
  schemaObj = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.flatClone)(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.flatClone)(schemaObj.properties);

  // additionalProperties is always false
  schemaObj.additionalProperties = false;

  // fill with key-compression-state ()
  if (!Object.prototype.hasOwnProperty.call(schemaObj, 'keyCompression')) {
    schemaObj.keyCompression = false;
  }

  // indexes must be array
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];

  // required must be array
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];

  // encrypted must be array
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];

  // add _rev
  schemaObj.properties._rev = {
    type: 'string',
    minLength: 1
  };

  // add attachments
  schemaObj.properties._attachments = {
    type: 'object'
  };

  // add deleted flag
  schemaObj.properties._deleted = {
    type: 'boolean'
  };

  // add meta property
  schemaObj.properties._meta = RX_META_SCHEMA;

  /**
   * meta fields are all required
   */
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push('_deleted');
  schemaObj.required.push('_rev');
  schemaObj.required.push('_meta');
  schemaObj.required.push('_attachments');

  // final fields are always required
  var finalFields = getFinalFields(schemaObj);
  (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.appendToArray)(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter(field => !field.includes('.')).filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique;

  // version is 0 by default
  schemaObj.version = schemaObj.version || 0;
  var useIndexes = schemaObj.indexes.map(index => {
    var arIndex = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isMaybeReadonlyArray)(index) ? index.slice(0) : [index];
    /**
     * Append primary key to indexes that do not contain the primaryKey.
     * All indexes must have the primaryKey to ensure a deterministic sort order.
     */
    if (!arIndex.includes(primaryPath)) {
      arIndex.push(primaryPath);
    }

    // add _deleted flag to all indexes so we can query only non-deleted fields
    // in RxDB itself
    if (arIndex[0] !== '_deleted') {
      arIndex.unshift('_deleted');
    }
    return arIndex;
  });
  if (useIndexes.length === 0) {
    useIndexes.push(getDefaultIndex(primaryPath));
  }

  // we need this index for the getChangedDocumentsSince() method
  useIndexes.push(['_meta.lwt', primaryPath]);

  // also add the internalIndexes
  if (schemaObj.internalIndexes) {
    schemaObj.internalIndexes.map(idx => {
      useIndexes.push(idx);
    });
  }

  // make indexes unique
  var hasIndex = new Set();
  useIndexes.filter(index => {
    var indexStr = index.join(',');
    if (hasIndex.has(indexStr)) {
      return false;
    } else {
      hasIndex.add(indexStr);
      return true;
    }
  });
  schemaObj.indexes = useIndexes;
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: 'object',
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: 'number',
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.RX_META_LWT_MINIMUM,
      maximum: 1000000000000000,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ['lwt']
};

/**
 * returns the final-fields of the schema
 * @return field-names of the final-fields
 */
function getFinalFields(jsonSchema) {
  var ret = Object.keys(jsonSchema.properties).filter(key => jsonSchema.properties[key].final);

  // primary is also final
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);
  ret.push(primaryPath);

  // fields of composite primary are final
  if (typeof jsonSchema.primaryKey !== 'string') {
    jsonSchema.primaryKey.fields.forEach(field => ret.push(field));
  }
  return ret;
}

/**
 * fills all unset fields with default-values if set
 * @hotPath
 */
function fillObjectWithDefaults(rxSchema, obj) {
  var defaultKeys = Object.keys(rxSchema.defaultValues);
  for (var i = 0; i < defaultKeys.length; ++i) {
    var key = defaultKeys[i];
    if (!Object.prototype.hasOwnProperty.call(obj, key) || typeof obj[key] === 'undefined') {
      obj[key] = rxSchema.defaultValues[key];
    }
  }
  return obj;
}
var DEFAULT_CHECKPOINT_SCHEMA = {
  type: 'object',
  properties: {
    id: {
      type: 'string'
    },
    lwt: {
      type: 'number'
    }
  },
  required: ['id', 'lwt'],
  additionalProperties: false
};
//# sourceMappingURL=rx-schema-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-schema.js":
/*!*************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-schema.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RxSchema: () => (/* binding */ RxSchema),
/* harmony export */   createRxSchema: () => (/* binding */ createRxSchema),
/* harmony export */   getIndexes: () => (/* binding */ getIndexes),
/* harmony export */   getPreviousVersions: () => (/* binding */ getPreviousVersions),
/* harmony export */   isRxSchema: () => (/* binding */ isRxSchema),
/* harmony export */   toTypedRxJsonSchema: () => (/* binding */ toTypedRxJsonSchema)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");






var RxSchema = /*#__PURE__*/function () {
  function RxSchema(jsonSchema, hashFunction) {
    this.jsonSchema = jsonSchema;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);

    // primary is always required
    this.primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.getPrimaryFieldOfPrimaryKey)(this.jsonSchema.primaryKey);

    /**
     * Many people accidentally put in wrong schema state
     * without the dev-mode plugin, so we need this check here
     * even in non-dev-mode.
     */
    if (!jsonSchema.properties[this.primaryPath].maxLength) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('SC39', {
        schema: jsonSchema
      });
    }
    this.finalFields = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.getFinalFields)(this.jsonSchema);
  }
  var _proto = RxSchema.prototype;
  /**
   * checks if a given change on a document is allowed
   * Ensures that:
   * - final fields are not modified
   * @throws {Error} if not valid
   */
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach(fieldName => {
      if (!(0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(dataBefore[fieldName], dataAfter[fieldName])) {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_2__.newRxError)('DOC9', {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  }

  /**
   * creates the schema-based document-prototype,
   * see RxCollection.getDocumentPrototype()
   */;
  _proto.getDocumentPrototype = function getDocumentPrototype() {
    var proto = {};

    /**
     * On the top level, we know all keys
     * and therefore do not have to create a new Proxy object
     * for each document. Instead we define the getter in the prototype once.
     */
    var pathProperties = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.getSchemaByObjectPath)(this.jsonSchema, '');
    Object.keys(pathProperties).forEach(key => {
      var fullPath = key;

      // getter - value
      proto.__defineGetter__(key, function () {
        if (!this.get || typeof this.get !== 'function') {
          /**
           * When an object gets added to the state of a vuejs-component,
           * it happens that this getter is called with another scope.
           * To prevent errors, we have to return undefined in this case
           */
          return undefined;
        }
        var ret = this.get(fullPath);
        return ret;
      });
      // getter - observable$
      Object.defineProperty(proto, key + '$', {
        get: function () {
          return this.get$(fullPath);
        },
        enumerable: false,
        configurable: false
      });
      // getter - reactivity$$
      Object.defineProperty(proto, key + '$$', {
        get: function () {
          return this.get$$(fullPath);
        },
        enumerable: false,
        configurable: false
      });
      // getter - populate_
      Object.defineProperty(proto, key + '_', {
        get: function () {
          return this.populate(fullPath);
        },
        enumerable: false,
        configurable: false
      });
    });
    (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'getDocumentPrototype', () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.getComposedPrimaryKeyOfDocumentData)(this.jsonSchema, documentData);
  };
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__["default"])(RxSchema, [{
    key: "version",
    get: function () {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function () {
      var values = {};
      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default')).forEach(([k, v]) => values[k] = v.default);
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'defaultValues', values);
    }

    /**
     * @overrides itself on the first call
     */
  }, {
    key: "hash",
    get: function () {
      return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.overwriteGetterForCaching)(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
}();
function getIndexes(jsonSchema) {
  return (jsonSchema.indexes || []).map(index => (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isMaybeReadonlyArray)(index) ? index : [index]);
}

/**
 * array with previous version-numbers
 */
function getPreviousVersions(schema) {
  var version = schema.version ? schema.version : 0;
  var c = 0;
  return new Array(version).fill(0).map(() => c++);
}
function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    (0,_hooks_js__WEBPACK_IMPORTED_MODULE_6__.runPluginHooks)('preCreateRxSchema', jsonSchema);
  }
  var useJsonSchema = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.fillWithDefaultSettings)(jsonSchema);
  useJsonSchema = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_1__.normalizeRxJsonSchema)(useJsonSchema);
  _overwritable_js__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  (0,_hooks_js__WEBPACK_IMPORTED_MODULE_6__.runPluginHooks)('createRxSchema', schema);
  return schema;
}
function isRxSchema(obj) {
  return obj instanceof RxSchema;
}

/**
 * Used as helper function the generate the document type out of the schema via typescript.
 * @link https://github.com/pubkey/rxdb/discussions/3467
 */
function toTypedRxJsonSchema(schema) {
  return schema;
}
//# sourceMappingURL=rx-schema.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-storage-helper.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-storage-helper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INTERNAL_STORAGE_NAME: () => (/* binding */ INTERNAL_STORAGE_NAME),
/* harmony export */   RX_DATABASE_LOCAL_DOCS_STORAGE_NAME: () => (/* binding */ RX_DATABASE_LOCAL_DOCS_STORAGE_NAME),
/* harmony export */   attachmentWriteDataToNormalData: () => (/* binding */ attachmentWriteDataToNormalData),
/* harmony export */   categorizeBulkWriteRows: () => (/* binding */ categorizeBulkWriteRows),
/* harmony export */   ensureRxStorageInstanceParamsAreCorrect: () => (/* binding */ ensureRxStorageInstanceParamsAreCorrect),
/* harmony export */   flatCloneDocWithMeta: () => (/* binding */ flatCloneDocWithMeta),
/* harmony export */   getAttachmentSize: () => (/* binding */ getAttachmentSize),
/* harmony export */   getChangedDocumentsSince: () => (/* binding */ getChangedDocumentsSince),
/* harmony export */   getChangedDocumentsSinceQuery: () => (/* binding */ getChangedDocumentsSinceQuery),
/* harmony export */   getSingleDocument: () => (/* binding */ getSingleDocument),
/* harmony export */   getWrappedStorageInstance: () => (/* binding */ getWrappedStorageInstance),
/* harmony export */   getWrittenDocumentsFromBulkWriteResponse: () => (/* binding */ getWrittenDocumentsFromBulkWriteResponse),
/* harmony export */   hasEncryption: () => (/* binding */ hasEncryption),
/* harmony export */   observeSingle: () => (/* binding */ observeSingle),
/* harmony export */   randomDelayStorage: () => (/* binding */ randomDelayStorage),
/* harmony export */   stackCheckpoints: () => (/* binding */ stackCheckpoints),
/* harmony export */   stripAttachmentsDataFromDocument: () => (/* binding */ stripAttachmentsDataFromDocument),
/* harmony export */   stripAttachmentsDataFromRow: () => (/* binding */ stripAttachmentsDataFromRow),
/* harmony export */   throwIfIsStorageWriteError: () => (/* binding */ throwIfIsStorageWriteError),
/* harmony export */   writeSingle: () => (/* binding */ writeSingle)
/* harmony export */ });
/* harmony import */ var _overwritable_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./overwritable.js */ "./node_modules/rxdb/dist/esm/overwritable.js");
/* harmony import */ var _rx_error_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-error.js */ "./node_modules/rxdb/dist/esm/rx-error.js");
/* harmony import */ var _rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper.js */ "./node_modules/rxdb/dist/esm/rx-schema-helper.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js");
/* harmony import */ var _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./plugins/utils/index.js */ "./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js");
/* harmony import */ var _rx_query_helper_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rx-query-helper.js */ "./node_modules/rxdb/dist/esm/rx-query-helper.js");
/* harmony import */ var _hooks_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hooks.js */ "./node_modules/rxdb/dist/esm/hooks.js");
/**
 * Helper functions for accessing the RxStorage instances.
 */








var INTERNAL_STORAGE_NAME = '_rxdb_internal';
var RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[0];
  if (doc) {
    return doc;
  } else {
    return undefined;
  }
}

/**
 * Writes a single document,
 * throws RxStorageBulkWriteError on failure
 */
async function writeSingle(instance, writeRow, context) {
  var writeResult = await instance.bulkWrite([writeRow], context);
  if (writeResult.error.length > 0) {
    var error = writeResult.error[0];
    throw error;
  } else {
    var primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(instance.schema.primaryKey);
    var success = getWrittenDocumentsFromBulkWriteResponse(primaryPath, [writeRow], writeResult);
    var ret = success[0];
    return ret;
  }
}

/**
 * Observe the plain document data of a single document.
 * Do not forget to unsubscribe.
 */
function observeSingle(storageInstance, documentId) {
  var firstFindPromise = getSingleDocument(storageInstance, documentId);
  var ret = storageInstance.changeStream().pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_1__.map)(evBulk => evBulk.events.find(ev => ev.documentId === documentId)), (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.filter)(ev => !!ev), (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.map)(ev => Promise.resolve((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(ev).documentData)), (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.startWith)(firstFindPromise), (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.switchMap)(v => v), (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.filter)(v => !!v));
  return ret;
}

/**
 * Checkpoints must be stackable over another.
 * This is required form some RxStorage implementations
 * like the sharding plugin, where a checkpoint only represents
 * the document state from some, but not all shards.
 */
function stackCheckpoints(checkpoints) {
  return Object.assign({}, ...checkpoints);
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('CONFLICT', {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('VD2', {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}

/**
 * Analyzes a list of BulkWriteRows and determines
 * which documents must be inserted, updated or deleted
 * and which events must be emitted and which documents cause a conflict
 * and must not be written.
 * Used as helper inside of some RxStorage implementations.
 * @hotPath The performance of this function is critical
 */
function categorizeBulkWriteRows(storageInstance, primaryPath,
/**
 * Current state of the documents
 * inside of the storage. Used to determine
 * which writes cause conflicts.
 * This must be a Map for better performance.
 */
docsInDb,
/**
 * The write rows that are passed to
 * RxStorageInstance().bulkWrite().
 */
bulkWriteRows, context,
/**
 * Used by some storages for better performance.
 * For example when get-by-id and insert/update can run in parallel.
 */
onInsert, onUpdate) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = [];
  var eventBulkId = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.randomToken)(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var hasDocsInDb = docsInDb.size > 0;
  var newestRow;

  /**
   * @performance is really important in this loop!
   */
  var rowAmount = bulkWriteRows.length;
  var _loop = function () {
    var writeRow = bulkWriteRows[rowId];

    // use these variables to have less property accesses
    var document = writeRow.document;
    var previous = writeRow.previous;
    var docId = document[primaryPath];
    var documentDeleted = document._deleted;
    var previousDeleted = previous && previous._deleted;
    var documentInDb = undefined;
    if (hasDocsInDb) {
      documentInDb = docsInDb.get(docId);
    }
    var attachmentError;
    if (!documentInDb) {
      /**
       * It is possible to insert already deleted documents,
       * this can happen on replication.
       */
      var insertedIsDeleted = documentDeleted ? true : false;
      if (hasAttachments) {
        Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors.push(attachmentError);
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData: attachmentData,
              digest: attachmentData.digest
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
          if (onInsert) {
            onInsert(document);
          }
        } else {
          bulkInsertDocs.push(writeRow);
          if (onInsert) {
            onInsert(document);
          }
        }
        newestRow = writeRow;
      }
      if (!insertedIsDeleted) {
        var event = {
          documentId: docId,
          operation: 'INSERT',
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(document) : document,
          previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous
        };
        eventBulkEvents.push(event);
      }
    } else {
      // update existing document
      var revInDb = documentInDb._rev;

      /**
       * Check for conflict
       */
      if (!previous || !!previous && revInDb !== previous._rev) {
        // is conflict error
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow: writeRow,
          documentInDb
        };
        errors.push(err);
        return 1; // continue
      }

      // handle attachments data

      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (documentDeleted) {
          /**
           * Deleted documents must have cleared all their attachments.
           */
          if (previous) {
            Object.keys(previous._attachments).forEach(attachmentId => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          // first check for errors
          Object.entries(document._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb: documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData: attachmentData,
                  digest: attachmentData.digest
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data &&
                /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData: attachmentData,
                    digest: attachmentData.digest
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors.push(attachmentError);
      } else {
        if (hasAttachments) {
          bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));
          if (onUpdate) {
            onUpdate(document);
          }
        } else {
          bulkUpdateDocs.push(updatedRow);
          if (onUpdate) {
            onUpdate(document);
          }
        }
        newestRow = updatedRow;
      }
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (previousDeleted && !documentDeleted) {
        operation = 'INSERT';
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;
      } else if (previous && !previousDeleted && !documentDeleted) {
        operation = 'UPDATE';
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;
        previousEventDocumentData = previous;
      } else if (documentDeleted) {
        operation = 'DELETE';
        eventDocumentData = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(document);
        previousEventDocumentData = previous;
      } else {
        throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('SNH', {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation: operation
      };
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop()) continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}

/**
 * Used in custom RxStorage implementations.
 */
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    length: getAttachmentSize(data),
    digest: writeData.digest,
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  if (!doc._attachments || Object.keys(doc._attachments).length === 0) {
    return doc;
  }
  var useDoc = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.flatClone)(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}

/**
 * Flat clone the document data
 * and also the _meta field.
 * Used many times when we want to change the meta
 * during replication etc.
 */
function flatCloneDocWithMeta(doc) {
  return Object.assign({}, doc, {
    _meta: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.flatClone)(doc._meta)
  });
}
/**
 * Wraps the normal storageInstance of a RxCollection
 * to ensure that all access is properly using the hooks
 * and other data transformations and also ensure that database.lockedRun()
 * is used properly.
 */
function getWrappedStorageInstance(database, storageInstance,
/**
 * The original RxJsonSchema
 * before it was mutated by hooks.
 */
rxJsonSchema) {
  _overwritable_js__WEBPACK_IMPORTED_MODULE_9__.overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(storageInstance.schema.primaryKey);
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    async bulkWrite(rows, context) {
      var databaseToken = database.token;
      var toStorageWriteRows = new Array(rows.length);
      /**
       * Use the same timestamp for all docs of this rows-set.
       * This improves performance because calling Date.now() inside of the now() function
       * is too costly.
       */
      var time = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.now)();
      for (var index = 0; index < rows.length; index++) {
        var writeRow = rows[index];
        var document = flatCloneDocWithMeta(writeRow.document);
        document._meta.lwt = time;

        /**
         * Yes we really want to set the revision here.
         * If you make a plugin that relies on having its own revision
         * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.
         */
        var previous = writeRow.previous;
        document._rev = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.createRevision)(databaseToken, previous);
        toStorageWriteRows[index] = {
          document,
          previous
        };
      }
      (0,_hooks_js__WEBPACK_IMPORTED_MODULE_12__.runPluginHooks)('preStorageWrite', {
        storageInstance: this.originalStorageInstance,
        rows: toStorageWriteRows
      });
      var writeResult = await database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context));

      /**
       * The RxStorageInstance MUST NOT allow to insert already _deleted documents,
       * without sending the previous document version.
       * But for better developer experience, RxDB does allow to re-insert deleted documents.
       * We do this by automatically fixing the conflict errors for that case
       * by running another bulkWrite() and merging the results.
       * @link https://github.com/pubkey/rxdb/pull/3839
      */
      var useWriteResult = {
        error: []
      };
      BULK_WRITE_ROWS_BY_RESPONSE.set(useWriteResult, toStorageWriteRows);
      var reInsertErrors = writeResult.error.length === 0 ? [] : writeResult.error.filter(error => {
        if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(error.documentInDb)._deleted) {
          return true;
        }

        // add the "normal" errors to the parent error array.
        useWriteResult.error.push(error);
        return false;
      });
      if (reInsertErrors.length > 0) {
        var reInsertIds = new Set();
        var reInserts = reInsertErrors.map(error => {
          reInsertIds.add(error.documentId);
          return {
            previous: error.documentInDb,
            document: Object.assign({}, error.writeRow.document, {
              _rev: (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.createRevision)(database.token, error.documentInDb)
            })
          };
        });
        var subResult = await database.lockedRun(() => storageInstance.bulkWrite(reInserts, context));
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.appendToArray)(useWriteResult.error, subResult.error);
        var successArray = getWrittenDocumentsFromBulkWriteResponse(primaryPath, toStorageWriteRows, useWriteResult, reInsertIds);
        var subSuccess = getWrittenDocumentsFromBulkWriteResponse(primaryPath, reInserts, subResult);
        (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.appendToArray)(successArray, subSuccess);
        return useWriteResult;
      }
      return useWriteResult;
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince((0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(limit), checkpoint));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    }
  };
  database.storageInstances.add(ret);
  return ret;
}

/**
 * Each RxStorage implementation should
 * run this method at the first step of createStorageInstance()
 * to ensure that the configuration is correct.
 */
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('UT5', {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('UT6', {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw (0,_rx_error_js__WEBPACK_IMPORTED_MODULE_6__.newRxError)('UT7', {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema) {
  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
function getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint) {
  var primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(storageInstance.schema.primaryKey);
  var sinceLwt = checkpoint ? checkpoint.lwt : _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_14__.RX_META_LWT_MINIMUM;
  var sinceId = checkpoint ? checkpoint.id : '';
  return (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_15__.normalizeMangoQuery)(storageInstance.schema, {
    selector: {
      $or: [{
        '_meta.lwt': {
          $gt: sinceLwt
        }
      }, {
        '_meta.lwt': {
          $eq: sinceLwt
        },
        [primaryPath]: {
          $gt: checkpoint ? sinceId : ''
        }
      }],
      // add this hint for better index usage
      '_meta.lwt': {
        $gte: sinceLwt
      }
    },
    sort: [{
      '_meta.lwt': 'asc'
    }, {
      [primaryPath]: 'asc'
    }],
    skip: 0,
    limit
    /**
     * DO NOT SET A SPECIFIC INDEX HERE!
     * The query might be modified by some plugin
     * before sending it to the storage.
     * We can be sure that in the end the query planner
     * will find the best index.
     */
    // index: ['_meta.lwt', primaryPath]
  });
}
async function getChangedDocumentsSince(storageInstance, limit, checkpoint) {
  if (storageInstance.getChangedDocumentsSince) {
    return storageInstance.getChangedDocumentsSince(limit, checkpoint);
  }
  var primaryPath = (0,_rx_schema_helper_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(storageInstance.schema.primaryKey);
  var query = (0,_rx_query_helper_js__WEBPACK_IMPORTED_MODULE_15__.prepareQuery)(storageInstance.schema, getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint));
  var result = await storageInstance.query(query);
  var documents = result.documents;
  var lastDoc = (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_13__.lastOfArray)(documents);
  return {
    documents: documents,
    checkpoint: lastDoc ? {
      id: lastDoc[primaryPath],
      lwt: lastDoc._meta.lwt
    } : checkpoint ? checkpoint : {
      id: '',
      lwt: 0
    }
  };
}
var BULK_WRITE_ROWS_BY_RESPONSE = new WeakMap();
var BULK_WRITE_SUCCESS_MAP = new WeakMap();

/**
 * For better performance, this is done only when accessed
 * because most of the time we do not need the results, only the errors.
 */
function getWrittenDocumentsFromBulkWriteResponse(primaryPath, writeRows, response, reInsertIds) {
  return (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_16__.getFromMapOrCreate)(BULK_WRITE_SUCCESS_MAP, response, () => {
    var ret = [];
    var realWriteRows = BULK_WRITE_ROWS_BY_RESPONSE.get(response);
    if (!realWriteRows) {
      realWriteRows = writeRows;
    }
    if (response.error.length > 0 || reInsertIds) {
      var errorIds = reInsertIds ? reInsertIds : new Set();
      for (var index = 0; index < response.error.length; index++) {
        var error = response.error[index];
        errorIds.add(error.documentId);
      }
      for (var _index = 0; _index < realWriteRows.length; _index++) {
        var doc = realWriteRows[_index].document;
        if (!errorIds.has(doc[primaryPath])) {
          ret.push(stripAttachmentsDataFromDocument(doc));
        }
      }
    } else {
      // pre-set array size for better performance
      ret.length = writeRows.length - response.error.length;
      for (var _index2 = 0; _index2 < realWriteRows.length; _index2++) {
        var _doc = realWriteRows[_index2].document;
        ret[_index2] = stripAttachmentsDataFromDocument(_doc);
      }
    }
    return ret;
  });
}

/**
 * Wraps the storage and simluates
 * delays. Mostly used in tests.
 */
function randomDelayStorage(input) {
  /**
   * Ensure writes to a delay storage
   * are still correctly run in order.
   */
  var randomDelayStorageWriteQueue = _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.PROMISE_RESOLVE_TRUE;
  var retStorage = {
    name: 'random-delay-' + input.storage.name,
    rxdbVersion: _plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_18__.RXDB_VERSION,
    async createStorageInstance(params) {
      await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
      var storageInstance = await input.storage.createStorageInstance(params);
      await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
      return {
        databaseName: storageInstance.databaseName,
        internals: storageInstance.internals,
        options: storageInstance.options,
        schema: storageInstance.schema,
        collectionName: storageInstance.collectionName,
        bulkWrite(a, b) {
          randomDelayStorageWriteQueue = randomDelayStorageWriteQueue.then(async () => {
            await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
            var response = await storageInstance.bulkWrite(a, b);
            await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
            return response;
          });
          var ret = randomDelayStorageWriteQueue;
          return ret;
        },
        async findDocumentsById(a, b) {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.findDocumentsById(a, b);
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        async query(a) {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.query(a);
          return ret;
        },
        async count(a) {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.count(a);
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        async getAttachmentData(a, b, c) {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.getAttachmentData(a, b, c);
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : async (a, b) => {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(storageInstance.getChangedDocumentsSince)(a, b);
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        changeStream() {
          return storageInstance.changeStream();
        },
        async cleanup(a) {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.cleanup(a);
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        async close() {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.close();
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        },
        async remove() {
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeBefore());
          var ret = await storageInstance.remove();
          await (0,_plugins_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.promiseWait)(input.delayTimeAfter());
          return ret;
        }
      };
    }
  };
  return retStorage;
}
//# sourceMappingURL=rx-storage-helper.js.map

/***/ }),

/***/ "./node_modules/rxdb/dist/esm/rx-storage-multiinstance.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxdb/dist/esm/rx-storage-multiinstance.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BROADCAST_CHANNEL_BY_TOKEN: () => (/* binding */ BROADCAST_CHANNEL_BY_TOKEN),
/* harmony export */   addRxStorageMultiInstanceSupport: () => (/* binding */ addRxStorageMultiInstanceSupport),
/* harmony export */   getBroadcastChannelReference: () => (/* binding */ getBroadcastChannelReference),
/* harmony export */   removeBroadcastChannelReference: () => (/* binding */ removeBroadcastChannelReference)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js");
/* harmony import */ var broadcast_channel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! broadcast-channel */ "./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js");
/**
 * When a persistent RxStorage is used in more the one JavaScript process,
 * the even stream of the changestream() function must be broadcasted to the other
 * RxStorageInstances of the same databaseName+collectionName.
 *
 * In the past this was done by RxDB but it makes more sense to do this
 * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker
 * and not on the main thread.
 * Also it makes it less complex to stack up different RxStorages onto each other
 * like what we do with the in-memory plugin.
 *
 * This is intended to be used inside of createStorageInstance() of a storage.
 * Do not use this if the storage anyway broadcasts the events like when using MongoDB
 * or in the future W3C might introduce a way to listen to IndexedDB changes.
 */





/**
 * The broadcast-channel is reused by the databaseInstanceToken.
 * This is required so that it is easy to simulate multi-tab usage
 * in the test where different instances of the same RxDatabase must
 * have different broadcast channels.
 * But also it ensures that for each RxDatabase we only create a single
 * broadcast channel that can even be reused in the leader election plugin.
 */
var BROADCAST_CHANNEL_BY_TOKEN = new Map();
function getBroadcastChannelReference(storageName, databaseInstanceToken, databaseName, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    state = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.BroadcastChannel(['RxDB:', storageName, databaseName].join('|')),
      refs: new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);
  }
  state.refs.add(refObject);
  return state.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    return;
  }
  state.refs.delete(refObject);
  if (state.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance,
/**
 * If provided, that channel will be used
 * instead of an own one.
 */
providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(storageName, instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
  var eventListener = msg => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel.addEventListener('message', eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe(eventBulk => {
    if (closed) {
      return;
    }
    broadcastChannel.postMessage({
      storageName: storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function () {
    return changesFromOtherInstances$.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.mergeWith)(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function () {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener('message', eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function () {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener('message', eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}
//# sourceMappingURL=rx-storage-multiinstance.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BehaviorSubject: () => (/* binding */ BehaviorSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");


var BehaviorSubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
            throw thrownError;
        }
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, (this._value = value));
    };
    return BehaviorSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_1__.Subject));

//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COMPLETE_NOTIFICATION: () => (/* binding */ COMPLETE_NOTIFICATION),
/* harmony export */   createNotification: () => (/* binding */ createNotification),
/* harmony export */   errorNotification: () => (/* binding */ errorNotification),
/* harmony export */   nextNotification: () => (/* binding */ nextNotification)
/* harmony export */ });
var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
function errorNotification(error) {
    return createNotification('E', undefined, error);
}
function nextNotification(value) {
    return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error,
    };
}
//# sourceMappingURL=NotificationFactories.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Observable.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Observable.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Observable: () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/observable */ "./node_modules/rxjs/dist/esm5/internal/symbol/observable.js");
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/pipe */ "./node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "./node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/errorContext */ "./node_modules/rxjs/dist/esm5/internal/util/errorContext.js");







var Observable = (function () {
    function Observable(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber(observerOrNext, error, complete);
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_1__.errorContext)(function () {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator
                ?
                    operator.call(subscriber, source)
                : source
                    ?
                        _this._subscribe(subscriber)
                    :
                        _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({
                next: function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve,
            });
            _this.subscribe(subscriber);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_3__.pipeFromArray)(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : _config__WEBPACK_IMPORTED_MODULE_4__.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.next) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.error) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.complete);
}
function isSubscriber(value) {
    return (value && value instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) || (isObserver(value) && (0,_Subscription__WEBPACK_IMPORTED_MODULE_6__.isSubscription)(value));
}
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReplaySubject: () => (/* binding */ ReplaySubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduler/dateTimestampProvider */ "./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js");



var ReplaySubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ReplaySubject, _super);
    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) { _bufferSize = Infinity; }
        if (_windowTime === void 0) { _windowTime = Infinity; }
        if (_timestampProvider === void 0) { _timestampProvider = _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_1__.dateTimestampProvider; }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
    }
    ReplaySubject.prototype.next = function (value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
            subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
    };
    ReplaySubject.prototype._trimBuffer = function () {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last = 0;
            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
                last = i;
            }
            last && _buffer.splice(0, last + 1);
        }
    };
    return ReplaySubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.Subject));

//# sourceMappingURL=ReplaySubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subject.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnonymousSubject: () => (/* binding */ AnonymousSubject),
/* harmony export */   Subject: () => (/* binding */ Subject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js");
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/arrRemove */ "./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/errorContext */ "./node_modules/rxjs/dist/esm5/internal/util/errorContext.js");






var Subject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();
        }
    };
    Subject.prototype.next = function (value) {
        var _this = this;
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                if (!_this.currentObservers) {
                    _this.currentObservers = Array.from(_this.observers);
                }
                try {
                    for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var observer = _c.value;
                        observer.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    };
    Subject.prototype.error = function (err) {
        var _this = this;
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().error(err);
                }
            }
        });
    };
    Subject.prototype.complete = function () {
        var _this = this;
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().complete();
                }
            }
        });
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function () {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function (subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function (subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function (subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new _Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription(function () {
            _this.currentObservers = null;
            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_4__.arrRemove)(observers, subscriber);
        });
    };
    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
            subscriber.error(thrownError);
        }
        else if (isStopped) {
            subscriber.complete();
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_5__.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_5__.Observable));

var AnonymousSubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function (err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function () {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subscriber.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_OBSERVER: () => (/* binding */ EMPTY_OBSERVER),
/* harmony export */   SafeSubscriber: () => (/* binding */ SafeSubscriber),
/* harmony export */   Subscriber: () => (/* binding */ Subscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "./node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/reportUnhandledError */ "./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js");
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/noop */ "./node_modules/rxjs/dist/esm5/internal/util/noop.js");
/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationFactories */ "./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ "./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/errorContext */ "./node_modules/rxjs/dist/esm5/internal/util/errorContext.js");









var Subscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.nextNotification)(value), this);
        }
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.errorNotification)(err), this);
        }
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) {
            handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.COMPLETE_NOTIFICATION, this);
        }
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function () {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function (value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
            try {
                partialObserver.next(value);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    ConsumerObserver.prototype.error = function (err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
            try {
                partialObserver.error(err);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
        else {
            handleUnhandledError(err);
        }
    };
    ConsumerObserver.prototype.complete = function () {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
            try {
                partialObserver.complete();
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    return ConsumerObserver;
}());
var SafeSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(observerOrNext) || !observerOrNext) {
            partialObserver = {
                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                error: error !== null && error !== void 0 ? error : undefined,
                complete: complete !== null && complete !== void 0 ? complete : undefined,
            };
        }
        else {
            var context_1;
            if (_this && _config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function () { return _this.unsubscribe(); };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                };
            }
            else {
                partialObserver = observerOrNext;
            }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));

function handleUnhandledError(error) {
    if (_config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedSynchronousErrorHandling) {
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_5__.captureError)(error);
    }
    else {
        (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__.reportUnhandledError)(error);
    }
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = _config__WEBPACK_IMPORTED_MODULE_4__.config.onStoppedNotification;
    onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
    error: defaultErrorHandler,
    complete: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
};
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subscription.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subscription.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SUBSCRIPTION: () => (/* binding */ EMPTY_SUBSCRIPTION),
/* harmony export */   Subscription: () => (/* binding */ Subscription),
/* harmony export */   isSubscription: () => (/* binding */ isSubscription)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/UnsubscriptionError */ "./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js");
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ "./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js");




var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialFinalizer = this.initialTeardown;
            if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(initialFinalizer)) {
                try {
                    initialFinalizer();
                }
                catch (e) {
                    errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError ? e.errors : [e];
                }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for (var _finalizers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError) {
                                errors = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(errors)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execFinalizer(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());

var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.unsubscribe)));
}
function execFinalizer(finalizer) {
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(finalizer)) {
        finalizer();
    }
    else {
        finalizer.unsubscribe();
    }
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/config.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/config.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false,
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   firstValueFrom: () => (/* binding */ firstValueFrom)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/EmptyError */ "./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js");


function firstValueFrom(source, config) {
    var hasConfig = typeof config === 'object';
    return new Promise(function (resolve, reject) {
        var subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({
            next: function (value) {
                resolve(value);
                subscriber.unsubscribe();
            },
            error: reject,
            complete: function () {
                if (hasConfig) {
                    resolve(config.defaultValue);
                }
                else {
                    reject(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__.EmptyError());
                }
            },
        });
        source.subscribe(subscriber);
    });
}
//# sourceMappingURL=firstValueFrom.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineLatest: () => (/* binding */ combineLatest),
/* harmony export */   combineLatestInit: () => (/* binding */ combineLatestInit)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/argsArgArrayOrObject */ "./node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js");
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from */ "./node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/dist/esm5/internal/util/identity.js");
/* harmony import */ var _util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/mapOneOrManyArgs */ "./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js");
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ "./node_modules/rxjs/dist/esm5/internal/util/args.js");
/* harmony import */ var _util_createObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/createObject */ "./node_modules/rxjs/dist/esm5/internal/util/createObject.js");
/* harmony import */ var _operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../operators/OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/executeSchedule */ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js");









function combineLatest() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);
    var resultSelector = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popResultSelector)(args);
    var _a = (0,_util_argsArgArrayOrObject__WEBPACK_IMPORTED_MODULE_1__.argsArgArrayOrObject)(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
        return (0,_from__WEBPACK_IMPORTED_MODULE_2__.from)([], scheduler);
    }
    var result = new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(combineLatestInit(observables, scheduler, keys
        ?
            function (values) { return (0,_util_createObject__WEBPACK_IMPORTED_MODULE_4__.createObject)(keys, values); }
        :
            _util_identity__WEBPACK_IMPORTED_MODULE_5__.identity));
    return resultSelector ? result.pipe((0,_util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_6__.mapOneOrManyArgs)(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) { valueTransform = _util_identity__WEBPACK_IMPORTED_MODULE_5__.identity; }
    return function (subscriber) {
        maybeSchedule(scheduler, function () {
            var length = observables.length;
            var values = new Array(length);
            var active = length;
            var remainingFirstValues = length;
            var _loop_1 = function (i) {
                maybeSchedule(scheduler, function () {
                    var source = (0,_from__WEBPACK_IMPORTED_MODULE_2__.from)(observables[i], scheduler);
                    var hasFirstValue = false;
                    source.subscribe((0,_operators_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_7__.createOperatorSubscriber)(subscriber, function (value) {
                        values[i] = value;
                        if (!hasFirstValue) {
                            hasFirstValue = true;
                            remainingFirstValues--;
                        }
                        if (!remainingFirstValues) {
                            subscriber.next(valueTransform(values.slice()));
                        }
                    }, function () {
                        if (!--active) {
                            subscriber.complete();
                        }
                    }));
                }, subscriber);
            };
            for (var i = 0; i < length; i++) {
                _loop_1(i);
            }
        }, subscriber);
    };
}
function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
        (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_8__.executeSchedule)(subscription, scheduler, execute);
    }
    else {
        execute();
    }
}
//# sourceMappingURL=combineLatest.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/concat.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/concat.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operators/concatAll */ "./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js");
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/args */ "./node_modules/rxjs/dist/esm5/internal/util/args.js");
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from */ "./node_modules/rxjs/dist/esm5/internal/observable/from.js");



function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return (0,_operators_concatAll__WEBPACK_IMPORTED_MODULE_0__.concatAll)()((0,_from__WEBPACK_IMPORTED_MODULE_1__.from)(args, (0,_util_args__WEBPACK_IMPORTED_MODULE_2__.popScheduler)(args)));
}
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/empty.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY: () => (/* binding */ EMPTY),
/* harmony export */   empty: () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");

var EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/from.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/from.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   from: () => (/* binding */ from)
/* harmony export */ });
/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduled/scheduled */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js");
/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");


function from(input, scheduler) {
    return scheduler ? (0,_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__.scheduled)(input, scheduler) : (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(input);
}
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromArrayLike: () => (/* binding */ fromArrayLike),
/* harmony export */   fromAsyncIterable: () => (/* binding */ fromAsyncIterable),
/* harmony export */   fromInteropObservable: () => (/* binding */ fromInteropObservable),
/* harmony export */   fromIterable: () => (/* binding */ fromIterable),
/* harmony export */   fromPromise: () => (/* binding */ fromPromise),
/* harmony export */   fromReadableStreamLike: () => (/* binding */ fromReadableStreamLike),
/* harmony export */   innerFrom: () => (/* binding */ innerFrom)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isArrayLike */ "./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js");
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isPromise */ "./node_modules/rxjs/dist/esm5/internal/util/isPromise.js");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isInteropObservable */ "./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js");
/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isAsyncIterable */ "./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js");
/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/throwUnobservableError */ "./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js");
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/isIterable */ "./node_modules/rxjs/dist/esm5/internal/util/isIterable.js");
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isReadableStreamLike */ "./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/reportUnhandledError */ "./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js");
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/dist/esm5/internal/symbol/observable.js");












function innerFrom(input) {
    if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable) {
        return input;
    }
    if (input != null) {
        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_1__.isInteropObservable)(input)) {
            return fromInteropObservable(input);
        }
        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(input)) {
            return fromArrayLike(input);
        }
        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_3__.isPromise)(input)) {
            return fromPromise(input);
        }
        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_4__.isAsyncIterable)(input)) {
            return fromAsyncIterable(input);
        }
        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_5__.isIterable)(input)) {
            return fromIterable(input);
        }
        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__.isReadableStreamLike)(input)) {
            return fromReadableStreamLike(input);
        }
    }
    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_7__.createInvalidObservableTypeError)(input);
}
function fromInteropObservable(obj) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_8__.observable]();
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_9__.isFunction)(obs.subscribe)) {
            return obs.subscribe(subscriber);
        }
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
}
function fromArrayLike(array) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        promise
            .then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__.reportUnhandledError);
    });
}
function fromIterable(iterable) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var e_1, _a;
        try {
            for (var iterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__values)(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__.readableStreamLikeToAsyncGenerator)(readableStream));
}
function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__awaiter)(this, void 0, void 0, function () {
        var value, e_2_1;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 11]);
                    asyncIterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__asyncValues)(asyncIterable);
                    _b.label = 1;
                case 1: return [4, asyncIterable_1.next()];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return [2];
                    }
                    _b.label = 3;
                case 3: return [3, 1];
                case 4: return [3, 11];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 11];
                case 6:
                    _b.trys.push([6, , 9, 10]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                    return [4, _a.call(asyncIterable_1)];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [3, 10];
                case 9:
                    if (e_2) throw e_2.error;
                    return [7];
                case 10: return [7];
                case 11:
                    subscriber.complete();
                    return [2];
            }
        });
    });
}
//# sourceMappingURL=innerFrom.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/merge.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/merge.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   merge: () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../operators/mergeAll */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js");
/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty */ "./node_modules/rxjs/dist/esm5/internal/observable/empty.js");
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ "./node_modules/rxjs/dist/esm5/internal/util/args.js");
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./from */ "./node_modules/rxjs/dist/esm5/internal/observable/from.js");





function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);
    var concurrent = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popNumber)(args, Infinity);
    var sources = args;
    return !sources.length
        ?
            _empty__WEBPACK_IMPORTED_MODULE_1__.EMPTY
        : sources.length === 1
            ?
                (0,_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(sources[0])
            :
                (0,_operators_mergeAll__WEBPACK_IMPORTED_MODULE_3__.mergeAll)(concurrent)((0,_from__WEBPACK_IMPORTED_MODULE_4__.from)(sources, scheduler));
}
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OperatorSubscriber: () => (/* binding */ OperatorSubscriber),
/* harmony export */   createOperatorSubscriber: () => (/* binding */ createOperatorSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js");


function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
    };
    return OperatorSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=OperatorSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatAll: () => (/* binding */ concatAll)
/* harmony export */ });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeAll */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js");

function concatAll() {
    return (0,_mergeAll__WEBPACK_IMPORTED_MODULE_0__.mergeAll)(1);
}
//# sourceMappingURL=concatAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged)
/* harmony export */ });
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/dist/esm5/internal/util/identity.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) { keySelector = _util_identity__WEBPACK_IMPORTED_MODULE_0__.identity; }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function (value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
                first = false;
                previousKey = currentKey;
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/filter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filter: () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function filter(predicate, thisArg) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var index = 0;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
    });
}
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/map.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function map(project, thisArg) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var index = 0;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/merge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   merge: () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeAll */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js");
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ "./node_modules/rxjs/dist/esm5/internal/util/args.js");
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observable/from */ "./node_modules/rxjs/dist/esm5/internal/observable/from.js");





function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);
    var concurrent = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popNumber)(args, Infinity);
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
        (0,_mergeAll__WEBPACK_IMPORTED_MODULE_2__.mergeAll)(concurrent)((0,_observable_from__WEBPACK_IMPORTED_MODULE_3__.from)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([source], (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__read)(args)), scheduler)).subscribe(subscriber);
    });
}
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeAll: () => (/* binding */ mergeAll)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeMap */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/dist/esm5/internal/util/identity.js");


function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Infinity; }
    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, concurrent);
}
//# sourceMappingURL=mergeAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeInternals: () => (/* binding */ mergeInternals)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
        if (isComplete && !buffer.length && !active) {
            subscriber.complete();
        }
    };
    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
    var doInnerSub = function (value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, index++)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (innerValue) {
            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
            if (expand) {
                outerNext(innerValue);
            }
            else {
                subscriber.next(innerValue);
            }
        }, function () {
            innerComplete = true;
        }, undefined, function () {
            if (innerComplete) {
                try {
                    active--;
                    var _loop_1 = function () {
                        var bufferedValue = buffer.shift();
                        if (innerSubScheduler) {
                            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
                        }
                        else {
                            doInnerSub(bufferedValue);
                        }
                    };
                    while (buffer.length && active < concurrent) {
                        _loop_1();
                    }
                    checkComplete();
                }
                catch (err) {
                    subscriber.error(err);
                }
            }
        }));
    };
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, outerNext, function () {
        isComplete = true;
        checkComplete();
    }));
    return function () {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
}
//# sourceMappingURL=mergeInternals.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeMap: () => (/* binding */ mergeMap)
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _mergeInternals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mergeInternals */ "./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");





function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Infinity; }
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector)) {
        return mergeMap(function (a, i) { return (0,_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (b, ii) { return resultSelector(a, b, i, ii); })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(project(a, i))); }, concurrent);
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_3__.operate)(function (source, subscriber) { return (0,_mergeInternals__WEBPACK_IMPORTED_MODULE_4__.mergeInternals)(source, subscriber, project, concurrent); });
}
//# sourceMappingURL=mergeMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeWith: () => (/* binding */ mergeWith)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./merge */ "./node_modules/rxjs/dist/esm5/internal/operators/merge.js");


function mergeWith() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
    }
    return _merge__WEBPACK_IMPORTED_MODULE_0__.merge.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(otherSources)));
}
//# sourceMappingURL=mergeWith.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observeOn: () => (/* binding */ observeOn)
/* harmony export */ });
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
    });
}
//# sourceMappingURL=observeOn.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/share.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/share.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   share: () => (/* binding */ share)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");





function share(options) {
    if (options === void 0) { options = {}; }
    var _a = options.connector, connector = _a === void 0 ? function () { return new _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function (wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function () {
            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
            resetConnection = undefined;
        };
        var reset = function () {
            cancelReset();
            connection = subject = undefined;
            hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function () {
            var conn = connection;
            reset();
            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
            refCount++;
            if (!hasErrored && !hasCompleted) {
                cancelReset();
            }
            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
            subscriber.add(function () {
                refCount--;
                if (refCount === 0 && !hasErrored && !hasCompleted) {
                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                }
            });
            dest.subscribe(subscriber);
            if (!connection &&
                refCount > 0) {
                connection = new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.SafeSubscriber({
                    next: function (value) { return dest.next(value); },
                    error: function (err) {
                        hasErrored = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnError, err);
                        dest.error(err);
                    },
                    complete: function () {
                        hasCompleted = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnComplete);
                        dest.complete();
                    },
                });
                (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__.innerFrom)(source).subscribe(connection);
            }
        })(wrapperSource);
    };
}
function handleReset(reset, on) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if (on === true) {
        reset();
        return;
    }
    if (on === false) {
        return;
    }
    var onSubscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.SafeSubscriber({
        next: function () {
            onSubscriber.unsubscribe();
            reset();
        },
    });
    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__.innerFrom)(on.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__read)(args)))).subscribe(onSubscriber);
}
//# sourceMappingURL=share.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shareReplay: () => (/* binding */ shareReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ReplaySubject */ "./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var _share__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share */ "./node_modules/rxjs/dist/esm5/internal/operators/share.js");


function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
    }
    else {
        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
    }
    return (0,_share__WEBPACK_IMPORTED_MODULE_0__.share)({
        connector: function () { return new _ReplaySubject__WEBPACK_IMPORTED_MODULE_1__.ReplaySubject(bufferSize, windowTime, scheduler); },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount,
    });
}
//# sourceMappingURL=shareReplay.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/startWith.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startWith: () => (/* binding */ startWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/concat */ "./node_modules/rxjs/dist/esm5/internal/observable/concat.js");
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ "./node_modules/rxjs/dist/esm5/internal/util/args.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");



function startWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(values);
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
        (scheduler ? (0,_observable_concat__WEBPACK_IMPORTED_MODULE_2__.concat)(values, source, scheduler) : (0,_observable_concat__WEBPACK_IMPORTED_MODULE_2__.concat)(values, source)).subscribe(subscriber);
    });
}
//# sourceMappingURL=startWith.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   subscribeOn: () => (/* binding */ subscribeOn)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");

function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
    });
}
//# sourceMappingURL=subscribeOn.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   switchMap: () => (/* binding */ switchMap)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "./node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function switchMap(project, resultSelector) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
            var innerIndex = 0;
            var outerIndex = index++;
            (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(project(value, outerIndex)).subscribe((innerSubscriber = (0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
                innerSubscriber = null;
                checkComplete();
            })));
        }, function () {
            isComplete = true;
            checkComplete();
        }));
    });
}
//# sourceMappingURL=switchMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleArray: () => (/* binding */ scheduleArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");

function scheduleArray(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var i = 0;
        return scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
            }
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    this.schedule();
                }
            }
        });
    });
}
//# sourceMappingURL=scheduleArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleAsyncIterable: () => (/* binding */ scheduleAsyncIterable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js");


function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {
            var iterator = input[Symbol.asyncIterator]();
            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {
                iterator.next().then(function (result) {
                    if (result.done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(result.value);
                    }
                });
            }, 0, true);
        });
    });
}
//# sourceMappingURL=scheduleAsyncIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleIterable: () => (/* binding */ scheduleIterable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js");




function scheduleIterable(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var iterator;
        (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {
            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__.iterator]();
            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {
                var _a;
                var value;
                var done;
                try {
                    (_a = iterator.next(), value = _a.value, done = _a.done);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                }
            }, 0, true);
        });
        return function () { return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };
    });
}
//# sourceMappingURL=scheduleIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleObservable: () => (/* binding */ scheduleObservable)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/observeOn */ "./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js");
/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/subscribeOn */ "./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js");



function scheduleObservable(input, scheduler) {
    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_2__.observeOn)(scheduler));
}
//# sourceMappingURL=scheduleObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   schedulePromise: () => (/* binding */ schedulePromise)
/* harmony export */ });
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/observeOn */ "./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js");
/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/subscribeOn */ "./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js");



function schedulePromise(input, scheduler) {
    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_2__.observeOn)(scheduler));
}
//# sourceMappingURL=schedulePromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduleReadableStreamLike: () => (/* binding */ scheduleReadableStreamLike)
/* harmony export */ });
/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduleAsyncIterable */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js");
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isReadableStreamLike */ "./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js");


function scheduleReadableStreamLike(input, scheduler) {
    return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__.scheduleAsyncIterable)((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__.readableStreamLikeToAsyncGenerator)(input), scheduler);
}
//# sourceMappingURL=scheduleReadableStreamLike.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scheduled: () => (/* binding */ scheduled)
/* harmony export */ });
/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduleObservable */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js");
/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schedulePromise */ "./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js");
/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scheduleArray */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js");
/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./scheduleIterable */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js");
/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduleAsyncIterable */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js");
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isInteropObservable */ "./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js");
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isPromise */ "./node_modules/rxjs/dist/esm5/internal/util/isPromise.js");
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isArrayLike */ "./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js");
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/isIterable */ "./node_modules/rxjs/dist/esm5/internal/util/isIterable.js");
/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isAsyncIterable */ "./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js");
/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/throwUnobservableError */ "./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js");
/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/isReadableStreamLike */ "./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js");
/* harmony import */ var _scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./scheduleReadableStreamLike */ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js");













function scheduled(input, scheduler) {
    if (input != null) {
        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__.isInteropObservable)(input)) {
            return (0,_scheduleObservable__WEBPACK_IMPORTED_MODULE_1__.scheduleObservable)(input, scheduler);
        }
        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(input)) {
            return (0,_scheduleArray__WEBPACK_IMPORTED_MODULE_3__.scheduleArray)(input, scheduler);
        }
        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(input)) {
            return (0,_schedulePromise__WEBPACK_IMPORTED_MODULE_5__.schedulePromise)(input, scheduler);
        }
        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__.isAsyncIterable)(input)) {
            return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__.scheduleAsyncIterable)(input, scheduler);
        }
        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_8__.isIterable)(input)) {
            return (0,_scheduleIterable__WEBPACK_IMPORTED_MODULE_9__.scheduleIterable)(input, scheduler);
        }
        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__.isReadableStreamLike)(input)) {
            return (0,_scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__.scheduleReadableStreamLike)(input, scheduler);
        }
    }
    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__.createInvalidObservableTypeError)(input);
}
//# sourceMappingURL=scheduled.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dateTimestampProvider: () => (/* binding */ dateTimestampProvider)
/* harmony export */ });
var dateTimestampProvider = {
    now: function () {
        return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined,
};
//# sourceMappingURL=dateTimestampProvider.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timeoutProvider: () => (/* binding */ timeoutProvider)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");

var timeoutProvider = {
    setTimeout: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
        }
        return setTimeout.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
    },
    clearTimeout: function (handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined,
};
//# sourceMappingURL=timeoutProvider.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSymbolIterator: () => (/* binding */ getSymbolIterator),
/* harmony export */   iterator: () => (/* binding */ iterator)
/* harmony export */ });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = getSymbolIterator();
//# sourceMappingURL=iterator.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/symbol/observable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/observable.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observable: () => (/* binding */ observable)
/* harmony export */ });
var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyError: () => (/* binding */ EmptyError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var EmptyError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {
    return function EmptyErrorImpl() {
        _super(this);
        this.name = 'EmptyError';
        this.message = 'no elements in sequence';
    };
});
//# sourceMappingURL=EmptyError.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectUnsubscribedError: () => (/* binding */ ObjectUnsubscribedError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var ObjectUnsubscribedError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = 'ObjectUnsubscribedError';
        this.message = 'object unsubscribed';
    };
});
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnsubscriptionError: () => (/* binding */ UnsubscriptionError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/args.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/args.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   popNumber: () => (/* binding */ popNumber),
/* harmony export */   popResultSelector: () => (/* binding */ popResultSelector),
/* harmony export */   popScheduler: () => (/* binding */ popScheduler)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScheduler */ "./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js");


function last(arr) {
    return arr[arr.length - 1];
}
function popResultSelector(args) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(last(args)) ? args.pop() : undefined;
}
function popScheduler(args) {
    return (0,_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(last(args)) ? args.pop() : undefined;
}
function popNumber(args, defaultValue) {
    return typeof last(args) === 'number' ? args.pop() : defaultValue;
}
//# sourceMappingURL=args.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   argsArgArrayOrObject: () => (/* binding */ argsArgArrayOrObject)
/* harmony export */ });
var isArray = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args) {
    if (args.length === 1) {
        var first_1 = args[0];
        if (isArray(first_1)) {
            return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
            var keys = getKeys(first_1);
            return {
                args: keys.map(function (key) { return first_1[key]; }),
                keys: keys,
            };
        }
    }
    return { args: args, keys: null };
}
function isPOJO(obj) {
    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
}
//# sourceMappingURL=argsArgArrayOrObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrRemove: () => (/* binding */ arrRemove)
/* harmony export */ });
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}
//# sourceMappingURL=arrRemove.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorClass: () => (/* binding */ createErrorClass)
/* harmony export */ });
function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}
//# sourceMappingURL=createErrorClass.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/createObject.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/createObject.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createObject: () => (/* binding */ createObject)
/* harmony export */ });
function createObject(keys, values) {
    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
}
//# sourceMappingURL=createObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/errorContext.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/errorContext.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   captureError: () => (/* binding */ captureError),
/* harmony export */   errorContext: () => (/* binding */ errorContext)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "./node_modules/rxjs/dist/esm5/internal/config.js");

var context = null;
function errorContext(cb) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
            context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) {
                throw error;
            }
        }
    }
    else {
        cb();
    }
}
function captureError(err) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}
//# sourceMappingURL=errorContext.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   executeSchedule: () => (/* binding */ executeSchedule)
/* harmony export */ });
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) { delay = 0; }
    if (repeat === void 0) { repeat = false; }
    var scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
        }
        else {
            this.unsubscribe();
        }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
        return scheduleSubscription;
    }
}
//# sourceMappingURL=executeSchedule.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/identity.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/identity.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArrayLike: () => (/* binding */ isArrayLike)
/* harmony export */ });
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function isAsyncIterable(obj) {
    return Symbol.asyncIterator && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
//# sourceMappingURL=isAsyncIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isFunction.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
function isFunction(value) {
    return typeof value === 'function';
}
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isInteropObservable: () => (/* binding */ isInteropObservable)
/* harmony export */ });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/dist/esm5/internal/symbol/observable.js");
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");


function isInteropObservable(input) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input[_symbol_observable__WEBPACK_IMPORTED_MODULE_1__.observable]);
}
//# sourceMappingURL=isInteropObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isIterable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isIterable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isIterable: () => (/* binding */ isIterable)
/* harmony export */ });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js");
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");


function isIterable(input) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input === null || input === void 0 ? void 0 : input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__.iterator]);
}
//# sourceMappingURL=isIterable.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isPromise.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isPromise.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPromise: () => (/* binding */ isPromise)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function isPromise(value) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value === null || value === void 0 ? void 0 : value.then);
}
//# sourceMappingURL=isPromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isReadableStreamLike: () => (/* binding */ isReadableStreamLike),
/* harmony export */   readableStreamLikeToAsyncGenerator: () => (/* binding */ readableStreamLikeToAsyncGenerator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");


function readableStreamLikeToAsyncGenerator(readableStream) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 9, 10]);
                    _b.label = 2;
                case 2:
                    if (false) {}
                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(reader.read())];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [3, 5];
                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(void 0)];
                case 4: return [2, _b.sent()];
                case 5: return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(value)];
                case 6: return [4, _b.sent()];
                case 7:
                    _b.sent();
                    return [3, 2];
                case 8: return [3, 10];
                case 9:
                    reader.releaseLock();
                    return [7];
                case 10: return [2];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
//# sourceMappingURL=isReadableStreamLike.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isScheduler: () => (/* binding */ isScheduler)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function isScheduler(value) {
    return value && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.schedule);
}
//# sourceMappingURL=isScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/lift.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/lift.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasLift: () => (/* binding */ hasLift),
/* harmony export */   operate: () => (/* binding */ operate)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function hasLift(source) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}
//# sourceMappingURL=lift.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapOneOrManyArgs: () => (/* binding */ mapOneOrManyArgs)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/map */ "./node_modules/rxjs/dist/esm5/internal/operators/map.js");


var isArray = Array.isArray;
function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
    return (0,_operators_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (args) { return callOrApply(fn, args); });
}
//# sourceMappingURL=mapOneOrManyArgs.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/noop.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/noop.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
function noop() { }
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/pipe.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/pipe.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   pipeFromArray: () => (/* binding */ pipeFromArray)
/* harmony export */ });
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/rxjs/dist/esm5/internal/util/identity.js");

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reportUnhandledError: () => (/* binding */ reportUnhandledError)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ "./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");


function reportUnhandledError(err) {
    _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__.timeoutProvider.setTimeout(function () {
        var onUnhandledError = _config__WEBPACK_IMPORTED_MODULE_1__.config.onUnhandledError;
        if (onUnhandledError) {
            onUnhandledError(err);
        }
        else {
            throw err;
        }
    });
}
//# sourceMappingURL=reportUnhandledError.js.map

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createInvalidObservableTypeError: () => (/* binding */ createInvalidObservableTypeError)
/* harmony export */ });
function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
//# sourceMappingURL=throwUnobservableError.js.map

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),

/***/ "./node_modules/unload/dist/es/browser.js":
/*!************************************************!*\
  !*** ./node_modules/unload/dist/es/browser.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addBrowser: () => (/* binding */ addBrowser)
/* harmony export */ });
/* global WorkerGlobalScope */

function addBrowser(fn) {
  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {
    /**
     * Because killing a worker does directly stop the excution
     * of the code, our only chance is to overwrite the close function
     * which could work some times.
     * @link https://stackoverflow.com/q/72903255/3443137
     */
    var oldClose = self.close.bind(self);
    self.close = function () {
      fn();
      return oldClose();
    };
  } else {
    /**
     * if we are on react-native, there is no window.addEventListener
     * @link https://github.com/pubkey/unload/issues/6
     */
    if (typeof window.addEventListener !== 'function') {
      return;
    }

    /**
     * for normal browser-windows, we use the beforeunload-event
     */
    window.addEventListener('beforeunload', function () {
      fn();
    }, true);

    /**
     * for iframes, we have to use the unload-event
     * @link https://stackoverflow.com/q/47533670/3443137
     */
    window.addEventListener('unload', function () {
      fn();
    }, true);
  }

  /**
   * TODO add fallback for safari-mobile
   * @link https://stackoverflow.com/a/26193516/3443137
   */
}

/***/ }),

/***/ "./node_modules/unload/dist/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/unload/dist/es/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   removeAll: () => (/* binding */ removeAll),
/* harmony export */   runAll: () => (/* binding */ runAll)
/* harmony export */ });
/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser.js */ "./node_modules/unload/dist/es/browser.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ "./node_modules/unload/dist/es/node.js");



/**
 * Use the code directly to prevent import problems
 * with the detect-node package.
 * @link https://github.com/iliakan/detect-node/blob/master/index.js
 */
var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
var USE_METHOD = isNode ? _node_js__WEBPACK_IMPORTED_MODULE_1__.addNode : _browser_js__WEBPACK_IMPORTED_MODULE_0__.addBrowser;
var LISTENERS = new Set();
var startedListening = false;
function startListening() {
  if (startedListening) {
    return;
  }
  startedListening = true;
  USE_METHOD(runAll);
}
function add(fn) {
  startListening();
  if (typeof fn !== 'function') {
    throw new Error('Listener is no function');
  }
  LISTENERS.add(fn);
  var addReturn = {
    remove: function remove() {
      return LISTENERS["delete"](fn);
    },
    run: function run() {
      LISTENERS["delete"](fn);
      return fn();
    }
  };
  return addReturn;
}
function runAll() {
  var promises = [];
  LISTENERS.forEach(function (fn) {
    promises.push(fn());
    LISTENERS["delete"](fn);
  });
  return Promise.all(promises);
}
function removeAll() {
  LISTENERS.clear();
}
function getSize() {
  return LISTENERS.size;
}

/***/ }),

/***/ "./node_modules/unload/dist/es/node.js":
/*!*********************************************!*\
  !*** ./node_modules/unload/dist/es/node.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addNode: () => (/* binding */ addNode)
/* harmony export */ });
function addNode(fn) {
  process.on('exit', function () {
    return fn();
  });

  /**
   * on the following events,
   * the process will not end if there are
   * event-handlers attached,
   * therefore we have to call process.exit()
   */
  process.on('beforeExit', function () {
    return fn().then(function () {
      return process.exit();
    });
  });
  // catches ctrl+c event
  process.on('SIGINT', function () {
    return fn().then(function () {
      return process.exit();
    });
  });
  // catches uncaught exceptions
  process.on('uncaughtException', function (err) {
    return fn().then(function () {
      console.trace(err);
      process.exit(101);
    });
  });
}

/***/ }),

/***/ "./node_modules/webextension-polyfill/dist/browser-polyfill.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webextension-polyfill/dist/browser-polyfill.js ***!
  \*********************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */
  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */
  /* vim: set sts=2 sw=2 et tw=80: */
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {
    throw new Error("This script should only be loaded in a browser extension.");
  }
  if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";

    // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.
    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };
      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }

      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */
      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }
        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }
          return super.get(key);
        }
      }

      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */
      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };

      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */
      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };
      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";

      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */
      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }
          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }
          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args);

                // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.
                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };

      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */
      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }
        });
      };
      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);

      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */
      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },
          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }
            if (!(prop in target)) {
              return undefined;
            }
            let value = target[prop];
            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.

              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,
                get() {
                  return target[prop];
                },
                set(value) {
                  target[prop] = value;
                }
              });
              return value;
            }
            cache[prop] = value;
            return value;
          },
          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }
            return true;
          },
          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },
          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }
        };

        // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.
        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };

      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */
      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },
        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },
        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }
      });
      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }

        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */
        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {} /* wrappers */, {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      });
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }

        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */
        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;
          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }
          const isResultThenable = result !== true && isThenable(result);

          // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.
          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          }

          // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).
          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;
              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }
              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          };

          // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.
          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          }

          // Let Chrome know that the listener is replying.
          return true;
        };
      });
      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };
      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }
        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }
        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };
      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.
    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = globalThis.browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map


/***/ }),

/***/ "./src/eventBus.js":
/*!*************************!*\
  !*** ./src/eventBus.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eventBus: () => (/* binding */ eventBus)
/* harmony export */ });
class EventBus {
  constructor() {
    this.listeners = new Map();
  }

  subscribe(eventName, callback) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, []);
    }
    this.listeners.get(eventName).push(callback);
  }

  unsubscribe(eventName, callback) {
    if (this.listeners.has(eventName)) {
      const eventListeners = this.listeners.get(eventName);
      const index = eventListeners.indexOf(callback);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
      // Optional: Clean up the event name if no listeners remain
      if (eventListeners.length === 0) {
        this.listeners.delete(eventName);
      }
    }
  }

  publish(eventName, data) {
    const listeners = this.listeners.get(eventName); // Get the specific listeners first
    if (listeners && listeners.length > 0) {
      try {
        const eventData = structuredClone(data); // Clone the data for this event
        // --> Log intent BEFORE loop <--
        console.log(`[EventBus] Publishing ${eventName}. Found ${listeners.length} listeners. Data to send:`, JSON.stringify(eventData));

        listeners.forEach((callback, index) => {
          try {
            // --> Log intent INSIDE loop for EACH listener <--
            console.log(`[EventBus] Calling listener #${index + 1} for ${eventName} with data:`, JSON.stringify(eventData));
            callback(eventData); // Pass the cloned data
          } catch (error) {
            // Log error for specific listener
            console.error(`[EventBus] Error in listener #${index + 1} for ${eventName}:`, error);
          }
        });
      } catch (cloneError) {
          console.error(`[EventBus] Failed to structuredClone data for event ${eventName}:`, cloneError, data);
      }
    } else {
        // Log if no listeners found, including the data for context
        console.log(`[EventBus] No listeners registered for event ${eventName}. Data:`, JSON.stringify(data));
    }
  }
}

const eventBus = new EventBus(); 

/***/ }),

/***/ "./src/events/dbEvents.js":
/*!********************************!*\
  !*** ./src/events/dbEvents.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DbAddLogRequest: () => (/* binding */ DbAddLogRequest),
/* harmony export */   DbAddMessageRequest: () => (/* binding */ DbAddMessageRequest),
/* harmony export */   DbAddMessageResponse: () => (/* binding */ DbAddMessageResponse),
/* harmony export */   DbClearLogsRequest: () => (/* binding */ DbClearLogsRequest),
/* harmony export */   DbClearLogsResponse: () => (/* binding */ DbClearLogsResponse),
/* harmony export */   DbCreateSessionRequest: () => (/* binding */ DbCreateSessionRequest),
/* harmony export */   DbCreateSessionResponse: () => (/* binding */ DbCreateSessionResponse),
/* harmony export */   DbDeleteMessageRequest: () => (/* binding */ DbDeleteMessageRequest),
/* harmony export */   DbDeleteMessageResponse: () => (/* binding */ DbDeleteMessageResponse),
/* harmony export */   DbDeleteSessionRequest: () => (/* binding */ DbDeleteSessionRequest),
/* harmony export */   DbDeleteSessionResponse: () => (/* binding */ DbDeleteSessionResponse),
/* harmony export */   DbEventBase: () => (/* binding */ DbEventBase),
/* harmony export */   DbGetAllSessionsRequest: () => (/* binding */ DbGetAllSessionsRequest),
/* harmony export */   DbGetAllSessionsResponse: () => (/* binding */ DbGetAllSessionsResponse),
/* harmony export */   DbGetCurrentAndLastLogSessionIdsRequest: () => (/* binding */ DbGetCurrentAndLastLogSessionIdsRequest),
/* harmony export */   DbGetCurrentAndLastLogSessionIdsResponse: () => (/* binding */ DbGetCurrentAndLastLogSessionIdsResponse),
/* harmony export */   DbGetLogsRequest: () => (/* binding */ DbGetLogsRequest),
/* harmony export */   DbGetLogsResponse: () => (/* binding */ DbGetLogsResponse),
/* harmony export */   DbGetSessionRequest: () => (/* binding */ DbGetSessionRequest),
/* harmony export */   DbGetSessionResponse: () => (/* binding */ DbGetSessionResponse),
/* harmony export */   DbGetStarredSessionsRequest: () => (/* binding */ DbGetStarredSessionsRequest),
/* harmony export */   DbGetStarredSessionsResponse: () => (/* binding */ DbGetStarredSessionsResponse),
/* harmony export */   DbGetUniqueLogValuesRequest: () => (/* binding */ DbGetUniqueLogValuesRequest),
/* harmony export */   DbGetUniqueLogValuesResponse: () => (/* binding */ DbGetUniqueLogValuesResponse),
/* harmony export */   DbInitializationCompleteNotification: () => (/* binding */ DbInitializationCompleteNotification),
/* harmony export */   DbInitializeRequest: () => (/* binding */ DbInitializeRequest),
/* harmony export */   DbMessagesUpdatedNotification: () => (/* binding */ DbMessagesUpdatedNotification),
/* harmony export */   DbRenameSessionRequest: () => (/* binding */ DbRenameSessionRequest),
/* harmony export */   DbRenameSessionResponse: () => (/* binding */ DbRenameSessionResponse),
/* harmony export */   DbResponseBase: () => (/* binding */ DbResponseBase),
/* harmony export */   DbSessionUpdatedNotification: () => (/* binding */ DbSessionUpdatedNotification),
/* harmony export */   DbStatusUpdatedNotification: () => (/* binding */ DbStatusUpdatedNotification),
/* harmony export */   DbToggleStarRequest: () => (/* binding */ DbToggleStarRequest),
/* harmony export */   DbToggleStarResponse: () => (/* binding */ DbToggleStarResponse),
/* harmony export */   DbUpdateMessageRequest: () => (/* binding */ DbUpdateMessageRequest),
/* harmony export */   DbUpdateMessageResponse: () => (/* binding */ DbUpdateMessageResponse),
/* harmony export */   DbUpdateStatusRequest: () => (/* binding */ DbUpdateStatusRequest),
/* harmony export */   DbUpdateStatusResponse: () => (/* binding */ DbUpdateStatusResponse)
/* harmony export */ });
/* harmony import */ var _eventNames_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventNames.js */ "./src/events/eventNames.js");


// Simple UUID generator (replace with a more robust library if needed)
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// --- Base Classes ---
class DbEventBase {
  constructor(requestId = null) {
    this.requestId = requestId || generateUUID();
    this.timestamp = Date.now();
  }
}

class DbResponseBase extends DbEventBase {
  constructor(originalRequestId, success, data = null, error = null) {
    super(originalRequestId);
    this.success = success;
    this.data = data;
    this.error = error ? (error.message || String(error)) : null;
  }
}

class DbNotificationBase {
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.timestamp = Date.now();
    }
}

// --- Response Events (Define Before Request Events) ---

class DbGetSessionResponse extends DbResponseBase {
  constructor(originalRequestId, success, sessionData, error = null) {
    super(originalRequestId, success, sessionData, error);
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_SESSION_RESPONSE;
  }
}

class DbAddMessageResponse extends DbResponseBase {
  constructor(originalRequestId, success, newMessageId, error = null) {
    super(originalRequestId, success, { newMessageId }, error);
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_ADD_MESSAGE_RESPONSE;
  }
}

class DbUpdateMessageResponse extends DbResponseBase {
    constructor(originalRequestId, success, error = null) {
        super(originalRequestId, success, null, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_MESSAGE_RESPONSE;
    }
}

class DbUpdateStatusResponse extends DbResponseBase {
  constructor(originalRequestId, success, error = null) {
    super(originalRequestId, success, null, error);
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_STATUS_RESPONSE;
  }
}

class DbDeleteMessageResponse extends DbResponseBase {
    constructor(originalRequestId, success, error = null) {
        super(originalRequestId, success, null, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_MESSAGE_RESPONSE;
    }
}

class DbToggleStarResponse extends DbResponseBase {
    constructor(originalRequestId, success, updatedSessionData, error = null) {
        super(originalRequestId, success, updatedSessionData, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_TOGGLE_STAR_RESPONSE;
    }
}

class DbCreateSessionResponse extends DbResponseBase {
    constructor(originalRequestId, success, newSessionId, error = null) {
        super(originalRequestId, success, { newSessionId }, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CREATE_SESSION_RESPONSE;
        console.log(`[dbEvents] DbCreateSessionResponse constructor: type set to ${this.type}`);
    }

    get newSessionId() {
        return this.data?.newSessionId;
    }
}

class DbDeleteSessionResponse extends DbResponseBase {
    constructor(originalRequestId, success, error = null) {
        super(originalRequestId, success, null, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_SESSION_RESPONSE;
    }
}

class DbRenameSessionResponse extends DbResponseBase {
    constructor(originalRequestId, success, error = null) {
        super(originalRequestId, success, null, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_RENAME_SESSION_RESPONSE;
    }
}

class DbGetAllSessionsResponse extends DbResponseBase {
    constructor(requestId, success, sessions = null, error = null) {
        super(requestId, success, sessions, error);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_ALL_SESSIONS_RESPONSE;
        this.payload = { sessions };
    }
}

class DbGetStarredSessionsResponse extends DbResponseBase {
    constructor(requestId, success, starredSessions = null, error = null) {
        super(requestId, success, starredSessions, error); 
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_STARRED_SESSIONS_RESPONSE;
    }
}

// --- Request Events (Define After Response Events) ---

class DbGetSessionRequest extends DbEventBase {
  static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_SESSION_RESPONSE;
  constructor(sessionId) {
    super();
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_SESSION_REQUEST;
    this.payload = { sessionId };
  }
}

class DbAddMessageRequest extends DbEventBase {
  static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_ADD_MESSAGE_RESPONSE;
  constructor(sessionId, messageObject) {
    super();
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_ADD_MESSAGE_REQUEST;
    this.payload = { sessionId, messageObject };
  }
}

class DbUpdateMessageRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_MESSAGE_RESPONSE;
    constructor(sessionId, messageId, updates) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_MESSAGE_REQUEST;
        this.payload = { sessionId, messageId, updates };
    }
}

class DbUpdateStatusRequest extends DbEventBase {
  static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_STATUS_RESPONSE;
  constructor(sessionId, status) {
    super();
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_UPDATE_STATUS_REQUEST;
    this.payload = { sessionId, status };
  }
}

class DbDeleteMessageRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_MESSAGE_RESPONSE;
    constructor(sessionId, messageId) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_MESSAGE_REQUEST;
        this.payload = { sessionId, messageId };
    }
}

class DbToggleStarRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_TOGGLE_STAR_RESPONSE;
    constructor(sessionId) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_TOGGLE_STAR_REQUEST;
        this.payload = { sessionId };
    }
}

class DbCreateSessionRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CREATE_SESSION_RESPONSE;
    constructor(initialMessage) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CREATE_SESSION_REQUEST;
        this.payload = { initialMessage };
        console.log(`[dbEvents] DbCreateSessionRequest constructor: type set to ${this.type}`);
    }
}

class DbInitializeRequest extends DbEventBase {
    // No response expected via requestDbAndWait, so no responseEventName needed
    constructor() {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_INITIALIZE_REQUEST;
        this.payload = {}; 
    }
}

class DbDeleteSessionRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_SESSION_RESPONSE;
    constructor(sessionId) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_DELETE_SESSION_REQUEST;
        this.payload = { sessionId };
    }
}

class DbRenameSessionRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_RENAME_SESSION_RESPONSE;
    constructor(sessionId, newName) {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_RENAME_SESSION_REQUEST;
        this.payload = { sessionId, newName };
    }
}

class DbGetAllSessionsRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_ALL_SESSIONS_RESPONSE;
    constructor() {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_ALL_SESSIONS_REQUEST;
    }
}

class DbGetStarredSessionsRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_STARRED_SESSIONS_RESPONSE;
    constructor() {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_STARRED_SESSIONS_REQUEST;
    }
}

// --- Notification Events ---

class DbMessagesUpdatedNotification extends DbNotificationBase {
    constructor(sessionId, messages) {
        super(sessionId);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_MESSAGES_UPDATED_NOTIFICATION;
        this.payload = { messages }; 
    }
}

class DbStatusUpdatedNotification extends DbNotificationBase {
    constructor(sessionId, status) {
        super(sessionId);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_STATUS_UPDATED_NOTIFICATION;
        this.payload = { status };
    }
}

class DbSessionUpdatedNotification extends DbNotificationBase {
    constructor(sessionId, updatedSessionData) {
        super(sessionId);
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_SESSION_UPDATED_NOTIFICATION;
        this.payload = { session: updatedSessionData }; 
    }
}

class DbInitializationCompleteNotification {
    constructor({ success, error = null }) {
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_INITIALIZATION_COMPLETE_NOTIFICATION;
        this.timestamp = Date.now();
        this.payload = { success, error: error ? (error.message || String(error)) : null };
    }
}

// --- Log Response Events ---

class DbGetLogsResponse extends DbResponseBase {
  constructor(originalRequestId, success, logs, error = null) {
    super(originalRequestId, success, logs, error); // data = logs array
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_LOGS_RESPONSE;
  }
}

class DbGetUniqueLogValuesResponse extends DbResponseBase {
  constructor(originalRequestId, success, values, error = null) {
    super(originalRequestId, success, values, error); // data = values array
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_UNIQUE_LOG_VALUES_RESPONSE;
  }
}

class DbClearLogsResponse extends DbResponseBase {
  constructor(originalRequestId, success, error = null) {
    super(originalRequestId, success, null, error);
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CLEAR_LOGS_RESPONSE;
  }
}

class DbGetCurrentAndLastLogSessionIdsResponse extends DbResponseBase {
    constructor(originalRequestId, success, ids, error = null) {
      // data = { currentLogSessionId: '...', previousLogSessionId: '...' | null }
      super(originalRequestId, success, ids, error);
      this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE;
    }
  }

// --- Log Request Events ---

// Request to add a single log entry
// No response needed, fire-and-forget style
class DbAddLogRequest extends DbEventBase {
  // No responseEventName needed for fire-and-forget
  constructor(logEntryData) {
    // logEntryData = { level, component, message, chatSessionId (optional) }
    // db service will add id, timestamp, extensionSessionId
    super(); // Generate request ID just for tracking if needed
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_ADD_LOG_REQUEST;
    this.payload = { logEntryData };
  }
}

// Request to get logs based on filters
class DbGetLogsRequest extends DbEventBase {
  static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_LOGS_RESPONSE;
  constructor(filters) {
    // filters = { extensionSessionId: 'id' | 'current' | 'last' | 'all',
    //             component: 'name' | 'all',
    //             level: 'level' | 'all' }
    super();
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_LOGS_REQUEST;
    this.payload = { filters };
  }
}

// Request to get unique values for a specific field in logs
class DbGetUniqueLogValuesRequest extends DbEventBase {
  static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_UNIQUE_LOG_VALUES_RESPONSE;
  constructor(fieldName) {
    // fieldName = 'extensionSessionId', 'component', 'level'
    super();
    this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_UNIQUE_LOG_VALUES_REQUEST;
    this.payload = { fieldName };
  }
}

// Request to clear logs (potentially based on filters in future, but maybe just 'all' or 'last_session' for now)
class DbClearLogsRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CLEAR_LOGS_RESPONSE;
    constructor(filter = 'all') { // 'all' or potentially 'last_session' or specific session ID later
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_CLEAR_LOGS_REQUEST;
        this.payload = { filter };
    }
}

// Request to get the actual IDs for 'current' and 'last' sessions
class DbGetCurrentAndLastLogSessionIdsRequest extends DbEventBase {
    static responseEventName = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE;
    constructor() {
        super();
        this.type = _eventNames_js__WEBPACK_IMPORTED_MODULE_0__.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST;
    }
} 

/***/ }),

/***/ "./src/events/eventNames.js":
/*!**********************************!*\
  !*** ./src/events/eventNames.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DB_ADD_LOG_REQUEST: () => (/* binding */ DB_ADD_LOG_REQUEST),
/* harmony export */   DB_ADD_LOG_RESPONSE: () => (/* binding */ DB_ADD_LOG_RESPONSE),
/* harmony export */   DB_ADD_MESSAGE_REQUEST: () => (/* binding */ DB_ADD_MESSAGE_REQUEST),
/* harmony export */   DB_ADD_MESSAGE_RESPONSE: () => (/* binding */ DB_ADD_MESSAGE_RESPONSE),
/* harmony export */   DB_CLEAR_LOGS_REQUEST: () => (/* binding */ DB_CLEAR_LOGS_REQUEST),
/* harmony export */   DB_CLEAR_LOGS_RESPONSE: () => (/* binding */ DB_CLEAR_LOGS_RESPONSE),
/* harmony export */   DB_CREATE_SESSION_REQUEST: () => (/* binding */ DB_CREATE_SESSION_REQUEST),
/* harmony export */   DB_CREATE_SESSION_RESPONSE: () => (/* binding */ DB_CREATE_SESSION_RESPONSE),
/* harmony export */   DB_DELETE_MESSAGE_REQUEST: () => (/* binding */ DB_DELETE_MESSAGE_REQUEST),
/* harmony export */   DB_DELETE_MESSAGE_RESPONSE: () => (/* binding */ DB_DELETE_MESSAGE_RESPONSE),
/* harmony export */   DB_DELETE_SESSION_REQUEST: () => (/* binding */ DB_DELETE_SESSION_REQUEST),
/* harmony export */   DB_DELETE_SESSION_RESPONSE: () => (/* binding */ DB_DELETE_SESSION_RESPONSE),
/* harmony export */   DB_GET_ALL_SESSIONS_REQUEST: () => (/* binding */ DB_GET_ALL_SESSIONS_REQUEST),
/* harmony export */   DB_GET_ALL_SESSIONS_RESPONSE: () => (/* binding */ DB_GET_ALL_SESSIONS_RESPONSE),
/* harmony export */   DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST: () => (/* binding */ DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST),
/* harmony export */   DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE: () => (/* binding */ DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE),
/* harmony export */   DB_GET_LOGS_REQUEST: () => (/* binding */ DB_GET_LOGS_REQUEST),
/* harmony export */   DB_GET_LOGS_RESPONSE: () => (/* binding */ DB_GET_LOGS_RESPONSE),
/* harmony export */   DB_GET_SESSION_REQUEST: () => (/* binding */ DB_GET_SESSION_REQUEST),
/* harmony export */   DB_GET_SESSION_RESPONSE: () => (/* binding */ DB_GET_SESSION_RESPONSE),
/* harmony export */   DB_GET_STARRED_SESSIONS_REQUEST: () => (/* binding */ DB_GET_STARRED_SESSIONS_REQUEST),
/* harmony export */   DB_GET_STARRED_SESSIONS_RESPONSE: () => (/* binding */ DB_GET_STARRED_SESSIONS_RESPONSE),
/* harmony export */   DB_GET_UNIQUE_LOG_VALUES_REQUEST: () => (/* binding */ DB_GET_UNIQUE_LOG_VALUES_REQUEST),
/* harmony export */   DB_GET_UNIQUE_LOG_VALUES_RESPONSE: () => (/* binding */ DB_GET_UNIQUE_LOG_VALUES_RESPONSE),
/* harmony export */   DB_INITIALIZATION_COMPLETE_NOTIFICATION: () => (/* binding */ DB_INITIALIZATION_COMPLETE_NOTIFICATION),
/* harmony export */   DB_INITIALIZE_REQUEST: () => (/* binding */ DB_INITIALIZE_REQUEST),
/* harmony export */   DB_MESSAGES_UPDATED_NOTIFICATION: () => (/* binding */ DB_MESSAGES_UPDATED_NOTIFICATION),
/* harmony export */   DB_RENAME_SESSION_REQUEST: () => (/* binding */ DB_RENAME_SESSION_REQUEST),
/* harmony export */   DB_RENAME_SESSION_RESPONSE: () => (/* binding */ DB_RENAME_SESSION_RESPONSE),
/* harmony export */   DB_SESSION_UPDATED_NOTIFICATION: () => (/* binding */ DB_SESSION_UPDATED_NOTIFICATION),
/* harmony export */   DB_STATUS_UPDATED_NOTIFICATION: () => (/* binding */ DB_STATUS_UPDATED_NOTIFICATION),
/* harmony export */   DB_TOGGLE_STAR_REQUEST: () => (/* binding */ DB_TOGGLE_STAR_REQUEST),
/* harmony export */   DB_TOGGLE_STAR_RESPONSE: () => (/* binding */ DB_TOGGLE_STAR_RESPONSE),
/* harmony export */   DB_UPDATE_MESSAGE_REQUEST: () => (/* binding */ DB_UPDATE_MESSAGE_REQUEST),
/* harmony export */   DB_UPDATE_MESSAGE_RESPONSE: () => (/* binding */ DB_UPDATE_MESSAGE_RESPONSE),
/* harmony export */   DB_UPDATE_STATUS_REQUEST: () => (/* binding */ DB_UPDATE_STATUS_REQUEST),
/* harmony export */   DB_UPDATE_STATUS_RESPONSE: () => (/* binding */ DB_UPDATE_STATUS_RESPONSE)
/* harmony export */ });
// Event name constants for DB events
const DB_GET_SESSION_REQUEST = 'DbGetSessionRequest';
const DB_GET_SESSION_RESPONSE = 'DbGetSessionResponse';
const DB_ADD_MESSAGE_REQUEST = 'DbAddMessageRequest';
const DB_ADD_MESSAGE_RESPONSE = 'DbAddMessageResponse';
const DB_UPDATE_MESSAGE_REQUEST = 'DbUpdateMessageRequest';
const DB_UPDATE_MESSAGE_RESPONSE = 'DbUpdateMessageResponse';
const DB_UPDATE_STATUS_REQUEST = 'DbUpdateStatusRequest';
const DB_UPDATE_STATUS_RESPONSE = 'DbUpdateStatusResponse';
const DB_DELETE_MESSAGE_REQUEST = 'DbDeleteMessageRequest';
const DB_DELETE_MESSAGE_RESPONSE = 'DbDeleteMessageResponse';
const DB_TOGGLE_STAR_REQUEST = 'DbToggleStarRequest';
const DB_TOGGLE_STAR_RESPONSE = 'DbToggleStarResponse';
const DB_CREATE_SESSION_REQUEST = 'DbCreateSessionRequest';
const DB_CREATE_SESSION_RESPONSE = 'DbCreateSessionResponse';
const DB_DELETE_SESSION_REQUEST = 'DbDeleteSessionRequest';
const DB_DELETE_SESSION_RESPONSE = 'DbDeleteSessionResponse';
const DB_RENAME_SESSION_REQUEST = 'DbRenameSessionRequest';
const DB_RENAME_SESSION_RESPONSE = 'DbRenameSessionResponse';
const DB_GET_ALL_SESSIONS_REQUEST = 'DbGetAllSessionsRequest';
const DB_GET_ALL_SESSIONS_RESPONSE = 'DbGetAllSessionsResponse';
const DB_GET_STARRED_SESSIONS_REQUEST = 'DbGetStarredSessionsRequest';
const DB_GET_STARRED_SESSIONS_RESPONSE = 'DbGetStarredSessionsResponse';
const DB_MESSAGES_UPDATED_NOTIFICATION = 'DbMessagesUpdatedNotification';
const DB_STATUS_UPDATED_NOTIFICATION = 'DbStatusUpdatedNotification';
const DB_SESSION_UPDATED_NOTIFICATION = 'DbSessionUpdatedNotification';
const DB_INITIALIZE_REQUEST = 'DbInitializeRequest';
const DB_INITIALIZATION_COMPLETE_NOTIFICATION = 'DbInitializationCompleteNotification';
const DB_GET_LOGS_REQUEST = 'DbGetLogsRequest';
const DB_GET_LOGS_RESPONSE = 'DbGetLogsResponse';
const DB_GET_UNIQUE_LOG_VALUES_REQUEST = 'DbGetUniqueLogValuesRequest';
const DB_GET_UNIQUE_LOG_VALUES_RESPONSE = 'DbGetUniqueLogValuesResponse';
const DB_CLEAR_LOGS_REQUEST = 'DbClearLogsRequest';
const DB_CLEAR_LOGS_RESPONSE = 'DbClearLogsResponse';
const DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST = 'DbGetCurrentAndLastLogSessionIdsRequest';
const DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE = 'DbGetCurrentAndLastLogSessionIdsResponse';
const DB_ADD_LOG_REQUEST = 'DbAddLogRequest';
const DB_ADD_LOG_RESPONSE = 'DbAddLogResponse'; 

/***/ }),

/***/ "./src/log-client.js":
/*!***************************!*\
  !*** ./src/log-client.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   logDebug: () => (/* binding */ logDebug),
/* harmony export */   logError: () => (/* binding */ logError),
/* harmony export */   logInfo: () => (/* binding */ logInfo),
/* harmony export */   logWarn: () => (/* binding */ logWarn)
/* harmony export */ });
/* harmony import */ var _eventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventBus.js */ "./src/eventBus.js");
/* harmony import */ var _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/dbEvents.js */ "./src/events/dbEvents.js");
/* harmony import */ var _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/eventNames.js */ "./src/events/eventNames.js");




const hasChromeRuntime = typeof chrome !== 'undefined' && chrome.runtime;
let componentName = 'unknown';
let mirrorToConsoleDefault = true;
let sendToDbDefault = true;
let isDbReadyForLogs = false;
const logBuffer = [];

async function flushLogBuffer() {
    if (!_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus) return;
    while (logBuffer.length > 0) {
        const logEvent = logBuffer.shift();
        if (logEvent) {
            try {
                await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(logEvent.type, logEvent);
            } catch (error) {
                console.error(`LogClient (${componentName}): Error publishing buffered log. Error: ${error}. Event:`, logEvent);
            }
        }
    }
}

function init(compName, options = {}) {
    if (!compName) {
        console.error("LogClient: init() requires a component name.");
        return;
    }
    componentName = compName;
    mirrorToConsoleDefault = options.mirrorToConsole !== undefined ? options.mirrorToConsole : true;
    sendToDbDefault = options.sendToDb !== undefined ? options.sendToDb : true;

    if (_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus) {
        _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.subscribe(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_INITIALIZATION_COMPLETE_NOTIFICATION, (notification) => {
            if (notification.payload.success) {
                console.log(`[LogClient (${componentName})] Received DB Initialization Complete. Flushing buffer.`);
                isDbReadyForLogs = true;
                flushLogBuffer();
            } else {
                console.error(`[LogClient (${componentName})] Received DB Initialization FAILED notification. Logs will not be sent to DB. Error:`, notification.payload.error);
            }
        });
    } else {
        console.error(`LogClient (${componentName}): CRITICAL - eventBus not available during init. DB logging disabled.`);
        sendToDbDefault = false;
    }

    let logMode = 'unknown';
    if (typeof _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus !== 'undefined') {
        logMode = 'sendMessage logging (Standard)';
    } else {
        logMode = 'console fallback';
        console.error(`LogClient (${componentName}): CRITICAL - No logging mechanism available. Falling back to console.`);
    }

    const initialLogMessage = `Log client initialized for component: ${componentName}. (${logMode}, Console Mirror: ${mirrorToConsoleDefault}, SendToDB: ${sendToDbDefault})`;
    _internalLogHelper('info', initialLogMessage, { mirrorToConsole: mirrorToConsoleDefault, sendToDb: sendToDbDefault, skipInitCheck: true });
}

async function _internalLogHelper(level, ...args) {
    const rawOptions = args.length > 0 && typeof args[args.length - 1] === 'object' && !Array.isArray(args[args.length - 1]) ? args.pop() : {};
    const options = rawOptions || {};

    const mirrorThisCall = options.mirrorToConsole !== undefined ? options.mirrorToConsole : mirrorToConsoleDefault;
    let sendThisCall = options.sendToDb !== undefined ? options.sendToDb : sendToDbDefault;
    const skipInitCheck = options.skipInitCheck || false;

    if (sendThisCall && typeof _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus === 'undefined') {
        console.warn(`LogClient (${componentName}): Attempted DB log but eventBus is unavailable. Disabling DB log for this call.`);
        sendThisCall = false;
    }

    if (!componentName && !skipInitCheck) {
        console.error("LogClient: Attempted to log before init() was called. Message:", level, ...args);
        return;
    }

    if (mirrorThisCall || level.toLowerCase() === 'error') {
        const consolePrefix = componentName ? `[${componentName}]` : `[LogClient]`;
        const consoleArgs = [consolePrefix, ...args];
        switch (level.toLowerCase()) {
            case 'error': console.error(...consoleArgs); break;
            case 'warn': if (mirrorThisCall) console.warn(...consoleArgs); break;
            case 'debug': if (mirrorThisCall) console.debug(...consoleArgs); break;
            case 'info': default: if (mirrorThisCall) console.log(...consoleArgs); break;
        }
    }

    if (!sendThisCall) return;

    const formattedMessage = args.map(arg => {
        try {
            if (arg instanceof Error) {
                return `Error: ${arg.message}${arg.stack ? '\n' + arg.stack : ''}`;
            }
            if (typeof arg === 'object' && arg !== null) {
                return '[Object]';
            }
            return String(arg);
        } catch (e) {
            return `[Unstringifiable Object: ${e.message}]`;
        }
    }).join(' ');

    const logPayload = {
        id: crypto.randomUUID(),
        timestamp: Date.now(),
        component: componentName,
        level: level.toLowerCase(),
        message: formattedMessage,
    };

    if (hasChromeRuntime && chrome.storage?.local) {
        try {
            const { currentLogSessionId } = await chrome.storage.local.get('currentLogSessionId');
            if (currentLogSessionId) {
                logPayload.extensionSessionId = currentLogSessionId;
            } else {
                console.warn(`LogClient (${componentName}): Could not retrieve currentLogSessionId from storage.`);
                logPayload.extensionSessionId = 'unknown-session';
            }
        } catch (storageError) {
            console.error(`LogClient (${componentName}): Error retrieving session ID from storage:`, storageError);
            logPayload.extensionSessionId = 'storage-error-session';
        }
    } else {
        logPayload.extensionSessionId = 'no-storage-session';
    }

    const logEvent = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbAddLogRequest(logPayload);

    if (isDbReadyForLogs) {
        try {
            await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(logEvent.type, logEvent);
        } catch (error) {
            console.error(`LogClient (${componentName}): Error during eventBus log submission. Error: ${error}. Original message:`, level, ...args);
        }
    } else {
        logBuffer.push(logEvent);
    }
}

function log(level, ...args) {
    _internalLogHelper(level, ...args);
}

function logDebug(...args) {
    _internalLogHelper('debug', ...args);
}

function logInfo(...args) {
    _internalLogHelper('info', ...args);
}

function logWarn(...args) {
    _internalLogHelper('warn', ...args);
}

function logError(...args) {
    _internalLogHelper('error', ...args);
}



/***/ }),

/***/ "./src/minimaldb.js":
/*!**************************!*\
  !*** ./src/minimaldb.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rxdb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxdb */ "./node_modules/rxdb/dist/esm/plugin.js");
/* harmony import */ var rxdb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxdb */ "./node_modules/rxdb/dist/esm/rx-database.js");
/* harmony import */ var rxdb_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxdb/plugins/storage-dexie */ "./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-dexie.js");
/* harmony import */ var rxdb_plugins_query_builder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxdb/plugins/query-builder */ "./node_modules/rxdb/dist/esm/plugins/query-builder/index.js");
/* harmony import */ var rxdb_plugins_migration_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxdb/plugins/migration-schema */ "./node_modules/rxdb/dist/esm/plugins/migration-schema/index.js");
/* harmony import */ var rxdb_plugins_update__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxdb/plugins/update */ "./node_modules/rxdb/dist/esm/plugins/update/index.js");
/* harmony import */ var _eventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventBus.js */ "./src/eventBus.js");
/* harmony import */ var _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/dbEvents.js */ "./src/events/dbEvents.js");
/* harmony import */ var _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/eventNames.js */ "./src/events/eventNames.js");
console.log('[Database] minimaldb.js initialized in context:', typeof window !== 'undefined' ? 'browser window' : (typeof self !== 'undefined' ? 'worker or background' : 'unknown context'));
const ENABLE_LOGGING = true;
const RESET_DB_ON_ERROR = true;
const LOG_LEVELS = {
    OFF: 0,
    ERROR: 1,
    INFO: 2,
    DEBUG: 3
};


class Logger {
    constructor(module, defaultLevel = 'debug') {
        this.module = module;
        this.level = ENABLE_LOGGING ? LOG_LEVELS[defaultLevel.toUpperCase()] : LOG_LEVELS.OFF;
    }

    debug(message, meta = {}) {
        if (this.level >= LOG_LEVELS.DEBUG) {
            console.debug(`[Database:${this.module}] ${message}`, { ...meta, timestamp: new Date().toISOString() });
        }
    }

    info(message, meta = {}) {
        if (this.level >= LOG_LEVELS.INFO) {
            console.info(`[Database:${this.module}] ${message}`, { ...meta, timestamp: new Date().toISOString() });
        }
    }

    error(message, meta = {}) {
        if (this.level >= LOG_LEVELS.ERROR) {
            console.error(`[Database:${this.module}] ${message}`, { ...meta, timestamp: new Date().toISOString() });
        }
    }

    setLevel(level) {
        this.level = LOG_LEVELS[level.toUpperCase()] || LOG_LEVELS.OFF;
    }
}


class AppError extends Error {
    constructor(code, message, details = {}) {
        super(message);
        this.code = code;
        this.details = details;
    }
}


async function withTimeout(promise, ms, errorMessage = `Operation timed out after ${ms}ms`) {
    const timeout = new Promise((_, reject) => setTimeout(() => reject(new AppError('TIMEOUT', errorMessage)), ms));
    return Promise.race([promise, timeout]);
}









 


const logger = new Logger('Main');


let db = null;
let chatHistoryCollection = null;
let logDbInstance = null;
let logsCollection = null;
let isDbInitialized = false;
let isLogDbInitialized = false;
let dbReadyResolve;
const dbReadyPromise = new Promise(resolve => { dbReadyResolve = resolve; });
let currentExtensionSessionId = null;
let previousExtensionSessionId = null;


const chatHistorySchema = {
    title: 'chat history schema',
    version: 0,
    description: 'Stores chat sessions',
    primaryKey: 'id',
    type: 'object',
    properties: {
        id: { type: 'string', maxLength: 100 },
        tabId: { type: 'number' },
        timestamp: { type: 'number' },
        title: { type: 'string', maxLength: 100 },
        messages: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    messageId: { type: 'string', maxLength: 100 },
                    sender: { type: 'string' },
                    text: { type: 'string' },
                    timestamp: { type: 'number' },
                    isLoading: { type: 'boolean', default: false }
                },
                required: ['messageId', 'sender', 'text', 'timestamp']
            }
        },
        isStarred: { type: 'boolean', default: false },
        status: { type: 'string', default: 'idle' }
    },
    required: ['id', 'timestamp', 'messages'],
    indexes: [['timestamp']]
};


const logSchema = {
  title: 'log schema',
  version: 0,
  description: 'Stores application log entries',
  primaryKey: 'id',
  type: 'object',
  properties: {
    id: { 
      type: 'string',
      maxLength: 100,
      final: true 
    },
    timestamp: { 
      type: 'number',
      index: true 
    },
    level: { 
      type: 'string',
      enum: ['error', 'warn', 'info', 'debug'],
      index: true 
    },
    message: { 
      type: 'string'
    },
    component: { 
      type: 'string',
      index: true
    },
    extensionSessionId: { 
      type: 'string',
      index: true
    },
    chatSessionId: {
      type: ['string', 'null'],
      index: true,
      default: null 
    }
  },
  required: ['id', 'timestamp', 'level', 'component', 'extensionSessionId', 'message']
};


async function ensureDbReady(type = 'chat') {
    const isReady = await withTimeout(dbReadyPromise, 5000, 'Database initialization timeout');
    if (!isReady) {
         throw new AppError('DB_NOT_READY', 'Main Database systems not initialized');
    }
    if (type === 'chat') {
        if (!chatHistoryCollection) throw new AppError('COLLECTION_NOT_READY', 'Chat history collection not initialized');
    return chatHistoryCollection;
    } else if (type === 'log') {
        if (!logsCollection) throw new AppError('COLLECTION_NOT_READY', 'Logs collection not initialized');
        return logsCollection;
    } else {
        throw new AppError('INVALID_INPUT', `Unknown DB type requested: ${type}`);
    }
}


async function resetDatabase() {
    const resetLogger = new Logger('Reset');
    resetLogger.info('Resetting databases due to initialization failure');
    try {
        if (db) {
            await db.destroy();
            resetLogger.debug('Main database instance destroyed');
        }
        if (logDbInstance) {
            await logDbInstance.destroy();
            resetLogger.debug('Log database instance destroyed');
        }
        db = null;
        chatHistoryCollection = null;
        isDbInitialized = false;
        logDbInstance = null;
        logsCollection = null;
        isLogDbInitialized = false;


        try {

            const mainStorage = (0,rxdb_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__.getRxStorageDexie)('tabagentdb');
            if (mainStorage && typeof mainStorage.remove === 'function') {
                 await mainStorage.remove();
                 resetLogger.info('Removed tabagentdb storage');
            } else {
                 resetLogger.warn('Could not get main storage or remove method.');
            }
        } catch (e) { resetLogger.warn('Could not remove tabagentdb storage (might not exist)', { error: e?.message }); }
         try {

             const logStorage = (0,rxdb_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__.getRxStorageDexie)('tabagent_logs_db');
             if (logStorage && typeof logStorage.remove === 'function') {
                 await logStorage.remove();
                 resetLogger.info('Removed tabagent_logs_db storage');
             } else {
                  resetLogger.warn('Could not get log storage or remove method.');
             }
        } catch (e) { resetLogger.warn('Could not remove tabagent_logs_db storage (might not exist)', { error: e?.message }); }

        dbReadyResolve(false);
    } catch (error) {
        console.error("[Database:Reset] CAUGHT RAW ERROR during reset:", error);
        resetLogger.error('Failed to reset databases', { error });
        throw new AppError('RESET_FAILED', 'Could not reset databases', { originalError: error });
    }
}


async function handleInitializeRequest(event) {
    const initLogger = new Logger('Initialize');
    initLogger.info('Handling initialize request');


    try {
        const ids = await chrome.storage.local.get(['currentLogSessionId', 'previousLogSessionId']);
        currentExtensionSessionId = ids.currentLogSessionId || null;
        previousExtensionSessionId = ids.previousLogSessionId || null;
        if (!currentExtensionSessionId) {
            initLogger.error('CRITICAL: currentLogSessionId not found in storage during DB init!');
        }
         initLogger.info('Retrieved log session IDs', { current: currentExtensionSessionId, previous: previousExtensionSessionId });
    } catch (storageError) {
         initLogger.error('Failed to retrieve log session IDs from storage', { error: storageError });

    }


    if (isDbInitialized && isLogDbInitialized) {
        initLogger.info('Both databases already initialized, skipping');
        return; 
    }
    
    try {
        (0,rxdb__WEBPACK_IMPORTED_MODULE_4__.addRxPlugin)(rxdb_plugins_query_builder__WEBPACK_IMPORTED_MODULE_5__.RxDBQueryBuilderPlugin);
        (0,rxdb__WEBPACK_IMPORTED_MODULE_4__.addRxPlugin)(rxdb_plugins_migration_schema__WEBPACK_IMPORTED_MODULE_6__.RxDBMigrationSchemaPlugin);
        (0,rxdb__WEBPACK_IMPORTED_MODULE_4__.addRxPlugin)(rxdb_plugins_update__WEBPACK_IMPORTED_MODULE_7__.RxDBUpdatePlugin);

        if (!isDbInitialized) {
        db = await withTimeout((0,rxdb__WEBPACK_IMPORTED_MODULE_8__.createRxDatabase)({
            name: 'tabagentdb',
            storage: (0,rxdb_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__.getRxStorageDexie)()
        }), 10000);
            initLogger.debug('Main database instance created', { name: db.name });

            const chatCollections = await db.addCollections({
            chatHistory: {
                schema: chatHistorySchema
            }
        });
            chatHistoryCollection = chatCollections.chatHistory;
        initLogger.debug('Chat history collection initialized');
            isDbInitialized = true;
        } else {
             initLogger.info('Main database already initialized');
        }
        
        if (!isLogDbInitialized) {
            logDbInstance = await withTimeout((0,rxdb__WEBPACK_IMPORTED_MODULE_8__.createRxDatabase)({
                 name: 'tabagent_logs_db',
                 storage: (0,rxdb_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__.getRxStorageDexie)()
             }), 10000);
             initLogger.debug('Log database instance created', { name: logDbInstance.name });

            const logCollections = await logDbInstance.addCollections({
                logs: {
                    schema: logSchema
                }
            });
            logsCollection = logCollections.logs;
            initLogger.debug('Logs collection initialized');
            isLogDbInitialized = true;
        } else {
            initLogger.info('Log database already initialized');
        }

        if (isDbInitialized && isLogDbInitialized) {
            const currentSubscriptions = (typeof _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus?.getSubscriptions === 'function') 
                ? _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.getSubscriptions() 
                : {}; 
            const chatEventNames = [
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_CREATE_SESSION_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_SESSION_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_ADD_MESSAGE_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_UPDATE_MESSAGE_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_DELETE_MESSAGE_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_UPDATE_STATUS_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_TOGGLE_STAR_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_ALL_SESSIONS_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_STARRED_SESSIONS_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_DELETE_SESSION_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_RENAME_SESSION_REQUEST
             ];
             const needChatSubscription = chatEventNames.some(name => !currentSubscriptions[name]);
            
             if (needChatSubscription) {
                 const chatSubscriptions = [
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_CREATE_SESSION_REQUEST, handler: handleDbCreateSessionRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_SESSION_REQUEST, handler: handleDbGetSessionRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_ADD_MESSAGE_REQUEST, handler: handleDbAddMessageRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_UPDATE_MESSAGE_REQUEST, handler: handleDbUpdateMessageRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_DELETE_MESSAGE_REQUEST, handler: handleDbDeleteMessageRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_UPDATE_STATUS_REQUEST, handler: handleDbUpdateStatusRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_TOGGLE_STAR_REQUEST, handler: handleDbToggleStarRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_ALL_SESSIONS_REQUEST, handler: handleDbGetAllSessionsRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_STARRED_SESSIONS_REQUEST, handler: handleDbGetStarredSessionsRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_DELETE_SESSION_REQUEST, handler: handleDbDeleteSessionRequest },
            { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_RENAME_SESSION_REQUEST, handler: handleDbRenameSessionRequest }
        ];
                 chatSubscriptions.forEach(({ event, handler }) => _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.subscribe(event, handler));
                 initLogger.debug('Chat event bus subscriptions complete', { count: chatSubscriptions.length });
             } else {
                 initLogger.debug('Chat event bus subscriptions already exist.');
             }

            const logEventNames = [
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_ADD_LOG_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_LOGS_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_UNIQUE_LOG_VALUES_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_CLEAR_LOGS_REQUEST,
                 _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST
             ];
             const needLogSubscription = logEventNames.some(name => !currentSubscriptions[name]);

             if (needLogSubscription) {
                 const logSubscriptions = [
                     { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_ADD_LOG_REQUEST, handler: handleDbAddLogRequest },
                     { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_LOGS_REQUEST, handler: handleDbGetLogsRequest },
                     { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_UNIQUE_LOG_VALUES_REQUEST, handler: handleDbGetUniqueLogValuesRequest },
                     { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_CLEAR_LOGS_REQUEST, handler: handleDbClearLogsRequest },
                     { event: _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST, handler: handleDbGetCurrentAndLastLogSessionIdsRequest }
                 ];
                 logSubscriptions.forEach(({ event, handler }) => _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.subscribe(event, handler));
                 initLogger.info('Subscribed to Log Database events', { count: logSubscriptions.length });
             } else {
                 initLogger.info('Log Database event subscriptions already exist.');
             }

        dbReadyResolve(true);
            initLogger.info('Initialization complete for both databases');
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_INITIALIZATION_COMPLETE_NOTIFICATION, new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbInitializationCompleteNotification({ success: true }));
        } else {
            initLogger.warn('Initialization partially complete, something went wrong.');
        }

        if (isDbInitialized && isLogDbInitialized) {
            setTimeout(async () => {
                initLogger.info('Running startup log pruning (delayed)...');
                initLogger.debug('Current/Previous IDs for pruning', { current: currentExtensionSessionId, previous: previousExtensionSessionId });
                try {
                     const currentId = currentExtensionSessionId;
                     const previousId = previousExtensionSessionId; 

                     if (!currentId) {
                         initLogger.warn('Cannot prune logs, currentExtensionSessionId is not set!');
                     } else {
                         initLogger.debug('Attempting to get all unique log session IDs...');
                         const allLogSessionIds = await getAllUniqueLogSessionIdsInternal();
                         initLogger.debug('Found unique log session IDs in DB', { ids: allLogSessionIds });
                         
                         const sessionsToKeep = new Set();
                         sessionsToKeep.add(currentId);
                         if (previousId) sessionsToKeep.add(previousId);
                         initLogger.debug('Session IDs to keep', { ids: Array.from(sessionsToKeep) });

                         const sessionIdsToDelete = Array.from(allLogSessionIds).filter(id => !sessionsToKeep.has(id));
                         initLogger.debug('Session IDs to delete', { ids: sessionIdsToDelete });

                         if (sessionIdsToDelete.length > 0) {
                             initLogger.info(`Attempting to clear logs for ${sessionIdsToDelete.length} old session(s).`);
                             const { deletedCount } = await clearLogsInternal(sessionIdsToDelete);
                             initLogger.info(`Startup pruning removed ${deletedCount} logs from old session(s).`);
                         } else {
                             initLogger.info('No old log sessions found to prune during startup.');
                         }
                     }
                } catch (pruneError) {
                    console.error('[Database:Initialize] Error during startup log pruning:', pruneError);
                }
            }, 100); 
        }

    } catch (error) {
        console.error("[Database:Initialize] Entered CATCH block for init error.");
        console.error("[Database:Initialize] Raw Error Name:", error?.name);
        console.error("[Database:Initialize] Raw Error Message:", error?.message);
        console.error("[Database:Initialize] CAUGHT RAW ERROR OBJECT during init:", error); 

        const appError = error instanceof AppError ? error : new AppError('INIT_FAILED', 'Database initialization failed', { originalError: error });
        initLogger.error('Initialization failed', { error: appError, details: error }); 

        if (RESET_DB_ON_ERROR) {
            try {
                await resetDatabase();
                initLogger.info('Attempting reinitialization after reset');
                await handleInitializeRequest(event); 
                return;
            } catch (resetError) {
                initLogger.error('Reinitialization after reset failed', { error: resetError });
            }
        }

        isDbInitialized = false;
        isLogDbInitialized = false;
        dbReadyResolve(false); 
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_INITIALIZATION_COMPLETE_NOTIFICATION, new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbInitializationCompleteNotification({ success: false, error: appError }));
    }
}

// Generate unique message ID
function generateMessageId(chatId) {
    if (!chatId || typeof chatId !== 'string') {
        throw new AppError('INVALID_INPUT', 'Chat ID must be a non-empty string');
    }
    return `${chatId}-msg-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
}

// Sanitize input to prevent injection
function sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    return input.replace(/[<>]/g, '');
}

// Internal database operations
async function createChatSessionInternal(initialMessage) {
    const opLogger = new Logger('CreateSession');
    opLogger.debug('Creating new chat session', { initialMessage });

    const collection = await ensureDbReady();
    if (!initialMessage || !initialMessage.text) {
        throw new AppError('INVALID_INPUT', 'Initial message with text is required');
    }

        const timestamp = Date.now();
    const sessionId = crypto.randomUUID();
    const message = {
            ...initialMessage,
        text: sanitizeInput(initialMessage.text),
            messageId: generateMessageId(sessionId),
        timestamp: initialMessage.timestamp || timestamp,
        sender: initialMessage.sender || 'user'
        };
    const sessionData = {
            id: sessionId,
            tabId: null,
        timestamp,
        title: sanitizeInput(message.text.substring(0, 30)) + '...',
        messages: [message],
        isStarred: false,
        status: 'idle'
        };

    opLogger.debug('Inserting session', { sessionId });
    const newSessionDoc = await withTimeout(collection.insert(sessionData), 3000);
    opLogger.info('Session created', { sessionId });

    await publishSessionUpdateNotificationInternal(sessionId);
    return newSessionDoc;
}

async function getChatSessionByIdInternal(sessionId) {
    const opLogger = new Logger('GetSession');
    opLogger.debug('Getting session', { sessionId });

    if (!sessionId) {
        throw new AppError('INVALID_INPUT', 'Session ID is required');
    }

    const collection = await ensureDbReady();
    const doc = await withTimeout(collection.findOne(sessionId).exec(), 3000);
    if (!doc) {
        opLogger.info('Session not found', { sessionId });
        return null;
    }

    opLogger.debug('Session retrieved', { sessionId });
    return doc;
}

async function addMessageToChatInternal(chatId, messageObject) {
    const opLogger = new Logger('AddMessage');
    opLogger.debug('Adding message', { chatId });

    if (!chatId || !messageObject || !messageObject.text) {
        throw new AppError('INVALID_INPUT', 'Chat ID and message with text are required');
        }

    const collection = await ensureDbReady();
    const chatDoc = await withTimeout(collection.findOne(chatId).exec(), 3000);
        if (!chatDoc) {
        throw new AppError('NOT_FOUND', `Chat session ${chatId} not found`);
        }

        const newMessage = {
            ...messageObject,
        text: sanitizeInput(messageObject.text),
            messageId: messageObject.messageId || generateMessageId(chatId),
            timestamp: messageObject.timestamp || Date.now(),
        isLoading: messageObject.isLoading ?? false
    };

    const updatedDoc = await withTimeout(
        chatDoc.incrementalPatch({ messages: [...chatDoc.messages, newMessage] }),
        3000
    );
    opLogger.info('Message added', { chatId, messageId: newMessage.messageId });

    return { updatedDoc, newMessageId: newMessage.messageId };
}

async function updateMessageInChatInternal(chatId, messageId, updates) {
    const opLogger = new Logger('UpdateMessage');
    opLogger.debug('Updating message', { chatId, messageId });

    if (!chatId || !messageId || !updates || !updates.text) {
        throw new AppError('INVALID_INPUT', 'Chat ID, message ID, and updates with text are required');
        }

    const collection = await ensureDbReady();
    const chatDoc = await withTimeout(collection.findOne(chatId).exec(), 3000);
        if (!chatDoc) {
        throw new AppError('NOT_FOUND', `Chat session ${chatId} not found`);
        }

    let messageFound = false;
    const updatedDoc = await withTimeout(
        chatDoc.incrementalModify((docData) => {
            const messageIndex = docData.messages.findIndex(m => m.messageId === messageId);
            if (messageIndex === -1) return docData;
            messageFound = true;
                const currentMessage = docData.messages[messageIndex];
            docData.messages[messageIndex] = {
                ...currentMessage,
                ...updates,
                text: sanitizeInput(updates.text),
                messageId: currentMessage.messageId
            };
            return docData;
        }),
        3000
    );

    if (!messageFound) {
        throw new AppError('NOT_FOUND', `Message ${messageId} not found in chat ${chatId}`);
    }

    opLogger.info('Message updated', { chatId, messageId });
    await publishSessionUpdateNotificationInternal(chatId);
    return updatedDoc;
        }
        
async function deleteMessageFromChatInternal(sessionId, messageId) {
    const opLogger = new Logger('DeleteMessage');
    opLogger.debug('Deleting message', { sessionId, messageId });

    if (!sessionId || !messageId) {
        throw new AppError('INVALID_INPUT', 'Session ID and message ID are required');
    }

    const collection = await ensureDbReady();
    const sessionDoc = await withTimeout(collection.findOne(sessionId).exec(), 3000);
    if (!sessionDoc) {
        throw new AppError('NOT_FOUND', `Session ${sessionId} not found`);
    }

    const initialLength = sessionDoc.messages.length;
    const updatedMessages = sessionDoc.messages.filter(msg => msg.messageId !== messageId);
    if (updatedMessages.length === initialLength) {
        opLogger.info('Message not found', { sessionId, messageId });
        return { updatedDoc: sessionDoc, deleted: false };
    }

    const updatedDoc = await withTimeout(
        sessionDoc.incrementalPatch({ messages: updatedMessages }),
        3000
    );
    opLogger.info('Message deleted', { sessionId, messageId });

    await publishSessionUpdateNotificationInternal(sessionId);
    return { updatedDoc, deleted: true };
}

async function updateSessionStatusInternal(sessionId, newStatus) {
    const opLogger = new Logger('UpdateStatus');
    opLogger.debug('Updating status', { sessionId, newStatus });

    const validStatuses = ['idle', 'processing', 'complete', 'error'];
    if (!sessionId || !validStatuses.includes(newStatus)) {
        throw new AppError('INVALID_INPUT', `Invalid session ID or status: ${newStatus}`);
        }

    const collection = await ensureDbReady();
    const chatDoc = await withTimeout(collection.findOne(sessionId).exec(), 3000);
    if (!chatDoc) {
        throw new AppError('NOT_FOUND', `Session ${sessionId} not found`);
    }

    const updatedDoc = await withTimeout(
        chatDoc.incrementalPatch({ status: newStatus }),
        3000
    );
    opLogger.info('Status updated', { sessionId, newStatus });

    await publishSessionUpdateNotificationInternal(sessionId);
    return updatedDoc;
}

async function toggleItemStarredInternal(itemId) {
    const opLogger = new Logger('ToggleStar');
    opLogger.debug('Toggling starred status', { itemId });

    if (!itemId) {
        throw new AppError('INVALID_INPUT', 'Item ID is required');
    }

    const collection = await ensureDbReady();
    const entryDoc = await withTimeout(collection.findOne(itemId).exec(), 3000);
        if (!entryDoc) {
        throw new AppError('NOT_FOUND', `Item ${itemId} not found`);
    }

    const currentStarredStatus = entryDoc.get('isStarred') || false;
    const updatedDoc = await withTimeout(
        entryDoc.incrementalPatch({ isStarred: !currentStarredStatus }),
        3000
    );
    opLogger.info('Starred status toggled', { itemId, isStarred: !currentStarredStatus });

    await publishSessionUpdateNotificationInternal(itemId);
    return updatedDoc;
}

async function deleteHistoryItemInternal(itemId) {
    const opLogger = new Logger('DeleteHistory');
    opLogger.debug('Deleting history item', { itemId });

    if (!itemId) {
        throw new AppError('INVALID_INPUT', 'Item ID is required');
    }

    const collection = await ensureDbReady();
    const entryDoc = await withTimeout(collection.findOne(itemId).exec(), 3000);
    if (!entryDoc) {
        opLogger.info('Item not found', { itemId });
        return false;
    }

    await withTimeout(entryDoc.remove(), 3000);
    opLogger.info('Item deleted', { itemId });

    await publishSessionUpdateNotificationInternal(itemId);
    return true;
}

async function renameHistoryItemInternal(itemId, newTitle) {
    const opLogger = new Logger('RenameHistory');
    opLogger.debug('Renaming history item', { itemId, newTitle });

    if (!itemId || !newTitle) {
        throw new AppError('INVALID_INPUT', 'Item ID and new title are required');
        }

    const collection = await ensureDbReady();
    const entryDoc = await withTimeout(collection.findOne(itemId).exec(), 3000);
    if (!entryDoc) {
        throw new AppError('NOT_FOUND', `Item ${itemId} not found`);
    }

    const updatedDoc = await withTimeout(
        entryDoc.incrementalPatch({ title: sanitizeInput(newTitle) }),
        3000
    );
    opLogger.info('Item renamed', { itemId, newTitle });

    await publishSessionUpdateNotificationInternal(itemId);
    return updatedDoc;
}

async function getAllSessionsInternal() {
    const opLogger = new Logger('GetAllSessions');
    opLogger.debug('Getting all sessions');

    const collection = await ensureDbReady();
    const sessionsDocs = await withTimeout(
        collection.find().sort({ timestamp: 'desc' }).exec(),
        5000
    );
    
    const plainSessions = sessionsDocs.map(doc => doc.toJSON());

    opLogger.info('Retrieved sessions', { count: plainSessions.length });

    return plainSessions; 
}

async function getStarredSessionsInternal() {
    const opLogger = new Logger('GetStarredSessions');
    opLogger.debug('Getting starred sessions');

    const collection = await ensureDbReady();
    const sessions = await withTimeout(
        collection.find({ selector: { isStarred: true } }).sort({ timestamp: 'desc' }).exec(),
        5000
    );
    opLogger.info('Retrieved starred sessions', { count: sessions.length });

    return sessions;
    }


async function publishSessionUpdateNotificationInternal(sessionId, updateType = 'update') { 
    const opLogger = new Logger('SessionUpdate');
    opLogger.debug(`Attempting to publish session update for ${sessionId}, type: ${updateType}`);
    try {
        await ensureDbReady();

        const updatedSessionDoc = await getChatSessionByIdInternal(sessionId);

        if (!updatedSessionDoc) {
            opLogger.error('Session not found after update, cannot publish notification', { sessionId });
            return; 
        }

        const updatedSessionData = updatedSessionDoc.toJSON ? updatedSessionDoc.toJSON() : updatedSessionDoc;
        
        opLogger.info(`Publishing session update notification for ${sessionId}`); 
        
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
            _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_SESSION_UPDATED_NOTIFICATION, 
            new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbSessionUpdatedNotification(sessionId, updatedSessionData, updateType)
        );
        opLogger.debug('Session update published', { sessionId, updateType });
    } catch (error) {
        opLogger.error('Failed to publish session update', { sessionId, error });
    }
}

async function handleDbCreateSessionRequest(event) {
    const opLogger = new Logger('CreateSessionHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling session creation', { requestId });

    try {
        if (!event?.requestId || !event?.payload?.initialMessage || !event.payload.initialMessage.text) {
            throw new AppError('INVALID_INPUT', 'Missing requestId, initialMessage, or message text');
        }

        const newSessionDoc = await withTimeout(createChatSessionInternal(event.payload.initialMessage), 5000);
        if (!newSessionDoc?.id) {
            throw new AppError('INVALID_DOCUMENT', 'Invalid session document returned');
        }

        await withTimeout(Promise.all([
            _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_MESSAGES_UPDATED_NOTIFICATION,
                new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbMessagesUpdatedNotification(newSessionDoc.id, newSessionDoc.messages)
            ),
            _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_STATUS_UPDATED_NOTIFICATION,
                new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbStatusUpdatedNotification(newSessionDoc.id, newSessionDoc.status)
            )
        ]), 3000);

        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbCreateSessionResponse(requestId, true, newSessionDoc.id);
        console.log(`[Database:${opLogger.module}] PRE-PUBLISH Check (Success Path): ReqID ${requestId}, Response Success: ${response?.success}, Response Type: ${response?.type}`);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Session created successfully', { requestId, sessionId: newSessionDoc.id });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to create session', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbCreateSessionResponse(requestId, false, null, appError);
        console.log(`[Database:${opLogger.module}] PRE-PUBLISH Check (Error Path): ReqID ${requestId}, Response Success: ${response?.success}, Response Type: ${response?.type}`);
        try {
             await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        } catch (publishError) {
             opLogger.error('FATAL: Failed even to publish error response!', { requestId, publishError });
        }
        opLogger.error('Session creation failed', { requestId, error: appError });
    }
}

async function handleDbGetSessionRequest(event) {
    const opLogger = new Logger('GetSessionHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling get session', { requestId });

    try {
        if (!event?.payload?.sessionId) {
            throw new AppError('INVALID_INPUT', 'Session ID is required');
        }

        const doc = await withTimeout(getChatSessionByIdInternal(event.payload.sessionId), 5000);
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetSessionResponse(requestId, true, doc ? doc.toJSON() : null);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Session retrieved', { requestId, sessionId: event.payload.sessionId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to get session', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetSessionResponse(requestId, false, null, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Get session failed', { requestId, error: appError });
    }
}

async function handleDbAddMessageRequest(event) {
    const opLogger = new Logger('AddMessageHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling add message', { requestId });

    try {
        if (!event?.payload?.sessionId || !event?.payload?.messageObject || !event.payload.messageObject.text) {
            throw new AppError('INVALID_INPUT', 'Session ID and message with text are required');
        }

        const { updatedDoc, newMessageId } = await withTimeout(
            addMessageToChatInternal(event.payload.sessionId, event.payload.messageObject),
            5000
        );

        const plainMessages = updatedDoc.messages.map(m => m.toJSON ? m.toJSON() : m); // Ensure plain messages
        await withTimeout(
            _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_MESSAGES_UPDATED_NOTIFICATION,
                new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbMessagesUpdatedNotification(updatedDoc.id, plainMessages)
            ),
            3000
        );

        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbAddMessageResponse(requestId, true, newMessageId);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Message added', { requestId, sessionId: event.payload.sessionId, messageId: newMessageId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to add message', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbAddMessageResponse(requestId, false, null, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Add message failed', { requestId, error: appError });
    }
}

async function handleDbUpdateMessageRequest(event) {
    const opLogger = new Logger('UpdateMessageHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling update message', { requestId });

    try {
        if (!event?.payload?.sessionId || !event?.payload?.messageId || !event?.payload?.updates || !event.payload.updates.text) {
            throw new AppError('INVALID_INPUT', 'Session ID, message ID, and updates with text are required');
        }

        const updatedDoc = await withTimeout(
            updateMessageInChatInternal(event.payload.sessionId, event.payload.messageId, event.payload.updates),
            5000
        );
        await withTimeout(
            _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_MESSAGES_UPDATED_NOTIFICATION,
                new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbMessagesUpdatedNotification(updatedDoc.id, updatedDoc.messages)
            ),
            3000
        );
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbUpdateMessageResponse(requestId, true);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Message updated', { requestId, sessionId: event.payload.sessionId, messageId: event.payload.messageId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to update message', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbUpdateMessageResponse(requestId, false, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Update message failed', { requestId, error: appError });
    }
}

async function handleDbDeleteMessageRequest(event) {
    const opLogger = new Logger('DeleteMessageHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling delete message', { requestId });

    try {
        if (!event?.payload?.sessionId || !event?.payload?.messageId) {
            throw new AppError('INVALID_INPUT', 'Session ID and message ID are required');
        }

        const { updatedDoc, deleted } = await withTimeout(
            deleteMessageFromChatInternal(event.payload.sessionId, event.payload.messageId),
            5000
        );
        if (deleted) {
            await withTimeout(
                _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                    _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_MESSAGES_UPDATED_NOTIFICATION,
                    new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbMessagesUpdatedNotification(updatedDoc.id, updatedDoc.messages)
                ),
                3000
            );
        }
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbDeleteMessageResponse(requestId, true);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Message deleted', { requestId, sessionId: event.payload.sessionId, messageId: event.payload.messageId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to delete message', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbDeleteMessageResponse(requestId, false, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Delete message failed', { requestId, error: appError });
    }
}

async function handleDbUpdateStatusRequest(event) {
    const opLogger = new Logger('UpdateStatusHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling update status', { requestId });

    try {
        if (!event?.payload?.sessionId || !event?.payload?.status) {
            throw new AppError('INVALID_INPUT', 'Session ID and status are required');
        }

        const updatedDoc = await withTimeout(
            updateSessionStatusInternal(event.payload.sessionId, event.payload.status),
            5000
        );
        await withTimeout(
            _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_STATUS_UPDATED_NOTIFICATION,
                new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbStatusUpdatedNotification(updatedDoc.id, updatedDoc.status)
            ),
            3000
        );
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbUpdateStatusResponse(requestId, true);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Status updated', { requestId, sessionId: event.payload.sessionId, status: event.payload.status });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to update status', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbUpdateStatusResponse(requestId, false, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Update status failed', { requestId, error: appError });
    try {
            await withTimeout(
                _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(
                    _events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_STATUS_UPDATED_NOTIFICATION,
                    new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbStatusUpdatedNotification(event.payload.sessionId, 'error')
                ),
                3000
            );
        } catch (notificationError) {
            opLogger.error('Failed to publish error status notification', { requestId, error: notificationError });
        }
    }
}

async function handleDbToggleStarRequest(event) {
    const opLogger = new Logger('ToggleStarHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling toggle star', { requestId });

    try {
        if (!event?.payload?.sessionId) {
            throw new AppError('INVALID_INPUT', 'Session ID is required');
        }

        const updatedDoc = await withTimeout(toggleItemStarredInternal(event.payload.sessionId), 5000);
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbToggleStarResponse(requestId, true, updatedDoc.toJSON());
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Star toggled', { requestId, sessionId: event.payload.sessionId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to toggle star', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbToggleStarResponse(requestId, false, null, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Toggle star failed', { requestId, error: appError });
    }
}

async function handleDbGetAllSessionsRequest(event) {
    const opLogger = new Logger('GetAllSessionsHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling get all sessions', { requestId });

    try {
        const sessionsRaw = await withTimeout(getAllSessionsInternal(), 5000);        
        const sortedSessions = sessionsRaw.sort((a, b) => b.timestamp - a.timestamp); 

        opLogger.debug('Using plain sessions directly', { count: sortedSessions.length });
        
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetAllSessionsResponse(requestId, true, sortedSessions);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Sessions retrieved', { requestId, count: sortedSessions.length });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to get all sessions', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetAllSessionsResponse(requestId, false, null, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Get all sessions failed', { requestId, error: appError });
    }
}

async function handleDbGetStarredSessionsRequest(event) {
    const opLogger = new Logger('GetStarredSessionsHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling get starred sessions', { requestId });

    try {
        const sessionsRaw = await withTimeout(getStarredSessionsInternal(), 5000);
        const starredSessions = sessionsRaw.map(s => ({
            sessionId: s.id,
            name: s.title,
            lastUpdated: s.timestamp,
            isStarred: s.isStarred
        })).sort((a, b) => b.lastUpdated - a.lastUpdated);

        opLogger.debug('Retrieved starred sessions', { count: starredSessions.length });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetStarredSessionsResponse(requestId, true, starredSessions);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Starred sessions retrieved', { requestId, count: starredSessions.length });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to get starred sessions', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetStarredSessionsResponse(requestId, false, null, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Get starred sessions failed', { requestId, error: appError });
    }
}

async function handleDbDeleteSessionRequest(event) {
    const opLogger = new Logger('DeleteSessionHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling delete session', { requestId });

    try {
        if (!event?.payload?.sessionId) {
            throw new AppError('INVALID_INPUT', 'Session ID is required');
        }

        const deleted = await withTimeout(deleteHistoryItemInternal(event.payload.sessionId), 5000);
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbDeleteSessionResponse(requestId, true);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Session deleted', { requestId, sessionId: event.payload.sessionId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to delete session', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbDeleteSessionResponse(requestId, false, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Delete session failed', { requestId, error: appError });
    }
}

async function handleDbRenameSessionRequest(event) {
    const opLogger = new Logger('RenameSessionHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    opLogger.info('Handling rename session', { requestId });

    try {
        if (!event?.payload?.sessionId || !event?.payload?.newName) {
            throw new AppError('INVALID_INPUT', 'Session ID and new name are required');
        }

        const updatedDoc = await withTimeout(
            renameHistoryItemInternal(event.payload.sessionId, event.payload.newName),
            5000
        );
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbRenameSessionResponse(requestId, true);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.info('Session renamed', { requestId, sessionId: event.payload.sessionId });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to rename session', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbRenameSessionResponse(requestId, false, appError);
        await withTimeout(_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response), 3000);
        opLogger.error('Rename session failed', { requestId, error: appError });
    }
}


async function handleDbAddLogRequest(event) {
    const opLogger = new Logger('AddLogHandler');
    try {
        if (!event?.payload?.logEntryData) {
            throw new AppError('INVALID_INPUT', 'Missing logEntryData in payload');
        }
        
        const collection = await ensureDbReady('log');
        await withTimeout(collection.insert(event.payload.logEntryData), 3000); 
        opLogger.debug('Log entry added successfully', { logId: event.payload.logEntryData.id });

    } catch (error) {
        opLogger.error('Failed to handle add log request', { requestId: event?.requestId, error });
    }
}

async function handleDbGetLogsRequest(event) {
    const opLogger = new Logger('GetLogsHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    try {
        if (!event?.payload?.filters) {
            throw new AppError('INVALID_INPUT', 'Missing filters in payload');
        }
        const logs = await getLogsInternal(event.payload.filters);
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetLogsResponse(requestId, true, logs);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response);
        opLogger.info('Log retrieval successful', { requestId, count: logs.length });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to get logs', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetLogsResponse(requestId, false, null, appError);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response); // Publish error response
        opLogger.error('Get logs failed', { requestId, error: appError });
    }
}

async function handleDbGetUniqueLogValuesRequest(event) {
    const opLogger = new Logger('GetUniqueLogValuesHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    try {
        if (!event?.payload?.fieldName) {
            throw new AppError('INVALID_INPUT', 'Missing fieldName in payload');
        }
        const values = await getUniqueLogValuesInternal(event.payload.fieldName);
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetUniqueLogValuesResponse(requestId, true, values);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response);
        opLogger.info('Unique value retrieval successful', { requestId, field: event.payload.fieldName, count: values.length });
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to get unique log values', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetUniqueLogValuesResponse(requestId, false, null, appError);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response); // Publish error response
        opLogger.error('Get unique log values failed', { requestId, error: appError });
    }
}

async function handleDbClearLogsRequest(event) {
    const opLogger = new Logger('ClearLogsHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    try {

        opLogger.info('ClearLogs request received. Performing pruning of non-current/last sessions.');
        
        const allLogSessionIds = await getAllUniqueLogSessionIdsInternal();
        const sessionsToKeep = new Set();
        if (currentExtensionSessionId) sessionsToKeep.add(currentExtensionSessionId);
        if (previousExtensionSessionId) sessionsToKeep.add(previousExtensionSessionId);
        const sessionIdsToDelete = Array.from(allLogSessionIds).filter(id => !sessionsToKeep.has(id));

        if (sessionIdsToDelete.length > 0) {
            const { deletedCount } = await clearLogsInternal(sessionIdsToDelete);
            opLogger.info(`ClearLogs request resulted in pruning ${deletedCount} logs from old sessions.`);
        } else {
             opLogger.info('ClearLogs request found no old sessions to prune.');
        }
        
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbClearLogsResponse(requestId, true);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response);
        
    } catch (error) {
        const appError = error instanceof AppError ? error : new AppError('UNKNOWN', 'Failed to clear logs', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbClearLogsResponse(requestId, false, appError);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response); // Publish error response
        opLogger.error('Clear logs failed', { requestId, error: appError });
    }
}

async function handleDbGetCurrentAndLastLogSessionIdsRequest(event) {
    const opLogger = new Logger('GetCurrentAndLastIdsHandler');
    const requestId = event?.requestId || crypto.randomUUID();
    try {
        const ids = {
             currentLogSessionId: currentExtensionSessionId,
             previousLogSessionId: previousExtensionSessionId // This might be null if it's the first run
        };
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetCurrentAndLastLogSessionIdsResponse(requestId, true, ids);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response);
        opLogger.info('Current/Last session ID retrieval successful', { requestId });
    } catch (error) { 
        const appError = new AppError('UNKNOWN', 'Failed to get current/last log session IDs', { originalError: error });
        const response = new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_1__.DbGetCurrentAndLastLogSessionIdsResponse(requestId, false, null, appError);
        await _eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.publish(response.type, response);
        opLogger.error('Get current/last log session IDs failed', { requestId, error: appError });
    }
}


_eventBus_js__WEBPACK_IMPORTED_MODULE_0__.eventBus.subscribe(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_2__.DB_INITIALIZE_REQUEST, handleInitializeRequest);
logger.info('Subscribed to DbInitializeRequest');



async function getAllUniqueLogSessionIdsInternal() {
    const opLogger = new Logger('GetUniqueLogSessionIds');
    opLogger.debug('Starting retrieval of unique session IDs...');
    const collection = await ensureDbReady('log');
    opLogger.debug('Log collection ensured ready.');

    try {
        opLogger.debug('Executing find().select(extensionSessionId).exec()...');
        const results = await collection.find().exec();
        opLogger.debug(`Found ${results.length} log documents.`);
        
        const uniqueIds = new Set(results.map(doc => doc.get('extensionSessionId')));
        opLogger.debug('Unique session IDs calculated', { count: uniqueIds.size });
        return uniqueIds; 
    } catch (error) {
        opLogger.error('Error during find().select().exec() for unique session IDs', { error });
        throw new AppError('DB_QUERY_FAILED', 'Failed to retrieve unique log session IDs', { originalError: error });
    }
}


async function clearLogsInternal(sessionIdsToDelete) {
    const opLogger = new Logger('ClearLogs');
    opLogger.info('ClearLogs request received. Performing pruning of non-current/last sessions.');
    
    const collection = await ensureDbReady('log');
    opLogger.debug('Log collection ensured ready.');

    const results = await collection.find().exec();
    opLogger.debug(`Found ${results.length} log documents.`);
    
    const filteredResults = results.filter(doc => {
        const sessionId = doc.get('extensionSessionId');
        return sessionId && !sessionIdsToDelete.includes(sessionId);
    });

    opLogger.debug(`Filtered results count: ${filteredResults.length}`);
    const deletedCount = filteredResults.length;
    await withTimeout(collection.bulkRemove(filteredResults), 3000);
    opLogger.info(`ClearLogs request resulted in pruning ${deletedCount} logs from old sessions.`);

    return { deletedCount };
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./src/background.js ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webextension-polyfill */ "./node_modules/webextension-polyfill/dist/browser-polyfill.js");
/* harmony import */ var webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webextension_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _minimaldb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./minimaldb.js */ "./src/minimaldb.js");
/* harmony import */ var _log_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log-client.js */ "./src/log-client.js");
/* harmony import */ var _eventBus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventBus.js */ "./src/eventBus.js");
/* harmony import */ var _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/dbEvents.js */ "./src/events/dbEvents.js");
/* harmony import */ var _events_eventNames_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events/eventNames.js */ "./src/events/eventNames.js");

 // Static import for service worker compatibility

const OFFSCREEN_DOCUMENT_PATH_SCRAPING = 'scrapingOffscreen.html';
const MODEL_WORKER_OFFSCREEN_PATH = 'modelLoaderWorkerOffscreen.html';






_log_client_js__WEBPACK_IMPORTED_MODULE_2__.init('Background');

_eventBus_js__WEBPACK_IMPORTED_MODULE_3__.eventBus.publish(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_5__.DB_INITIALIZE_REQUEST, new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_4__.DbInitializeRequest());

let detachedPopups = {};
let popupIdToTabId = {};

const DNR_RULE_ID_1 = 1;
const DNR_RULE_PRIORITY_1 = 1;

let modelWorkerState = 'uninitialized';
let workerScriptReadyPromise = null;
let workerScriptReadyResolver = null;
let workerScriptReadyRejecter = null;
let modelLoadPromise = null;
let modelLoadResolver = null;
let modelLoadRejecter = null;

let activeGenerations = {};

let currentLogSessionId = null;
let previousLogSessionId = null;

let lastLoggedProgress = -10;

// Log Session Management
async function initializeSessionIds() {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Initializing log session IDs...');
    currentLogSessionId = Date.now() + '-' + Math.random().toString(36).substring(2, 9);
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Current log session ID:', currentLogSessionId);
    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.set({ currentLogSessionId: currentLogSessionId });
    const { previousLogSessionId: storedPreviousId } = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.get('previousLogSessionId');
    previousLogSessionId = storedPreviousId || null;
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Previous log session ID found in storage:', previousLogSessionId);
    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.set({ previousLogSessionId: currentLogSessionId });
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Stored new previousLogSessionId for next run.');
}

// Model Worker Offscreen Communication
async function hasModelWorkerOffscreenDocument() {
    const targetUrl = webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH);
    const existingContexts = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getContexts({
        contextTypes: ['OFFSCREEN_DOCUMENT'],
        documentUrls: [targetUrl]
    });
    return existingContexts.length > 0;
}

async function setupModelWorkerOffscreenDocument() {
    if (await hasModelWorkerOffscreenDocument()) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("Model worker offscreen document already exists.");
        return;
    }
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("Creating model worker offscreen document...");
    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().offscreen.createDocument({
        url: MODEL_WORKER_OFFSCREEN_PATH,
        reasons: [(webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().offscreen).Reason.WORKERS],
        justification: 'Run model inference in a separate worker via offscreen document',
    });
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("Model worker offscreen document created.");
}

async function sendToModelWorkerOffscreen(message) {
    if (message.type !== 'init' && message.type !== 'generate' && message.type !== 'interrupt' && message.type !== 'reset') {
        if (modelWorkerState === 'uninitialized' || !(await hasModelWorkerOffscreenDocument())) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Ensuring model worker offscreen doc potentially exists before sending ${message?.type}`);
            await setupModelWorkerOffscreenDocument();
        }
    } else {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Background: Ensuring worker script is ready before sending ${message.type}...`);
        try {
            await ensureWorkerScriptIsReady();
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Background: Worker script confirmed ready. Proceeding to send ${message.type}.`);
        } catch (error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Background: Worker script failed to become ready. Cannot send ${message.type}. Error:`, error);
            modelWorkerState = 'error';
            throw new Error(`Worker script failed to initialize, cannot send ${message.type}.`);
        }
    }

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Background: Sending message type '${message?.type}' to model worker offscreen doc`);
    try {
        const contexts = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getContexts({
            contextTypes: ['OFFSCREEN_DOCUMENT'],
            documentUrls: [webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH)]
        });
        if (contexts.length > 0) {
            webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage(message);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Background: Message type '${message?.type}' sent to offscreen.`);
            return { success: true };
        } else {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Background: Could not find target offscreen document context to send ${message?.type}.`);
            throw new Error(`Target offscreen document not found.`);
        }
    } catch (error) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Background: Error sending message type '${message?.type}' to offscreen:`, error);
        modelWorkerState = 'error';
        if (message.type === 'init') {
            if (modelLoadRejecter) modelLoadRejecter(new Error(`Failed to send init message: ${error.message}`));
            modelLoadPromise = null;
        } else if (workerScriptReadyRejecter && (modelWorkerState === 'uninitialized' || modelWorkerState === 'creating_worker')) {
            workerScriptReadyRejecter(new Error(`Failed to send message early: ${error.message}`));
            workerScriptReadyPromise = null;
        }
        throw new Error(`Failed to send message to model worker offscreen: ${error.message}`);
    }
}

function ensureWorkerScriptIsReady() {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`[ensureWorkerScriptIsReady] Current state: ${modelWorkerState}`);
    if (modelWorkerState !== 'uninitialized' && modelWorkerState !== 'creating_worker') {
        if (modelWorkerState === 'error' && !workerScriptReadyPromise) {
            return Promise.reject(new Error("Worker script initialization previously failed."));
        }
        return Promise.resolve();
    }
    if (workerScriptReadyPromise) {
        return workerScriptReadyPromise;
    }

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug("[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise.");
    modelWorkerState = 'creating_worker';
    workerScriptReadyPromise = new Promise((resolve, reject) => {
        workerScriptReadyResolver = resolve;
        workerScriptReadyRejecter = reject;

        setupModelWorkerOffscreenDocument().catch(err => {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("[ensureWorkerScriptIsReady] Error setting up offscreen doc:", err);
            modelWorkerState = 'error';
            if (workerScriptReadyRejecter) workerScriptReadyRejecter(err);
            workerScriptReadyPromise = null;
        });
    });

    const scriptLoadTimeout = 30000;
    setTimeout(() => {
        if (modelWorkerState === 'creating_worker' && workerScriptReadyRejecter) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`[ensureWorkerScriptIsReady] Timeout (${scriptLoadTimeout}ms) waiting for workerScriptReady.`);
            workerScriptReadyRejecter(new Error('Timeout waiting for model worker script to load.'));
            modelWorkerState = 'error';
            workerScriptReadyPromise = null;
        }
    }, scriptLoadTimeout);

    return workerScriptReadyPromise;
}

async function loadModel(modelId) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Request to load model: ${modelId}. Current state: ${modelWorkerState}`);
    try {
        await ensureWorkerScriptIsReady();
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Worker script confirmed ready (state: ${modelWorkerState}). Proceeding with model load.`);
    } catch (err) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Failed to ensure worker script readiness:", err);
        throw new Error(`Failed to ensure worker script readiness: ${err.message}`);
    }

    if (modelWorkerState !== 'worker_script_ready' && modelWorkerState !== 'idle' && modelWorkerState !== 'error') {
        const errorMsg = `Cannot load model '${modelId}'. Worker state is '${modelWorkerState}', expected 'worker_script_ready', 'idle', or 'error'.`;
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("State check failed loading model:", errorMsg);
        throw new Error(errorMsg);
    }

    if (!modelId) {
        return Promise.reject(new Error("Cannot load model: Model ID not provided."));
    }

    if (modelWorkerState === 'model_ready') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Model appears ready. Assuming it's ${modelId}.`);
        return Promise.resolve();
    }
    if (modelWorkerState === 'loading_model' && modelLoadPromise) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Model is already loading. Assuming it's ${modelId}.`);
        return modelLoadPromise;
    }
    if (modelWorkerState !== 'worker_script_ready') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Cannot load model. Worker script is not ready. State:", modelWorkerState);
        return Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${modelWorkerState})`));
    }

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Worker script ready. Initiating load for model: ${modelId}.`);
    modelWorkerState = 'loading_model';
    // TODO: Store the modelId being loaded
    modelLoadPromise = new Promise((resolve, reject) => {
        modelLoadResolver = resolve;
        modelLoadRejecter = reject;

        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Attempting to send 'init' message for model: ${modelId}`);
        sendToModelWorkerOffscreen({ type: 'init', payload: { modelId: modelId } })
            .catch(err => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Failed to send 'init' message for ${modelId}:`, err);
                modelWorkerState = 'error';
                if (modelLoadRejecter) modelLoadRejecter(err);
                modelLoadPromise = null;
            });
    });

    const modelLoadTimeout = 300000;
    setTimeout(() => {
        if (modelWorkerState === 'loading_model' && modelLoadRejecter) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Timeout (${modelLoadTimeout}ms) waiting for model ${modelId} load completion.`);
            modelLoadRejecter(new Error(`Timeout waiting for model ${modelId} to load.`));
            modelWorkerState = 'error';
            modelLoadPromise = null;
        }
    }, modelLoadTimeout);

    return modelLoadPromise;
}

// Declarative Net Request Management
async function updateDeclarativeNetRequestRules() {
    const currentRules = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().declarativeNetRequest.getDynamicRules();
    const currentRuleIds = currentRules.map(rule => rule.id);

    const rulesToAdd = [
        {
            id: DNR_RULE_ID_1,
            priority: DNR_RULE_PRIORITY_1,
            action: {
                type: 'modifyHeaders',
                responseHeaders: [
                    { header: 'x-frame-options', operation: 'remove' },
                    { header: 'X-Frame-Options', operation: 'remove' },
                    { header: 'content-security-policy', operation: 'remove' },
                    { header: 'Content-Security-Policy', operation: 'remove' }
                ]
            },
            condition: {
                resourceTypes: ['main_frame'],
                urlFilter: '|http*://*/*|'
            }
        }
    ];

    const rulesToRemove = currentRuleIds.filter(id => id === DNR_RULE_ID_1);

    try {
        await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().declarativeNetRequest.updateDynamicRules({
            removeRuleIds: rulesToRemove,
            addRules: rulesToAdd
        });
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("Declarative Net Request rules updated successfully.");
    } catch (error) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Error updating Declarative Net Request rules:", error);
    }
}
updateDeclarativeNetRequestRules();

// Offscreen Document Management
async function hasOffscreenDocument(path) {
    if ((webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime).getContexts) {
        const contexts = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getContexts({
            contextTypes: ['OFFSCREEN_DOCUMENT'],
            documentUrls: [webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.getURL(path)] 
        });
        return contexts.length > 0;
    }
    return false;
}

async function setupOffscreenDocument(path, reasons, justification) {
    if (await hasOffscreenDocument(path)) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Offscreen document at ${path} already exists.`);
        return;
    }
    const filename = path.split('/').pop();
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Creating offscreen document using filename: ${filename}...`);
    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().offscreen.createDocument({
        url: filename,
        reasons: reasons,
        justification: justification,
    });
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: <<< Offscreen document ${path} CREATED successfully. Script should now load. >>>`);
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Offscreen document created successfully using ${filename}.`);
}

// Scraping Logic
async function scrapeUrlWithOffscreenIframe(url) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 3] Attempting Offscreen + iframe: ${url}`);
    const DYNAMIC_SCRIPT_ID_PREFIX = 'offscreen-scrape-';
    const DYNAMIC_SCRIPT_MESSAGE_TYPE = 'offscreenIframeResult';
    const IFRAME_LOAD_TIMEOUT = 30000;
    let dynamicScripterId = null;

    const cleanup = async (scriptIdBase) => {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 3 Cleanup] Starting cleanup for script ID base: ${scriptIdBase}`);
        if (scriptIdBase) {
            try {
                await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().scripting.unregisterContentScripts({ ids: [scriptIdBase] });
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 3 Cleanup] Unregistered script: ${scriptIdBase}`);
            } catch (error) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Stage 3 Cleanup] Failed to unregister script ${scriptIdBase}:`, error);
            }
        }
        try {
            await cleanupOffscreen(OFFSCREEN_DOCUMENT_PATH_SCRAPING);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 3 Cleanup] Sent removeIframe request to offscreen.');
        } catch (error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn('[Stage 3 Cleanup] Failed to send removeIframe request: ', error);
        }
    };

    try {
        await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH_SCRAPING, [(webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().offscreen).Reason.DOM_PARSER, (webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().offscreen).Reason.IFRAME_SCRIPTING], 'Parse HTML content and manage scraping iframes');
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 3] Sending createIframe request to offscreen...');
        const createResponse = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({
            type: 'createIframe',
            target: 'offscreen',
            url: url
        });
        if (!createResponse?.success) {
            throw new Error(`Failed to create iframe in offscreen: ${createResponse?.error || 'Unknown error'}`);
        }
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 3] Iframe creation request successful. Waiting for load and script...');
        dynamicScripterId = `${DYNAMIC_SCRIPT_ID_PREFIX}${Date.now()}`;
        await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().scripting.registerContentScripts([{
            id: dynamicScripterId,
            js: ['pageExtractor.js', 'stage2Helper.js'],
            matches: [url],
            runAt: 'document_idle',
            world: 'ISOLATED',
            allFrames: true,
            persistAcrossSessions: false
        }]);
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 3] Registered dynamic script(s): ${dynamicScripterId} (files: pageExtractor.js, stage2Helper.js)`);
        let messageListener = null;
        const scriptResponsePromise = new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Stage 3] Timeout (${IFRAME_LOAD_TIMEOUT / 1000}s) waiting for response from dynamic script.`);
                if (messageListener) {
                    webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onMessage.removeListener(messageListener);
                }
                reject(new Error('Timeout waiting for dynamic script response.'));
            }, IFRAME_LOAD_TIMEOUT);

            messageListener = (message, sender, sendResponse) => {
                if (message?.type === DYNAMIC_SCRIPT_MESSAGE_TYPE) {
                    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 3] Received response from dynamic script:', message.payload);
                    clearTimeout(timeoutId);
                    webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onMessage.removeListener(messageListener);
                    if (message.payload?.success) {
                        resolve(message.payload);
                    } else {
                        reject(new Error(message.payload?.error || 'Dynamic script reported failure.'));
                    }
                    return false;
                }
                return false;
            };
            webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onMessage.addListener(messageListener);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 3] Listener added for dynamic script response.');
        });
        const resultPayload = await scriptResponsePromise;
        await cleanup(dynamicScripterId);
        return resultPayload;
    } catch (error) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`[Stage 3] Error during Offscreen + iframe process:`, error);
        await cleanup(dynamicScripterId);
        throw new Error(`Stage 3 (Offscreen + iframe) failed: ${error.message}`);
    }
}

async function scrapeUrlWithTempTabExecuteScript(url) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] Attempting Temp Tab + executeScript: ${url}`);
    let tempTabId = null;
    const TEMP_TAB_LOAD_TIMEOUT = 30000;

    return new Promise(async (resolve, reject) => {
        const cleanupAndReject = (errorMsg, errorObj = null) => {
            const finalError = errorObj ? errorObj : new Error(errorMsg);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Stage 1 (ExecuteScript)] Cleanup & Reject: ${errorMsg}`, errorObj);
            if (tempTabId) {
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.remove(tempTabId).catch(err => _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Stage 1 (ExecuteScript)] Error removing tab ${tempTabId}: ${err.message}`));
                tempTabId = null;
            }
            reject(finalError);
        };

        try {
            const tab = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.create({ url: url, active: false });
            tempTabId = tab.id;
            if (!tempTabId) {
                cleanupAndReject('[Stage 1 (ExecuteScript)] Failed to get temporary tab ID.');
                return;
            }
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] Created temp tab ${tempTabId}.`);

            // Wait for the tab to load
            let loadTimeoutId = null;
            const loadPromise = new Promise((resolveLoad, rejectLoad) => {
                const listener = (tabIdUpdated, changeInfo, updatedTab) => {
                    if (tabIdUpdated === tempTabId && changeInfo.status === 'complete') {
                        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] Tab ${tempTabId} loaded.`);
                        if (loadTimeoutId) clearTimeout(loadTimeoutId);
                        webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.onUpdated.removeListener(listener);
                        resolveLoad();
                    }
                };
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.onUpdated.addListener(listener);
                loadTimeoutId = setTimeout(() => {
                    webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.onUpdated.removeListener(listener);
                    rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load in tab ${tempTabId}.`));
                }, TEMP_TAB_LOAD_TIMEOUT);
            });

            await loadPromise;
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] Page loaded. Injecting pageExtractor.js module into tab ${tempTabId}...`);

            // 1. Inject the PageExtractor.js script
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().scripting.executeScript({
                target: { tabId: tempTabId },
                files: ['pageExtractor.js'] 
            });
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] pageExtractor.js module INJECTED successfully into tab ${tempTabId}.`);

            // 2. Execute a function that calls the globally exposed extract method
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Stage 1 (ExecuteScript)] Executing function to call window.TabAgentPageExtractor.extract in tab ${tempTabId}...`);
            const injectionResults = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().scripting.executeScript({
                target: { tabId: tempTabId },
                func: () => { // Arrow function for lexical this, though not strictly needed here
                    if (window.TabAgentPageExtractor && typeof window.TabAgentPageExtractor.extract === 'function') {
                        try {
                            return window.TabAgentPageExtractor.extract(document);
                        } catch (e) {
                            console.error('[In-Tab] Error during execution of PageExtractor.extract:', e);
                            return { error: `Error in PageExtractor.extract: ${e.message} (Stack: ${e.stack})` };
                        }
                    } else {
                        console.error('[In-Tab] TabAgentPageExtractor or its extract function not found on window.');
                        return { error: 'TabAgentPageExtractor.extract function not found on window.' };
                    }
                }
            });

            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 1 (ExecuteScript)] Raw results from executeScript func:', injectionResults);

            if (!injectionResults || injectionResults.length === 0 || !injectionResults[0].result) {
                cleanupAndReject('[Stage 1 (ExecuteScript)] No result returned from executeScript func.', injectionResults && injectionResults[0] ? injectionResults[0].error : null);
                return;
            }

            const scriptResult = injectionResults[0].result;

            if (scriptResult && scriptResult.error) {
                cleanupAndReject(`[Stage 1 (ExecuteScript)] Script execution reported an error: ${scriptResult.error}`, scriptResult);
                return;
            }
            
            if (scriptResult && typeof scriptResult === 'object') {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Stage 1 (ExecuteScript)] pageExtractor.js module execution succeeded (returned object).');
                resolve(scriptResult);
            } else {
                cleanupAndReject('[Stage 1 (ExecuteScript)] pageExtractor.js module returned unexpected non-object/error type.', scriptResult);
            }

        } catch (error) {
            cleanupAndReject(`[Stage 1 (ExecuteScript)] Error: ${error.message}`, error);
        } finally {
            if (tempTabId) { // Ensure tab is closed if something went wrong before explicit resolve/reject
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.remove(tempTabId).catch(err => _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Stage 1 (ExecuteScript)] Error removing tab ${tempTabId} in final catch: ${err.message}`));
            }
        }
    });
}


async function scrapeUrlMultiStage(url, chatId, messageId) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Scraping Orchestrator: Starting for ${url}. ChatID: ${chatId}, MessageID: ${messageId}`);
    const sendStageResult = (stageResult) => {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Orchestrator] Sending STAGE_SCRAPE_RESULT for Stage ${stageResult.stage}, ChatID: ${chatId}, Success: ${stageResult.success}`);
        webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({
            type: 'STAGE_SCRAPE_RESULT',
            payload: stageResult
        }).catch(e => _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Orchestrator] Failed to send result for Stage ${stageResult.stage}:`, e));
    };


    try {
        try {
            const executeScriptResult = await scrapeUrlWithTempTabExecuteScript(url);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Orchestrator Log] Stage 1 (Temp Tab + executeScript) Succeeded for ${url}.`);
            const stage1SuccessPayload = {
                stage: 1, success: true, chatId: chatId, messageId: messageId,
                method: 'tempTabExecuteScript', url: url,
                length: executeScriptResult?.text?.length || 0,
                ...executeScriptResult
            };
            sendStageResult(stage1SuccessPayload);
            return; // Stop after successful Stage 1
        } catch (stage1Error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Orchestrator Log] Stage 1 (Temp Tab + executeScript) Failed for ${url}: ${stage1Error.message}`);
            sendStageResult({ stage: 1, success: false, chatId: chatId, messageId: messageId, method: 'tempTabExecuteScript', error: stage1Error.message });
            // Do not proceed to other stages if Stage 1 fails, as per new plan
            return; 
        }

        // All other stages (2, 3, 4) have been removed.
        // If Stage 1 fails, the orchestrator will have already returned.
        // This part of the code should ideally not be reached if Stage 1 was the only one.
        // However, to be safe and explicit:
        logClient.logInfo("[Orchestrator Log] No successful scraping stage completed (should have exited after Stage 1 attempt).");

    } finally {
        // No specific cleanup for scraping stages needed here anymore.
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Scraping Orchestrator] Finished processing for ${url}.`);
    }
}

// Google Drive Integration
async function getDriveToken() {
    return new Promise((resolve, reject) => {
        webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().identity.getAuthToken({ interactive: true }, (token) => {
            if ((webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime).lastError) {
                reject(new Error((webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime).lastError.message));
            } else {
                resolve(token);
            }
        });
    });
}

async function fetchDriveFileList(token, folderId = 'root') {
    const fields = "files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)";
    const query = `'${folderId}' in parents and trashed=false`;
    const pageSize = 100;
    const orderBy = 'folder,modifiedTime desc';
    const url = `https://www.googleapis.com/drive/v3/files?${new URLSearchParams({
        pageSize: pageSize.toString(),
        q: query,
        fields: fields,
        orderBy: orderBy
    })}`;
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Fetching Drive list for folder '${folderId}': ${url}`);
    const response = await fetch(url, {
        headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/json'
        }
    });
    if (!response.ok) {
        const errorData = await response.text();
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Background: Drive API files.list error (Folder: ${folderId}):`, response.status, errorData);
        if (response.status === 404) {
            throw new Error(`Folder with ID '${folderId}' not found or access denied.`);
        }
        throw new Error(`Drive API Error ${response.status} (Folder: ${folderId}): ${errorData || response.statusText}`);
    }
    const data = await response.json();
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Background: Drive API files.list success (Folder: ${folderId}). Found ${data.files?.length || 0} items.`);
    return data.files || [];
}

async function fetchDriveFileContent(token, fileId) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`Background: fetchDriveFileContent not implemented yet for fileId: ${fileId}`);
    return `(Content fetch not implemented for ${fileId})`;
}

// Message Forwarding
async function forwardMessageToSidePanelOrPopup(message, originalSender) {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Attempting to forward message type '${message?.type}' from worker.`);
    for (const tabId in detachedPopups) {
        const popupId = detachedPopups[tabId];
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Forwarding message to detached popup ID: ${popupId} (original tab: ${tabId})`);
        try {
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().windows.get(popupId);
            webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage(message);
        } catch (error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`Error sending to detached popup ID ${popupId}:`, error.message);
            if (error.message.includes("No window with id")) {
                delete detachedPopups[tabId];
                delete popupIdToTabId[popupId];
            }
        }
    }

    const tabs = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.query({ status: 'complete' });
    for (const tab of tabs) {
        if (detachedPopups[tab.id]) continue;
        try {
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.sendMessage(tab.id, message);
        } catch (error) {
            if (!error.message.includes('Could not establish connection') && !error.message.includes('Receiving end does not exist')) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`Error forwarding message to tab ${tab.id}:`, error.message);
            }
        }
    }
}

// Extension Lifecycle Listeners
webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onInstalled.addListener(async (details) => {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('onInstalled event fired. Reason:', details.reason);
    await initializeSessionIds();

    webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().sidePanel
        .setPanelBehavior({ openPanelOnActionClick: true })
        .catch((error) => _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError('Error setting side panel behavior:', error));
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Side panel behavior set.');

    webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.get().then((items) => {
        const keysToRemove = Object.keys(items).filter(key => key.startsWith('detachedState_'));
        if (keysToRemove.length > 0) {
            webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.remove(keysToRemove).then(() => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Cleaned up old storage keys on install/update.');
            }).catch(err => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError('Error removing old storage keys:', err);
            });
        }
    }).catch(err => {
         _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError('Error getting storage items for cleanup:', err);
    });

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Triggering DB Initialization from onInstalled.');
    _eventBus_js__WEBPACK_IMPORTED_MODULE_3__.eventBus.publish(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_5__.DB_INITIALIZE_REQUEST, new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_4__.DbInitializeRequest());

    ensureWorkerScriptIsReady().catch(err => {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Initial worker script readiness check failed after install:", err);
    });
});

webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onStartup.addListener(async () => {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('onStartup event fired.');
    await initializeSessionIds();

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('Triggering DB Initialization from onStartup (may be redundant).');
    _eventBus_js__WEBPACK_IMPORTED_MODULE_3__.eventBus.publish(_events_eventNames_js__WEBPACK_IMPORTED_MODULE_5__.DB_INITIALIZE_REQUEST, new _events_dbEvents_js__WEBPACK_IMPORTED_MODULE_4__.DbInitializeRequest());

    if (modelWorkerState === 'uninitialized') {
        ensureWorkerScriptIsReady().catch(err => {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Worker script readiness check failed on startup:", err);
        });
    }
});

webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().action.onClicked.addListener(async (tab) => {
    if (!tab.id) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Action Clicked: Missing tab ID.");
        return;
    }
    const tabId = tab.id;
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Action clicked for tab ${tabId}`);
    const existingPopupId = detachedPopups[tabId];
    if (existingPopupId) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Popup ${existingPopupId} exists for tab ${tabId}. Attempting to close popup.`);
        try {
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().windows.remove(existingPopupId);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Closed popup window ${existingPopupId} via action click.`);
        } catch (error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`Failed to close popup ${existingPopupId} via action click, maybe already closed?`, error);
            if (popupIdToTabId[existingPopupId]) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Force cleaning maps and storage for tab ${tabId} after failed close.`);
                delete detachedPopups[tabId];
                delete popupIdToTabId[existingPopupId];
                try {
                    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.remove(`detachedState_${tabId}`);
                    await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().sidePanel.setOptions({ tabId: tabId, enabled: true });
                } catch (cleanupError) {
                    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Error during defensive cleanup:", cleanupError);
                }
            }
        }
    } else {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`No popup exists for tab ${tabId}. Default side panel opening behavior should trigger.`);
    }
});

webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().windows.onRemoved.addListener(async (windowId) => {
    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Window removed: ${windowId}`);
    const tabId = popupIdToTabId[windowId];
    if (tabId) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Popup window ${windowId} for tab ${tabId} was closed.`);
        delete detachedPopups[tabId];
        delete popupIdToTabId[windowId];
        try {
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.remove(`detachedState_${tabId}`);
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Removed detached state from storage for tab ${tabId}`);
            await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().sidePanel.setOptions({ tabId: tabId, enabled: true });
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Re-enabled side panel for tab ${tabId} after popup closed.`);
        } catch (error) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Error cleaning up storage or re-enabling side panel for tab ${tabId} on popup close:`, error);
        }
    } else {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Window ${windowId} closed, but it wasn't a tracked popup.`);
    }
});

// Message Handling
webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.onMessage.addListener((message, sender, sendResponse) => {
    const { type, payload } = message;
    let isResponseAsync = false;

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Received message type '${type}' from`, sender.tab ? `tab ${sender.tab.id}` : sender.url || sender.id);

    const workerMessageTypes = [
        'workerScriptReady',
        'workerReady',
        'loadingStatus',
        'generationStatus',
        'generationUpdate',
        'generationComplete',
        'generationError',
        'resetComplete',
        'error'
    ];

    if (workerMessageTypes.includes(type)) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Handling message from worker: ${type}`);
        let uiUpdatePayload = null;
        switch (type) {
            case 'workerScriptReady':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Worker SCRIPT is ready!");
                modelWorkerState = 'worker_script_ready';
                if (workerScriptReadyResolver) {
                    workerScriptReadyResolver();
                    workerScriptReadyPromise = null;
                }
                uiUpdatePayload = { modelStatus: 'script_ready' };
                break;
            case 'workerReady':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Worker MODEL is ready! Model:", payload?.model);
                modelWorkerState = 'model_ready';
                if (modelLoadResolver) {
                    modelLoadResolver();
                    modelLoadPromise = null;
                }
                uiUpdatePayload = { modelStatus: 'model_ready', model: payload?.model };
                if (workerScriptReadyResolver) {
                    workerScriptReadyResolver();
                    workerScriptReadyPromise = null;
                }
                break;
            case 'loadingStatus':
                if (payload?.status === 'progress' && payload?.progress) {
                    const currentProgress = Math.floor(payload.progress);
                    if (currentProgress >= lastLoggedProgress + 10) {
                        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Worker loading status (progress):", payload);
                        lastLoggedProgress = currentProgress;
                    }
                } else {
                    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Worker loading status (other):", payload);
                    lastLoggedProgress = -10;
                }
                if (modelWorkerState !== 'loading_model') {
                    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Background] Received loadingStatus in unexpected state: ${modelWorkerState}`);
                    modelWorkerState = 'loading_model';
                }
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({ type: 'uiLoadingStatusUpdate', payload: payload }).catch(err => {
                    if (err.message !== "Could not establish connection. Receiving end does not exist.") {
                        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn("[Background] Error sending loading status to UI:", err.message);
                    }
                });
                break;
            case 'generationStatus':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Background] Generation status: ${payload?.status}`);
                if (payload?.status === 'generating') modelWorkerState = 'generating';
                else if (payload?.status === 'interrupted') modelWorkerState = 'model_ready';
                break;
            case 'generationUpdate':
                if (modelWorkerState !== 'generating') {
                    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Background] Received generationUpdate in unexpected state: ${modelWorkerState}`);
                }
                modelWorkerState = 'generating';
                break;
            case 'generationComplete':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Generation complete.");
                modelWorkerState = 'model_ready';
                break;
            case 'generationError':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("[Background] Generation error from worker:", payload);
                modelWorkerState = 'error';
                break;
            case 'resetComplete':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Worker reset complete.");
                modelWorkerState = 'model_ready';
                break;
            case 'error':
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("[Background] Received generic error from worker/offscreen:", payload);
                const previousState = modelWorkerState;
                modelWorkerState = 'error';
                if (previousState === 'creating_worker' && workerScriptReadyRejecter) {
                    workerScriptReadyRejecter(new Error(payload || 'Generic error during script init'));
                    workerScriptReadyPromise = null;
                } else if (previousState === 'loading_model' && modelLoadRejecter) {
                    modelLoadRejecter(new Error(payload || 'Generic error during model load'));
                    modelLoadPromise = null;
                }
                uiUpdatePayload = { modelStatus: 'error', error: payload };
                break;
        }
        
        if (uiUpdatePayload) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`[Background] Sending uiUpdate to tabs:`, uiUpdatePayload);
            webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.query({}).then(tabs => {
                tabs.forEach(tab => {
                    if (tab.id) {
                        webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().tabs.sendMessage(tab.id, { type: 'uiUpdate', payload: uiUpdatePayload })
                            .catch(err => { 
                                if (!err.message.includes('Could not establish connection') && !err.message.includes('Receiving end does not exist')) {
                                     _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`[Background] Error sending uiUpdate to tab ${tab.id}:`, err.message);
                                }
                            });
                    }
                });
            }).catch(err => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError('[Background] Error querying tabs to send uiUpdate:', err);
            });
        }
        
        forwardMessageToSidePanelOrPopup(message, sender);
        return false;
    }

    if (type === 'loadModel') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Received 'loadModel' request from sender:`, sender);
        const modelId = payload?.modelId;
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Received 'loadModel' request from UI for model: ${modelId}.`);
        if (!modelId) {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("[Background] 'loadModel' request missing modelId.");
            sendResponse({ success: false, error: "Model ID not provided in request." });
            return false;
        }

        isResponseAsync = true;
        loadModel(modelId)
            .then(() => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`loadModel(${modelId}) promise resolved successfully.`);
                sendResponse({ success: true, message: `Model loading initiated or already complete for ${modelId}.` });
            })
            .catch(error => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`loadModel(${modelId}) failed:`, error);
                sendResponse({ success: false, error: error.message });
            });
        return isResponseAsync;
    }

    if (type === 'sendChatMessage') {
        isResponseAsync = true;
        const { chatId, messages, options, messageId } = payload;
        const correlationId = messageId || chatId;

        if (modelWorkerState !== 'model_ready') {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Cannot send chat message. Model state is ${modelWorkerState}, not 'model_ready'.`);
            sendResponse({ success: false, error: `Model not ready (state: ${modelWorkerState}). Please load a model first.` });
            return false;
        }

        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Model ready, sending generate request for ${correlationId}`);
        sendToModelWorkerOffscreen({
            type: 'generate',
            payload: {
                messages: messages,
                max_new_tokens: options?.max_new_tokens,
                temperature: options?.temperature,
                top_k: options?.top_k,
                correlationId: correlationId
            }
        })
        .then(sendResult => {
            if (!sendResult.success) throw new Error("Failed to send generate message initially.");
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Generate request sent for ${correlationId}. Waiting for worker responses.`);
            sendResponse({ success: true, message: "Generation request forwarded to worker."});
        })
        .catch(error => {
            _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Error processing sendChatMessage for ${correlationId}:`, error);
            if (modelWorkerState === 'generating') modelWorkerState = 'model_ready';
            sendResponse({ success: false, error: error.message });
        });

        return isResponseAsync;
    }

    if (type === 'interruptGeneration') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Received interrupt request from UI.");
        ensureWorkerScriptIsReady()
            .then(() => sendToModelWorkerOffscreen({ type: 'interrupt' }))
            .then(() => sendResponse({ success: true }))
            .catch(err => sendResponse({ success: false, error: err.message }));
        isResponseAsync = true;
        return isResponseAsync;
    }

    if (type === 'resetWorker') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background] Received reset request from UI.");
        ensureWorkerScriptIsReady()
            .then(() => sendToModelWorkerOffscreen({ type: 'reset' }))
            .then(() => sendResponse({ success: true }))
            .catch(err => sendResponse({ success: false, error: err.message }));
        isResponseAsync = true;
        return isResponseAsync;
    }

    if (type === 'getModelWorkerState') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Handling 'getModelWorkerState' request. Current state: ${modelWorkerState}`);
        sendResponse({ success: true, state: modelWorkerState });
        return false;
    }

    if (type === 'scrapeRequest') {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Handling 'scrapeRequest' request. Scraping URL: ${payload?.url}`);
        isResponseAsync = true;
        scrapeUrlMultiStage(payload?.url, payload?.chatId, payload?.messageId)
            .then(() => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`scrapeRequest(${payload?.url}) promise resolved successfully.`);
                sendResponse({ success: true, message: `Scraping orchestrator started for ${payload?.url}.` });
            })
            .catch(error => {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`scrapeRequest(${payload?.url}) failed:`, error);
                sendResponse({ success: false, error: error.message });
            });
        return isResponseAsync;
    }

    if (type === 'getDriveFileList') {
        const receivedFolderId = message.folderId;
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Handling 'getDriveFileList' for folder: ${receivedFolderId}`);
        isResponseAsync = true;
        (async () => {
            try {
                const token = await getDriveToken();
                const files = await fetchDriveFileList(token, receivedFolderId);
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`Successfully fetched ${files?.length || 0} files/folders.`);

                // Send file list via separate sendMessage
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Background] Sending driveFileListData...');
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({
                    type: 'driveFileListData',
                    success: true,
                    files: files,
                    folderId: receivedFolderId
                }).catch(err => {
                     _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn('[Background] Failed to send driveFileListData:', err?.message);
                     webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({ type: 'driveFileListData', success: false, error: `Failed to send data: ${err?.message}` , folderId: receivedFolderId });
                });

                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Background] sendResponse for driveFileListResponse skipped (using separate message).');

            } catch (error) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Error handling getDriveFileList:", error);
                // Send error via separate message too
                webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().runtime.sendMessage({
                     type: 'driveFileListData',
                     success: false,
                     error: error.message,
                     folderId: receivedFolderId
                 }).catch(err => {
                     _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn('[Background] Failed to send driveFileListData error message:', err?.message);
                 });
                 _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('[Background] sendResponse for driveFileListResponse error skipped (using separate message).');
            }
        })();
        return isResponseAsync;
    }

    if (type.startsWith('db:')) {
        _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logDebug(`Forwarding DB request of type '${type}' to event bus.`);
        _eventBus_js__WEBPACK_IMPORTED_MODULE_3__.eventBus.publish(type, message);
        return false;
    }

    if (type === 'getLogSessions') {
        isResponseAsync = true;
        (async () => {
            try {
                const { logSessions: sessions } = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.get('logSessions');
                sendResponse({ success: true, sessions: sessions || [] });
            } catch (err) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError("Error fetching log sessions:", err);
                sendResponse({ success: false, error: err.message });
            }
        })();
        return isResponseAsync;
    }

    if (type === 'getLogEntries') {
        isResponseAsync = true;
        (async () => {
            const sessionId = payload?.sessionId;
            if (!sessionId) {
                sendResponse({ success: false, error: 'Session ID required' });
                return true;
            }
            try {
                const key = `logs_${sessionId}`;
                const result = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.get(key);
                sendResponse({ success: true, entries: result[key] || [] });
            } catch (err) {
                _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logError(`Error fetching log entries for ${sessionId}:`, err);
                sendResponse({ success: false, error: err.message });
            }
        })();
        return isResponseAsync;
    }

    if (type === 'detachSidePanel') {
        isResponseAsync = true;
        handleDetach(sender.tab?.id).then(result => {
            sendResponse(result);
        }).catch(error => {
            sendResponse({ success: false, error: error.message });
        });
        return isResponseAsync;
    }

    if (type === 'getDetachedState') {
        isResponseAsync = true;
        (async () => {
            try {
                const { [`detachedState_${sender.tab?.id}`]: state } = await webextension_polyfill__WEBPACK_IMPORTED_MODULE_0___default().storage.local.get(`detachedState_${sender.tab?.id}`);
                sendResponse({ success: true, state: state });
            } catch (error) {
                sendResponse({ success: false, error: error.message });
            }
        })();
        return isResponseAsync;
    }

    _log_client_js__WEBPACK_IMPORTED_MODULE_2__.logWarn(`Unhandled message type: ${type}`);
    return false;
});

_log_client_js__WEBPACK_IMPORTED_MODULE_2__.logInfo("[Background-Simple] Script loaded and listening.");
})();

/******/ })()
;
//# sourceMappingURL=background.js.map