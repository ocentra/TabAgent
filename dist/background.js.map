{"version":3,"file":"background.js","sources":["../node_modules/webextension-polyfill/dist/browser-polyfill.js","../src/log-client.js","../src/background.js"],"sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n  /* vim: set sts=2 sw=2 et tw=80: */\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n  if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\n    // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n          return super.get(key);\n        }\n      }\n\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args);\n\n                // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n        });\n      };\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n            if (!(prop in target)) {\n              return undefined;\n            }\n            let value = target[prop];\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                  return target[prop];\n                },\n                set(value) {\n                  target[prop] = value;\n                }\n              });\n              return value;\n            }\n            cache[prop] = value;\n            return value;\n          },\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n            return true;\n          },\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n        };\n\n        // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n      });\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {} /* wrappers */, {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          const isResultThenable = result !== true && isThenable(result);\n\n          // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          }\n\n          // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          };\n\n          // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          }\n\n          // Let Chrome know that the listener is replying.\n          return true;\n        };\n      });\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    };\n\n    // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","import { eventBus } from './eventBus.js';\nimport { DbAddLogRequest, DbInitializationCompleteNotification } from './events/dbEvents.js';\n\nconst hasChromeRuntime = typeof chrome !== 'undefined' && chrome.runtime;\nlet componentName = 'unknown';\nlet mirrorToConsoleDefault = true;\nlet sendToDbDefault = true;\nlet isDbReadyForLogs = false;\nconst logBuffer = [];\n\nasync function flushLogBuffer() {\n    if (!eventBus) return;\n    while (logBuffer.length > 0) {\n        const logEvent = logBuffer.shift();\n        if (logEvent) {\n            try {\n                await eventBus.publish(logEvent.type, logEvent);\n            } catch (error) {\n                console.error(`LogClient (${componentName}): Error publishing buffered log. Error: ${error}. Event:`, logEvent);\n            }\n        }\n    }\n}\n\nfunction init(compName, options = {}) {\n    if (!compName) {\n        console.error(\"LogClient: init() requires a component name.\");\n        return;\n    }\n    componentName = compName;\n    mirrorToConsoleDefault = options.mirrorToConsole !== undefined ? options.mirrorToConsole : true;\n    sendToDbDefault = options.sendToDb !== undefined ? options.sendToDb : true;\n\n    if (eventBus) {\n        eventBus.subscribe(DbInitializationCompleteNotification.name, (notification) => {\n            if (notification.payload.success) {\n                console.log(`[LogClient (${componentName})] Received DB Initialization Complete. Flushing buffer.`);\n                isDbReadyForLogs = true;\n                flushLogBuffer();\n            } else {\n                console.error(`[LogClient (${componentName})] Received DB Initialization FAILED notification. Logs will not be sent to DB. Error:`, notification.payload.error);\n            }\n        });\n    } else {\n        console.error(`LogClient (${componentName}): CRITICAL - eventBus not available during init. DB logging disabled.`);\n        sendToDbDefault = false;\n    }\n\n    let logMode = 'unknown';\n    if (typeof eventBus !== 'undefined') {\n        logMode = 'sendMessage logging (Standard)';\n    } else {\n        logMode = 'console fallback';\n        console.error(`LogClient (${componentName}): CRITICAL - No logging mechanism available. Falling back to console.`);\n    }\n\n    const initialLogMessage = `Log client initialized for component: ${componentName}. (${logMode}, Console Mirror: ${mirrorToConsoleDefault}, SendToDB: ${sendToDbDefault})`;\n    _internalLogHelper('info', initialLogMessage, { mirrorToConsole: mirrorToConsoleDefault, sendToDb: sendToDbDefault, skipInitCheck: true });\n}\n\nasync function _internalLogHelper(level, ...args) {\n    const rawOptions = args.length > 0 && typeof args[args.length - 1] === 'object' && !Array.isArray(args[args.length - 1]) ? args.pop() : {};\n    const options = rawOptions || {};\n\n    const mirrorThisCall = options.mirrorToConsole !== undefined ? options.mirrorToConsole : mirrorToConsoleDefault;\n    let sendThisCall = options.sendToDb !== undefined ? options.sendToDb : sendToDbDefault;\n    const skipInitCheck = options.skipInitCheck || false;\n\n    if (sendThisCall && typeof eventBus === 'undefined') {\n        console.warn(`LogClient (${componentName}): Attempted DB log but eventBus is unavailable. Disabling DB log for this call.`);\n        sendThisCall = false;\n    }\n\n    if (!componentName && !skipInitCheck) {\n        console.error(\"LogClient: Attempted to log before init() was called. Message:\", level, ...args);\n        return;\n    }\n\n    if (mirrorThisCall || level.toLowerCase() === 'error') {\n        const consolePrefix = componentName ? `[${componentName}]` : `[LogClient]`;\n        const consoleArgs = [consolePrefix, ...args];\n        switch (level.toLowerCase()) {\n            case 'error': console.error(...consoleArgs); break;\n            case 'warn': if (mirrorThisCall) console.warn(...consoleArgs); break;\n            case 'debug': if (mirrorThisCall) console.debug(...consoleArgs); break;\n            case 'info': default: if (mirrorThisCall) console.log(...consoleArgs); break;\n        }\n    }\n\n    if (!sendThisCall) return;\n\n    const formattedMessage = args.map(arg => {\n        try {\n            if (arg instanceof Error) {\n                return `Error: ${arg.message}${arg.stack ? '\\n' + arg.stack : ''}`;\n            }\n            if (typeof arg === 'object' && arg !== null) {\n                return '[Object]';\n            }\n            return String(arg);\n        } catch (e) {\n            return `[Unstringifiable Object: ${e.message}]`;\n        }\n    }).join(' ');\n\n    const logPayload = {\n        id: crypto.randomUUID(),\n        timestamp: Date.now(),\n        component: componentName,\n        level: level.toLowerCase(),\n        message: formattedMessage,\n    };\n\n    if (hasChromeRuntime && chrome.storage?.local) {\n        try {\n            const { currentLogSessionId } = await chrome.storage.local.get('currentLogSessionId');\n            if (currentLogSessionId) {\n                logPayload.extensionSessionId = currentLogSessionId;\n            } else {\n                console.warn(`LogClient (${componentName}): Could not retrieve currentLogSessionId from storage.`);\n                logPayload.extensionSessionId = 'unknown-session';\n            }\n        } catch (storageError) {\n            console.error(`LogClient (${componentName}): Error retrieving session ID from storage:`, storageError);\n            logPayload.extensionSessionId = 'storage-error-session';\n        }\n    } else {\n        logPayload.extensionSessionId = 'no-storage-session';\n    }\n\n    const logEvent = new DbAddLogRequest(logPayload);\n\n    if (isDbReadyForLogs) {\n        try {\n            await eventBus.publish(logEvent.type, logEvent);\n        } catch (error) {\n            console.error(`LogClient (${componentName}): Error during eventBus log submission. Error: ${error}. Original message:`, level, ...args);\n        }\n    } else {\n        logBuffer.push(logEvent);\n    }\n}\n\nfunction log(level, ...args) {\n    _internalLogHelper(level, ...args);\n}\n\nfunction logDebug(...args) {\n    _internalLogHelper('debug', ...args);\n}\n\nfunction logInfo(...args) {\n    _internalLogHelper('info', ...args);\n}\n\nfunction logWarn(...args) {\n    _internalLogHelper('warn', ...args);\n}\n\nfunction logError(...args) {\n    _internalLogHelper('error', ...args);\n}\n\nexport { init, log, logDebug, logInfo, logWarn, logError };","import browser from 'webextension-polyfill';\n\nconst OFFSCREEN_DOCUMENT_PATH = 'offscreen.html';\nconst MODEL_WORKER_OFFSCREEN_PATH = 'offscreenWorker.html';\n\nimport * as logClient from './log-client.js';\nimport { eventBus } from './eventBus.js';\nimport { DbInitializeRequest } from './events/dbEvents.js';\n\nlogClient.init('Background');\n\nlet detachedPopups = {};\nlet popupIdToTabId = {};\n\nconst DNR_RULE_ID_1 = 1;\nconst DNR_RULE_PRIORITY_1 = 1;\n\nlet modelWorkerState = 'uninitialized';\nlet workerScriptReadyPromise = null;\nlet workerScriptReadyResolver = null;\nlet workerScriptReadyRejecter = null;\nlet modelLoadPromise = null;\nlet modelLoadResolver = null;\nlet modelLoadRejecter = null;\n\nlet activeGenerations = {};\n\nlet currentLogSessionId = null;\nlet previousLogSessionId = null;\n\nlet lastLoggedProgress = -10;\n\n// Log Session Management\nasync function initializeSessionIds() {\n    logClient.logInfo('Initializing log session IDs...');\n    currentLogSessionId = Date.now() + '-' + Math.random().toString(36).substring(2, 9);\n    logClient.logInfo('Current log session ID:', currentLogSessionId);\n    await browser.storage.local.set({ currentLogSessionId: currentLogSessionId });\n    const { previousLogSessionId: storedPreviousId } = await browser.storage.local.get('previousLogSessionId');\n    previousLogSessionId = storedPreviousId || null;\n    logClient.logInfo('Previous log session ID found in storage:', previousLogSessionId);\n    await browser.storage.local.set({ previousLogSessionId: currentLogSessionId });\n    logClient.logInfo('Stored new previousLogSessionId for next run.');\n}\n\n// Model Worker Offscreen Communication\nasync function hasModelWorkerOffscreenDocument() {\n    const targetUrl = browser.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH);\n    const existingContexts = await browser.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    return existingContexts.length > 0;\n}\n\nasync function setupModelWorkerOffscreenDocument() {\n    if (await hasModelWorkerOffscreenDocument()) {\n        logClient.logInfo(\"Model worker offscreen document already exists.\");\n        return;\n    }\n    logClient.logInfo(\"Creating model worker offscreen document...\");\n    await browser.offscreen.createDocument({\n        url: MODEL_WORKER_OFFSCREEN_PATH,\n        reasons: [browser.offscreen.Reason.WORKERS],\n        justification: 'Run model inference in a separate worker via offscreen document',\n    });\n    logClient.logInfo(\"Model worker offscreen document created.\");\n}\n\nasync function sendToModelWorkerOffscreen(message) {\n    if (message.type !== 'init' && message.type !== 'generate' && message.type !== 'interrupt' && message.type !== 'reset') {\n        if (modelWorkerState === 'uninitialized' || !(await hasModelWorkerOffscreenDocument())) {\n            logClient.logInfo(`Background: Ensuring model worker offscreen doc potentially exists before sending ${message?.type}`);\n            await setupModelWorkerOffscreenDocument();\n        }\n    } else {\n        logClient.logDebug(`Background: Ensuring worker script is ready before sending ${message.type}...`);\n        try {\n            await ensureWorkerScriptIsReady();\n            logClient.logDebug(`Background: Worker script confirmed ready. Proceeding to send ${message.type}.`);\n        } catch (error) {\n            logClient.logError(`Background: Worker script failed to become ready. Cannot send ${message.type}. Error:`, error);\n            modelWorkerState = 'error';\n            throw new Error(`Worker script failed to initialize, cannot send ${message.type}.`);\n        }\n    }\n\n    logClient.logDebug(`Background: Sending message type '${message?.type}' to model worker offscreen doc`);\n    try {\n        const contexts = await browser.runtime.getContexts({\n            contextTypes: ['OFFSCREEN_DOCUMENT'],\n            documentUrls: [browser.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH)]\n        });\n        if (contexts.length > 0) {\n            browser.runtime.sendMessage(message);\n            logClient.logDebug(`Background: Message type '${message?.type}' sent to offscreen.`);\n            return { success: true };\n        } else {\n            logClient.logError(`Background: Could not find target offscreen document context to send ${message?.type}.`);\n            throw new Error(`Target offscreen document not found.`);\n        }\n    } catch (error) {\n        logClient.logError(`Background: Error sending message type '${message?.type}' to offscreen:`, error);\n        modelWorkerState = 'error';\n        if (message.type === 'init') {\n            if (modelLoadRejecter) modelLoadRejecter(new Error(`Failed to send init message: ${error.message}`));\n            modelLoadPromise = null;\n        } else if (workerScriptReadyRejecter && (modelWorkerState === 'uninitialized' || modelWorkerState === 'creating_worker')) {\n            workerScriptReadyRejecter(new Error(`Failed to send message early: ${error.message}`));\n            workerScriptReadyPromise = null;\n        }\n        throw new Error(`Failed to send message to model worker offscreen: ${error.message}`);\n    }\n}\n\nfunction ensureWorkerScriptIsReady() {\n    logClient.logDebug(`[ensureWorkerScriptIsReady] Current state: ${modelWorkerState}`);\n    if (modelWorkerState !== 'uninitialized' && modelWorkerState !== 'creating_worker') {\n        if (modelWorkerState === 'error' && !workerScriptReadyPromise) {\n            return Promise.reject(new Error(\"Worker script initialization previously failed.\"));\n        }\n        return Promise.resolve();\n    }\n    if (workerScriptReadyPromise) {\n        return workerScriptReadyPromise;\n    }\n\n    logClient.logDebug(\"[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise.\");\n    modelWorkerState = 'creating_worker';\n    workerScriptReadyPromise = new Promise((resolve, reject) => {\n        workerScriptReadyResolver = resolve;\n        workerScriptReadyRejecter = reject;\n\n        setupModelWorkerOffscreenDocument().catch(err => {\n            logClient.logError(\"[ensureWorkerScriptIsReady] Error setting up offscreen doc:\", err);\n            modelWorkerState = 'error';\n            if (workerScriptReadyRejecter) workerScriptReadyRejecter(err);\n            workerScriptReadyPromise = null;\n        });\n    });\n\n    const scriptLoadTimeout = 30000;\n    setTimeout(() => {\n        if (modelWorkerState === 'creating_worker' && workerScriptReadyRejecter) {\n            logClient.logError(`[ensureWorkerScriptIsReady] Timeout (${scriptLoadTimeout}ms) waiting for workerScriptReady.`);\n            workerScriptReadyRejecter(new Error('Timeout waiting for model worker script to load.'));\n            modelWorkerState = 'error';\n            workerScriptReadyPromise = null;\n        }\n    }, scriptLoadTimeout);\n\n    return workerScriptReadyPromise;\n}\n\nasync function loadModel(modelId) {\n    logClient.logInfo(`Request to load model: ${modelId}. Current state: ${modelWorkerState}`);\n    try {\n        await ensureWorkerScriptIsReady();\n        logClient.logDebug(`Worker script confirmed ready (state: ${modelWorkerState}). Proceeding with model load.`);\n    } catch (err) {\n        logClient.logError(\"Failed to ensure worker script readiness:\", err);\n        throw new Error(`Failed to ensure worker script readiness: ${err.message}`);\n    }\n\n    if (modelWorkerState !== 'worker_script_ready' && modelWorkerState !== 'idle' && modelWorkerState !== 'error') {\n        const errorMsg = `Cannot load model '${modelId}'. Worker state is '${modelWorkerState}', expected 'worker_script_ready', 'idle', or 'error'.`;\n        logClient.logError(\"State check failed loading model:\", errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    if (!modelId) {\n        return Promise.reject(new Error(\"Cannot load model: Model ID not provided.\"));\n    }\n\n    if (modelWorkerState === 'model_ready') {\n        logClient.logInfo(`Model appears ready. Assuming it's ${modelId}.`);\n        return Promise.resolve();\n    }\n    if (modelWorkerState === 'loading_model' && modelLoadPromise) {\n        logClient.logInfo(`Model is already loading. Assuming it's ${modelId}.`);\n        return modelLoadPromise;\n    }\n    if (modelWorkerState !== 'worker_script_ready') {\n        logClient.logError(\"Cannot load model. Worker script is not ready. State:\", modelWorkerState);\n        return Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${modelWorkerState})`));\n    }\n\n    logClient.logInfo(`Worker script ready. Initiating load for model: ${modelId}.`);\n    modelWorkerState = 'loading_model';\n    // TODO: Store the modelId being loaded\n    modelLoadPromise = new Promise((resolve, reject) => {\n        modelLoadResolver = resolve;\n        modelLoadRejecter = reject;\n\n        logClient.logDebug(`Attempting to send 'init' message for model: ${modelId}`);\n        sendToModelWorkerOffscreen({ type: 'init', payload: { modelId: modelId } })\n            .catch(err => {\n                logClient.logError(`Failed to send 'init' message for ${modelId}:`, err);\n                modelWorkerState = 'error';\n                if (modelLoadRejecter) modelLoadRejecter(err);\n                modelLoadPromise = null;\n            });\n    });\n\n    const modelLoadTimeout = 300000;\n    setTimeout(() => {\n        if (modelWorkerState === 'loading_model' && modelLoadRejecter) {\n            logClient.logError(`Timeout (${modelLoadTimeout}ms) waiting for model ${modelId} load completion.`);\n            modelLoadRejecter(new Error(`Timeout waiting for model ${modelId} to load.`));\n            modelWorkerState = 'error';\n            modelLoadPromise = null;\n        }\n    }, modelLoadTimeout);\n\n    return modelLoadPromise;\n}\n\n// Declarative Net Request Management\nasync function updateDeclarativeNetRequestRules() {\n    const currentRules = await browser.declarativeNetRequest.getDynamicRules();\n    const currentRuleIds = currentRules.map(rule => rule.id);\n\n    const rulesToAdd = [\n        {\n            id: DNR_RULE_ID_1,\n            priority: DNR_RULE_PRIORITY_1,\n            action: {\n                type: 'modifyHeaders',\n                responseHeaders: [\n                    { header: 'x-frame-options', operation: 'remove' },\n                    { header: 'X-Frame-Options', operation: 'remove' },\n                    { header: 'content-security-policy', operation: 'remove' },\n                    { header: 'Content-Security-Policy', operation: 'remove' }\n                ]\n            },\n            condition: {\n                resourceTypes: ['main_frame'],\n                urlFilter: '|http*://*/*|'\n            }\n        }\n    ];\n\n    const rulesToRemove = currentRuleIds.filter(id => id === DNR_RULE_ID_1);\n\n    try {\n        await browser.declarativeNetRequest.updateDynamicRules({\n            removeRuleIds: rulesToRemove,\n            addRules: rulesToAdd\n        });\n        logClient.logInfo(\"Declarative Net Request rules updated successfully.\");\n    } catch (error) {\n        logClient.logError(\"Error updating Declarative Net Request rules:\", error);\n    }\n}\nupdateDeclarativeNetRequestRules();\n\n// Offscreen Document Management\nasync function hasOffscreenDocument(path) {\n    const filename = path.split('/').pop();\n    const targetUrl = browser.runtime.getURL(filename);\n    const existingContexts = await browser.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    return existingContexts.length > 0;\n}\n\nasync function setupOffscreenDocument(path, reasons, justification) {\n    if (await hasOffscreenDocument(path)) {\n        logClient.logInfo(`Background: Offscreen document at ${path} already exists.`);\n        return;\n    }\n    const filename = path.split('/').pop();\n    logClient.logInfo(`Background: Creating offscreen document using filename: ${filename}...`);\n    await browser.offscreen.createDocument({\n        url: filename,\n        reasons: reasons,\n        justification: justification,\n    });\n    logClient.logInfo(`Background: Offscreen document created successfully using ${filename}.`);\n}\n\n// Scraping Logic\nasync function scrapeUrlWithOffscreenIframe(url) {\n    logClient.logInfo(`[Stage 2] Attempting Offscreen + iframe: ${url}`);\n    const DYNAMIC_SCRIPT_ID_PREFIX = 'offscreen-scrape-';\n    const DYNAMIC_SCRIPT_MESSAGE_TYPE = 'offscreenIframeResult';\n    const IFRAME_LOAD_TIMEOUT = 30000;\n    let dynamicScripterId = null;\n\n    const cleanup = async (scriptIdBase) => {\n        logClient.logInfo(`[Stage 2 Cleanup] Starting cleanup for script ID base: ${scriptIdBase}`);\n        if (scriptIdBase) {\n            try {\n                await browser.scripting.unregisterContentScripts({ ids: [scriptIdBase] });\n                logClient.logInfo(`[Stage 2 Cleanup] Unregistered script: ${scriptIdBase}`);\n            } catch (error) {\n                logClient.logWarn(`[Stage 2 Cleanup] Failed to unregister script ${scriptIdBase}:`, error);\n            }\n        }\n        try {\n            await browser.runtime.sendMessage({ type: 'removeIframe', target: 'offscreen' });\n            logClient.logInfo('[Stage 2 Cleanup] Sent removeIframe request to offscreen.');\n        } catch (error) {\n            logClient.logWarn('[Stage 2 Cleanup] Failed to send removeIframe request: ', error);\n        }\n    };\n\n    try {\n        await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH, ['DOM_PARSER', 'IFRAME_SCRIPTING'], 'Parse HTML content and manage scraping iframes');\n        logClient.logInfo('[Stage 2] Sending createIframe request to offscreen...');\n        const createResponse = await browser.runtime.sendMessage({\n            type: 'createIframe',\n            target: 'offscreen',\n            url: url\n        });\n        if (!createResponse?.success) {\n            throw new Error(`Failed to create iframe in offscreen: ${createResponse?.error || 'Unknown error'}`);\n        }\n        logClient.logInfo('[Stage 2] Iframe creation request successful. Waiting for load and script...');\n        dynamicScripterId = `${DYNAMIC_SCRIPT_ID_PREFIX}${Date.now()}`;\n        await browser.scripting.registerContentScripts([{\n            id: dynamicScripterId,\n            js: ['PageExtractor.js', 'stage2-helper.js'],\n            matches: [url],\n            runAt: 'document_idle',\n            world: 'ISOLATED',\n            allFrames: true,\n            persistAcrossSessions: false\n        }]);\n        logClient.logInfo(`[Stage 2] Registered dynamic script(s): ${dynamicScripterId} (files: PageExtractor.js, stage2-helper.js)`);\n        let messageListener = null;\n        const scriptResponsePromise = new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                logClient.logWarn(`[Stage 2] Timeout (${IFRAME_LOAD_TIMEOUT / 1000}s) waiting for response from dynamic script.`);\n                if (messageListener) {\n                    browser.runtime.onMessage.removeListener(messageListener);\n                }\n                reject(new Error('Timeout waiting for dynamic script response.'));\n            }, IFRAME_LOAD_TIMEOUT);\n\n            messageListener = (message, sender, sendResponse) => {\n                if (message?.type === DYNAMIC_SCRIPT_MESSAGE_TYPE) {\n                    logClient.logInfo('[Stage 2] Received response from dynamic script:', message.payload);\n                    clearTimeout(timeoutId);\n                    browser.runtime.onMessage.removeListener(messageListener);\n                    if (message.payload?.success) {\n                        resolve(message.payload);\n                    } else {\n                        reject(new Error(message.payload?.error || 'Dynamic script reported failure.'));\n                    }\n                    return false;\n                }\n                return false;\n            };\n            browser.runtime.onMessage.addListener(messageListener);\n            logClient.logInfo('[Stage 2] Listener added for dynamic script response.');\n        });\n        const resultPayload = await scriptResponsePromise;\n        await cleanup(dynamicScripterId);\n        return resultPayload;\n    } catch (error) {\n        logClient.logError(`[Stage 2] Error during Offscreen + iframe process:`, error);\n        await cleanup(dynamicScripterId);\n        throw new Error(`Stage 2 (Offscreen + iframe) failed: ${error.message}`);\n    }\n}\n\nasync function scrapeUrlWithTempTabExecuteScript(url) {\n    logClient.logInfo(`[Stage 3] Attempting Temp Tab + executeScript (using window.scraper.extract): ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            logClient.logWarn(`[Stage 3] Cleanup: ${errorMsg}`);\n            if (tempTabId) {\n                browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 3] Error removing tab ${tempTabId}: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n            const tab = await browser.tabs.create({ url: url, active: false });\n            tempTabId = tab.id;\n            if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n            logClient.logInfo(`[Stage 3] Created temp tab ${tempTabId} for executeScript.`);\n        } catch (error) {\n            return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    logClient.logInfo(`[Stage 3] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    browser.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            browser.runtime.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                browser.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load.`));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch (error) {\n            return cleanupAndReject(`Load failed or timed out: ${error.message}`);\n        }\n        logClient.logInfo(`[Stage 3] Injecting PageExtractor.js and calling window.scraper.extract() in tab ${tempTabId}`);\n        try {\n            await browser.scripting.executeScript({\n                target: { tabId: tempTabId },\n                files: ['PageExtractor.js']\n            });\n            const results = await browser.scripting.executeScript({\n                target: { tabId: tempTabId },\n                func: () => window.scraper.extract(),\n            });\n            if (tempTabId) {\n                browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 3] Error removing tab ${tempTabId} post-execute: ${err.message}`));\n                tempTabId = null;\n            }\n            if (results && results.length > 0 && results[0].result) {\n                const scriptResult = results[0].result;\n                if (scriptResult && typeof scriptResult === 'object') {\n                    logClient.logInfo('[Stage 3] window.scraper.extract() succeeded.');\n                    resolve(scriptResult);\n                } else {\n                    reject(new Error(scriptResult?.error || 'window.scraper.extract() failed or returned null.'));\n                }\n            } else {\n                const lastError = browser.runtime.lastError ? browser.runtime.lastError.message : 'No result returned';\n                reject(new Error(`executeScript failed: ${lastError}`));\n            }\n        } catch (error) {\n            cleanupAndReject(`executeScript call failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlWithTempTab_ContentScript(url) {\n    logClient.logInfo(`[Stage 4] Attempting Temp Tab + Content Script: ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            if (tempTabId) {\n                browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 4] Error removing tab ${tempTabId} during cleanup: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n            const tab = await browser.tabs.create({ url: url, active: false });\n            tempTabId = tab.id;\n            if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n            logClient.logInfo(`[Stage 4] Created temp tab ${tempTabId}`);\n        } catch (error) {\n            return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    logClient.logInfo(`[Stage 4] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    browser.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            browser.tabs.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                browser.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load.`));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch (error) {\n            return cleanupAndReject(error.message);\n        }\n        logClient.logInfo(`[Stage 4] Sending SCRAPE_PAGE to content script in tab ${tempTabId}`);\n        try {\n            const response = await browser.tabs.sendMessage(tempTabId, { type: 'SCRAPE_PAGE' });\n            if (tempTabId) browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 4] Error removing tab ${tempTabId} post-message: ${err.message}`));\n            tempTabId = null;\n            if (response?.success) {\n                logClient.logInfo(`[Stage 4] Success from content script.`);\n                resolve(response);\n            } else {\n                reject(new Error(response?.error || 'Content script failed or gave invalid response.'));\n            }\n        } catch (error) {\n            cleanupAndReject(`Messaging content script failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlMultiStage(url, chatId, messageId) {\n    logClient.logInfo(`Scraping Orchestrator: Starting for ${url}. ChatID: ${chatId}, MessageID: ${messageId}`);\n    const sendStageResult = (stageResult) => {\n        logClient.logInfo(`[Orchestrator] Sending STAGE_SCRAPE_RESULT for Stage ${stageResult.stage}, ChatID: ${chatId}, Success: ${stageResult.success}`);\n        browser.runtime.sendMessage({\n            type: 'STAGE_SCRAPE_RESULT',\n            payload: stageResult\n        }).catch(e => logClient.logWarn(`[Orchestrator] Failed to send result for Stage ${stageResult.stage}:`, e));\n    };\n\n    try {\n        try {\n            const iframeResult = await scrapeUrlWithOffscreenIframe(url);\n            logClient.logInfo(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Succeeded for ${url}.`);\n            const stage2SuccessPayload = {\n                stage: 2, success: true, chatId: chatId, messageId: messageId,\n                method: 'offscreenIframe', url: url,\n                length: iframeResult?.text?.length || 0,\n                ...iframeResult\n            };\n            sendStageResult(stage2SuccessPayload);\n            return;\n        } catch (stage2Error) {\n            logClient.logWarn(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Failed for ${url}: ${stage2Error.message}`);\n            sendStageResult({ stage: 2, success: false, chatId: chatId, messageId: messageId, error: stage2Error.message });\n        }\n\n        try {\n            const executeScriptResult = await scrapeUrlWithTempTabExecuteScript(url);\n            logClient.logInfo(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Succeeded for ${url}.`);\n            const stage3SuccessPayload = {\n                stage: 3, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabExecuteScript', url: url,\n                length: executeScriptResult?.text?.length || 0,\n                ...executeScriptResult\n            };\n            sendStageResult(stage3SuccessPayload);\n            return;\n        } catch (stage3Error) {\n            logClient.logWarn(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Failed for ${url}: ${stage3Error.message}`);\n            sendStageResult({ stage: 3, success: false, chatId: chatId, messageId: messageId, error: stage3Error.message });\n        }\n\n        try {\n            const tempTabResult = await scrapeUrlWithTempTab_ContentScript(url);\n            logClient.logInfo(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Succeeded for ${url}.`);\n            const stage4SuccessPayload = {\n                stage: 4, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabContentScript', url: url,\n                length: tempTabResult?.text?.length || 0,\n                ...tempTabResult\n            };\n            logClient.logInfo(\"[Orchestrator Log] Stage 4 Payload being sent:\", stage4SuccessPayload);\n            sendStageResult(stage4SuccessPayload);\n            return;\n        } catch (stage4Error) {\n            logClient.logWarn(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Failed for ${url}: ${stage4Error.message}`);\n            sendStageResult({ stage: 4, success: false, chatId: chatId, messageId: messageId, error: stage4Error.message });\n        }\n\n        logClient.logInfo(\"[Orchestrator Log] All stages failed.\");\n    } finally {\n        logClient.logInfo(\"[Orchestrator Cleanup] Attempting to close offscreen document after multi-stage scrape.\");\n        try {\n            if (await hasOffscreenDocument(OFFSCREEN_DOCUMENT_PATH)) {\n                await browser.offscreen.closeDocument();\n                logClient.logInfo(\"[Orchestrator Cleanup] Offscreen document closed successfully.\");\n            } else {\n                logClient.logInfo(\"[Orchestrator Cleanup] No offscreen document found to close.\");\n            }\n        } catch (error) {\n            logClient.logWarn(\"[Orchestrator Cleanup] Error closing offscreen document:\", error);\n        }\n    }\n}\n\n// Google Drive Integration\nasync function getDriveToken() {\n    return new Promise((resolve, reject) => {\n        browser.identity.getAuthToken({ interactive: true }, (token) => {\n            if (browser.runtime.lastError) {\n                reject(new Error(browser.runtime.lastError.message));\n            } else {\n                resolve(token);\n            }\n        });\n    });\n}\n\nasync function fetchDriveFileList(token, folderId = 'root') {\n    const fields = \"files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)\";\n    const query = `'${folderId}' in parents and trashed=false`;\n    const pageSize = 100;\n    const orderBy = 'folder,modifiedTime desc';\n    const url = `https://www.googleapis.com/drive/v3/files?${new URLSearchParams({\n        pageSize: pageSize.toString(),\n        q: query,\n        fields: fields,\n        orderBy: orderBy\n    })}`;\n    logClient.logInfo(`Background: Fetching Drive list for folder '${folderId}': ${url}`);\n    const response = await fetch(url, {\n        headers: {\n            'Authorization': `Bearer ${token}`,\n            'Accept': 'application/json'\n        }\n    });\n    if (!response.ok) {\n        const errorData = await response.text();\n        logClient.logError(`Background: Drive API files.list error (Folder: ${folderId}):`, response.status, errorData);\n        if (response.status === 404) {\n            throw new Error(`Folder with ID '${folderId}' not found or access denied.`);\n        }\n        throw new Error(`Drive API Error ${response.status} (Folder: ${folderId}): ${errorData || response.statusText}`);\n    }\n    const data = await response.json();\n    logClient.logInfo(`Background: Drive API files.list success (Folder: ${folderId}). Found ${data.files?.length || 0} items.`);\n    return data.files || [];\n}\n\nasync function fetchDriveFileContent(token, fileId) {\n    logClient.logWarn(`Background: fetchDriveFileContent not implemented yet for fileId: ${fileId}`);\n    return `(Content fetch not implemented for ${fileId})`;\n}\n\n// Message Forwarding\nasync function forwardMessageToSidePanelOrPopup(message, originalSender) {\n    logClient.logInfo(`Attempting to forward message type '${message?.type}' from worker.`);\n    for (const tabId in detachedPopups) {\n        const popupId = detachedPopups[tabId];\n        logClient.logInfo(`Forwarding message to detached popup ID: ${popupId} (original tab: ${tabId})`);\n        try {\n            await browser.windows.get(popupId);\n            browser.runtime.sendMessage(message);\n        } catch (error) {\n            logClient.logWarn(`Error sending to detached popup ID ${popupId}:`, error.message);\n            if (error.message.includes(\"No window with id\")) {\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[popupId];\n            }\n        }\n    }\n\n    const tabs = await browser.tabs.query({ status: 'complete' });\n    for (const tab of tabs) {\n        if (detachedPopups[tab.id]) continue;\n        try {\n            await browser.tabs.sendMessage(tab.id, message);\n        } catch (error) {\n            if (!error.message.includes('Could not establish connection') && !error.message.includes('Receiving end does not exist')) {\n                logClient.logWarn(`Error forwarding message to tab ${tab.id}:`, error.message);\n            }\n        }\n    }\n}\n\n// Extension Lifecycle Listeners\nbrowser.runtime.onInstalled.addListener(async (details) => {\n    logClient.logInfo('onInstalled event fired. Reason:', details.reason);\n    await initializeSessionIds();\n\n    browser.sidePanel\n        .setPanelBehavior({ openPanelOnActionClick: true })\n        .catch((error) => logClient.logError('Error setting side panel behavior:', error));\n    logClient.logInfo('Side panel behavior set.');\n\n    browser.storage.local.get(null, (items) => {\n        const keysToRemove = Object.keys(items).filter(key => key.startsWith('detachedState_'));\n        if (keysToRemove.length > 0) {\n            browser.storage.local.remove(keysToRemove, () => {\n                logClient.logInfo('Cleaned up old storage keys on install/update.');\n            });\n        }\n    });\n\n    logClient.logInfo('Triggering DB Initialization from onInstalled.');\n    eventBus.publish(DbInitializeRequest.name, new DbInitializeRequest());\n\n    ensureWorkerScriptIsReady().catch(err => {\n        logClient.logError(\"Initial worker script readiness check failed after install:\", err);\n    });\n});\n\nbrowser.runtime.onStartup.addListener(async () => {\n    logClient.logInfo('onStartup event fired.');\n    await initializeSessionIds();\n\n    logClient.logInfo('Triggering DB Initialization from onStartup (may be redundant).');\n    eventBus.publish(DbInitializeRequest.name, new DbInitializeRequest());\n\n    if (modelWorkerState === 'uninitialized') {\n        ensureWorkerScriptIsReady().catch(err => {\n            logClient.logError(\"Worker script readiness check failed on startup:\", err);\n        });\n    }\n});\n\nbrowser.action.onClicked.addListener(async (tab) => {\n    if (!tab.id) {\n        logClient.logError(\"Action Clicked: Missing tab ID.\");\n        return;\n    }\n    const tabId = tab.id;\n    logClient.logInfo(`Action clicked for tab ${tabId}`);\n    const existingPopupId = detachedPopups[tabId];\n    if (existingPopupId) {\n        logClient.logInfo(`Popup ${existingPopupId} exists for tab ${tabId}. Attempting to close popup.`);\n        try {\n            await browser.windows.remove(existingPopupId);\n            logClient.logInfo(`Closed popup window ${existingPopupId} via action click.`);\n        } catch (error) {\n            logClient.logWarn(`Failed to close popup ${existingPopupId} via action click, maybe already closed?`, error);\n            if (popupIdToTabId[existingPopupId]) {\n                logClient.logInfo(`Force cleaning maps and storage for tab ${tabId} after failed close.`);\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[existingPopupId];\n                try {\n                    await browser.storage.local.remove(`detachedState_${tabId}`);\n                    await browser.sidePanel.setOptions({ tabId: tabId, enabled: true });\n                } catch (cleanupError) {\n                    logClient.logError(\"Error during defensive cleanup:\", cleanupError);\n                }\n            }\n        }\n    } else {\n        logClient.logInfo(`No popup exists for tab ${tabId}. Default side panel opening behavior should trigger.`);\n    }\n});\n\nbrowser.windows.onRemoved.addListener(async (windowId) => {\n    logClient.logInfo(`Window removed: ${windowId}`);\n    const tabId = popupIdToTabId[windowId];\n    if (tabId) {\n        logClient.logInfo(`Popup window ${windowId} for tab ${tabId} was closed.`);\n        delete detachedPopups[tabId];\n        delete popupIdToTabId[windowId];\n        try {\n            await browser.storage.local.remove(`detachedState_${tabId}`);\n            logClient.logInfo(`Removed detached state from storage for tab ${tabId}`);\n            await browser.sidePanel.setOptions({ tabId: tabId, enabled: true });\n            logClient.logInfo(`Re-enabled side panel for tab ${tabId} after popup closed.`);\n        } catch (error) {\n            logClient.logError(`Error cleaning up storage or re-enabling side panel for tab ${tabId} on popup close:`, error);\n        }\n    } else {\n        logClient.logInfo(`Window ${windowId} closed, but it wasn't a tracked popup.`);\n    }\n});\n\n// Message Handling\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const { type, payload } = message;\n    let isResponseAsync = false;\n\n    logClient.logInfo(`Received message type '${type}' from`, sender.tab ? `tab ${sender.tab.id}` : sender.url || sender.id);\n\n    const workerMessageTypes = [\n        'workerScriptReady',\n        'workerReady',\n        'loadingStatus',\n        'generationStatus',\n        'generationUpdate',\n        'generationComplete',\n        'generationError',\n        'resetComplete',\n        'error'\n    ];\n\n    if (workerMessageTypes.includes(type)) {\n        logClient.logInfo(`Handling message from worker: ${type}`);\n        switch (type) {\n            case 'workerScriptReady':\n                logClient.logInfo(\"[Background] Worker SCRIPT is ready!\");\n                modelWorkerState = 'worker_script_ready';\n                if (workerScriptReadyResolver) {\n                    workerScriptReadyResolver();\n                    workerScriptReadyPromise = null;\n                }\n                browser.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'script_ready' } }).catch(() => {});\n                break;\n            case 'workerReady':\n                logClient.logInfo(\"[Background] Worker MODEL is ready! Model:\", payload?.model);\n                modelWorkerState = 'model_ready';\n                if (modelLoadResolver) {\n                    modelLoadResolver();\n                    modelLoadPromise = null;\n                }\n                browser.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'model_ready', model: payload?.model } }).catch(() => {});\n                if (workerScriptReadyResolver) {\n                    workerScriptReadyResolver();\n                    workerScriptReadyPromise = null;\n                }\n                break;\n            case 'loadingStatus':\n                if (payload?.status === 'progress' && payload?.progress) {\n                    const currentProgress = Math.floor(payload.progress);\n                    if (currentProgress >= lastLoggedProgress + 10) {\n                        logClient.logInfo(\"[Background] Worker loading status (progress):\", payload);\n                        lastLoggedProgress = currentProgress;\n                    }\n                } else {\n                    logClient.logInfo(\"[Background] Worker loading status (other):\", payload);\n                    lastLoggedProgress = -10;\n                }\n                if (modelWorkerState !== 'loading_model') {\n                    logClient.logWarn(`[Background] Received loadingStatus in unexpected state: ${modelWorkerState}`);\n                    modelWorkerState = 'loading_model';\n                }\n                browser.runtime.sendMessage({ type: 'uiLoadingStatusUpdate', payload: payload }).catch(err => {\n                    if (err.message !== \"Could not establish connection. Receiving end does not exist.\") {\n                        logClient.logWarn(\"[Background] Error sending loading status to UI:\", err.message);\n                    }\n                });\n                break;\n            case 'generationStatus':\n                logClient.logInfo(`[Background] Generation status: ${payload?.status}`);\n                if (payload?.status === 'generating') modelWorkerState = 'generating';\n                else if (payload?.status === 'interrupted') modelWorkerState = 'model_ready';\n                break;\n            case 'generationUpdate':\n                if (modelWorkerState !== 'generating') {\n                    logClient.logWarn(`[Background] Received generationUpdate in unexpected state: ${modelWorkerState}`);\n                }\n                modelWorkerState = 'generating';\n                break;\n            case 'generationComplete':\n                logClient.logInfo(\"[Background] Generation complete.\");\n                modelWorkerState = 'model_ready';\n                break;\n            case 'generationError':\n                logClient.logError(\"[Background] Generation error from worker:\", payload);\n                modelWorkerState = 'error';\n                break;\n            case 'resetComplete':\n                logClient.logInfo(\"[Background] Worker reset complete.\");\n                modelWorkerState = 'model_ready';\n                break;\n            case 'error':\n                logClient.logError(\"[Background] Received generic error from worker/offscreen:\", payload);\n                const previousState = modelWorkerState;\n                modelWorkerState = 'error';\n                if (previousState === 'creating_worker' && workerScriptReadyRejecter) {\n                    workerScriptReadyRejecter(new Error(payload || 'Generic error during script init'));\n                    workerScriptReadyPromise = null;\n                } else if (previousState === 'loading_model' && modelLoadRejecter) {\n                    modelLoadRejecter(new Error(payload || 'Generic error during model load'));\n                    modelLoadPromise = null;\n                }\n                browser.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'error', error: payload } }).catch(() => {});\n                break;\n        }\n        forwardMessageToSidePanelOrPopup(message, sender);\n        return false;\n    }\n\n    if (type === 'loadModel') {\n        logClient.logInfo(`Received 'loadModel' request from sender:`, sender);\n        const modelId = payload?.modelId;\n        logClient.logInfo(`Received 'loadModel' request from UI for model: ${modelId}.`);\n        if (!modelId) {\n            logClient.logError(\"[Background] 'loadModel' request missing modelId.\");\n            sendResponse({ success: false, error: \"Model ID not provided in request.\" });\n            return false;\n        }\n\n        isResponseAsync = true;\n        loadModel(modelId)\n            .then(() => {\n                logClient.logInfo(`loadModel(${modelId}) promise resolved successfully.`);\n                sendResponse({ success: true, message: `Model loading initiated or already complete for ${modelId}.` });\n            })\n            .catch(error => {\n                logClient.logError(`loadModel(${modelId}) failed:`, error);\n                sendResponse({ success: false, error: error.message });\n            });\n        return isResponseAsync;\n    }\n\n    if (type === 'sendChatMessage') {\n        isResponseAsync = true;\n        const { chatId, messages, options, messageId } = payload;\n        const correlationId = messageId || chatId;\n\n        if (modelWorkerState !== 'model_ready') {\n            logClient.logError(`Cannot send chat message. Model state is ${modelWorkerState}, not 'model_ready'.`);\n            sendResponse({ success: false, error: `Model not ready (state: ${modelWorkerState}). Please load a model first.` });\n            return false;\n        }\n\n        logClient.logInfo(`Model ready, sending generate request for ${correlationId}`);\n        sendToModelWorkerOffscreen({\n            type: 'generate',\n            payload: {\n                messages: messages,\n                max_new_tokens: options?.max_new_tokens,\n                temperature: options?.temperature,\n                top_k: options?.top_k,\n                correlationId: correlationId\n            }\n        })\n        .then(sendResult => {\n            if (!sendResult.success) throw new Error(\"Failed to send generate message initially.\");\n            logClient.logInfo(`Generate request sent for ${correlationId}. Waiting for worker responses.`);\n            sendResponse({ success: true, message: \"Generation request forwarded to worker.\"});\n        })\n        .catch(error => {\n            logClient.logError(`Error processing sendChatMessage for ${correlationId}:`, error);\n            if (modelWorkerState === 'generating') modelWorkerState = 'model_ready';\n            sendResponse({ success: false, error: error.message });\n        });\n\n        return isResponseAsync;\n    }\n\n    if (type === 'interruptGeneration') {\n        logClient.logInfo(\"[Background] Received interrupt request from UI.\");\n        ensureWorkerScriptIsReady()\n            .then(() => sendToModelWorkerOffscreen({ type: 'interrupt' }))\n            .then(() => sendResponse({ success: true }))\n            .catch(err => sendResponse({ success: false, error: err.message }));\n        isResponseAsync = true;\n        return isResponseAsync;\n    }\n\n    if (type === 'resetWorker') {\n        logClient.logInfo(\"[Background] Received reset request from UI.\");\n        ensureWorkerScriptIsReady()\n            .then(() => sendToModelWorkerOffscreen({ type: 'reset' }))\n            .then(() => sendResponse({ success: true }))\n            .catch(err => sendResponse({ success: false, error: err.message }));\n        isResponseAsync = true;\n        return isResponseAsync;\n    }\n\n    if (!isResponseAsync) {\n        logClient.logWarn(`Unhandled message type: ${type}`);\n    }\n    return isResponseAsync;\n});\n\nlogClient.logInfo(\"[Background-Simple] Script loaded and listening.\");"],"names":["global","factory","module","this","CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE","wrapAPIs","extensionAPIs","apiMetadata","DefaultWeakMap","createItem","items","key","isThenable","value","makeCallback","promise","metadata","callbackArgs","pluralizeArguments","numArgs","wrapAsyncFunction","name","target","args","resolve","reject","cbError","wrapMethod","method","wrapper","targetMethod","thisObj","hasOwnProperty","wrapObject","wrappers","cache","handlers","proxyTarget","prop","receiver","desc","wrapEvent","wrapperMap","listener","onRequestFinishedWrappers","req","wrappedReq","onMessageWrappers","message","sender","sendResponse","didCallSendResponse","wrappedSendResponse","sendResponsePromise","response","result","err","isResultThenable","sendPromisedResult","msg","error","wrappedSendMessageCallback","reply","wrappedSendMessage","apiNamespaceObj","wrappedCb","staticWrappers","settingMetadata","hasChromeRuntime","componentName","mirrorToConsoleDefault","sendToDbDefault","isDbReadyForLogs","logBuffer","flushLogBuffer","eventBus","logEvent","init","compName","options","DbInitializationCompleteNotification","notification","logMode","initialLogMessage","_internalLogHelper","level","mirrorThisCall","sendThisCall","skipInitCheck","consoleArgs","formattedMessage","arg","e","logPayload","_a","currentLogSessionId","storageError","DbAddLogRequest","logDebug","logInfo","logWarn","logError","MODEL_WORKER_OFFSCREEN_PATH","logClient.init","detachedPopups","popupIdToTabId","DNR_RULE_ID_1","DNR_RULE_PRIORITY_1","modelWorkerState","workerScriptReadyPromise","workerScriptReadyResolver","workerScriptReadyRejecter","modelLoadPromise","modelLoadResolver","modelLoadRejecter","previousLogSessionId","lastLoggedProgress","initializeSessionIds","logClient.logInfo","browser","storedPreviousId","hasModelWorkerOffscreenDocument","targetUrl","setupModelWorkerOffscreenDocument","sendToModelWorkerOffscreen","logClient.logDebug","ensureWorkerScriptIsReady","logClient.logError","scriptLoadTimeout","loadModel","modelId","errorMsg","modelLoadTimeout","updateDeclarativeNetRequestRules","currentRuleIds","rule","rulesToAdd","rulesToRemove","id","forwardMessageToSidePanelOrPopup","originalSender","tabId","popupId","logClient.logWarn","tabs","tab","details","keysToRemove","DbInitializeRequest","existingPopupId","cleanupError","windowId","type","payload","isResponseAsync","currentProgress","previousState","chatId","messages","messageId","correlationId","sendResult"],"mappings":"0KAAC,SAAUA,EAAQC,EAAS,CAIxBA,EAAQC,CAAM,CAQlB,GAAG,OAAO,WAAe,IAAc,WAAa,OAAO,KAAS,IAAc,KAAOC,GAAM,SAAUD,EAAQ,CAS/G,GAAI,EAAE,WAAW,QAAU,WAAW,OAAO,SAAW,WAAW,OAAO,QAAQ,IAChF,MAAM,IAAI,MAAM,2DAA2D,EAE7E,GAAM,WAAW,SAAW,WAAW,QAAQ,SAAW,WAAW,QAAQ,QAAQ,GA6qCnFA,EAAO,QAAU,WAAW,YA7qC4D,CACxF,MAAME,EAAmD,0DAOnDC,EAAWC,GAAiB,CAIhC,MAAMC,EAAc,CAClB,OAAU,CACR,MAAS,CACP,QAAW,EACX,QAAW,CACZ,EACD,SAAY,CACV,QAAW,EACX,QAAW,CACZ,EACD,IAAO,CACL,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACvB,CACS,EACD,UAAa,CACX,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,IAAO,CACL,QAAW,EACX,QAAW,CACZ,EACD,YAAe,CACb,QAAW,EACX,QAAW,CACZ,EACD,UAAa,CACX,QAAW,EACX,QAAW,CACZ,EACD,WAAc,CACZ,QAAW,EACX,QAAW,CACZ,EACD,QAAW,CACT,QAAW,EACX,QAAW,CACZ,EACD,KAAQ,CACN,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,WAAc,CACZ,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACvB,CACS,EACD,cAAiB,CACf,QAAW,CACT,QAAW,EACX,QAAW,EACX,qBAAwB,EACzB,EACD,OAAU,CACR,QAAW,EACX,QAAW,EACX,qBAAwB,EACzB,EACD,wBAA2B,CACzB,QAAW,EACX,QAAW,CACZ,EACD,aAAgB,CACd,QAAW,EACX,QAAW,CACZ,EACD,SAAY,CACV,QAAW,EACX,QAAW,CACZ,EACD,SAAY,CACV,QAAW,EACX,QAAW,CACZ,EACD,UAAa,CACX,QAAW,EACX,QAAW,CACZ,EACD,wBAA2B,CACzB,QAAW,EACX,QAAW,EACX,qBAAwB,EACzB,EACD,aAAgB,CACd,QAAW,EACX,QAAW,EACX,qBAAwB,EACzB,EACD,QAAW,CACT,QAAW,EACX,QAAW,CACZ,EACD,SAAY,CACV,QAAW,EACX,QAAW,EACX,qBAAwB,EACzB,EACD,SAAY,CACV,QAAW,EACX,QAAW,EACX,qBAAwB,EACpC,CACS,EACD,aAAgB,CACd,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,YAAe,CACb,QAAW,EACX,QAAW,CACZ,EACD,cAAiB,CACf,QAAW,EACX,QAAW,CACZ,EACD,gBAAmB,CACjB,QAAW,EACX,QAAW,CACZ,EACD,eAAkB,CAChB,QAAW,EACX,QAAW,CACZ,EACD,cAAiB,CACf,QAAW,EACX,QAAW,CACZ,EACD,mBAAsB,CACpB,QAAW,EACX,QAAW,CACZ,EACD,gBAAmB,CACjB,QAAW,EACX,QAAW,CACZ,EACD,iBAAoB,CAClB,QAAW,EACX,QAAW,CACZ,EACD,SAAY,CACV,QAAW,EACX,QAAW,CACvB,CACS,EACD,SAAY,CACV,OAAU,CACR,QAAW,EACX,QAAW,CACvB,CACS,EACD,aAAgB,CACd,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,UAAa,CACX,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACvB,CACS,EACD,QAAW,CACT,IAAO,CACL,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,mBAAsB,CACpB,QAAW,EACX,QAAW,CACZ,EACD,OAAU,CACR,QAAW,EACX,QAAW,CACZ,EACD,IAAO,CACL,QAAW,EACX,QAAW,CACvB,CACS,EACD,SAAY,CACV,gBAAmB,CACjB,KAAQ,CACN,QAAW,EACX,QAAW,EACX,kBAAqB,EACnC,CACW,EACD,OAAU,CACR,OAAU,CACR,QAAW,EACX,QAAW,EACX,kBAAqB,EACtB,EACD,SAAY,CACV,kBAAqB,CACnB,QAAW,EACX,QAAW,CAC3B,CACA,CACA,CACS,EACD,UAAa,CACX,OAAU,CACR,QAAW,EACX,QAAW,C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","x_google_ignoreList":[0]}