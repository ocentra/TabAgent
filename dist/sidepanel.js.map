{"version":3,"file":"sidepanel.js","mappings":";;;;;;;;;AAAA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAgC,CAAC,MAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACxD,IAAI,KAAK,YAQN;AACH,CAAC;AACD;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC5I;AACA;AACA,gDAAgD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gCAAgC,MAAM;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC1I;AACA;AACA,8CAA8C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AACzI;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACxsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B;AAC9B,kCAAkC;AAClC,gCAAgC;AAChC,8BAA8B;AAC9B,iCAAiC;AACjC,+BAA+B;AAC/B;AACA,MAAM;AACN;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,gBAAgB;AACtH,qCAAqC,YAAY,8CAA8C,wCAAwC;AACvI;AACA;AACA;AACA;AACA,0GAA0G,gBAAgB;AAC1H,oGAAoG,aAAa;AACjH,kLAAkL,aAAa;AAC/L,iIAAiI,eAAe;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,YAAY,IAAI,YAAY;AAC1H,oHAAoH,YAAY,uBAAuB;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,cAAc;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,qCAAqC;AACrC,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kEAAkE,qBAAqB,wBAAwB;AAC/G;AACA;AACA,0EAA0E,qBAAqB,4BAA4B;AAC3H;AACA;AACA,oEAAoE,qBAAqB,yBAAyB;AAClH;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,sFAAsF;AACtF,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,0DAA0D;AAC1D,+DAA+D,SAAS;AACxE,cAAc;AACd;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iRAAiR;AACjR,8DAA8D;AAC9D;AACA;AACA,mEAAmE,SAAS;AAC5E,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA,kEAAkE,qBAAqB,wBAAwB;AAC/G;AACA;AACA;AACA,iEAAiE,qBAAqB,wBAAwB;AAC9G;AACA;AACA;;;;;;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3B4C;AACW;AACO;;;AAG9D;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,0BAA0B,+DAAgB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH;AACtH;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E,oBAAoB,UAAU;AAC7G;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qGAAqG,2DAA2D;AAChK;AACA;;AAEA;AACA;AACA;AACA,2IAA2I;AAC3I;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,cAAc,SAAS,6BAA6B;AACjG,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,SAAS;AAChF;AACA;;AAEA;;AAEA;AACA,yEAAyE,SAAS;AAClF;AACA;AACA;AACA;;AAEA,IAAI,oEAAe;AACnB,cAAc,sEAAmB;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA,4EAA4E,uBAAuB;AACnG;AACA;AACA,UAAU;AACV;AACA,yEAAyE,SAAS,IAAI,SAAS;AAC/F,kEAAkE,SAAS;AAC3E;AACA,gHAAgH,SAAS;AACzH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mEAAmE,kCAAkC;AACrG;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,UAAU,GAAG,OAAO;AACpF;AACA,iCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA,MAAM;AACN,qEAAqE,UAAU,GAAG,OAAO;AACzF,mDAAmD,oEAAoE;AACvH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,aAAa,GAAG,eAAe;AAC1G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,cAAc;AACxE,mFAAmF,GAAG,SAAS;;AAE/F,gCAAgC,SAAS,EAAE,WAAW,EAAE,cAAc;AACtE;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;;AAEA;AACA;AACA;AACA,oEAAoE,gBAAgB;AACpF;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,mBAAmB,GAAG,gBAAgB;AAC5G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/XA;;AAE4C;AAKb;AAC2C;AAClB;AACD;AACT;AACuB;;;;AAIrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iFAAiF,WAAW;AAC5F;AACA;;AAEA,wEAAwE,UAAU,UAAU,WAAW,iBAAiB,6BAA6B;;AAErJ;;AAEA;;AAEA;AACA;AACA,6EAA6E,WAAW;AACxF;AACA;AACA;AACA,MAAM;AACN;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+EAA+E,WAAW;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,6EAA6E,kBAAkB;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sBAAsB;AACvF,MAAM;AACN,8DAA8D,sBAAsB;AACpF;;AAEA;;AAEA;AACA;AACA,4GAA4G,kBAAkB;AAC9H;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sFAA0B;AAC1D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D,wEAAuB;AACpF;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,2EAA2E,4BAA4B;AACvG;AACA;AACA,MAAM;AACN;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA,cAAc,oEAAe,aAAa,0BAA0B;AACpE,QAAQ,0DAAU;AAClB;AACA,MAAM;AACN;AACA,QAAQ,mEAAgB;AACxB;AACA;;AAEA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA,uCAAuC,oEAAmB;AAC1D,QAAQ,mEAAgB;AACxB,MAAM;AACN;AACA,QAAQ,mEAAgB,2BAA2B,cAAc;AACjE;AACA;;AAEA;AACA;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,uEAAsB;AAC7D,QAAQ,mEAAgB;AACxB,MAAM;AACN;AACA,QAAQ,mEAAgB,2BAA2B,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,WAAW,MAAM,QAAQ;AACvF;AACA,uCAAuC,uEAAsB;AAC7D,QAAQ,mEAAgB;AACxB,MAAM;AACN;AACA,QAAQ,mEAAgB,2BAA2B,cAAc;AACjE;AACA;;AAEA;AACA;AACA,QAAQ,iFAAoB,kCAAkC,+DAAgB;AAC9E,MAAM;AACN;AACA,QAAQ,mEAAgB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,UAAU;AAClF;;AAEA;AACA,2DAA2D,oEAAmB;AAC9E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA,4FAA4F,OAAO,6BAA6B,KAAK;AACrI,SAAS;;AAET;;AAEA,MAAM;AACN,6EAA6E,UAAU;AACvF,gGAAgG,cAAc;AAC9G;AACA;;AAEA,0BAA0B,6EAA4B;AAC/C;AACP;;AAEA;AACA,0HAA0H,uBAAuB;AACjJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oEAAQ;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7T0N;AAChJ;AACL;AACd;AACC;AACV;AACS,CAAC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA,uCAAuC,oEAAmB;AAC1D,QAAQ,mEAAgB;AACxB,MAAM;AACN;AACA,QAAQ,mEAAgB,2BAA2B,cAAc;AACjE;AACA;;AAEA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA,2CAA2C,uEAAsB;AACjE,YAAY,mEAAgB;AAC5B,UAAU;AACV;AACA,YAAY,mEAAgB,2BAA2B,cAAc;AACrE;AACA;AACA;;AAEA;AACA,yDAAyD,WAAW,MAAM,QAAQ;AAClF;AACA;AACA,uCAAuC,uEAAsB;AAC7D,QAAQ,mEAAgB;AACxB,MAAM;AACN;AACA,QAAQ,mEAAgB,2BAA2B,cAAc;AACjE;AACA;;AAEA;;AAEA;AACA,QAAQ,iFAAoB,kCAAkC,+DAAgB;AAC9E,MAAM;AACN;AACA,QAAQ,mEAAgB;AACxB;AACA;;AAEA;AACA,qDAAqD,UAAU;AAC/D;AACA,yCAAyC,0BAA0B;AACnE,QAAQ,0DAAU;AAClB,MAAM;AACN;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;;AAEA;AACA,sDAAsD,UAAU;AAChE,IAAI,mEAAgB;AACpB;;AAEA;AACA,wDAAwD,UAAU;AAClE,IAAI,mEAAgB;AACpB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D,4EAA2B;AAC1F;AACA,oDAAoD,4BAA4B;AAChF;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6EAA6E,WAAW;AACxF;AACA;AACA;AACA,mEAAmE,UAAU,wBAAwB,6BAA6B;;AAElI;;AAEA;AACA;AACA,uDAAuD,WAAW;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,uDAAuD,WAAW;AAClE;AACA,UAAU;AACV,wDAAwD,WAAW;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,0BAA0B,+DAAY;;AAEtC;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4GAA4G,OAAO;AACnH;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sFAA0B;AAC1D;AACA;AACA;AACA,SAAS;AACT;AACA,iDAAiD,sBAAsB;AACvE;;AAEA,0BAA0B,oEAAQ;AAClC;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA,CAAC;;AAEM;AACP;AACA,gEAAgE;AAChE,qIAAqI,uBAAuB;AAC5J;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;AC1QA;AAC4C;AACS;AACU;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uIAAuI;;AAEvI;AACA;AACA;AACA,oEAAoE,gBAAgB;;AAEpF;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,yDAAyD,UAAU,qBAAqB,YAAY;AACpG,MAAM;AACN,qFAAqF,SAAS;AAC9F,4FAA4F,YAAY;AACxG;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAe;AAC/B;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uEAAsB;AAC9D,yCAAyC,iEAAkB;AAC3D;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5BuD;AACE;AAK1B;AAC8B;AACN;;;AAGvD;AACA;AACA;AACA,qBAAqB;AACrB,kDAAkD;;AAElD;AACA;AACA;AACA,gIAAgI,cAAc;AAC9I;AACA;AACA;AACA;AACA,mHAAmH,iBAAiB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,kBAAkB;AAChG;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kFAAkF,iBAAiB,eAAe,yBAAyB,aAAa,6BAA6B;AACrL;AACA;AACA;AACA;;AAEA,0BAA0B,8EAA6B;AACvD;AACA;AACA,CAAC;;AAED,0BAA0B,6EAA4B;AACtD;AACA;AACA,CAAC;;AAED,+DAAS;AACT;AACA;AACA;AACA;AACA,4DAA4D,aAAa,cAAc,UAAU,iBAAiB,uBAAuB;AACzI;AACA,iBAAiB,8EAA6B;AAC9C;AACA;AACA,iBAAiB,6EAA4B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa,cAAc,UAAU,iBAAiB,uBAAuB;AACnJ;AACA,qBAAqB,8EAA6B;AAClD;AACA;AACA,qBAAqB,6EAA4B;AACjD;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,gEAAgE,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oFAAoF,UAAU;AAC9F;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE,UAAU;AAC5E;AACA,4BAA4B,oEAAmB;AAC/C;;AAEA;AACA,mDAAmD,6BAA6B,eAAe,UAAU;AACzG;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV,iFAAiF,UAAU;AAC3F;AACA;AACA,MAAM;AACN,4EAA4E,UAAU;AACtF,QAAQ,qEAAS,yBAAyB,cAAc;AACxD,+GAA+G,cAAc;AAC7H;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,+DAA+D,eAAe,WAAW,kBAAkB,aAAa,sBAAsB;AAC9I;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,wFAAwF,KAAK;AACvG;AACA;;AAEA;AACA;AACA,qDAAqD,WAAW,GAAG,wCAAwC;AAC3G;AACA;AACA;;AAEA,uBAAuB,qEAAkB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6TAA6T,wBAAwB;AACrV;AACA;AACA,MAAM;AACN;AACA;;AAEA,yEAAyE,WAAW;AACpF;AACA;AACA;AACA;AACA,MAAM,wBAAwB,qEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,kCAAkC;AAClC,kCAAkC;AAClC,qCAAqC;AACrC,mCAAmC;AACnC,oCAAoC;AACpC,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,sDAAsD;AACxJ;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,wDAAwD,aAAa,GAAG;AACxE;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA,uJAAuJ,mBAAmB;AAC1K,kBAAkB;AAClB;AACA,8IAA8I,cAAc,sBAAsB,mBAAmB,eAAe,aAAa;AACjO,kBAAkB;AAClB;AACA;AACA;AACA,oDAAoD,UAAU,IAAI,0BAA0B;AAC5F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;;AAEA;AACA;AACA,mEAAmE,KAAK,KAAK,KAAK;AAClF;AACA;AACA,mDAAmD,KAAK;;AAExD;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,oHAAoH;AACpH,0GAA0G;;AAE1G;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;;AAEA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,+FAA+F;AAC/F;AACA;AACA,4BAA4B;AAC5B;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;;AAEL;AACA,4CAA4C,gCAAgC;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B,mEAAgB;AAC5C;AACA,sBAAsB;AACtB;AACA,wBAAwB,qEAAS;AACjC;AACA;AACA,cAAc;AACd;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,wBAAwB,qEAAS;AACjC;AACA;AACA;AACA,SAAS;AACT;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7oByD;;AAEzD;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,UAAU,UAAU,UAAU,UAAU,UAAU;;AAElG;AACA;AACA,QAAQ,qEAAS;AACjB;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA,SAAS,qEAAS;AAClB,MAAM;AACN;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnE4C;AACsC;AAC7B;AAatB;AAC4B;AACiB;;AAE5E;AACA;AACA;AACA,8BAA8B;;AAE9B;;AAEA;AACA;AACA;AACA,iCAAiC,iEAAkB;AACnD;AACA;AACA;AACA;AACA,cAAc;AACd,oEAAoE,mBAAmB;AACvF;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;;AAEA;AACA,YAAY,OAAO;AACnB,gFAAgF,KAAK;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mFAAmF,KAAK,cAAc,UAAU;AAChH,kBAAkB,iEAAS;;AAE3B;AACA,QAAQ,wEAAsB;AAC9B,8BAA8B;AAC9B;AACA;AACA,sCAAsC,uEAAsB;AAC5D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV,qGAAqG,WAAW;AAChH,YAAY,wEAAsB;AAClC,mCAAmC,oEAAmB;AACtD;AACA;AACA,yEAAyE,WAAW;AACpF,kCAAkC,sEAAqB;AACvD;AACA;AACA;AACA,4BAA4B,sCAAsC,KAAK;AACvE,UAAU;AACV,4BAA4B;AAC5B;AACA,uFAAuF,WAAW;AAClG,0CAA0C,oEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAe;AACtD,0BAA0B,sEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc;AACd;AACA,+CAA+C,uEAAsB;AACrE,2FAA2F,cAAc;AACzG,iBAAiB;AACjB;AACA,qCAAqC,sEAAqB;AAC1D;AACA;AACA,UAAU;AACV;AACA;AACA,sBAAsB,sEAAmB;AACzC;AACA;AACA,iCAAiC,6BAA6B;AAC9D,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA,uCAAuC,oEAAe;AACtD;AACA;AACA,kBAAkB;AAClB;AACA,2CAA2C,oEAAoE,mCAAmC;AAClJ,mDAAmD,uEAAsB;AACzE,gEAAgE;AAChE,+CAA+C,sEAAqB;AACpE,8CAA8C;AAC9C;AACA,cAAc;AACd;AACA;AACA,uCAAuC,kEAAkE,UAAU;AACnH,+CAA+C,uEAAsB;AACrE;AACA,qCAAqC,sEAAqB;AAC1D,0CAA0C;AAC1C;AACA;AACA,MAAM;AACN;AACA,QAAQ,qEAAS,WAAW,uBAAuB;AACnD;AACA,6EAA6E,WAAW;AACxF,iCAAiC,sEAAqB;AACtD,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,0BAA0B;AACtC,wEAAwE,OAAO,gBAAgB,UAAU;AACzG;AACA,gCAAgC;AAChC,kCAAkC,uEAAsB;AACxD;AACA,mFAAmF,QAAQ;AAC3F,kCAAkC,sEAAqB;AACvD;AACA,MAAM;AACN,iHAAiH,OAAO;AACxH,QAAQ,qEAAS,yCAAyC,uBAAuB;AACjF,kCAAkC,sEAAqB;AACvD;AACA,MAAM;AACN,mCAAmC;AACnC;AACA;;AAEA;AACA,sFAAsF,eAAe,gBAAgB,kBAAkB,IAAI,cAAc;AACzJ,IAAI,qEAAS,8BAA8B,cAAc,IAAI;;AAE7D,gDAAgD;;AAEhD;AACA;AACA,6FAA6F,mBAAmB,oBAAoB,WAAW;AAC/I,+BAA+B,mDAAmD,cAAc;AAChG,uCAAuC,uEAAsB;AAC7D,kCAAkC,sEAAqB;AACvD;AACA;AACA,gHAAgH,UAAU;AAC1H;AACA,4EAA4E,WAAW;AACvF,UAAU;AACV;AACA;AACA,YAAY,qEAAS,6CAA6C,gBAAgB;AAClF;AACA;AACA,4CAA4C,sEAAqB;AACjE,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN,4GAA4G,UAAU,mBAAmB,kBAAkB,+BAA+B,eAAe;AACzM;AACA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA,YAAY,oDAAoD;AAChE,qEAAqE,MAAM,YAAY,OAAO,aAAa,QAAQ;;AAEnH;AACA,8BAA8B;;AAE9B;AACA,gFAAgF,OAAO,qBAAqB,OAAO;AACnH;AACA,mDAAmD,yBAAyB,GAAG;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA,6DAA6D,MAAM;AACnE,kFAAkF,OAAO,kBAAkB,OAAO,WAAW,UAAU;AACvI,0BAA0B,mEAAmE,MAAM,KAAK,UAAU;AAClH;AACA;;AAEA;AACA;AACA,oFAAoF,WAAW,YAAY,OAAO;AAClH,kCAAkC,uEAAsB;AACxD;AACA,uFAAuF,WAAW,aAAa,OAAO;;AAEtH;AACA,mFAAmF,QAAQ,aAAa,YAAY,gBAAgB,OAAO;AAC3I,kCAAkC,sEAAqB;AACvD;;AAEA,MAAM;AACN,qGAAqG,OAAO;AAC5G,QAAQ,qEAAS,8CAA8C,2BAA2B;AAC1F;AACA;AACA;AACA,mDAAmD,sEAAqB;AACxE;AACA,eAAe;AACf;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mDAAmD;AAC/D,+EAA+E,OAAO,gBAAgB,UAAU,aAAa,QAAQ;AACrI,4BAA4B;AAC5B;AACA;AACA,qDAAqD,sCAAsC;AAC3F;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kDAAkD,0BAA0B;AAC5E;AACA;AACA,kCAAkC,uEAAsB;AACxD;AACA;AACA,0FAA0F,QAAQ,aAAa,YAAY;AAC3H,kCAAkC,sEAAqB;AACvD;AACA,MAAM;AACN,yHAAyH,OAAO;AAChI,QAAQ,qEAAS,qDAAqD,uBAAuB;AAC7F,kCAAkC,sEAAqB;AACvD;AACA,MAAM;AACN,mCAAmC;AACnC;AACA;;AAEA,0BAA0B,+DAAY;AACtC,0BAA0B,+DAAY;AACtC,0BAA0B,+DAAY;AACtC,0BAA0B,+DAAY;AACtC,0BAA0B,+DAAY;;AAE/B;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3UqF;AACzB;AAChB;AACW;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,4EAA2B;AACrD;AACA;AACA,GAAG;;AAEH;AACA,oEAAe;AACf;AACA;AACA,yBAAyB,4EAA2B;AACpD;AACA;AACA,sBAAsB,gEAAa;AACnC;AACA;AACA,sBAAsB,+DAAY;AAClC;AACA;AACA,yBAAyB,+DAAY,6CAA6C,+DAAY;AAC9F;AACA;AACA;AACA,CAAC;;AAED,+DAAS;AACT;AACA;AACA;AACA,iBAAiB,4EAA2B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+DAAY,oBAAoB,UAAU,qBAAqB;AAClH;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,+DAAY,oBAAoB,UAAU,qBAAqB;AAC9G;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,iCAAiC,kCAAkC;AACnE;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,OAAO;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,8BAA8B,UAAU;AACxC;AACA,+BAA+B,oBAAoB,KAAK,oBAAoB;AAC5E;AACA,uBAAuB,oBAAoB;AAC3C,MAAM;AACN;AACA,kBAAkB,WAAW;AAC7B,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;;;;;AAKO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kEAAkE,4BAA4B,iBAAiB,6BAA6B;;AAE5I,IAAI,wEAAsB;;AAE1B;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,yDAAyD,aAAa,GAAG,QAAQ;AACjF;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;AACA,aAAa;AACb;;AAEO;AACP,uEAAuE,UAAU;AACjF;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,gBAAgB;AAC7E;AACA,4BAA4B,qDAAqD;AACjF,2CAA2C,+DAAY,uBAAuB,UAAU,4BAA4B;AACpH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;AC/aM;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClJ4D;AACiB;AAC7E;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA,2DAA2D,oEAAmB;AAC9E;AACA;AACA;AACA;AACA,4BAA4B,uEAAgB;AAC5C,gIAAgI,GAAG;AACnI,4BAA4B,UAAU,GAAG,0BAA0B;AACnE;AACA,QAAQ,uEAAgB;AACxB;AACA,SAAS;AACT,MAAM;AACN,6EAA6E,UAAU;AACvF,4DAA4D,cAAc;AAC1E;AACA;;;;;;;;;;;;;;;;;;;;;ACpC4C;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP,eAAe,8DAAO,qBAAqB,mEAAY;AACvD;AACA;AACA;AACA,WAAW,iEAAY,SAAS,mCAAmC;AACnE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,eAAe,8DAAO,qBAAqB,mEAAY;AACvD;AACA;AACA;AACA,WAAW,iEAAY,SAAS,mCAAmC;AACnE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;;;;;;;;;;;;;;;;ACpE4D;;AAE5D;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;;AAEA;AACA;AACA,2CAA2C,qEAAkB;AAC7D,2CAA2C,qEAAkB,gCAAgC,qEAAkB;AAC/G;AACA,wDAAwD,sBAAsB;AAC9E;AACA;;AAEA;AACA,sCAAsC,0DAA0D;AAChG,6CAA6C,YAAY;AACzD,iDAAiD,YAAY;AAC7D,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,yBAAyB,kBAAkB,WAAW,YAAY,2BAA2B;AAC5G,qBAAqB,kBAAkB,mBAAmB,2BAA2B,eAAe,oBAAoB;AACxH,aAAa,gBAAgB,kCAAkC,sBAAsB;AACrF,qBAAqB;AACrB,uBAAuB,qBAAqB,kBAAkB;AAC9D,oBAAoB;AACpB,qBAAqB;AACrB,0BAA0B,uBAAuB,oBAAoB,qBAAqB,gBAAgB;AAC1G,wBAAwB,2BAA2B,cAAc,mBAAmB;AACpF,yBAAyB,2BAA2B,gBAAgB,oBAAoB;AACxF,wBAAwB,mBAAmB,gBAAgB,oBAAoB,kBAAkB;AACjG,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,sBAAsB,GAAG;AACvE,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,sBAAsB,yBAAyB,sBAAsB,GAAG;AACxE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,2BAA2B;AACtC;AACO;AACP;AACA,+CAA+C,mBAAmB;AAClE;;AAEA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2BAA2B;AAC/E,sBAAsB;AACtB;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,8EAA8E,WAAW;AACzF;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1H+C;;AAE/C;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA,4CAA4C,cAAc;AAC1D;AACA,mFAAmF,UAAU;AAC7F;;AAEA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA,4CAA4C,OAAO;AACnD;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB,kFAAkF,UAAU;AAC5F;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;;AAEA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,kBAAkB,uBAAuB;AACzC;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA,oDAAoD;AACpD;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA,sDAAsD;AACtD;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C,kCAAkC;AAClC;AACA;AACA,yBAAyB;AACzB;AACA;;AAEO;AACP,kBAAkB,wDAAY;AAC9B,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB,wDAAY;AAC5B,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChhBO;AACP;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACpMD;AAC4C;AAuDd;AACkC;AACZ;AACE;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA,oFAAoF,GAAG;AACvF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oEAAe;AACrC,uCAAuC,gBAAgB;AACvD;AACA,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR,4CAA4C,mBAAmB;AAC/D,QAAQ;AACR,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2CAA2C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,KAAK;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA,qCAAqC;AACrC,yBAAyB,0BAA0B;AACnD,GAAG;AACH;;AAEA;AACA;AACA,qEAAqE,QAAQ;AAC7E;AACA,kBAAkB,oEAAe;AACjC;AACA;AACA;AACA;AACA,QAAQ,mEAAwB;AAChC;AACA,QAAQ,sEAA2B;AACnC;AACA,QAAQ,4EAAiC;AACzC,KAAK;AACL,MAAM,8BAA8B,iEAAsB,EAAE;AAC5D,MAAM,gCAAgC,yEAA8B,EAAE;AACtE;AACA;AACA,cAAc,mFAAwC,UAAU,mFAAwC;AACxG,KAAK;AACL;AACA;AACA,MAAM,uEAAuE;AAC7E,MAAM,wCAAwC;AAC9C,MAAM,kDAAkD;AACxD,MAAM,uFAAuF;AAC7F;AACA;AACA;AACA;AACA,uBAAuB,mEAAwB;AAC/C,qBAAqB,iEAAsB;AAC3C,6BAA6B,yEAA8B;AAC3D,0BAA0B,sEAA2B;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAY,mBAAmB,+DAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,oEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,eAAe;AACf;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mBAAmB,kEAAkE,KAAK,KAAK;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,2EAA2E,KAAK;AAChF;AACA;AACA;AACA,4EAA4E,KAAK,KAAK,kBAAkB;AACxG;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA,yCAAyC,4BAA4B,mBAAmB,cAAc,mBAAmB,kBAAkB,gBAAgB,mBAAmB;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK,0BAA0B,gBAAgB;AACzF;AACA,aAAa,aAAa,cAAc,kBAAkB,iBAAiB,4BAA4B,iBAAiB,cAAc;AACtI;AACA,uDAAuD,KAAK,0BAA0B,gBAAgB;AACtG;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,uEAAsB,SAAS,gBAAgB;AAC1F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,oEAAmB,SAAS,WAAW;AAClF;AACA,aAAa,mDAAmD,WAAW;AAC3E;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,oEAAmB,SAAS,uBAAuB;AAC9F;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uEAAsB;AACjE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,uEAAsB,SAAS,sBAAsB;AAChG;AACA;AACA;AACA,0DAA0D,WAAW,eAAe,UAAU;AAC9F;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,aAAa,wDAAwD,UAAU;AAC/E;AACA,2CAA2C,sEAAqB,SAAS,8BAA8B;AACvG;AACA,aAAa,8EAA8E,UAAU;AACrG;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,oEAAmB,SAAS,mBAAmB;AAC1F;AACA,aAAa,oFAAoF,OAAO;AACxG;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,uEAAsB,SAAS,mBAAmB;AAC7F;AACA,aAAa,iEAAiE,OAAO;AACrF;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,uEAAsB;AACjE;AACA;AACA,GAAG;AACH;AACA,aAAa,iEAAiE,QAAQ,KAAK,SAAS;AACpG;AACA;AACA,WAAW;AACX;;AAEA;AACA,2CAA2C,wEAAuB;AAClE;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;AACA,2CAA2C,4EAA2B;AACtE;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;AACA,2CAA2C,iEAAgB,SAAS,SAAS;AAC7E;AACA;AACA;;AAEA;AACA,2CAA2C,4EAA2B,SAAS,WAAW;AAC1F;AACA;AACA;;AAEA;AACA,2CAA2C,mEAAkB,SAAS,oBAAoB;AAC1F;AACA,aAAa,wEAAwE;AACrF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,GAAG,uEAAsB;AACzB,GAAG,uEAAsB;AACzB,GAAG,oEAAmB;AACtB,GAAG,oEAAmB;AACtB,GAAG,uEAAsB;AACzB,GAAG,uEAAsB;AACzB,GAAG,sEAAqB;AACxB,GAAG,oEAAmB;AACtB,GAAG,wEAAuB;AAC1B,GAAG,4EAA2B;AAC9B,GAAG,uEAAsB;AACzB,GAAG,uEAAsB;AACzB,GAAG,gEAAe;AAClB,GAAG,iEAAgB;AACnB,GAAG,4EAA2B;AAC9B,GAAG,mEAAkB;AACrB,GAAG,wFAAuC;AAC1C,GAAG,uEAAsB;AACzB,GAAG,uEAAsB;AACzB,GAAG,+EAA8B;AACjC,GAAG,qFAAoC;AACvC,GAAG,wEAAuB;AAC1B,GAAG,6EAA4B;AAC/B,GAAG,4EAA2B;AAC9B,GAAG,2EAA0B;AAC7B;AACA;AACA,iBAAiB,4EAA2B;AAC5C,MAAM;AACN,iBAAiB,4EAA2B;AAC5C;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAoB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAoB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8CAA8C,uEAAsB;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAoB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,yEAAwB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,6EAA4B;AAChC;AACA;AACA;AACA,uBAAuB,kFAAkF;AACzG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,6EAA6E,kEAAiB;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6EAA4B;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAmB,oBAAoB,cAAc;AACpE,IAAI;AACJ;AACA;AACA;AACA,4DAA4D,sBAAsB;AAClF,eAAe,oEAAmB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,eAAe,yFAAwC;AACvD,IAAI;AACJ;AACA;AACA,KAAK;AACL,eAAe,yFAAwC;AACvD;AACA;;AAEA;AACA,mCAAmC,+DAAY;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,cAAc,UAAU,iBAAiB,uBAAuB,UAAU,aAAa;AAC1J,IAAI,oEAAe;AACnB,IAAI,sCAAsC,2DAAQ;AAClD;AACA,iDAAiD,kBAAkB,cAAc,UAAU,iBAAiB,uBAAuB,UAAU,aAAa;AAC1J,gEAAgE,sBAAsB;AACtF;AACA,iDAAiD,kBAAkB,cAAc,UAAU,iBAAiB,uBAAuB,UAAU,aAAa;AAC1J,IAAI,+DAAS;AACb,IAAI;AACJ;AACA,iDAAiD,kBAAkB,cAAc,UAAU,iBAAiB,uBAAuB,UAAU,aAAa;AAC1J,IAAI,+DAAS;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,wBAAwB;AACxB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY,6EAA4B;AACxC,iBAAiB,mCAAmC;AACpD;AACA;AACA,IAAI;AACJ,gFAAgF,uBAAuB;AACvG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD,6BAA6B,8EAA6B;AAC1D;AACA,IAAI;AACJ,8EAA8E,WAAW;AACzF;AACA;;AAEA;AACA;AACA,6BAA6B,4EAA2B;AACxD;AACA,IAAI;AACJ,4EAA4E,WAAW;AACvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uEAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,2CAA2C,6EAA4B,SAAS,cAAc;AAC9F;AACA;AACA;;AAEA;AACA,2CAA2C,+EAA8B;AACzE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,2CAA2C,qFAAoC,SAAS,QAAQ;AAChG;AACA;AACA;;AAEA;AACA,2CAA2C,wEAAuB,SAAS,SAAS;AACpF;AACA;AACA;;AAEA;AACA,2CAA2C,4EAA2B;AACtE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,gFAA+B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,sFAAqC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,yEAAwB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,8EAA6B;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,6EAA4B;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU,IAAI,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAe;AACf,kDAAkD,+DAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,kEAAkE;AACvF,KAAK;AACL;AACA,CAAC;;AAED;AACO;AACP;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA,IAAI;AACJ,aAAa;AACb;AACA;;AAEO;AACP;AACA;AACA,aAAa;AACb,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtpC4C;AACU;AACF;AAC0C;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,WAAW,MAAM,UAAU,QAAQ,cAAc,SAAS;AACzF,MAAM;AACN,uBAAuB,QAAQ,WAAW,MAAM;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,uEAAsB;AAC9C,gCAAgC,iEAAkB;AAClD;AACA;AACA,uBAAuB,QAAQ,gCAAgC,SAAS,MAAM,kBAAkB,QAAQ,mBAAmB;AAC3H;AACA;AACA,qBAAqB,QAAQ,8BAA8B,YAAY;AACvE;AACA;;AAEA;AACA,oBAAoB,+EAA8B,GAAG,gDAAgD;AACrG,yBAAyB,iEAAkB;AAC3C;AACA;;AAEA;AACA,wDAAwD,4BAA4B;AACpF,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA,yEAAyE,QAAQ,IAAI,iBAAiB,EAAE,oBAAoB;AAC5H,sDAAsD,gBAAgB,KAAK,oBAAoB;AAC/F;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA,MAAM;AACN,6DAA6D,QAAQ;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB,mBAAmB,QAAQ;;AAEzF;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA,UAAU;AACV,4DAA4D,IAAI;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB,IAAI,KAAK;AAC3F,cAAc;AACd,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA,KAAK;;AAEL;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kDAAkD,2DAA2D;AAC7G,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,iFAAiF,gDAAgD;AACjI;AACA,+DAA+D,6DAA6D;AAC5H;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,qDAAqD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,GAAG,SAAS;AAChD;;AAEA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA,sDAAsD,YAAY;AAClE;;AAEA;AACA;AACA,wDAAwD,QAAQ,GAAG,SAAS,IAAI,yBAAyB,EAAE,4BAA4B;AACvI;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B,QAAQ,2CAA2C,UAAU;AACvG,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;;AAEA;AACA,gEAAgE,SAAS,UAAU,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B,QAAQ,2CAA2C,UAAU;AAC3G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+EAA+E,wDAAwD;AACvI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB,QAAQ,aAAa;AACjG;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B,QAAQ,8CAA8C,UAAU;AACtH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B,QAAQ,iCAAiC,UAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE,6DAA6D;;AAEtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB,QAAQ,aAAa;AAC/F;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B,QAAQ,oDAAoD,UAAU;AACpH,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B,QAAQ,0CAA0C,UAAU;AAC1G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oGAAoG,QAAQ,GAAG,UAAU;AACzH,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qCAAqC;AACxF;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B,QAAQ,+CAA+C,UAAU;AAC/G;AACA,UAAU;AACV,oEAAoE,QAAQ,GAAG,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B,QAAQ,gDAAgD,UAAU;AAC5G;;AAEA;AACA,oCAAoC,SAAS;AAC7C;AACA,MAAM;AACN;AACA,mDAAmD,QAAQ,GAAG,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAA6B,QAAQ,uCAAuC,UAAU;AAC/F;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;;AAEA;AACA,WAAW,oEAAe;AAC1B,cAAc,+DAAY;AAC1B;AACA,KAAK,6BAA6B,QAAQ,yCAAyC,UAAU;AAC7F;;AAEO;AACP,qEAAqE,QAAQ;AAC7E,sDAAsD,QAAQ;;AAE9D;AACA;AACA,gBAAgB,4CAA4C;;AAE5D;AACA;AACA,qBAAqB,0BAA0B;AAC/C;;AAEA,gBAAgB,4DAA4D;AAC5E;AACA,0DAA0D,SAAS;AACnE;AACA,qBAAqB,0BAA0B;AAC/C;;AAEA,gBAAgB,6BAA6B;AAC7C,+DAA+D,QAAQ;AACvE,wEAAwE,QAAQ;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAA6B,QAAQ,uCAAuC,UAAU;;;AAG/F;AACA,+BAA+B,qBAAqB,aAAa,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B,QAAQ,kDAAkD,UAAU;AAC9G,qBAAqB;AACrB;;AAEA,gBAAgB,6EAA6E;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,qBAAqB,mBAAmB,QAAQ,2BAA2B,iCAAiC;AACnK;AACA;AACA,qBAAqB,qBAAqB,aAAa,SAAS;AAChE,kDAAkD,QAAQ,QAAQ,iCAAiC,KAAK,oBAAoB,kBAAkB,uBAAuB;;AAErK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAA6B,QAAQ,wCAAwC,UAAU;AAChG;AACA,iBAAiB;;AAEjB,MAAM;AACN,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA,SAAS,6BAA6B,QAAQ,4CAA4C,UAAU;AACpG,iBAAiB,sDAAsD,QAAQ,IAAI,cAAc;AACjG;AACA;;;;;;;;;;;;;;;;;ACzjBgE;AAChE,2BAA2B,2DAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA,2CAA2C,+DAAY,4BAA4B,UAAU,UAAU;AACvG,+EAA+E,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AAC4C;;;;;;;;;;;;;;;;ACjF5C;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,8BAA8B;AACzC,WAAW,QAAQ;AACnB;AACO;AACP,kCAAkC,mBAAmB,IAAI,SAAS,aAAa,SAAS;AACxF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACwB;AACW;AACS;AACW;AACA;AAKvB;AACuC;AAKxC;AAMC;AACiE;AAC3C;AACsB;AACD;AACM;AACA;AACE;AACA;AACJ;AACF;AAU7C;AAC8C;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4DAAQ;AAClB;AACA,UAAU,4DAAQ;AAClB,UAAU,4DAAQ;AAClB,IAAI;AACJ,+BAA+B,4DAAQ;AACvC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sCAAsC;AACrF,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC,+BAA+B;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,2DAAgB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAS;AACjB;AACA;AACA;AACA,IAAI,gEAAS;AACb,IAAI,gEAAS,eAAe,qCAAqC;AACjE,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,+DAAgB;AACjC;AACA,eAAe,oEAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,4DAA4D,mBAAmB;AAC/E;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oBAAoB,iEAAe;AACnC;AACA;AACA;;AAEA,iEAAU;AACV,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,oEAAe,eAAe,eAAe;AAC/C;;AAEA;AACA,EAAE,oEAAe,eAAe,MAAM,gEAAY,iCAAiC;AACnF;;AAEA;AACA;AACA;;AAEA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA,UAAU,oEAAe,aAAa,6BAA6B;AACnE,IAAI;AACJ,UAAU,oEAAe;AACzB;AACA,EAAE,yEAAoB;AACtB,EAAE,uEAAgB;AAClB;;AAEA;AACA,iCAAiC,4DAAQ;AACzC,EAAE,gEAAS;AACX,YAAY,gEAAgE;AAC5E;AACA;AACA,6BAA6B,oEAAe;AAC5C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM,gEAAS,eAAe,wDAAwD;AACtF,MAAM;AACN;AACA,MAAM,gEAAS;AACf;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA,OAAO;AACP;AACA;;AAEA,EAAE,iEAAU;AACZ,YAAY,qCAAqC;AACjD;AACA;AACA,QAAQ,oEAAgB;AACxB,QAAQ,oEAAgB;AACxB,QAAQ,oEAAgB;AACxB,QAAQ,oEAAgB;AACxB,QAAQ,oEAAgB;AACxB;AACA;AACA;AACA;AACA,iBAAiB,uEAAmB;AACpC;AACA,MAAM,iEAAU;AAChB,cAAc,uEAAmB;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,eAAe,uEAAmB;AAClC;AACA;AACA;AACA,MAAM,iEAAU;AAChB,cAAc,uEAAmB;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,kBAAkB,uEAAmB;AAC3C;AACA,MAAM,iEAAU;AAChB,cAAc,uEAAmB;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,kBAAkB,uEAAmB;AAC3C;AACA,MAAM,iEAAU;AAChB,cAAc,uEAAmB;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,kBAAkB,uEAAmB;AAC3C;AACA;AACA,MAAM,iEAAU;AAChB,cAAc,uEAAmB;AACjC,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,oBAAoB,iEAAa,kCAAkC,gEAAY;AAC/E;AACA;AACA,eAAe,yEAAqB;AACpC,gBAAgB,gEAAY;AAC5B;AACA;AACA;AACA,KAAK;AACL,IAAI,kBAAkB,yEAAqB;AAC3C,gBAAgB,gEAAY;AAC5B;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB,IAAI,kBAAkB,yEAAqB;AAC3C,gBAAgB,gEAAY;AAC5B,mBAAmB,0BAA0B;AAC7C,IAAI,kBAAkB,yEAAqB;AAC3C,gBAAgB,gEAAY;AAC5B,mBAAmB;AACnB,IAAI,kBAAkB,yEAAqB;AAC3C,gBAAgB,gEAAY;AAC5B,IAAI;AACJ,aAAa,gFAA4B;AACzC,aAAa,gEAAY;AACzB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA,wBAAwB,qEAAmB;AAC3C;AACA;AACA,oFAAoF,aAAa;AACjG;AACA,IAAI;AACJ,0EAA0E,aAAa;AACvF,IAAI,qEAAa,kDAAkD,cAAc;AACjF;AACA;;AAEA;AACA;AACA;AACA,EAAE,iEAAU;AACZ,EAAE,iEAAU;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE,IAAI,qEAAc;AAClB,IAAI;AACJ,0DAA0D,UAAU;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA,wBAAwB,qEAAmB;AAC3C;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA,+EAA+E,UAAU;AACzF;AACA,IAAI;AACJ,wDAAwD,UAAU;AAClE,IAAI,qEAAa,yBAAyB,cAAc;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,qEAAa;AACjB;AACA;AACA;AACA;AACA,2BAA2B,oEAAe;AAC1C;AACA;AACA,KAAK;AACL;AACA,YAAY,oEAAe,4BAA4B,eAAe;AACtE;AACA;AACA,4CAA4C,aAAa;AACzD,UAAU,oEAAe,aAAa,gCAAgC;AACtE,+CAA+C,kBAAkB,iBAAiB,WAAW;AAC7F,wBAAwB,oEAAe;AACvC,WAAW,oEAAe,sDAAsD,aAAa;AAC7F;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,oEAAe;AAC3B;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI,qEAAa,0BAA0B,cAAc;AACzD;AACA;;AAEA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB,QAAQ,oEAAe;AACrD;AACA,sDAAsD,cAAc;AACpE;AACA,cAAc,oEAAe;AAC7B,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,qEAAa;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA,MAAM,oEAAgB;AACtB,MAAM,oEAAgB;AACtB,MAAM,oEAAgB;AACtB,MAAM,oEAAgB;AACtB,MAAM,oEAAgB;AACtB;AACA;AACA,IAAI,iEAAU,eAAe,6DAA6D;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA,oCAAoC,2NAA8C;AAClF;AACA;AACA,MAAM;AACN;AACA;AACA,0DAA0D,aAAa,mCAAmC,YAAY;AACtH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,sEAAuB;AAChD;AACA;AACA;AACA;AACA,wBAAwB,iEAAe;AACvC;AACA;AACA;AACA,MAAM;AACN,yDAAyD,iCAAiC;AAC1F;AACA,IAAI;AACJ;AACA,IAAI,qEAAa,2BAA2B,cAAc;AAC1D;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA;;AAEA;AACA;AACA,YAAY,mEAAmE,EAAE,mEAAY;AAC7F;AACA;AACA,oBAAoB,mEAAiB;AACrC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,IAAI,yEAAkB;AACtB;;AAEA,IAAI,oEAAoB;AACxB;;AAEA,8BAA8B,gEAAY;;AAE1C,IAAI,4EAAsB;AAC1B,kBAAkB;AAClB;AACA,KAAK;AACL;;AAEA;AACA;AACA,sDAAsD,oEAAkB;AACxE,MAAM;AACN;AACA;;AAEA,4BAA4B,wEAAY;AACxC;AACA;AACA,+CAA+C,aAAa;;AAE5D,IAAI,oFAAsB;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA,IAAI,oEAAe;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,+FAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM,+FAA2B,GAAG,mCAAmC;AACvE;AACA,MAAM;AACN;AACA;;AAEA,8BAA8B,gEAAY;AAC1C,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,MAAM,oEAAe;AACrB,uBAAuB,MAAM,uEAAmB,wBAAwB,WAAW;AACnF,wEAAwE,YAAY;AACpF,KAAK;;AAEL,IAAI,iGAA4B;AAChC;;AAEA,IAAI,iGAA4B;AAChC;;AAEA,IAAI,6FAA0B;AAC9B;;AAEA,IAAI,2FAAyB;AAC7B;AACA;AACA;AACA,sBAAsB;AACtB,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA,OAAO;AACP;;AAEA;AACA,8CAA8C,uBAAuB;AACrE,2BAA2B,oEAAe;AAC1C;AACA;AACA,oEAAoE,kBAAkB;AACtF;AACA,QAAQ;AACR,8EAA8E,WAAW;AACzF;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA,IAAI,qEAAa,2BAA2B,cAAc;AAC1D;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA,CAAC;;AAED;;;;;;;UCnsBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,iCAAiC;;WAEjC;WACA;WACA;WACA,KAAK;WACL,eAAe;WACf;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;;;;;UErFA;UACA;UACA;UACA","sources":["webpack://tabagent/./node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://tabagent/./src/Components/HistoryItem.js","webpack://tabagent/./src/Controllers/DiscoverController.js","webpack://tabagent/./src/Controllers/DriveController.js","webpack://tabagent/./src/Controllers/HistoryPopupController.js","webpack://tabagent/./src/Controllers/LibraryController.js","webpack://tabagent/./src/Controllers/SettingsController.js","webpack://tabagent/./src/Controllers/SpacesController.js","webpack://tabagent/./src/Home/chatRenderer.js","webpack://tabagent/./src/Home/fileHandler.js","webpack://tabagent/./src/Home/messageOrchestrator.js","webpack://tabagent/./src/Home/uiController.js","webpack://tabagent/./src/Utilities/dbChannels.js","webpack://tabagent/./src/Utilities/dbSchema.js","webpack://tabagent/./src/Utilities/downloadUtils.js","webpack://tabagent/./src/Utilities/generalUtils.js","webpack://tabagent/./src/downloadFormatter.js","webpack://tabagent/./src/events/dbEvents.js","webpack://tabagent/./src/events/eventNames.js","webpack://tabagent/./src/minimaldb.js","webpack://tabagent/./src/modelAssetDownloader.js","webpack://tabagent/./src/navigation.js","webpack://tabagent/./src/notifications.js","webpack://tabagent/./src/sidepanel.js","webpack://tabagent/webpack/bootstrap","webpack://tabagent/webpack/runtime/compat get default export","webpack://tabagent/webpack/runtime/define property getters","webpack://tabagent/webpack/runtime/ensure chunk","webpack://tabagent/webpack/runtime/get javascript chunk filename","webpack://tabagent/webpack/runtime/global","webpack://tabagent/webpack/runtime/hasOwnProperty shorthand","webpack://tabagent/webpack/runtime/load script","webpack://tabagent/webpack/runtime/make namespace object","webpack://tabagent/webpack/runtime/publicPath","webpack://tabagent/webpack/runtime/jsonp chunk loading","webpack://tabagent/webpack/before-startup","webpack://tabagent/webpack/startup","webpack://tabagent/webpack/after-startup"],"sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n  /* vim: set sts=2 sw=2 et tw=80: */\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n  if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\n    // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n          return super.get(key);\n        }\n      }\n\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args);\n\n                // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n        });\n      };\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n            if (!(prop in target)) {\n              return undefined;\n            }\n            let value = target[prop];\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                  return target[prop];\n                },\n                set(value) {\n                  target[prop] = value;\n                }\n              });\n              return value;\n            }\n            cache[prop] = value;\n            return value;\n          },\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n            return true;\n          },\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n        };\n\n        // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n      });\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {} /* wrappers */, {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          const isResultThenable = result !== true && isThenable(result);\n\n          // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          }\n\n          // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          };\n\n          // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          }\n\n          // Let Chrome know that the listener is replying.\n          return true;\n        };\n      });\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    };\n\n    // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","// src/Components/HistoryItem.js\r\n\r\n// --- SVG Icons ---\r\nconst previewIconSvg = `<svg class=\"w-4 h-4 action-icon\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM12.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM18.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z\" /></svg>`;\r\nconst trashIconSvg = `<svg class=\"w-4 h-4 action-icon\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.5 5.5L18.8803 15.5251C18.7219 18.0864 18.6428 19.3671 17.8798 20.1818C17.1169 21 15.8356 21 13.2731 21H10.7269C8.16438 21 6.8831 21 6.12019 20.1818C5.35728 19.3671 5.27811 18.0864 5.11973 15.5251L4.5 5.5\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M3 5.5H21M16.5 5.5L16.1733 3.57923C16.0596 2.8469 15.9989 2.48073 15.8184 2.21449C15.638 1.94825 15.362 1.75019 15.039 1.67153C14.7158 1.59286 14.3501 1.59286 13.6186 1.59286H10.3814C9.64993 1.59286 9.28419 1.59286 8.96099 1.67153C8.63796 1.75019 8.36201 1.94825 8.18156 2.21449C8.00111 2.48073 7.9404 2.8469 7.82672 3.57923L7.5 5.5\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M10 10.5V15.5\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/><path d=\"M14 10.5V15.5\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/></svg>`;\r\nconst downloadIconSvg = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4 action-icon\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3\" /></svg>`;\r\nconst shareIconSvg = `<img src=\"icons/LinkChain.png\" alt=\"Share\" class=\"w-4 h-4 action-icon-img\">`;\r\n\r\n// --- Helper functions for inline editing UI ---\r\n\r\nfunction startEditing(historyItemElement) {\r\n    if (!historyItemElement) return;\r\n    const previewSpan = historyItemElement.querySelector('.history-item-preview');\r\n    const renameInput = historyItemElement.querySelector('.history-item-rename-input');\r\n\r\n    if (!previewSpan || !renameInput) return;\r\n\r\n    historyItemElement.classList.add('is-editing');\r\n    previewSpan.style.display = 'none';\r\n    renameInput.style.display = 'block';\r\n    renameInput.value = previewSpan.textContent; // Start with current preview text\r\n    renameInput.focus();\r\n    renameInput.select();\r\n}\r\n\r\nfunction cancelEditing(historyItemElement) {\r\n    if (!historyItemElement) return;\r\n    const previewSpan = historyItemElement.querySelector('.history-item-preview');\r\n    const renameInput = historyItemElement.querySelector('.history-item-rename-input');\r\n\r\n    if (!previewSpan || !renameInput) return;\r\n\r\n    renameInput.style.display = 'none';\r\n    previewSpan.style.display = 'block';\r\n    historyItemElement.classList.remove('is-editing');\r\n    // No need to reset value here as it wasn't submitted\r\n}\r\n\r\n// --- Main Component Rendering Function ---\r\n\r\nexport function renderHistoryItemComponent(props) {\r\n    const { \r\n        entry, \r\n        onStarClick = () => {}, \r\n        onDownloadClick = () => {}, \r\n        onDeleteClick = () => {}, \r\n        onLoadClick = () => {}, \r\n        onRenameSubmit = () => {}, \r\n        onShareClick = () => {}, \r\n        onPreviewClick = () => {} \r\n    } = props;\r\n\r\n    if (!entry || !entry.id) {\r\n        console.error(\"renderHistoryItemComponent: Invalid entry data provided\", entry);\r\n        return null; // Or return an error element\r\n    }\r\n\r\n    const item = document.createElement('div');\r\n    item.className = 'history-item group relative mb-2';\r\n    item.dataset.id = entry.id; \r\n    if (entry.isStarred) {\r\n        item.classList.add('starred');\r\n    }\r\n\r\n    const date = new Date(entry.timestamp);\r\n    const formattedDate = date.toLocaleString(); // Consider using Intl.DateTimeFormat for better localization\r\n    const previewText = entry.title || (entry.messages && entry.messages.length > 0 \r\n        ? (entry.messages[0].text || '').substring(0, 50) + '...' \r\n        : 'Empty chat');\r\n\r\n    const starIconSrc = entry.isStarred ? 'icons/StarFilled.png' : 'icons/StarHollow.png';\r\n    const starToggleClass = entry.isStarred ? 'starred' : 'unstarred';\r\n\r\n    item.innerHTML = `\r\n        <div class=\"chat-card bg-gray-100 dark:bg-gray-700 rounded-lg shadow p-3 flex flex-col justify-between min-h-[100px]\">\r\n            <div>\r\n                <div class=\"card-header flex justify-between items-center mb-2\">\r\n                    <button data-action=\"toggle-star\" class=\"action-button history-item-star-toggle ${starToggleClass}\" title=\"Toggle Star\">\r\n                         <img src=\"${starIconSrc}\" alt=\"Star\" class=\"w-4 h-4 action-icon-img ${entry.isStarred ? '' : 'icon-unstarred'}\">\r\n                    </button>\r\n                    <div class=\"actions flex items-center space-x-1\">\r\n                        <!-- Normal Actions (initially visible) -->\r\n                        <div class=\"normal-actions flex items-center space-x-1\" data-normal-container>\r\n                             <button data-action=\"download-chat\" class=\"action-button\" title=\"Download\">${downloadIconSvg}</button>\r\n                             <button data-action=\"share-chat\" class=\"action-button\" title=\"Share\">${shareIconSvg}</button>\r\n                             <button data-action=\"delete-chat\" class=\"action-button text-gray-500 hover:text-red-600 dark:text-gray-400 dark:hover:text-red-400\" title=\"Delete\">${trashIconSvg}</button>\r\n                             <button data-action=\"preview-chat\" class=\"action-button history-item-preview-btn\" title=\"Preview\">${previewIconSvg}</button>\r\n                        </div>\r\n                        <!-- Confirm Delete Actions (initially hidden) -->\r\n                        <div class=\"confirm-delete-actions hidden flex items-center space-x-1\" data-confirm-container>\r\n                            <span class=\"text-xs text-red-600 dark:text-red-400 mr-1\">Confirm?</span>\r\n                            <button data-action=\"confirm-delete\" class=\"action-button text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300\" title=\"Confirm Delete\">\r\n                                <svg class=\"w-4 h-4 action-icon\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 13l4 4L19 7\"></path></svg> <!-- Checkmark -->\r\n                            </button>\r\n                            <button data-action=\"cancel-delete\" class=\"action-button text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200\" title=\"Cancel Delete\">\r\n                                <svg class=\"w-4 h-4 action-icon\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6 18L18 6M6 6l12 12\"></path></svg> <!-- X mark -->\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div class=\"card-body mb-1\">\r\n                    <div class=\"history-item-preview font-semibold text-sm truncate\" title=\"${previewText}\">${previewText}</div>\r\n                    <input type=\"text\" class=\"history-item-rename-input w-full text-sm p-1 border rounded\" value=\"${previewText}\" style=\"display: none;\"/>\r\n                </div>\r\n                <div class=\"history-item-preview-content hidden mt-2 p-2 border-t border-gray-200 dark:border-gray-600 text-xs max-h-24 overflow-y-auto\">\r\n                     <!-- Preview content will be loaded here -->\r\n                </div>\r\n            </div>\r\n            <div class=\"card-footer mt-auto flex justify-between items-center\">\r\n                 <span class=\"history-item-date text-xs text-gray-500 dark:text-gray-400\">${formattedDate}</span>\r\n                 <button class=\"history-item-load-btn text-xs p-0.5 rounded\" data-action=\"load-chat\" title=\"Load Chat\">\r\n                    <img src=\"icons/Load.png\" alt=\"Load\" class=\"h-6 w-auto\">\r\n                 </button>\r\n            </div>\r\n        </div>\r\n    `;\r\n\r\n    // --- Add Event Listeners ---\r\n\r\n    const previewSpan = item.querySelector('.history-item-preview');\r\n    const renameInput = item.querySelector('.history-item-rename-input');\r\n    \r\n    // Rename UI Listeners\r\n    if (previewSpan && renameInput) {\r\n        previewSpan.addEventListener('dblclick', (e) => {\r\n            e.stopPropagation(); \r\n            startEditing(item);\r\n        });\r\n        renameInput.addEventListener('blur', () => {\r\n            // Option 1: Cancel on blur (Commented out)\r\n            // cancelEditing(item); \r\n            \r\n            // Option 2: Submit on blur (Enabled)\r\n            const newTitle = renameInput.value.trim();\r\n            const originalTitle = previewSpan.textContent;\r\n            if (newTitle && newTitle !== originalTitle) {\r\n                onRenameSubmit(entry.id, newTitle); // Call parent's submit handler\r\n                // Update the preview span immediately for responsiveness\r\n                previewSpan.textContent = newTitle;\r\n                previewSpan.title = newTitle;\r\n                cancelEditing(item); // Exit editing mode after successful submission\r\n            } else {\r\n                // If title is empty or unchanged, just cancel\r\n                cancelEditing(item); \r\n            }\r\n        });\r\n        renameInput.addEventListener('keydown', (event) => {\r\n            if (event.key === 'Enter') {\r\n                event.preventDefault();\r\n                const newTitle = renameInput.value.trim();\r\n                const originalTitle = previewSpan.textContent; \r\n                if (newTitle && newTitle !== originalTitle) {\r\n                    onRenameSubmit(entry.id, newTitle); // Call parent's submit handler\r\n                } else {\r\n                    // If title is empty or unchanged, just cancel\r\n                    cancelEditing(item);\r\n                }\r\n            } else if (event.key === 'Escape') {\r\n                 event.preventDefault();\r\n                 cancelEditing(item); // Cancel editing on Escape\r\n            }\r\n        });\r\n    }\r\n\r\n    // Action Button Listeners\r\n    const starButton = item.querySelector('[data-action=\"toggle-star\"]');\r\n    if (starButton) starButton.addEventListener('click', (e) => { e.stopPropagation(); onStarClick(entry.id); });\r\n\r\n    const downloadButton = item.querySelector('[data-action=\"download-chat\"]');\r\n    if (downloadButton) downloadButton.addEventListener('click', (e) => { e.stopPropagation(); onDownloadClick(entry.id); });\r\n    \r\n    const shareButton = item.querySelector('[data-action=\"share-chat\"]');\r\n    if (shareButton) shareButton.addEventListener('click', (e) => { e.stopPropagation(); onShareClick(entry.id); });\r\n\r\n    // --- Delete Confirmation Logic ---\r\n    const deleteButton = item.querySelector('[data-action=\"delete-chat\"]'); // Original trash icon button\r\n    const normalActionsContainer = item.querySelector('[data-normal-container]'); \r\n    const confirmActionsContainer = item.querySelector('[data-confirm-container]');\r\n    const confirmDeleteButton = item.querySelector('[data-action=\"confirm-delete\"]'); // Checkmark button\r\n    const cancelDeleteButton = item.querySelector('[data-action=\"cancel-delete\"]'); // X button\r\n\r\n    // Initial Delete Click (Trash Icon)\r\n    if (deleteButton && normalActionsContainer && confirmActionsContainer) {\r\n        deleteButton.addEventListener('click', (e) => { \r\n            e.stopPropagation(); \r\n\r\n            // Cancel editing if active\r\n            if (item.classList.contains('is-editing')) {\r\n                 cancelEditing(item); \r\n            }\r\n\r\n            // Toggle UI to show confirmation state\r\n            item.classList.add('is-confirming-delete'); // Optional class for styling parent if needed\r\n            normalActionsContainer.classList.add('hidden');\r\n            confirmActionsContainer.classList.remove('hidden');\r\n        });\r\n    }\r\n\r\n    // Cancel Delete Click (X Icon)\r\n    if (cancelDeleteButton && normalActionsContainer && confirmActionsContainer) {\r\n        cancelDeleteButton.addEventListener('click', (e) => {\r\n            e.stopPropagation();\r\n            // Revert UI to normal state\r\n            item.classList.remove('is-confirming-delete');\r\n            normalActionsContainer.classList.remove('hidden');\r\n            confirmActionsContainer.classList.add('hidden');\r\n        });\r\n    }\r\n\r\n    // Confirm Delete Click (Checkmark Icon)\r\n    if (confirmDeleteButton && normalActionsContainer && confirmActionsContainer) {\r\n        confirmDeleteButton.addEventListener('click', (e) => {\r\n            e.stopPropagation();\r\n            item.classList.remove('is-confirming-delete');\r\n            // Optionally hide confirm actions immediately? Or let controller handle full item state change.\r\n            // confirmActionsContainer.classList.add('hidden'); \r\n\r\n            // Call the actual delete handler passed from the parent\r\n            onDeleteClick(entry.id, item); // Pass item element (still needed by controller)\r\n        });\r\n    }\r\n    // --- End Delete Confirmation Logic ---\r\n    \r\n    const previewButton = item.querySelector('[data-action=\"preview-chat\"]');\r\n    const previewContentDiv = item.querySelector('.history-item-preview-content'); // Get content div reference\r\n\r\n    if (previewButton && previewContentDiv) {\r\n        previewButton.addEventListener('click', (e) => {\r\n            e.stopPropagation();\r\n            const isPreviewVisible = !previewContentDiv.classList.contains('hidden');\r\n\r\n            if (isPreviewVisible) {\r\n                // --- Hiding Preview ---\r\n                previewContentDiv.classList.add('hidden');\r\n                previewContentDiv.innerHTML = ''; // Clear content immediately on hide\r\n                item.classList.remove('preview-active');\r\n                previewButton.innerHTML = previewIconSvg; // Restore '...' icon\r\n                console.log(`HistoryItem: Hiding preview for ${entry.id}`);\r\n            } else {\r\n                // --- Showing Preview ---\r\n                // 1. Hide any other open previews (optional, but good UX)\r\n                document.querySelectorAll('.history-item.preview-active').forEach(activeItem => {\r\n                    if (activeItem !== item) { // Don't hide self\r\n                        const otherPreviewDiv = activeItem.querySelector('.history-item-preview-content');\r\n                        const otherPreviewBtn = activeItem.querySelector('[data-action=\"preview-chat\"]');\r\n                        if (otherPreviewDiv) {\r\n                            otherPreviewDiv.classList.add('hidden');\r\n                            otherPreviewDiv.innerHTML = '';\r\n                        }\r\n                        activeItem.classList.remove('preview-active');\r\n                        if (otherPreviewBtn) otherPreviewBtn.innerHTML = previewIconSvg; // Restore icon\r\n                    }\r\n                });\r\n\r\n                // 2. Update UI for *this* item (Show loading state is now handled by the controller)\r\n                item.classList.add('preview-active');\r\n                previewButton.innerHTML = '<svg class=\"w-4 h-4 action-icon\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18 18 6M6 6l12 12\" /></svg>'; // Change icon to 'X'\r\n                previewContentDiv.classList.remove('hidden'); // Make container visible\r\n\r\n                // 3. Call the handler (which will fetch data and fill contentDiv)\r\n                console.log(`HistoryItem: Requesting preview for ${entry.id}`);\r\n                onPreviewClick(entry.id, previewContentDiv); // Pass the content div\r\n            }\r\n        });\r\n    }\r\n\r\n    const loadButton = item.querySelector('[data-action=\"load-chat\"]');\r\n    if (loadButton) loadButton.addEventListener('click', (e) => { e.stopPropagation(); onLoadClick(entry.id); });\r\n\r\n    // Optional: Add listener to card body for loading if desired\r\n    const cardBody = item.querySelector('.card-body');\r\n    // if (cardBody) cardBody.addEventListener('click', (e) => { e.stopPropagation(); onLoadClick(entry.id); });\r\n\r\n    return item;\r\n} ","// src/Controllers/DiscoverController.js\r\n\r\n\r\nlet isInitialized = false;\r\n\r\nfunction handleNavigationChange(event) {\r\n    if (!isInitialized || event?.pageId !== 'page-discover') {\r\n        return; // Only act when discover page becomes active, if needed\r\n    }\r\n    console.log(\"[DiscoverController] Discover page activated.\");\r\n\r\n}\r\n\r\nexport function initializeDiscoverController(/* Pass necessary elements or functions if needed */) {\r\n    if (isInitialized) {\r\n        console.log(\"[DiscoverController] Already initialized.\");\r\n        return;\r\n    }\r\n    console.log(\"[DiscoverController] Initializing...\");\r\n    \r\n\r\n\r\n    isInitialized = true;\r\n    console.log(\"[DiscoverController] Initialized successfully.\");\r\n\r\n\r\n    return {}; \r\n} ","import browser from 'webextension-polyfill'; \nimport { showNotification } from '../notifications.js';\nimport { RuntimeMessageTypes } from '../events/eventNames.js';\n\n\nconst GOOGLE_FOLDER_MIME_TYPE = 'application/vnd.google-apps.folder';\n\nlet driveButton;\nlet driveViewerModal, driveViewerClose, driveViewerList, driveViewerCancel, driveViewerInsert, driveViewerSearch, driveViewerSelectedArea, driveViewerBreadcrumbsContainer, driveViewerBack;\nlet isDriveOpen = false;\nlet currentFolderId = 'root';\nlet currentFolderPath = [{ id: 'root', name: 'Root' }];\nlet driveFilesCache = {};\nlet selectedDriveFiles = {};\nlet isFetchingDriveList = false;\nlet driveSearchTerm = '';\nlet showNotificationDep = showNotification; \nlet debounceDep = null; \n\nfunction showDriveViewerModal() {\n    console.log(\"Attempting to show Drive modal...\");\n    if (isDriveOpen) return;\n    if (!driveViewerModal) {\n        console.error(\"DriveViewerModal element not found.\");\n        return;\n    }\n\n    console.log(\"DriveController: Showing Drive Viewer modal.\");\n    currentFolderId = 'root';\n    currentFolderPath = [{ id: 'root', name: 'Root' }];\n    selectedDriveFiles = {};\n    driveFilesCache = {};\n    driveSearchTerm = '';\n    if (driveViewerSearch) driveViewerSearch.value = '';\n    updateInsertButtonState();\n    renderSelectedFiles();\n    console.log(\"Fetching root content and making modal visible.\");\n    fetchAndDisplayViewerFolderContent('root');\n    driveViewerModal.classList.remove('hidden');\n    isDriveOpen = true;\n}\n\nfunction hideDriveViewerModal() {\n    if (!isDriveOpen) return;\n    if (!driveViewerModal) return;\n    console.log(\"DriveController: Hiding Drive Viewer modal.\");\n    driveViewerModal.classList.add('hidden');\n    isDriveOpen = false;\n    if (driveViewerList) {\n        driveViewerList.innerHTML = `<div class=\"text-center text-gray-500 dark:text-gray-400 p-4\">Loading...</div>`; // Reset list content on close\n    }\n}\n\n\nfunction getFallbackIcon(mimeType) {\n    if (mimeType === GOOGLE_FOLDER_MIME_TYPE) {\n        return '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M2.25 12.75V12A2.25 2.25 0 0 1 4.5 9.75h15A2.25 2.25 0 0 1 21.75 12v.75m-8.69-6.44-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z\" /></svg>';\n    }\n\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z\" /></svg>';\n}\n\nfunction renderDriveViewerItems(items) {\n    console.log(`[DriveController:Render] renderDriveViewerItems called with ${items?.length ?? 0} items.`); // Log entry\n    if (!driveViewerList) return;\n    driveViewerList.innerHTML = ''; \n\n    const searchTermLower = driveSearchTerm.toLowerCase();\n    const filteredItems = driveSearchTerm\n        ? items.filter(item => item.name.toLowerCase().includes(searchTermLower))\n        : items;\n\n    if (!filteredItems || filteredItems.length === 0) {\n        driveViewerList.innerHTML = `<div class=\"text-center text-gray-500 dark:text-gray-400 p-4\">${driveSearchTerm ? 'No results found.' : 'Folder is empty.'}</div>`;\n        return;\n    }\n\n    filteredItems.forEach(item => {\n        const isFolder = item.mimeType === GOOGLE_FOLDER_MIME_TYPE;\n        const itemElement = document.createElement('div');\n        itemElement.className = 'drive-viewer-item flex items-center p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded cursor-pointer'; // Tailwind classes from old code\n        itemElement.dataset.id = item.id;\n        itemElement.dataset.name = item.name;\n        itemElement.dataset.mimeType = item.mimeType;\n        itemElement.dataset.iconLink = item.iconLink || ''; \n\n        const iconDiv = document.createElement('div');\n        iconDiv.className = 'flex-shrink-0 w-6 h-6 mr-3 flex items-center justify-center';\n        if (item.iconLink) {\n            iconDiv.innerHTML = `<img src=\"${item.iconLink}\" alt=\"${isFolder ? 'Folder' : 'File'}\" class=\"w-5 h-5\">`;\n        } else {\n            iconDiv.innerHTML = getFallbackIcon(item.mimeType); \n        }\n\n        const nameSpan = document.createElement('span');\n        nameSpan.className = 'flex-grow truncate';\n        nameSpan.textContent = item.name;\n        nameSpan.title = item.name; \n\n        itemElement.appendChild(iconDiv);\n        itemElement.appendChild(nameSpan);\n\n        if (selectedDriveFiles[item.id]) {\n            itemElement.classList.add('selected'); \n        }\n\n        itemElement.addEventListener('click', handleDriveItemClick);\n\n        driveViewerList.appendChild(itemElement);\n    });\n}\n\nfunction fetchAndDisplayViewerFolderContent(folderId) {\n    if (!driveViewerList || isFetchingDriveList) {\n        return;\n    }\n\n    isFetchingDriveList = true;\n    console.log(`DriveController: Fetching Drive content for folder: ${folderId}`);\n    updateBreadcrumbs(); \n    updateHeaderState(); \n\n    driveViewerList.innerHTML = `<div class=\"text-center text-gray-500 dark:text-gray-400 p-4\">Loading...</div>`;\n\n    if (driveFilesCache[folderId]) {\n        console.log(`DriveController: Using cached content for folder: ${folderId}`);\n        renderDriveViewerItems(driveFilesCache[folderId]);\n        isFetchingDriveList = false;\n        return;\n    }\n\n    browser.runtime.sendMessage({\n        type: RuntimeMessageTypes.GET_DRIVE_FILE_LIST,\n        folderId: folderId\n    })\n    .then((response) => {\n        isFetchingDriveList = false;\n        if (response && response.success && response.files) {\n            console.log(`[DriveController] Success! Caching and rendering ${response.files.length} files.`);\n            driveFilesCache[folderId] = response.files;\n            renderDriveViewerItems(response.files);\n        } else {\n            const errorMsg = response?.error || 'Unknown error fetching files.';\n            console.error(`[DriveController] Drive file list error for ${folderId}: ${errorMsg}`);\n            showNotificationDep(`Error fetching folder content: ${errorMsg}`, 'error');\n            if (driveViewerList) {\n                driveViewerList.innerHTML = `<div class=\"text-center text-red-500 p-4\">Error loading content: ${errorMsg}</div>`;\n            }\n        }\n    })\n    .catch((error) => {\n        isFetchingDriveList = false;\n        console.error(\"[DriveController] Error sending getDriveFileList message:\", error?.message || error);\n        showNotificationDep(`Error contacting background script: ${error?.message || 'Unknown error'}`, 'error');\n        if (driveViewerList) driveViewerList.innerHTML = `<div class=\"text-center text-red-500 p-4\">Error sending request.</div>`;\n    });\n}\n\nfunction handleDriveItemClick(event) {\n    event.stopPropagation();\n    const itemElement = event.currentTarget;\n    const itemId = itemElement.dataset.id;\n    const itemName = itemElement.dataset.name;\n    const mimeType = itemElement.dataset.mimeType;\n    const iconLink = itemElement.dataset.iconLink;\n\n    if (!itemId || !mimeType) {\n        console.error(\"DriveController: Clicked Drive item missing ID or mimeType.\");\n        return;\n    }\n\n    if (mimeType === GOOGLE_FOLDER_MIME_TYPE) {\n        console.log(`DriveController: Navigating into folder: ${itemName} (${itemId})`);\n        currentFolderId = itemId;\n        currentFolderPath.push({ id: itemId, name: itemName }); \n        driveSearchTerm = ''; \n        if (driveViewerSearch) driveViewerSearch.value = '';\n        fetchAndDisplayViewerFolderContent(itemId);\n    } else {\n        console.log(`DriveController: Toggling selection for file: ${itemName} (${itemId})`);\n        toggleFileSelection(itemId, itemElement, { id: itemId, name: itemName, mimeType: mimeType, iconLink: iconLink });\n    }\n}\n\nfunction updateBreadcrumbs() {\n    if (!driveViewerBreadcrumbsContainer) return;\n    driveViewerBreadcrumbsContainer.innerHTML = '';\n    currentFolderPath.forEach((folder, index) => {\n        const crumbElement = document.createElement(index === currentFolderPath.length - 1 ? 'span' : 'button');\n        crumbElement.textContent = folder.name;\n        crumbElement.dataset.id = folder.id; \n        crumbElement.dataset.index = index; \n        if (index < currentFolderPath.length - 1) {\n            crumbElement.className = 'text-blue-600 hover:underline dark:text-blue-400 cursor-pointer'; \n            crumbElement.addEventListener('click', handleBreadcrumbClick);\n            const separator = document.createElement('span');\n            separator.textContent = ' / ';\n            separator.className = 'mx-1 text-gray-400';\n            driveViewerBreadcrumbsContainer.appendChild(crumbElement);\n            driveViewerBreadcrumbsContainer.appendChild(separator);\n        } else {\n            crumbElement.className = 'font-semibold';\n            driveViewerBreadcrumbsContainer.appendChild(crumbElement);\n        }\n    });\n}\n\nfunction handleBreadcrumbClick(event) {\n    const targetIndex = parseInt(event.currentTarget.dataset.index, 10);\n    const targetFolderId = event.currentTarget.dataset.id;\n\n    if (isNaN(targetIndex) || !targetFolderId) {\n        console.error(\"DriveController: Invalid breadcrumb data.\");\n        return;\n    }\n    if (targetFolderId === currentFolderId) return;\n\n    console.log(`DriveController: Breadcrumb click - Navigating to index ${targetIndex} (${targetFolderId})`);\n    currentFolderPath = currentFolderPath.slice(0, targetIndex + 1);\n    currentFolderId = targetFolderId; \n    driveSearchTerm = ''; \n    if (driveViewerSearch) driveViewerSearch.value = '';\n    fetchAndDisplayViewerFolderContent(targetFolderId);\n}\n\nfunction toggleFileSelection(fileId, element, fileData) {\n    if (selectedDriveFiles[fileId]) {\n        delete selectedDriveFiles[fileId];\n        element?.classList.remove('selected');\n    } else {\n        selectedDriveFiles[fileId] = fileData;\n        element?.classList.add('selected');\n    }\n    renderSelectedFiles();\n    updateInsertButtonState();\n}\n\nfunction renderSelectedFiles() {\n    if (!driveViewerSelectedArea) return;\n\n    const selectedIds = Object.keys(selectedDriveFiles);\n    const pillContainer = driveViewerSelectedArea; \n\n    if (!pillContainer) {\n         console.error(\"Selected area container not found\");\n         return;\n    }\n\n    const pillInnerContainer = pillContainer.querySelector('.flex-wrap') || pillContainer; \n    pillInnerContainer.innerHTML = ''; \n\n    if (selectedIds.length === 0) {\n        pillContainer.classList.add('hidden'); \n    } else {\n        pillContainer.classList.remove('hidden');\n        selectedIds.forEach(id => {\n            const file = selectedDriveFiles[id];\n            const pill = document.createElement('span');\n            pill.className = 'selected-file-item'; \n\n            const iconHtml = file.iconLink ? `<img src=\"${file.iconLink}\" alt=\"\" class=\"w-3 h-3 mr-1.5\">` : '';\n            const removeBtnHtml = `<button class=\"selected-file-remove\" data-id=\"${id}\">&times;</button>`;\n\n            pill.innerHTML = `${iconHtml}${file.name} ${removeBtnHtml}`;\n            pillInnerContainer.appendChild(pill);\n\n            const removeBtn = pill.querySelector('.selected-file-remove');\n            removeBtn?.addEventListener('click', handleRemoveSelectedFile);\n        });\n    }\n}\n\n\nfunction handleRemoveSelectedFile(event) {\n    const fileId = event.currentTarget.dataset.id;\n    if (fileId && selectedDriveFiles[fileId]) {\n        delete selectedDriveFiles[fileId];\n        renderSelectedFiles();\n        updateInsertButtonState();\n        const listItem = driveViewerList?.querySelector(`.drive-viewer-item[data-id=\"${fileId}\"]`);\n        listItem?.classList.remove('selected');\n    }\n}\n\nfunction updateInsertButtonState() {\n    if (!driveViewerInsert) return;\n    const count = Object.keys(selectedDriveFiles).length;\n    driveViewerInsert.disabled = count === 0;\n    driveViewerInsert.textContent = `Insert (${count})`;\n}\n\nlet debouncedDriveSearchHandler = null;\nfunction handleDriveSearchInput(event) {\n    driveSearchTerm = event.target.value.trim();\n    console.log(`DriveController: Filtering Drive items by term: \"${driveSearchTerm}\"`);\n    if (driveFilesCache[currentFolderId]) {\n        renderDriveViewerItems(driveFilesCache[currentFolderId]);\n    } else {\n        driveViewerList.innerHTML = `<div class=\"text-center text-gray-500 dark:text-gray-400 p-4\">Folder not loaded or empty.</div>`;\n    }\n}\n\nfunction handleDriveBackButtonClick() {\n    if (currentFolderPath.length <= 1) return; \n\n    const parentFolder = currentFolderPath[currentFolderPath.length - 2]; \n    currentFolderPath.pop();\n    currentFolderId = parentFolder.id; \n    console.log(`DriveController: Back button click - Navigating to ${parentFolder.name} (${parentFolder.id})`);\n    driveSearchTerm = ''; \n    if (driveViewerSearch) driveViewerSearch.value = '';\n    fetchAndDisplayViewerFolderContent(parentFolder.id);\n}\n\nfunction updateHeaderState() {\n    if (!driveViewerBack) return;\n    if (currentFolderPath.length > 1) {\n        driveViewerBack.classList.remove('hidden');\n    } else {\n        driveViewerBack.classList.add('hidden');\n    }\n}\n\nexport function initializeDriveController(dependencies) {\n    console.log(\"Initializing DriveController...\");\n\n    if (!dependencies || !dependencies.showNotification || !dependencies.debounce) {\n        console.error(\"DriveController requires dependencies: showNotification, debounce!\");\n        return; \n    }\n    showNotificationDep = dependencies.showNotification;\n    debounceDep = dependencies.debounce;\n    driveButton = document.getElementById('drive-button');\n    driveViewerModal = document.getElementById('drive-viewer-modal');\n    driveViewerClose = document.getElementById('drive-viewer-close');\n    driveViewerList = document.getElementById('drive-viewer-list');\n    driveViewerCancel = document.getElementById('drive-viewer-cancel');\n    driveViewerInsert = document.getElementById('drive-viewer-insert');\n    driveViewerSearch = document.getElementById('drive-viewer-search');\n    driveViewerSelectedArea = document.getElementById('drive-viewer-selected');\n    driveViewerBreadcrumbsContainer = document.getElementById('drive-viewer-breadcrumbs');\n    driveViewerBack = document.getElementById('drive-viewer-back');\n\n    if (!driveViewerModal || !driveViewerList) {\n        console.error(\"DriveController: Essential modal elements (#drive-viewer-modal, #drive-viewer-list) not found!\");\n        return; \n    }\n\n    if (driveButton) {\n        driveButton.addEventListener('click', handleDriveButtonClick);\n    }\n    if (driveViewerClose) {\n        driveViewerClose.addEventListener('click', hideDriveViewerModal);\n    }\n    if (driveViewerCancel) {\n        driveViewerCancel.addEventListener('click', hideDriveViewerModal);\n    }\n    if (driveViewerInsert) {\n        driveViewerInsert.addEventListener('click', () => {\n            console.warn(\"Insert button functionality not yet implemented.\");\n            // Placeholder: Insert selected files into chat\n            // You'll need access to the chat input/send mechanism here\n            hideDriveViewerModal();\n        });\n    }\n    if (driveViewerSearch && debounceDep) {\n         driveViewerSearch.addEventListener('input', debounceDep(handleDriveSearchInput, 300));\n     } else if (driveViewerSearch) {\n         console.warn(\"Debounce dependency missing, search will trigger on every keypress.\");\n         driveViewerSearch.addEventListener('input', handleDriveSearchInput);\n     }\n    if (driveViewerBack) {\n        driveViewerBack.addEventListener('click', handleDriveBackButtonClick);\n    }\n\n    console.log(\"DriveController Initialized successfully.\");\n}\n\n\nconst handleDriveButtonClick = (event) => {\n    console.log(\"Drive button clicked!\");\n    event.stopPropagation(); \n    showDriveViewerModal();\n};\n\n","// src/Controllers/HistoryPopupController.js\n\nimport browser from 'webextension-polyfill';\nimport { \n    DbGetAllSessionsRequest, \n    DbToggleStarRequest, DbDeleteSessionRequest, DbRenameSessionRequest, DbGetSessionRequest,    \n    DbSessionUpdatedNotification,\n} from '../events/dbEvents.js';\nimport { renderHistoryItemComponent } from '../Components/HistoryItem.js';\nimport { debounce } from '../Utilities/generalUtils.js';\nimport { showNotification } from '../notifications.js';\nimport { navigateTo } from '../navigation.js';\nimport { initiateChatDownload } from '../Utilities/downloadUtils.js';\n\n\n\nlet isInitialized = false;\nlet historyPopupElement = null;\nlet historyListElement = null;\nlet historySearchElement = null;\nlet closeHistoryButtonElement = null;\nlet requestDbAndWaitFunc = null;\n\nlet currentHistoryItems = []; \nlet currentSearchTerm = '';\n\nfunction handleSessionUpdate(notification) {\n    if (!isInitialized || !notification || !notification.payload || !notification.payload.session) {\n        console.warn(\"[HistoryPopupController] Invalid session update notification received.\", notification);\n        return;\n    }\n\n    const updatedSessionData = notification.payload.session; \n    const sessionId = updatedSessionData.id;\n    const updateType = notification.payload.updateType || 'update'; \n\n    if (!updatedSessionData) {\n        console.warn(`[HistoryPopupController] Session update notification for ${sessionId} missing session data.`, notification);\n        return;\n    }\n\n    console.log(`[HistoryPopupController] Received session update for ${sessionId}. Type: ${updateType}, New starred: ${updatedSessionData.isStarred}`);\n\n    const itemIndex = currentHistoryItems.findIndex(item => item.id === sessionId); \n\n    let listChanged = false;\n\n    if (updateType === 'delete') {\n        if (itemIndex !== -1) {\n            console.log(`[HistoryPopupController] Removing deleted session ${sessionId} from local list.`);\n            currentHistoryItems.splice(itemIndex, 1);\n            listChanged = true;\n        }\n    } else {\n        if (itemIndex !== -1) {\n            console.log(`[HistoryPopupController] Updating session ${sessionId} in local list.`);\n            currentHistoryItems[itemIndex] = { \n                ...currentHistoryItems[itemIndex], \n                ...updatedSessionData\n            };\n            listChanged = true; \n        } else {\n            console.log(`[HistoryPopupController] Adding new/updated session ${sessionId} to local list.`);\n            currentHistoryItems.push(updatedSessionData); \n            listChanged = true;\n        }\n    }\n\n    if (listChanged && historyPopupElement && !historyPopupElement.classList.contains('hidden')) {\n        console.log(`[HistoryPopupController] Popup visible and list changed, calling renderHistoryList()`);\n        renderHistoryList(); \n    } else {\n        console.log(`[HistoryPopupController] Popup not visible or list unchanged, skipping renderHistoryList()`);\n    }\n}\n\nfunction renderHistoryList() {\n    if (!isInitialized || !historyListElement) return;\n    console.log(`[HistoryPopupController] Rendering history list (Search: \"${currentSearchTerm}\")...`);\n\n    let filteredItems = currentHistoryItems;\n    if (currentSearchTerm) {\n        const lowerCaseTerm = currentSearchTerm.toLowerCase();\n        filteredItems = currentHistoryItems.filter(entry => \n            (entry.name || '').toLowerCase().includes(lowerCaseTerm)\n        );\n        console.log(`[HistoryPopupController] Filtered down to ${filteredItems.length} sessions.`);\n    } else {\n        console.log(`[HistoryPopupController] Rendering all ${filteredItems.length} sessions (no search term).`);\n    }\n\n    historyListElement.innerHTML = ''; \n\n    if (filteredItems.length === 0) {\n        const message = currentSearchTerm\n            ? `<p class=\"p-4 text-center text-gray-500 dark:text-gray-400 italic\">No history items match \"${currentSearchTerm}\".</p>`\n            : '<p class=\"p-4 text-center text-gray-500 dark:text-gray-400 italic\">No chat history yet.</p>';\n        historyListElement.innerHTML = message;\n    } else {\n        filteredItems.forEach(entry => {\n            const props = {\n                entry: {\n                    id: entry.id,\n                    name: entry.title,\n                    title: entry.title,\n                    timestamp: entry.timestamp,\n                    isStarred: entry.isStarred,\n                    messages: [] \n                },\n                onLoadClick: handleLoadClick,\n                onStarClick: handleStarClick,\n                onDeleteClick: handleDeleteClick,\n                onRenameSubmit: handleRenameSubmit,\n                onDownloadClick: handleDownloadClick,\n                onShareClick: handleShareClick,\n                onPreviewClick: handlePreviewClick\n            };\n            const itemElement = renderHistoryItemComponent(props);\n            if (itemElement) {\n                historyListElement.appendChild(itemElement);\n            }\n        });\n    }\n    console.log(\"[HistoryPopupController] History list rendered.\");\n}\n\nasync function showPopup() { \n    if (!isInitialized || !historyPopupElement || !requestDbAndWaitFunc) return;\n    console.log(\"[Trace][HistoryPopupController] showPopup: Requesting all sessions...\");\n    try {\n        const sessionsArray = await requestDbAndWaitFunc(new DbGetAllSessionsRequest());\n        console.log(\"[Trace][HistoryPopupController] showPopup: Received sessionsArray:\", sessionsArray);\n        if (Array.isArray(sessionsArray) && sessionsArray.length > 0) {\n             console.log(\"[Trace][HistoryPopupController] showPopup: First session item sample:\", sessionsArray[0]);\n        } else if (sessionsArray === null || sessionsArray === undefined) {\n             console.log(\"[Trace][HistoryPopupController] showPopup: sessionsArray is null or undefined.\");\n        } else {\n             console.log(\"[Trace][HistoryPopupController] showPopup: sessionsArray is empty or not an array:\", typeof sessionsArray);\n        }\n        currentHistoryItems = sessionsArray || []; \n        console.log(`[Trace][HistoryPopupController] showPopup: Assigned ${currentHistoryItems.length} sessions to currentHistoryItems.`);\n        renderHistoryList(); \n        historyPopupElement.classList.remove('hidden');\n    } catch (error) {\n        console.error(\"[Trace][HistoryPopupController] showPopup: Error fetching history list:\", error);\n        showNotification(\"Failed to load history.\", 'error');\n        if (historyListElement) {\n            historyListElement.innerHTML = '<p class=\"p-4 text-center text-red-500 dark:text-red-400\">Error loading history. Please try again.</p>';\n        }\n        historyPopupElement.classList.remove('hidden'); \n    }\n}\n\nfunction hidePopup() {\n    if (!isInitialized || !historyPopupElement) return;\n    console.log(\"[HistoryPopupController] Hiding popup.\");\n    historyPopupElement.classList.add('hidden');\n}\n\nfunction handleSearchInput(event) {\n    if (!isInitialized) return;\n    currentSearchTerm = event.target.value.trim();\n    renderHistoryList(); \n}\n\n\nasync function handleLoadClick(sessionId) {\n    console.log(`[HistoryPopupController] Load clicked: ${sessionId}`);\n    if (!sessionId) return;\n    try {\n        await browser.storage.local.set({ lastSessionId: sessionId });\n        navigateTo('page-home');\n        hidePopup();\n    } catch (error) {\n        console.error(\"[HistoryPopupController] Error setting storage or navigating:\", error);\n        showNotification(\"Failed to load chat.\", 'error');\n    }\n}\n\nasync function handleStarClick(sessionId) {\n    if (!sessionId || !requestDbAndWaitFunc) return;\n    console.log(`[HistoryPopupController] Star clicked: ${sessionId}`);\n    try {\n        await requestDbAndWaitFunc(new DbToggleStarRequest(sessionId));\n        showNotification(\"Star toggled\", 'success');\n    } catch (error) {\n        console.error(\"[HistoryPopupController] Error toggling star:\", error);\n        showNotification(`Failed to toggle star: ${error.message}`, 'error');\n    }\n}\n\nasync function handleDeleteClick(sessionId, itemElement) {\n    if (!sessionId || !itemElement || !requestDbAndWaitFunc) return;\n    console.log(`[HistoryPopupController] Delete confirmed inline for: ${sessionId}. Applying deleting state.`);\n    \n    itemElement.classList.add('is-deleting'); \n    itemElement.querySelectorAll('button').forEach(btn => btn.disabled = true);\n\n    const footer = itemElement.querySelector('.card-footer');\n    const existingMsg = footer?.querySelector('.deleting-message'); \n    if (footer && !existingMsg) { \n        const deletingMsg = document.createElement('span');\n        deletingMsg.textContent = 'Deleting...';\n        deletingMsg.className = 'text-xs text-red-500 ml-2 deleting-message';\n        footer.appendChild(deletingMsg);\n    }\n\n    try {\n        await requestDbAndWaitFunc(new DbDeleteSessionRequest(sessionId));\n        showNotification(\"Chat deletion initiated...\", 'info'); \n    } catch (error) {\n        console.error(\"[HistoryPopupController] Error deleting chat:\", error);\n        showNotification(`Failed to delete chat: ${error.message}`, 'error');\n        itemElement.classList.remove('is-deleting'); \n        itemElement.querySelectorAll('button').forEach(btn => btn.disabled = false);\n        footer?.querySelector('.deleting-message')?.remove();\n        const normalActionsContainer = itemElement.querySelector('[data-normal-container]');\n        if(normalActionsContainer) normalActionsContainer.classList.remove('hidden');\n        const confirmActionsContainer = itemElement.querySelector('[data-confirm-container]');\n        if(confirmActionsContainer) confirmActionsContainer.classList.add('hidden');\n    }\n}\n\nasync function handleRenameSubmit(sessionId, newName) {\n    if (!sessionId || !newName || !requestDbAndWaitFunc) return;\n    console.log(`[HistoryPopupController] Rename submitted: ${sessionId} to \"${newName}\"`);\n    try {\n        await requestDbAndWaitFunc(new DbRenameSessionRequest(sessionId, newName));\n        showNotification(\"Rename successful\", 'success');\n    } catch (error) {\n        console.error(\"[HistoryPopupController] Error submitting rename:\", error);\n        showNotification(`Failed to rename chat: ${error.message}`, 'error');\n    }\n}\n\nasync function handleDownloadClick(sessionId) {\n    if (requestDbAndWaitFunc) {\n        initiateChatDownload(sessionId, requestDbAndWaitFunc, showNotification);\n    } else {\n        console.error(\"[HistoryPopupController] Cannot download: requestDbAndWaitFunc not available.\");\n        showNotification(\"Download failed: Internal setup error.\", 'error');\n    }\n}\n\nfunction handleShareClick(sessionId) {\n   \n}\n\nasync function handlePreviewClick(sessionId, contentElement) {\n    if (!sessionId || !contentElement || !requestDbAndWaitFunc) {\n        console.error(\"[HistoryPopupController] Preview failed: Missing sessionId, contentElement, or requestDbAndWaitFunc.\");\n        return;\n    }\n    \n    console.log(`[HistoryPopupController] Handling preview click for: ${sessionId}`);\n    contentElement.innerHTML = '<span class=\"text-gray-500 dark:text-gray-400 italic text-xs\">Loading preview...</span>'; \n\n    try {\n        const sessionData = await requestDbAndWaitFunc(new DbGetSessionRequest(sessionId));\n        \n        if (!sessionData || !sessionData.messages || sessionData.messages.length === 0) {\n            contentElement.innerHTML = '<span class=\"text-gray-500 dark:text-gray-400 text-xs\">No messages in this chat.</span>';\n            return;\n        }\n\n        const messagesToPreview = sessionData.messages.slice(0, 3);\n\n        const previewHtml = messagesToPreview.map(msg => {\n            const sender = msg.sender === 'user' ? 'You' : (msg.sender === 'ai' ? 'Agent' : 'System');\n            const text = (msg.text || '')\n                         .replace(/</g, \"&lt;\")\n                         .replace(/>/g, \"&gt;\")\n                         .substring(0, 100) + (msg.text && msg.text.length > 100 ? '...' : '');\n            return `<div class=\"preview-message mb-1 last:mb-0\"><span class=\"font-medium\">${sender}:</span><span class=\"ml-1\">${text}</span></div>`;\n        }).join('');\n\n        contentElement.innerHTML = previewHtml; \n\n    } catch (error) {\n        console.error(`[HistoryPopupController] Error fetching preview for ${sessionId}:`, error);\n        contentElement.innerHTML = `<span class=\"text-red-500 text-xs\">Error loading preview: ${error.message}</span>`;\n    }\n}\n\ndocument.addEventListener(DbSessionUpdatedNotification.type, (e) => handleSessionUpdate(e.detail));\nexport function initializeHistoryPopup(elements, requestFunc) {\n    console.log(\"[HistoryPopupController] Entering initializeHistoryPopup...\");\n\n    if (!elements || !elements.popupContainer || !elements.listContainer || !elements.searchInput || !elements.closeButton || !requestFunc) {\n        console.error(\"[HistoryPopupController] Initialization failed: Missing required elements or request function.\", { elements, requestFunc });\n        return null;\n    }\n\n    historyPopupElement = elements.popupContainer;\n    historyListElement = elements.listContainer;\n    historySearchElement = elements.searchInput;\n    closeHistoryButtonElement = elements.closeButton;\n    requestDbAndWaitFunc = requestFunc;\n    console.log(\"[HistoryPopupController] Elements and request function assigned.\");\n\n    try {\n        closeHistoryButtonElement.addEventListener('click', hidePopup);\n        const debouncedSearchHandler = debounce(handleSearchInput, 300);\n        historySearchElement.addEventListener('input', debouncedSearchHandler);\n        \n        isInitialized = true;\n        console.log(\"[HistoryPopupController] Initialization successful. History will be rendered when popup is shown.\");\n\n        return {\n            show: showPopup,\n            hide: hidePopup\n        };\n    } catch (error) {\n        console.error(\"[HistoryPopupController] Error during initialization listeners/subscriptions:\", error);\n        isInitialized = false;\n        return null; \n    }\n}\n","import { DbGetStarredSessionsRequest, DbGetStarredSessionsResponse, DbSessionUpdatedNotification, DbToggleStarRequest, DbDeleteSessionRequest, DbRenameSessionRequest, DbGetSessionRequest } from '../events/dbEvents.js';\nimport { renderHistoryItemComponent } from '../Components/HistoryItem.js';\nimport { initiateChatDownload } from '../Utilities/downloadUtils.js'; \nimport { showNotification } from '../notifications.js'; \nimport { debounce } from '../Utilities/generalUtils.js'; \nimport { navigateTo } from '../navigation.js'; \nimport { UIEventNames } from '../events/eventNames.js'; // Adjust path if necessary\n\nlet isInitialized = false;\nlet starredListElement = null;\nlet librarySearchInput = null; \nlet requestDbAndWaitFunc = null; \nlet currentStarredItems = [];\nlet currentSearchFilter = ''; \nlet searchListenerAttached = false; \n\n\nasync function handleStarClick(sessionId) {\n    console.log(`[LibraryController] Star clicked: ${sessionId}`);\n    if (!requestDbAndWaitFunc) return;\n    try {\n        await requestDbAndWaitFunc(new DbToggleStarRequest(sessionId));\n        showNotification(\"Star toggled\", 'success');\n    } catch (error) {\n        console.error(\"[LibraryController] Error toggling star:\", error);\n        showNotification(`Failed to toggle star: ${error.message}`, 'error');\n    }\n}\n\nasync function handleDeleteClick(sessionId) {\n    console.log(`[LibraryController] Delete clicked: ${sessionId}`);\n    if (!requestDbAndWaitFunc) return;\n    if (confirm('Are you sure you want to delete this chat history item? This cannot be undone.')) {\n        try {\n            await requestDbAndWaitFunc(new DbDeleteSessionRequest(sessionId));\n            showNotification(\"Chat deleted\", 'success');\n        } catch (error) {\n            console.error(\"[LibraryController] Error deleting chat:\", error);\n            showNotification(`Failed to delete chat: ${error.message}`, 'error');\n        }\n    }\n}\n\nasync function handleRenameSubmit(sessionId, newName) {\n    console.log(`[LibraryController] Rename submitted: ${sessionId} to \"${newName}\"`);\n    if (!requestDbAndWaitFunc) return;\n    try {\n        await requestDbAndWaitFunc(new DbRenameSessionRequest(sessionId, newName));\n        showNotification(\"Rename successful\", 'success');\n    } catch (error) {\n        console.error(\"[LibraryController] Error submitting rename:\", error);\n        showNotification(`Failed to rename chat: ${error.message}`, 'error');\n    }\n}\n\nasync function handleDownloadClick(sessionId) {\n\n    if (requestDbAndWaitFunc) {\n        initiateChatDownload(sessionId, requestDbAndWaitFunc, showNotification);\n    } else {\n        console.error(\"[LibraryController] Cannot download: requestDbAndWaitFunc not available.\");\n        showNotification(\"Download failed: Internal setup error.\", 'error');\n    }\n}\n\nasync function handleLoadClick(sessionId) {\n    console.log(`[LibraryController] Load clicked: ${sessionId}`);\n    try {\n        await chrome.storage.local.set({ lastSessionId: sessionId });\n        navigateTo('page-home'); \n    } catch (error) {\n        console.error(\"[LibraryController] Error setting storage or navigating:\", error);\n        showNotification(\"Failed to load chat.\", 'error');\n        await chrome.storage.local.remove('lastSessionId');\n    }\n}\n\nfunction handleShareClick(sessionId) {\n    console.log(`[LibraryController] Share clicked: ${sessionId}`);\n    showNotification(\"Share functionality not yet implemented.\", 'info');\n}\n\nfunction handlePreviewClick(sessionId, contentElement) {\n    console.log(`[LibraryController] Preview clicked: ${sessionId}`);\n    showNotification(\"Preview functionality not yet implemented.\", 'info');\n    if (contentElement) {\n        contentElement.innerHTML = 'Preview loading...';\n        contentElement.classList.toggle('hidden');\n    }\n}\n\n\n\nfunction handleNavigationChange(event) {\n    if (!isInitialized || event?.pageId !== 'page-library') {\n        return; \n    }\n    console.log(\"[LibraryController] Library page activated.\");\n\n    if (!searchListenerAttached) {\n        librarySearchInput = document.getElementById('library-search');\n        if (librarySearchInput) {\n            librarySearchInput.addEventListener('input', handleSearchInput);\n            searchListenerAttached = true;\n            console.log(\"[LibraryController] Search input listener attached.\");\n        } else {\n            console.warn(\"[LibraryController] Library search input (#library-search) still not found even when page is active.\");\n        }\n    }\n    \n    fetchAndRenderLibrary(); \n}\n\nasync function fetchAndRenderLibrary() {\n    if (!isInitialized || !starredListElement || !requestDbAndWaitFunc) {\n        console.error(\"[LibraryController] Cannot fetch/render - not initialized or missing elements/functions.\");\n        return;\n    }\n    console.log(\"[LibraryController] Fetching starred items...\");\n    starredListElement.innerHTML = '<p class=\"p-4 text-center text-gray-500 dark:text-gray-400 italic\">Loading starred items...</p>';\n    currentSearchFilter = librarySearchInput?.value.trim() || ''; \n\n    try {\n        const responsePayload = await requestDbAndWaitFunc(new DbGetStarredSessionsRequest());\n        currentStarredItems = Array.isArray(responsePayload) ? responsePayload : (responsePayload?.sessions || []); \n        console.log(`[LibraryController] Received ${currentStarredItems.length} starred items.`);\n        renderLibraryList(currentSearchFilter); \n    } catch (error) {\n        console.error(\"[LibraryController] Error fetching starred items:\", error);\n        starredListElement.innerHTML = '<div class=\"p-4 text-red-500\">Error loading starred items.</div>';\n    }\n}\n\nfunction handleSessionUpdate(notification) {\n    if (!isInitialized || !notification || !notification.payload || !notification.payload.session) {\n        console.warn(\"[LibraryController] Invalid session update notification received.\", notification);\n        return;\n    }\n\n    const updatedSessionData = notification.payload.session; \n    const sessionId = updatedSessionData.id;\n\n    if (!updatedSessionData) {\n         console.warn(`[LibraryController] Session update notification for ${sessionId} missing session data in payload.session.`, notification);\n         return;\n    }\n    \n    console.log(`[LibraryController] Received session update for ${sessionId}. New starred status: ${updatedSessionData.isStarred}`);\n\n    const itemIndex = currentStarredItems.findIndex(item => item.sessionId === sessionId); \n\n    if (updatedSessionData.isStarred) {\n        if (itemIndex === -1) {\n            console.log(`[LibraryController] Session ${sessionId} is newly starred. Adding to list.`);\n\n             const newItem = {\n                 sessionId: sessionId,\n                 name: updatedSessionData.title || 'Untitled', \n                 lastUpdated: updatedSessionData.timestamp || Date.now(), \n                 isStarred: true\n             };\n             currentStarredItems.push(newItem);\n        } else {\n            console.log(`[LibraryController] Session ${sessionId} was already starred. Updating data.`);\n            currentStarredItems[itemIndex] = {\n                ...currentStarredItems[itemIndex], \n                name: updatedSessionData.title || currentStarredItems[itemIndex].name, \n                lastUpdated: updatedSessionData.timestamp || currentStarredItems[itemIndex].lastUpdated, \n                isStarred: true\n            };\n        }\n    } else {\n        if (itemIndex !== -1) {\n            console.log(`[LibraryController] Session ${sessionId} is no longer starred. Removing from list.`);\n            currentStarredItems.splice(itemIndex, 1);\n        } else {\n             console.log(`[LibraryController] Session ${sessionId} is not starred and was not in the list.`);\n        }\n    }\n\n    const libraryPage = document.getElementById('page-library');\n    if (libraryPage && !libraryPage.classList.contains('hidden')) {\n        console.log(\"[LibraryController] Library page is active, re-rendering list with filter.\");\n        currentSearchFilter = librarySearchInput?.value.trim() || '';\n        renderLibraryList(currentSearchFilter);\n    } else {\n        console.log(\"[LibraryController] Library page not active, internal list updated passively.\");\n    }\n}\n\ndocument.addEventListener(UIEventNames.NAVIGATION_PAGE_CHANGED, (e) => handleNavigationChange(e.detail));\n\nfunction renderLibraryList(filter = '') {\n    if (!isInitialized || !starredListElement) return;\n    console.log(`[LibraryController] Rendering with filter \"${filter}\"`);\n    \n    let itemsToRender = [...currentStarredItems];\n\n    if (filter) {\n        const searchTerm = filter.toLowerCase();\n        itemsToRender = itemsToRender.filter(entry =>\n            (entry.name || '').toLowerCase().includes(searchTerm)\n        );\n    }\n\n    itemsToRender.sort((a, b) => b.lastUpdated - a.lastUpdated);\n\n    starredListElement.innerHTML = ''; \n\n    if (itemsToRender.length === 0) {\n        const message = filter\n            ? `<p class=\"p-4 text-center text-gray-500 dark:text-gray-400 italic\">No starred items match \"${filter}\".</p>`\n            : '<p class=\"p-4 text-center text-gray-500 dark:text-gray-400 italic\">No starred items yet.</p>';\n        starredListElement.innerHTML = message;\n    } else {\n        itemsToRender.forEach(entry => {\n            const props = {\n                entry: {\n                    id: entry.sessionId,\n                    name: entry.name,\n                    title: entry.name,\n                    timestamp: entry.lastUpdated,\n                    isStarred: entry.isStarred,\n                    messages: [] \n                },\n                onLoadClick: handleLoadClick,\n                onStarClick: handleStarClick,\n                onDeleteClick: handleDeleteClick,\n                onRenameSubmit: handleRenameSubmit,\n                onDownloadClick: handleDownloadClick,\n                onShareClick: handleShareClick, \n                onPreviewClick: handlePreviewClick \n            };\n            const itemElement = renderHistoryItemComponent(props);\n            if (itemElement) {\n                starredListElement.appendChild(itemElement);\n            }\n        });\n    }\n     console.log(`[LibraryController] Rendered ${itemsToRender.length} items.`);\n}\n\nconst handleSearchInput = debounce((event) => {\n    if (!isInitialized) return;\n    currentSearchFilter = event.target.value.trim();\n    console.log(`[LibraryController] Search input changed: \"${currentSearchFilter}\"`);\n    renderLibraryList(currentSearchFilter);\n}, 300);\n\nexport function initializeLibraryController(elements, requestFunc) {\n    console.log(\"[LibraryController] Initializing...\");\n    if (!elements || !elements.listContainer || !requestFunc) { // Removed searchInput from mandatory checks here, handled in navigation\n        console.error(\"[LibraryController] Initialization failed: Missing required elements (listContainer) or request function.\", { elements, requestFunc });\n        return null;\n    }\n\n    starredListElement = elements.listContainer;\n    requestDbAndWaitFunc = requestFunc;\n    console.log(\"[LibraryController] Elements and request function assigned.\");\n\n    isInitialized = true;\n    console.log(\"[LibraryController] Initialization successful. Library will render when activated.\");\n\n    return {\n\n    };\n} ","// src/Controllers/SettingsController.js\nimport browser from 'webextension-polyfill';\nimport { sendDbRequestSmart } from '../sidepanel.js';\nimport { DbResetDatabaseRequest } from '../events/dbEvents.js';\nlet isInitialized = false;\n\nconst updateThemeButtonText = (button) => {\n    if (!button) return;\n    const isDarkMode = document.documentElement.classList.contains('dark');\n    button.textContent = isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode';\n};\n\nfunction setupThemeToggle() {\n    const settingsPageContainer = document.getElementById('page-settings');\n    if (!settingsPageContainer) {\n        console.warn(\"[SettingsController] Could not find #page-settings container.\");\n        return;\n    }\n\n    let themeToggleButton = settingsPageContainer.querySelector('#theme-toggle-button');\n\n    if (!themeToggleButton) {\n        console.log(\"[SettingsController] Creating theme toggle button.\");\n        themeToggleButton = document.createElement('button');\n        themeToggleButton.id = 'theme-toggle-button';\n        themeToggleButton.className = 'p-2 border rounded bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 mt-4'; // Standard styling\n\n        themeToggleButton.onclick = () => {\n            const htmlElement = document.documentElement;\n            const isCurrentlyDark = htmlElement.classList.contains('dark');\n            console.log(`[SettingsToggle] Before toggle - isDark: ${isCurrentlyDark}`);\n\n            if (isCurrentlyDark) {\n                htmlElement.classList.remove('dark');\n                localStorage.setItem('theme', 'light');\n                console.log(`[SettingsToggle] Removed dark class, set localStorage to light`);\n            } else {\n                htmlElement.classList.add('dark');\n                localStorage.setItem('theme', 'dark');\n                console.log(`[SettingsToggle] Added dark class, set localStorage to dark`);\n            }\n            updateThemeButtonText(themeToggleButton); \n        };\n        \n        const placeholderText = settingsPageContainer.querySelector('p');\n        if (placeholderText) {\n            placeholderText.insertAdjacentElement('afterend', themeToggleButton);\n        } else {\n            settingsPageContainer.appendChild(themeToggleButton);\n        }\n    } else {\n        console.log(\"[SettingsController] Theme toggle button already exists.\");\n    }\n\n    updateThemeButtonText(themeToggleButton);\n}\n\nfunction setupSlider(sliderId, valueSpanId) {\n    const slider = document.getElementById(sliderId);\n    const valueSpan = document.getElementById(valueSpanId);\n\n    if (slider && valueSpan) {\n        valueSpan.textContent = slider.value;\n        slider.addEventListener('input', (event) => {\n            valueSpan.textContent = event.target.value;\n        });\n        console.log(`[SettingsController] Setup slider ${sliderId} with value display ${valueSpanId}`);\n    } else {\n        if (!slider) console.warn(`[SettingsController] Slider element not found: #${sliderId}`);\n        if (!valueSpan) console.warn(`[SettingsController] Value span element not found: #${valueSpanId}`);\n    }\n}\n\nexport function initializeSettingsController() {\n    if (isInitialized) {\n        console.log(\"[SettingsController] Already initialized.\");\n        return;\n    }\n    console.log(\"[SettingsController] Initializing...\");\n\n    setupThemeToggle();\n    \n    setupSlider('setting-temperature', 'setting-temperature-value');\n    setupSlider('setting-repeat-penalty', 'setting-repeat-penalty-value');\n    setupSlider('setting-top-p', 'setting-top-p-value');\n    setupSlider('setting-min-p', 'setting-min-p-value');\n\n    const viewLogsButton = document.getElementById('viewLogsButton');\n    if (viewLogsButton) {\n        viewLogsButton.addEventListener('click', () => {\n            console.log('[SettingsController] View Logs button clicked. Opening log viewer popup...');\n            try {\n                const viewerUrl = 'sidepanel.html?view=logs'; \n                \n                browser.windows.create({\n                     url: viewerUrl,\n                     type: 'popup',\n                     width: 800,\n                     height: 600\n                 });\n            } catch (error) {\n                console.error('[SettingsController] Error opening log viewer popup:', error);\n\n            }\n        });\n        console.log('[SettingsController] Added listener to View Logs button.');\n\n        const resetDbButton = document.getElementById('resetDbButton');\n        if (resetDbButton) {\n            resetDbButton.addEventListener('click', async () => {\n                console.log('[SettingsController] Reset DB button clicked.');\n                try {\n                    const request = new DbResetDatabaseRequest();\n                    const result = await sendDbRequestSmart(request);\n                    if (result && result.success) {\n                        alert('Database reset successfully!');\n                    } else {\n                        alert('Database reset failed.');\n                    }\n                    console.log('[SettingsController] Reset DB result:', result);\n                } catch (e) {\n                    alert('Failed to reset database: ' + (e.message || e));\n                    console.error('[SettingsController] Reset DB error:', e);\n                }\n            });\n        }\n        console.log('[SettingsController] Added Reset DB button next to View Logs button.');\n    } else {\n        console.warn('[SettingsController] View Logs button (viewLogsButton) not found.');\n    }\n\n\n    isInitialized = true;\n    console.log(\"[SettingsController] Initialized successfully.\");\n\n    return {}; \n} ","// src/Controllers/SpacesController.js\r\n\r\n\r\n\r\nlet isInitialized = false;\r\n\r\nfunction handleNavigationChange(event) {\r\n    if (!isInitialized || event?.pageId !== 'page-spaces') {\r\n        return; \r\n    }\r\n    console.log(\"[SpacesController] Spaces page activated.\");\r\n\r\n}\r\n\r\nexport function initializeSpacesController(/* Pass necessary elements or functions if needed */) {\r\n    if (isInitialized) {\r\n        console.log(\"[SpacesController] Already initialized.\");\r\n        return;\r\n    }\r\n    console.log(\"[SpacesController] Initializing...\");\r\n    \r\n\r\n\r\n    isInitialized = true;\r\n    console.log(\"[SpacesController] Initialized successfully.\");\r\n\r\n\r\n    return {}; \r\n} ","import { showNotification } from '../notifications.js';\nimport { showError } from '../Utilities/generalUtils.js';\nimport { \n    DbMessagesUpdatedNotification, \n    DbSessionUpdatedNotification, \n    DbGetSessionRequest\n} from '../events/dbEvents.js';\nimport { MessageSenderTypes } from '../events/eventNames.js';\nimport { dbChannel } from '../Utilities/dbChannels.js';\n\n\nlet chatBodyElement = null;\nlet currentSessionId = null;\nlet requestDbAndWaitFunc = null;\nlet observer = null; // MutationObserver\nconst TEMP_MESSAGE_CLASS = 'temp-status-message'; // Class for temporary messages\n\nfunction handleMessagesUpdate(notification) {\n    console.log('[ChatRenderer handleMessagesUpdate] handleMessagesUpdate received notification:', JSON.parse(JSON.stringify(notification)));\n    if (!notification || !notification.sessionId || !notification.payload) {\n        console.warn('[ChatRenderer][DEBUG] handleMessagesUpdate: Invalid or incomplete notification received. Bailing out.', { notification });\n        return;\n    }\n    \n    if (notification.sessionId === currentSessionId) {\n        console.log(`[ChatRenderer handleMessagesUpdate] Received message update notification for active session ${currentSessionId}. Rendering.`);\n        \n        let messages = notification.payload.messages;\n        if (!Array.isArray(messages)) {\n            console.error('[ChatRenderer handleMessagesUpdate] ERROR: notification.payload.messages is not an array! Got:', notification.payload);\n            return;\n        }\n        \n        console.log(`[ChatRenderer handleMessagesUpdate] Messages array received:`, JSON.stringify(messages));\n        if (!chatBodyElement) return;\n        chatBodyElement.innerHTML = '';\n        if (messages.length === 0) {\n            console.log(`[ChatRenderer handleMessagesUpdate] Active session ${currentSessionId} has no messages. Displaying welcome.`);\n            displayWelcomeMessage();\n        } else {\n            messages.forEach(msg => renderSingleMessage(msg));\n            scrollToBottom();\n        }\n    }\n}\n\nfunction handleSessionMetadataUpdate(notification) {\n    if (!notification || !notification.sessionId || !notification.payload?.session) return;\n\n    if (notification.sessionId === currentSessionId) {\n        const updatedSessionData = notification.payload.session;\n        console.log(`[ChatRenderer] Received metadata update for active session ${currentSessionId}. New Title: ${updatedSessionData.title}, Starred: ${updatedSessionData.isStarred}`);\n        \n        updateChatHeader(updatedSessionData);\n    }\n}\n\ndocument.addEventListener(DbMessagesUpdatedNotification.type, (e) => {\n    console.log('[ChatRenderer] document event received for DbMessagesUpdatedNotification:', e);\n    handleMessagesUpdate(e.detail);\n});\n\ndocument.addEventListener(DbSessionUpdatedNotification.type, (e) => {\n    console.log('[ChatRenderer] Received DbSessionUpdatedNotification: ', e.detail);\n    handleSessionMetadataUpdate(e.detail);\n});\n\ndbChannel.onmessage = (event) => {\n    console.log('[ChatRenderer] dbChannel event received:', event.data);\n    const message = event.data;\n    const payloadKeys = message && message.payload ? Object.keys(message.payload) : [];\n    const sessionId = message.sessionId || (message.payload && message.payload.session && message.payload.session.id) || 'N/A';\n    console.log(`[ChatRenderer] dbChannel.onmessage: type=${message.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}]`);\n    const type = message?.type;\n    if (type === DbMessagesUpdatedNotification.type) {\n        handleMessagesUpdate(message.payload);\n    }\n    if (type === DbSessionUpdatedNotification.type) {\n        handleSessionMetadataUpdate(message.payload);\n    }\n};\n\n// If browser.runtime.onMessage is used for notifications, add a similar log\nif (typeof browser !== 'undefined' && browser.runtime && browser.runtime.onMessage) {\n    browser.runtime.onMessage.addListener((message) => {\n        const payloadKeys = message && message.payload ? Object.keys(message.payload) : [];\n        const sessionId = message.sessionId || (message.payload && message.payload.session && message.payload.session.id) || 'N/A';\n        console.log(`[ChatRenderer] browser.runtime.onMessage: type=${message.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}]`);\n        const type = message?.type;\n        if (type === DbMessagesUpdatedNotification.type) {\n            handleMessagesUpdate(message.payload);\n        }\n        if (type === DbSessionUpdatedNotification.type) {\n            handleSessionMetadataUpdate(message.payload);\n        }\n    });\n}\n\nexport function initializeRenderer(chatBody, requestDbFunc) {\n    if (!chatBody) {\n        console.error(\"[ChatRenderer] chatBody element is required for initialization.\");\n        return;\n    }\n    if (!requestDbFunc) {\n        console.error(\"[ChatRenderer] requestDbAndWait function is required for initialization.\");\n        return;\n    }\n    chatBodyElement = chatBody;\n    requestDbAndWaitFunc = requestDbFunc;\n    console.log(\"[ChatRenderer] Initialized with chat body element and DB request function.\");\n    initializeObserver();\n}\n\nexport function setActiveSessionId(sessionId) {\n    console.log(`[ChatRenderer] Setting active session ID to: ${sessionId}`);\n    currentSessionId = sessionId;\n    if (chatBodyElement) {\n        chatBodyElement.innerHTML = '';\n    }\n    if (!sessionId) {\n        displayWelcomeMessage();\n    } else {\n        console.log(`[ChatRenderer] Proactively loading messages for new session: ${sessionId}`);\n        loadAndRenderMessages(sessionId);\n    }\n}\n\nexport function displayWelcomeMessage() {\n    if (!chatBodyElement) return;\n    chatBodyElement.innerHTML = '';\n    const welcomeMsg = {\n        messageId: 'welcome-msg',\n        sender: 'system',\n        text: 'Welcome to Tab Agent! Ask me anything or paste a URL to scrape.',\n        timestamp: Date.now(),\n        isLoading: false\n    };\n    renderSingleMessage(welcomeMsg);\n}\n\nexport function scrollToBottom() {\n    if (chatBodyElement) {\n        requestAnimationFrame(() => {\n             chatBodyElement.scrollTop = chatBodyElement.scrollHeight;\n        });\n    }\n}\n\nasync function loadAndRenderMessages(sessionId) {\n    if (!requestDbAndWaitFunc) {\n        console.error(\"[ChatRenderer] Cannot load messages: requestDbAndWait function not available.\");\n        if (chatBodyElement) chatBodyElement.innerHTML = '<div class=\"p-4 text-red-500\">Error: Cannot load chat messages.</div>';\n        return;\n    }\n    if (!sessionId) {\n        console.warn(\"[ChatRenderer] loadAndRenderMessages called with null sessionId. Displaying welcome.\");\n        displayWelcomeMessage();\n        return;\n    }\n\n    console.log(`[ChatRenderer] Requesting messages for session ${sessionId}...`);\n    try {\n        const request = new DbGetSessionRequest(sessionId);\n        const sessionData = await requestDbAndWaitFunc(request);\n\n        if (sessionData && sessionData.messages) {\n            console.log(`[ChatRenderer] Received ${sessionData.messages.length} messages for ${sessionId}. Rendering.`);\n            if (chatBodyElement) chatBodyElement.innerHTML = '';\n            if (sessionData.messages.length === 0) {\n                displayWelcomeMessage();\n            } else {\n                sessionData.messages.forEach(msg => renderSingleMessage(msg));\n                scrollToBottom();\n            }\n        } else {\n            console.warn(`[ChatRenderer] No messages found in session data for ${sessionId}. Displaying welcome.`, sessionData);\n            displayWelcomeMessage();\n        }\n    } catch (error) {\n        console.error(`[ChatRenderer] Failed to load messages for session ${sessionId}:`, error);\n        showError(`Failed to load chat: ${error.message}`);\n        if (chatBodyElement) chatBodyElement.innerHTML = `<div class=\"p-4 text-red-500\">Failed to load chat: ${error.message}</div>`;\n    }\n}\n\nfunction updateChatHeader(sessionData) {\n    if (!sessionData) {\n        console.log('[ChatRenderer] Clearing chat header (no active session).');\n    } else {\n        console.log(`[ChatRenderer] Updating chat header for ${sessionData.id}. Title: ${sessionData.title}, Starred: ${sessionData.isStarred}`);\n    }\n}\n\nfunction renderSingleMessage(msg) {\n    if (!chatBodyElement) return;\n\n    console.log('[ChatRenderer] renderSingleMessage: msg object:', JSON.parse(JSON.stringify(msg)));\n\n    // Parse metadata for type detection\n    let meta = {};\n    try { meta = typeof msg.metadata === 'string' ? JSON.parse(msg.metadata) : (msg.metadata || {}); } catch {}\n    const extraction = meta.extraction;\n    const isPageExtractor = (meta.extractionType === 'PageExtractor') || (extraction && extraction.__type === 'PageExtractor');\n\n    const messageDiv = document.createElement('div');\n    messageDiv.classList.add('flex', 'mb-2');\n    messageDiv.id = msg.messageId || `msg-fallback-${Date.now()}-${Math.random().toString(36).substring(2)}`;\n    \n    const bubbleDiv = document.createElement('div');\n    bubbleDiv.classList.add('rounded-lg', 'break-words', 'relative', 'group', 'p-2', 'min-w-0');\n\n    if (msg.sender !== MessageSenderTypes.USER) {\n        bubbleDiv.classList.add('max-w-4xl');\n    }\n\n    // Actions container (copy/download) as before\n    const actionsContainer = document.createElement('div');\n    actionsContainer.className = 'actions-container absolute top-1 right-1 transition-opacity flex space-x-1 z-10';\n\n    const copyButton = document.createElement('button');\n    copyButton.innerHTML = '<img src=\"icons/copy.svg\" alt=\"Copy\" class=\"w-4 h-4\">';\n    copyButton.title = 'Copy message text';\n    copyButton.onclick = () => {\n        let textToCopy = msg.text;\n        if (msg.metadata?.type === 'scrape_result_full' && msg.metadata.scrapeData) {\n            textToCopy = JSON.stringify(msg.metadata.scrapeData, null, 2);\n        }\n        navigator.clipboard.writeText(textToCopy).then(() => {\n            // Assuming originalUITooltipController is available globally or passed appropriately\n            if (window.originalUITooltipController) {\n                window.originalUITooltipController.showTooltip(copyButton, 'Copied!');\n            }\n        }).catch(err => console.error('Failed to copy text: ', err));\n    };\n    actionsContainer.appendChild(copyButton);\n\n    if (msg.metadata?.type === 'scrape_result_full' && msg.metadata.scrapeData) {\n        const downloadButton = document.createElement('button');\n        downloadButton.innerHTML = '<img src=\"icons/download.svg\" alt=\"Download\" class=\"w-4 h-4\">';\n        downloadButton.title = 'Download scrape data as JSON';\n        downloadButton.onclick = () => {\n            console.log('Download clicked for:', msg.metadata.scrapeData); // Placeholder\n            if (window.originalUITooltipController) {\n                window.originalUITooltipController.showTooltip(downloadButton, 'Download (placeholder)');\n            }\n        };\n        actionsContainer.appendChild(downloadButton);\n    }\n    // IMPORTANT: Append actionsContainer AFTER main content is set, or ensure it's not overwritten.\n    // For now, we will append it after other content elements are added to bubbleDiv.\n\n    let contentToParse = msg.text || msg.content || '';\n    let specialHeaderHTML = '';\n\n    // --- Special handling for PageExtractor results ---\n    if (isPageExtractor && extraction) {\n        specialHeaderHTML = `<div class=\"scrape-header p-2 rounded-t-md bg-gray-200 dark:bg-gray-700 border-b border-gray-300 dark:border-gray-600 mb-1\"><h4 class=\"text-sm font-semibold text-gray-700 dark:text-gray-300\">Scraped Page Extraction</h4><p class=\"text-xs text-gray-500 dark:text-gray-400 break-all\">URL: ${extraction.url || 'N/A'}</p></div>`;\n        contentToParse = '```json\\n' + JSON.stringify(extraction, null, 2) + '\\n```';\n        console.log('[ChatRenderer] Rendering PageExtractor JSON:', contentToParse);\n    } else if (msg.text) {\n        console.log('[ChatRenderer] Preparing to parse regular message. Input to marked:', contentToParse);\n    }\n\n    console.log(`[ChatRenderer] Before style application: msg.sender = ${msg.sender}`);\n    // Apply sender-specific alignment and base bubble styling\n    if (msg.isLoading) {\n        messageDiv.classList.add('justify-start');\n        bubbleDiv.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-500', 'dark:text-gray-400', 'italic', 'border', 'border-gray-300', 'dark:border-gray-500');\n    } else if (msg.sender === MessageSenderTypes.USER) {\n        messageDiv.classList.add('justify-end', 'min-w-0');\n        bubbleDiv.classList.add(\n            'bg-[rgba(236,253,245,0.51)]', // very subtle green tint\n            'dark:bg-[rgba(20,83,45,0.12)]', // subtle dark green tint for dark mode\n            'text-green-900',\n            'dark:text-green-100',\n            'border',\n            'border-green-100',\n            'dark:border-green-900'\n        );\n    } else if (msg.sender === 'error') {\n        messageDiv.classList.add('justify-start');\n        bubbleDiv.classList.add(\n            'bg-[rgba(254,226,226,0.37)]', // subtle red tint (light)\n            'dark:bg-[rgba(120,20,20,0.12)]', // subtle red tint (dark)\n            'text-red-700',\n            'dark:text-red-200',\n            'border',\n            'border-red-200',\n            'dark:border-red-700'\n        );\n    } else if (msg.sender === 'system') { \n        messageDiv.classList.add('justify-start');\n        bubbleDiv.classList.add(\n            'bg-[rgba(219,234,254,0.5)]', // subtle blue tint\n            'dark:bg-[rgba(30,41,59,0.2)]', // subtle dark blue/gray for dark mode\n            'text-blue-900',\n            'dark:text-blue-100',\n            'border',\n            'border-blue-100',\n            'dark:border-blue-900'\n        );\n    } else { // Default for 'ai' or other non-user/non-error/non-system senders\n        messageDiv.classList.add('justify-start');\n        bubbleDiv.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-900', 'dark:text-gray-100', 'border', 'border-gray-300', 'dark:border-gray-600');\n    }\n    console.log('[ChatRenderer] messageDiv classes:', messageDiv.className);\n    console.log('[ChatRenderer] bubbleDiv classes:', bubbleDiv.className);\n\n    // --- HEADER BAR WITH FOLDOUT AND ACTIONS ---\n    const headerBar = document.createElement('div');\n    headerBar.className = 'bubble-header flex items-center justify-between px-2 py-0.5 min-w-[300px] w-full bg-[rgba(200,200,200,0.18)] dark:bg-[rgba(50,50,50,0.28)] rounded-t-lg border-b border-gray-200 dark:border-gray-700 transition-all duration-150 group';\n    headerBar.onmouseenter = () => headerBar.classList.add('bg-[rgba(200,200,200,0.28)]', 'dark:bg-[rgba(50,50,50,0.38)]');\n    headerBar.onmouseleave = () => headerBar.classList.remove('bg-[rgba(200,200,200,0.28)]', 'dark:bg-[rgba(50,50,50,0.38)]');\n\n    // Foldout button with SVG chevron\n    const foldoutBtn = document.createElement('button');\n    foldoutBtn.className = 'toggle-foldout mr-2 flex items-center justify-center w-5 h-5 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition cursor-pointer';\n    foldoutBtn.title = 'Expand/collapse message';\n    foldoutBtn.innerHTML = `<svg class=\"chevron-icon transition-transform duration-150\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6 8L10 12L14 8\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>`;\n    headerBar.appendChild(foldoutBtn);\n\n    // Actions container (already created above)\n    actionsContainer.classList.add('ml-auto', 'flex', 'items-center', 'space-x-1');\n    headerBar.appendChild(actionsContainer);\n\n    // --- MAIN CONTENT (foldable) ---\n    const mainContentDiv = document.createElement('div');\n    mainContentDiv.className = 'message-main-content';\n\n    if (window.marked && window.marked.parse) {\n        try {\n            const localRenderer = new window.marked.Renderer();\n\n            const escapeHtmlEntities = (str) => {\n                if (typeof str !== 'string') return '';\n                return str.replace(/[&<>\"'\\/]/g, function (match) {\n                    return {\n                        '&': '&amp;',\n                        '<': '&lt;',\n                        '>': '&gt;',\n                        '\\\"': '&quot;',\n                        \"'\": '&#39;',\n                        '/': '&#x2F;' \n                    }[match];\n                });\n            };\n\n            // ONLY override the .code() method for now\n            localRenderer.code = (tokenOrCode, languageInfoString, isEscaped) => {\n                // Log what we receive\n                console.log('[ChatRenderer Custom Code] Received arguments:', \n                    {\n                        tokenOrCode_type: typeof tokenOrCode,\n                        tokenOrCode_value: JSON.parse(JSON.stringify(tokenOrCode)), // Deep copy for logging\n                        languageInfoString_type: typeof languageInfoString,\n                        languageInfoString_value: languageInfoString,\n                        isEscaped_value: isEscaped\n                    }\n                );\n\n                let actualCodeString = '';\n                let actualLanguageString = languageInfoString || '';\n                // let actuallyEscaped = isEscaped; // Not directly used with hljs which expects raw code\n\n                if (typeof tokenOrCode === 'object' && tokenOrCode !== null && typeof tokenOrCode.text === 'string') {\n                    actualCodeString = tokenOrCode.text;\n                    actualLanguageString = tokenOrCode.lang || actualLanguageString; \n                    // actuallyEscaped = typeof tokenOrCode.escaped === 'boolean' ? tokenOrCode.escaped : isEscaped;\n                    console.log('[ChatRenderer Custom Code] Interpreted as token object. Using token.text and token.lang.');\n                } else if (typeof tokenOrCode === 'string') {\n                    actualCodeString = tokenOrCode;\n                    console.log('[ChatRenderer Custom Code] Interpreted as direct code string.');\n                } else {\n                    console.warn('[ChatRenderer Custom Code] Received unexpected type for code argument:', tokenOrCode);\n                    actualCodeString = '[Error: Unexpected code content type]';\n                }\n                \n                // Initialize safeLanguage and langClass based on the *provided* language hint\n                let languageHint = actualLanguageString.trim();\n                let safeLanguage = escapeHtmlEntities(languageHint || 'plaintext');\n                let langClass = `language-${safeLanguage}`;\n                \n                const copyIcon = '<img src=\"icons/copy.svg\" alt=\"Copy code\" class=\"w-4 h-4\">'; \n                const downloadIcon = '<img src=\"icons/download.svg\" alt=\"Download code\" class=\"w-4 h-4\">';\n                \n                const encodedCodeForAttr = encodeURIComponent(actualCodeString);\n                \n                let highlightedCodeForDisplay = '';\n                if (window.hljs) {\n                    // highlight.js expects raw, unescaped code.\n                    // actualCodeString should be raw based on Marked.js default behavior without sanitize: true\n                    if (actualLanguageString && window.hljs.getLanguage(actualLanguageString)) {\n                        try {\n                            highlightedCodeForDisplay = window.hljs.highlight(actualCodeString, { language: actualLanguageString, ignoreIllegals: true }).value;\n                            console.log('[ChatRenderer Custom Code] Highlighted with specified language:', actualLanguageString);\n                        } catch (e) {\n                            console.error('[ChatRenderer Custom Code] hljs.highlight error:', e);\n                            highlightedCodeForDisplay = escapeHtmlEntities(actualCodeString);\n                        }\n                    } else {\n                        try {\n                            const autoResult = window.hljs.highlightAuto(actualCodeString);\n                            highlightedCodeForDisplay = autoResult.value;\n                            const detectedLang = autoResult.language;\n                            console.log('[ChatRenderer Custom Code] Highlighted with auto-detection. Detected:', detectedLang);\n\n                            if (detectedLang) { // If auto-detection was successful\n                                safeLanguage = escapeHtmlEntities(detectedLang);\n                                langClass = `language-${safeLanguage}`; // Update based on detected language\n                            }\n                        } catch (e) {\n                            console.error('[ChatRenderer Custom Code] hljs.highlightAuto error:', e);\n                            highlightedCodeForDisplay = escapeHtmlEntities(actualCodeString);\n                        }\n                    }\n                } else {\n                    console.warn('[ChatRenderer Custom Code] window.hljs not found. Falling back to escaped code.');\n                    highlightedCodeForDisplay = escapeHtmlEntities(actualCodeString);\n                }\n\n                return `\n<div class=\"code-block-wrapper bg-gray-800 dark:bg-gray-900 rounded-md shadow-md my-2 text-sm\">\n    <div class=\"code-block-header flex justify-between items-center px-3 py-1.5 bg-gray-700 dark:bg-gray-800 rounded-t-md border-b border-gray-600 dark:border-gray-700\">\n        <span class=\"code-language text-xs text-gray-300 dark:text-gray-400 font-semibold\">${safeLanguage}</span>\n        <div class=\"code-actions flex space-x-2\">\n            <button class=\"code-action-copy-snippet p-1 rounded text-gray-300 hover:bg-gray-600 dark:hover:bg-gray-700\" title=\"Copy code\" data-code=\"${encodedCodeForAttr}\">\n                ${copyIcon}\n            </button>\n            <button class=\"code-action-download-snippet p-1 rounded text-gray-300 hover:bg-gray-600 dark:hover:bg-gray-700\" title=\"Download ${safeLanguage} snippet\" data-code=\"${encodedCodeForAttr}\" data-lang=\"${safeLanguage}\">\n                ${downloadIcon}\n            </button>\n        </div>\n    </div>\n    <pre class=\"p-3 overflow-x-auto\"><code class=\"${langClass}\">${highlightedCodeForDisplay}</code></pre>\n</div>`;\n            };\n\n            // DO NOT override .paragraph, .list, .listitem, .heading for this test.\n            // Let Marked.js use its defaults for these.\n\n            const parsedContent = window.marked.parse(contentToParse || '', {\n                renderer: localRenderer, // Use the renderer with only .code overridden\n                gfm: true, \n                breaks: true \n            });\n            console.log('[ChatRenderer Minimal Custom Marked.parse() output:]', parsedContent);\n            mainContentDiv.innerHTML = parsedContent;\n            if (window.hljs) {\n                console.log('[ChatRenderer] Content set. highlight.js should have processed via Marked.js config.');\n            }\n        } catch (e) {\n            console.error('Error during marked.parse:', e);\n            mainContentDiv.textContent = contentToParse || ''; \n        }\n    } else {\n        console.warn('Marked.js not available. Falling back to textContent.');\n        mainContentDiv.textContent = contentToParse || '';\n    }\n\n    // FOLDOUT LOGIC\n    let expanded = true;\n    foldoutBtn.onclick = () => {\n        expanded = !expanded;\n        mainContentDiv.style.display = expanded ? '' : 'none';\n        // Rotate chevron\n        const svg = foldoutBtn.querySelector('.chevron-icon');\n        if (svg) svg.style.transform = expanded ? 'rotate(0deg)' : 'rotate(-90deg)';\n    };\n    // Default: expanded\n    mainContentDiv.style.display = '';\n\n    // --- ASSEMBLE BUBBLE ---\n    bubbleDiv.innerHTML = '';\n    bubbleDiv.appendChild(headerBar);\n    if (specialHeaderHTML) {\n        const headerDiv = document.createElement('div');\n        headerDiv.innerHTML = specialHeaderHTML;\n        bubbleDiv.appendChild(headerDiv);\n    }\n    bubbleDiv.appendChild(mainContentDiv);\n    bubbleDiv.appendChild(actionsContainer); // Append actions container LAST to ensure it's not overwritten and is on top (due to z-10)\n    \n    messageDiv.appendChild(bubbleDiv);\n    chatBodyElement.appendChild(messageDiv);\n    scrollToBottom();\n    return messageDiv;\n}\n\n// --- NEW: Functions for Temporary Messages ---\n\n/**\n * Renders a temporary status message directly to the chat body.\n * These messages are not saved to the database.\n * @param {string} type - 'system', 'success', or 'error'\n * @param {string} text - The message content.\n */\nexport function renderTemporaryMessage(type, text) {\n    if (!chatBodyElement) return;\n\n    // Only log non-system temporary messages to reduce noise\n    if (type !== 'system') {\n        console.log(`[ChatRenderer] Rendering temporary message (${type}): ${text}`);\n    }\n    const messageDiv = document.createElement('div');\n    messageDiv.classList.add('message', `message-${type}`, TEMP_MESSAGE_CLASS);\n\n    // Basic styling (can be enhanced in CSS)\n    messageDiv.style.padding = '8px 12px';\n    messageDiv.style.borderRadius = '8px';\n    messageDiv.style.marginBottom = '10px';\n    messageDiv.style.maxWidth = '90%';\n    messageDiv.style.alignSelf = 'center'; // Center align system/error messages\n    messageDiv.style.backgroundColor = type === 'error' ? '#fee2e2' : (type === 'success' ? '#dcfce7' : '#f3f4f6'); // Example colors\n    messageDiv.style.color = type === 'error' ? '#b91c1c' : (type === 'success' ? '#166534' : '#374151'); // Example colors\n\n    // Handle dark mode styling (basic example)\n    if (document.documentElement.classList.contains('dark')) {\n        messageDiv.style.backgroundColor = type === 'error' ? '#450a0a' : (type === 'success' ? '#14532d' : '#374151');\n        messageDiv.style.color = type === 'error' ? '#fca5a5' : (type === 'success' ? '#bbf7d0' : '#d1d5db');\n    }\n\n    messageDiv.textContent = text;\n\n    chatBodyElement.appendChild(messageDiv);\n    scrollToBottom();\n}\n\n/**\n * Removes all temporary status messages from the chat body.\n */\nexport function clearTemporaryMessages() {\n    if (!chatBodyElement) return;\n    console.log(\"[ChatRenderer] Clearing temporary status messages.\");\n    const tempMessages = chatBodyElement.querySelectorAll(`.${TEMP_MESSAGE_CLASS}`);\n    tempMessages.forEach(msg => msg.remove());\n}\n\n// --- END: Temporary Message Functions ---\n\nfunction initializeObserver() {\n    if (observer) observer.disconnect(); // Disconnect previous observer if any\n\n    observer = new MutationObserver(mutations => {\n        mutations.forEach(mutation => {\n            if (mutation.type === 'childList') {\n                mutation.addedNodes.forEach(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        // If using hljs and it needs to be re-triggered on dynamic additions, this is one place.\n                        // However, if Marked+hljs provides fully rendered HTML, this might only be for other dynamic changes.\n                        // For now, let's assume the initial render from Marked handles it.\n                        // const codeBlocks = node.querySelectorAll('pre code[class*=\"language-\"]');\n                        // codeBlocks.forEach(codeElement => {\n                        //     if (!codeElement.classList.contains('hljs-highlighted')) { // or appropriate hljs class\n                        //         if (window.hljs) window.hljs.highlightElement(codeElement); // or hljs.highlightBlock(codeElement)\n                        //         codeElement.classList.add('hljs-highlighted');\n                        //     }\n                        // });\n                    }\n                });\n            }\n        });\n    });\n\n    if (chatBodyElement) {\n        observer.observe(chatBodyElement, { childList: true, subtree: true });\n        console.log(\"[ChatRenderer] MutationObserver initialized and observing chat body.\");\n\n        // Event delegation for code block actions\n        chatBodyElement.addEventListener('click', async (event) => {\n            const target = event.target.closest('button');\n            if (!target) return;\n\n            if (target.classList.contains('code-action-copy-snippet')) {\n                const codeToCopy = target.dataset.code;\n                if (codeToCopy) {\n                    try {\n                        await navigator.clipboard.writeText(decodeURIComponent(codeToCopy));\n                        if (window.originalUITooltipController) {\n                            window.originalUITooltipController.showTooltip(target, 'Code Copied!');\n                        } else {\n                            showNotification('Code snippet copied!', 'success', 1500);\n                        }\n                    } catch (err) {\n                        console.error('Failed to copy code snippet:', err);\n                        showError('Failed to copy code snippet.');\n                    }\n                }\n            } else if (target.classList.contains('code-action-download-snippet')) {\n                const codeToDownload = target.dataset.code;\n                const lang = target.dataset.lang || 'txt';\n                const filename = `snippet.${lang}`;\n                if (codeToDownload) {\n                    try {\n                        downloadFile(filename, decodeURIComponent(codeToDownload), getMimeType(lang));\n                        if (window.originalUITooltipController) {\n                            window.originalUITooltipController.showTooltip(target, 'Downloading...');\n                        }\n                    } catch (err) {\n                        console.error('Failed to download code snippet:', err);\n                        showError('Failed to download code snippet.');\n                    }\n                }\n            }\n        });\n        console.log(\"[ChatRenderer] Event listeners for code block actions (copy/download) added to chatBody.\");\n\n    } else {\n        console.error(\"[ChatRenderer] Cannot initialize MutationObserver or event listeners: chatBody is null.\");\n    }\n}\n\n// Helper function to get MIME type from language\nfunction getMimeType(lang) {\n    const mimeTypes = {\n        json: 'application/json',\n        javascript: 'application/javascript',\n        js: 'application/javascript',\n        html: 'text/html',\n        css: 'text/css',\n        xml: 'application/xml',\n        python: 'text/x-python',\n        py: 'text/x-python',\n        java: 'text/x-java-source',\n        c: 'text/x-csrc',\n        cpp: 'text/x-c++src',\n        cs: 'text/x-csharp',\n        go: 'text/x-go',\n        rb: 'text/x-ruby',\n        php: 'application/x-httpd-php',\n        swift: 'text/x-swift',\n        kt: 'text/x-kotlin',\n        rs: 'text/rust',\n        sql: 'application/sql',\n        sh: 'application/x-sh',\n        bash: 'application/x-sh',\n        // Add more as needed\n        txt: 'text/plain',\n        plaintext: 'text/plain'\n    };\n    return mimeTypes[lang.toLowerCase()] || 'text/plain';\n}\n\n// Helper function to trigger file download\nfunction downloadFile(filename, content, mimeType) {\n    const blob = new Blob([content], { type: mimeType });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n}","import { showError } from '../Utilities/generalUtils.js';\n\nlet db = null;\nlet renderer = null;\nlet getActiveSessionIdFunc = null;\nlet ui = null;\n\nexport function initializeFileHandling(dependencies) {\n    getActiveSessionIdFunc = dependencies.getActiveSessionIdFunc;\n    ui = dependencies.uiController;\n\n    if (!getActiveSessionIdFunc || !ui) {\n        console.error(\"FileHandler: Missing getActiveSessionIdFunc or uiController dependency!\");\n    } else {\n        console.log(\"[FileHandler] Initialized (Note: DB/Renderer interaction via events assumed).\");\n    }\n}\n\nexport async function handleFileSelected(event) {\n    if (!getActiveSessionIdFunc) {\n         console.error(\"FileHandler: Not initialized properly (missing getActiveSessionIdFunc).\");\n         return;\n    }\n\n    const files = event.target.files;\n    if (!files || files.length === 0) {\n        console.log(\"FileHandler: No file selected.\");\n        return;\n    }\n\n    const file = files[0];\n    console.log(`FileHandler: File selected - ${file.name}, Type: ${file.type}, Size: ${file.size}`);\n\n    const sessionId = getActiveSessionIdFunc();\n    if (!sessionId) {\n        showError(\"Please start or select a chat before attaching a file.\");\n        event.target.value = '';\n        return;\n    }\n\n    const fileMessage = {\n        sender: 'system',\n        text: ` Attached file: ${file.name}`,\n        timestamp: Date.now(),\n        isLoading: false,\n    };\n\n    try {\n        const request = new DbAddMessageRequest(sessionId, fileMessage);\n        eventBus.publish(DbAddMessageRequest.type, request);\n        console.log(\"[FileHandler] Published DbAddMessageRequest for file attachment.\");\n\n    } catch (error) {\n         console.error(\"FileHandler: Error publishing file attachment message event:\", error);\n         showError(\"Failed to process file attachment.\");\n    } finally {\n        event.target.value = ''; \n    }\n}\n\nexport function handleAttachClick() {\n    if (!ui) {\n        console.error(\"FileHandler: UI Controller not available to trigger file input.\");\n        return;\n    }\n    console.log(\"FileHandler: Triggering file input click.\");\n    ui.triggerFileInputClick();\n}","import browser from 'webextension-polyfill';\nimport { URL_REGEX, getActiveTab, showError } from '../Utilities/generalUtils.js';\nimport { sendDbRequestSmart } from '../sidepanel.js';\nimport {\n    DbCreateSessionRequest, DbCreateSessionResponse,\n    DbAddMessageRequest, DbAddMessageResponse,\n    DbUpdateMessageRequest, DbUpdateMessageResponse,\n    DbDeleteMessageRequest, DbDeleteMessageResponse,\n    DbUpdateStatusRequest, DbUpdateStatusResponse,\n    DbGetSessionRequest, DbGetSessionResponse,\n    DbToggleStarRequest, DbToggleStarResponse,\n    DbGetAllSessionsRequest, DbGetAllSessionsResponse,\n    DbGetStarredSessionsRequest, DbGetStarredSessionsResponse,\n    DbDeleteSessionRequest, DbDeleteSessionResponse,\n    DbRenameSessionRequest, DbRenameSessionResponse\n} from '../events/dbEvents.js';\nimport { clearTemporaryMessages } from './chatRenderer.js';\nimport { UIEventNames, RuntimeMessageTypes } from '../events/eventNames.js';\n\nlet getActiveSessionIdFunc = null;\nlet onSessionCreatedCallback = null;\nlet getCurrentTabIdFunc = null;\nlet isSendingMessage = false; // TODO: Remove this and rely on status check via DB event\n\nconst pendingDbRequests = new Map();\n\nfunction requestDbAndWait(requestEvent, timeoutMs = 5000) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const result = await sendDbRequestSmart(requestEvent, timeoutMs);\n            console.log('[Trace][sidepanel] requestDbAndWait: Raw result', result);\n            const response = Array.isArray(result) ? result[0] : result;\n            if (response && (response.success || response.error === undefined)) {\n                resolve(response.data || response.payload);\n            } else {\n                reject(new Error(response?.error || `DB operation ${requestEvent.type} failed`));\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nasync function handleQuerySubmit(data) {\n    const { text } = data;\n    console.log(`[Orchestrator: handleQuerySubmit] received event with text: \"${text}\"`);\n    if (isSendingMessage) {\n        console.warn(\"[Orchestrator handleQuerySubmit]: Already processing a previous submission.\");\n        return;\n    }\n    isSendingMessage = true;\n\n    let sessionId = getActiveSessionIdFunc();\n    const currentTabId = getCurrentTabIdFunc();\n    let placeholderMessageId = null;\n\n    console.log(`[Orchestrator: handleQuerySubmit] Processing submission. Text: \"${text}\". Session: ${sessionId}`);\n    const isURL = URL_REGEX.test(text);\n\n    try {\n        clearTemporaryMessages();\n        const userMessage = { sender: 'user', text: text, timestamp: Date.now(), isLoading: false };\n        if (!sessionId) {\n            console.log(\"[Orchestrator: handleQuerySubmit] No active session, creating new one via event.\");\n            const createRequest = new DbCreateSessionRequest(userMessage);\n            const createResponse = await requestDbAndWait(createRequest);\n            sessionId = createResponse.newSessionId;\n            if (onSessionCreatedCallback) {\n                onSessionCreatedCallback(sessionId);\n            } else {\n                 console.error(\"[Orchestrator: handleQuerySubmit] onSessionCreatedCallback is missing!\");\n                 throw new Error(\"Configuration error: Cannot notify about new session.\");\n            }\n        } else {\n            console.log(`[Orchestrator: handleQuerySubmit] Adding user message to existing session ${sessionId} via event.`);\n            clearTemporaryMessages();\n            const addRequest = new DbAddMessageRequest(sessionId, userMessage);\n            await requestDbAndWait(addRequest);\n        }\n        console.log(`[Orchestrator: handleQuerySubmit] Setting session ${sessionId} status to 'processing' via event`);\n        const statusRequest = new DbUpdateStatusRequest(sessionId, 'processing');\n        await requestDbAndWait(statusRequest);\n        let placeholder;\n        if (isURL) {\n            placeholder = { sender: 'system', text: ` Scraping ${text}...`, timestamp: Date.now(), isLoading: true };\n        } else {\n            placeholder = { sender: 'ai', text: 'Thinking...', timestamp: Date.now(), isLoading: true };\n        }\n        console.log(`[Orchestrator: handleQuerySubmit] Adding placeholder to session ${sessionId} via event.`);\n        const addPlaceholderRequest = new DbAddMessageRequest(sessionId, placeholder);\n        const placeholderResponse = await requestDbAndWait(addPlaceholderRequest);\n        placeholderMessageId = placeholderResponse.newMessageId;\n        \n        if (isURL) {\n            // Always send scrape request to background, let background decide how to scrape\n            try {\n                const response = await browser.runtime.sendMessage({\n                    type: RuntimeMessageTypes.SCRAPE_REQUEST,\n                    payload: {\n                        url: text,\n                        chatId: sessionId,\n                        messageId: placeholderMessageId\n                    }\n                });\n                console.log(\"[Orchestrator: handleQuerySubmit] SCRAPE_REQUEST sent to background.\", response);\n            } catch (error) {\n                console.error('[Orchestrator: handleQuerySubmit] Error sending SCRAPE_REQUEST:', error.message);\n                const errorUpdateRequest = new DbUpdateMessageRequest(sessionId, placeholderMessageId, {\n                    isLoading: false, sender: 'error', text: `Failed to initiate scrape: ${error.message}`\n                });\n                requestDbAndWait(errorUpdateRequest).catch(e => console.error(\"Failed to update placeholder on send error:\", e));\n                requestDbAndWait(new DbUpdateStatusRequest(sessionId, 'error')).catch(e => console.error(\"Failed to set session status on send error:\", e));\n                isSendingMessage = false;\n            }\n        } else {\n            console.log(\"[Orchestrator: handleQuerySubmit] Sending query to background for AI response.\");\n            const messagePayload = {\n                type: RuntimeMessageTypes.SEND_CHAT_MESSAGE,\n                payload: {\n                    chatId: sessionId,\n                    messages: [{ role: 'user', content: text }], \n                    options: { /* model, temp, etc */ },\n                    messageId: placeholderMessageId\n                }\n            };\n            try {\n                const response = await browser.runtime.sendMessage(messagePayload);\n                if (response && response.success) {\n                    console.log('[Orchestrator: handleQuerySubmit] Background acknowledged forwarding sendChatMessage. Actual AI response will follow separately.', response);\n                } else {\n                    console.error('[Orchestrator: handleQuerySubmit] Background reported an error while attempting to forward sendChatMessage:', response?.error);\n                    const errorPayload = { isLoading: false, sender: 'error', text: `Error forwarding query: ${response?.error || 'Unknown error'}` };\n                    const errorUpdateRequest = new DbUpdateMessageRequest(sessionId, placeholderMessageId, errorPayload);\n                    await requestDbAndWait(errorUpdateRequest); // Can await here too\n                    await requestDbAndWait(new DbUpdateStatusRequest(sessionId, 'error'));\n                    isSendingMessage = false; // Reset flag if forwarding failed\n                }\n            } catch (error) {\n                console.error('[Orchestrator: handleQuerySubmit] Error sending query to background or processing its direct ack:', error);\n                const errorText = error && typeof error.message === 'string' ? error.message : 'Unknown error during send/ack';\n                const errorPayload = { isLoading: false, sender: 'error', text: `Failed to send query: ${errorText}` };\n                const errorUpdateRequest = new DbUpdateMessageRequest(sessionId, placeholderMessageId, errorPayload);\n                requestDbAndWait(errorUpdateRequest).catch(e => console.error(\"Failed to update placeholder on send error (within catch):\", e));\n                requestDbAndWait(new DbUpdateStatusRequest(sessionId, 'error')).catch(e => console.error(\"Failed to set session status on send error (within catch):\", e));\n                isSendingMessage = false; // Reset flag on send error\n            }\n        }\n    } catch (error) {\n        console.error(\"[Orchestrator: handleQuerySubmit] Error processing query submission:\", error);\n        showError(`Error: ${error.message || error}`);\n        if (sessionId) {\n            console.log(`[Orchestrator: handleQuerySubmit] Setting session ${sessionId} status to 'error' due to processing failure via event`);\n            requestDbAndWait(new DbUpdateStatusRequest(sessionId, 'error')).catch(e => console.error(\"Failed to set session status on processing error:\", e));\n        } else {\n            console.error(\"[Orchestrator: handleQuerySubmit] Error occurred before session ID was established.\");\n        }\n        isSendingMessage = false;\n    }\n}\n\nasync function handleBackgroundMsgResponse(message) {\n    const { chatId, messageId, text } = message;\n    console.log(`[Orchestrator: handleBackgroundMsgResponse] for chat ${chatId}, placeholder ${messageId}`);\n    try {\n        const updatePayload = { isLoading: false, sender: 'ai', text: text || 'Received empty response.' };\n        const updateRequest = new DbUpdateMessageRequest(chatId, messageId, updatePayload);\n        await requestDbAndWait(updateRequest);\n        console.log(`[Orchestrator: handleBackgroundMsgResponse] Setting session ${chatId} status to 'idle' after response via event`);\n        const statusRequest = new DbUpdateStatusRequest(chatId, 'idle');\n        await requestDbAndWait(statusRequest);\n    } catch (error) {\n        console.error(`[Orchestrator: handleBackgroundMsgResponse] Error handling background response for chat ${chatId}:`, error);\n        showError(`Failed to update chat with response: ${error.message || error}`);\n        const statusRequest = new DbUpdateStatusRequest(chatId, 'error');\n        requestDbAndWait(statusRequest).catch(e => console.error(\"Failed to set session status on response processing error:\", e));\n    } finally {\n         isSendingMessage = false; // TODO: Remove later\n    }\n}\n\nasync function handleBackgroundMsgError(message) {\n    console.error(`[Orchestrator: handleBackgroundMsgError] Received error for chat ${message.chatId}, placeholder ${message.messageId}: ${message.error}`);\n    showError(`Error processing request: ${message.error}`); // Show global error regardless\n\n    const sessionId = getActiveSessionIdFunc(); // Get current session ID\n\n    if (sessionId && message.chatId === sessionId && message.messageId) {\n        // Only update DB if the error belongs to the *active* session and has a message ID\n        console.log(`[Orchestrator: handleBackgroundMsgError] Attempting to update message ${message.messageId} in active session ${sessionId} with error.`);\n        const errorPayload = { isLoading: false, sender: 'error', text: `Error: ${message.error}` };\n        const errorUpdateRequest = new DbUpdateMessageRequest(sessionId, message.messageId, errorPayload);\n        const statusRequest = new DbUpdateStatusRequest(sessionId, 'error');\n        try {\n            await requestDbAndWait(errorUpdateRequest);\n            console.log(`[Orchestrator: handleBackgroundMsgError] Error message update successful for session ${sessionId}.`);\n            await requestDbAndWait(statusRequest);\n            console.log(`[Orchestrator: handleBackgroundMsgError] Session ${sessionId} status set to 'error'.`);\n        } catch (dbError) {\n            console.error('[Orchestrator: handleBackgroundMsgError] Error updating chat/status on background error:', dbError);\n            // Show a more specific UI error if DB update fails\n            showError(`Failed to update chat with error status: ${dbError.message}`);\n            // Attempt to set status to error even if message update failed\n            try {\n                 await requestDbAndWait(new DbUpdateStatusRequest(sessionId, 'error'));\n            } catch (statusError) {\n                 console.error('[Orchestrator: handleBackgroundMsgError] Failed to set session status on error handling error:', statusError);\n            }\n        }\n    } else {\n         console.warn(`[Orchestrator: handleBackgroundMsgError] Received error, but no active session ID (${sessionId}) or message ID (${message.messageId}) matches the error context (${message.chatId}). Not updating DB.`);\n         // If the error is specifically a model load error (we might need a better way to signal this)\n         // ensure the UI controller knows. The direct worker:error event might be better.\n    }\n\n    isSendingMessage = false; // Reset flag after handling error\n}\n\nasync function handleBackgroundScrapeStage(payload) {\n    const { stage, success, chatId, messageId, error, ...rest } = payload;\n    console.log(`[Orchestrator: handleBackgroundScrapeStage] Stage ${stage}, chatId: ${chatId}, Success: ${success}`);\n\n    let updatePayload = {};\n    let finalStatus = 'idle'; // Default to idle on success\n\n    if (success) {\n        console.log(`[Orchestrator: handleBackgroundScrapeStage] Scrape stage ${stage} succeeded for chat ${chatId}.`);\n        // Construct a success message matching the 'scrape_result_full' style\n        const successText = `Full Scrape Result: ${rest.title || 'No Title'}`; // Use title for the text part\n        // Use the 'scrape_result_full' type and structure\n        updatePayload = { \n            isLoading: false, \n            sender: 'system', \n            text: successText, // Main text shown outside bubble if needed\n            metadata: { \n                type: 'scrape_result_full', \n                scrapeData: rest // Put the full data here for the renderer\n            }\n        };\n        finalStatus = 'idle';\n\n    } else {\n        // If a stage fails, update the message immediately with the error\n        const errorText = error || `Scraping failed (Stage ${stage}). Unknown error.`;\n        console.error(`[Orchestrator: handleBackgroundScrapeStage] Scrape stage ${stage} failed for chat ${chatId}. Error: ${errorText}`);\n        updatePayload = { isLoading: false, sender: 'error', text: `Scraping failed (Stage ${stage}): ${errorText}` };\n        finalStatus = 'error';\n    }\n\n    // --- Update DB regardless of success/failure based on this stage result --- \n    try {\n        console.log(`[Orchestrator: handleBackgroundScrapeStage] Updating message ${messageId} for stage ${stage} result.`);\n        const updateRequest = new DbUpdateMessageRequest(chatId, messageId, updatePayload);\n        await requestDbAndWait(updateRequest);\n        console.log(`[Orchestrator: handleBackgroundScrapeStage] Updated placeholder ${messageId} with stage ${stage} result.`);\n\n        // Also set final session status based on this stage outcome\n        console.log(`[Orchestrator: handleBackgroundScrapeStage] Setting session ${chatId} status to '${finalStatus}' after stage ${stage} result via event`);\n        const statusRequest = new DbUpdateStatusRequest(chatId, finalStatus);\n        await requestDbAndWait(statusRequest);\n\n    } catch (dbError) {\n        console.error(`[Orchestrator: handleBackgroundScrapeStage] Failed to update DB after stage ${stage} result:`, dbError);\n        showError(`Failed to update chat with scrape result: ${dbError.message || dbError}`);\n        // If DB update fails, maybe try setting status to error anyway?\n        if (finalStatus !== 'error') {\n             try {\n                 const fallbackStatusRequest = new DbUpdateStatusRequest(chatId, 'error');\n                 await requestDbAndWait(fallbackStatusRequest);\n             } catch (fallbackError) {\n                 console.error(\"Failed to set fallback error status:\", fallbackError);\n             }\n        }\n    } finally {\n        // Reset sending flag only after processing a stage result\n        // This assumes the background script won't send more results for this specific scrape\n        // Might need adjustment if background sends a final DIRECT_SCRAPE_RESULT later\n         isSendingMessage = false; \n         console.log(\"[Orchestrator: handleBackgroundScrapeStage] Resetting isSendingMessage after processing scrape stage result.\");\n    }\n}\n\nasync function handleBackgroundDirectScrapeResult(message) {\n    const { chatId, messageId, success, error, ...scrapeData } = message;\n    console.log(`[Orchestrator: handleBackgroundDirectScrapeResult] for chat ${chatId}, placeholder ${messageId}, Success: ${success}`);\n    const updatePayload = { isLoading: false };\n     if (success) {\n         updatePayload.sender = 'system';\n         updatePayload.text = `Full Scrape Result: ${scrapeData.title || 'Scraped Content'}`;\n         updatePayload.metadata = {\n             type: 'scrape_result_full', \n             scrapeData: scrapeData\n         };\n     } else {\n         updatePayload.sender = 'error';\n         updatePayload.text = `Scraping failed: ${error || 'Unknown error.'}`;\n     }\n    try {\n        const updateRequest = new DbUpdateMessageRequest(chatId, messageId, updatePayload);\n        await requestDbAndWait(updateRequest);\n        const finalStatus = success ? 'idle' : 'error';\n        console.log(`[Orchestrator: handleBackgroundDirectScrapeResult] Setting session ${chatId} status to '${finalStatus}' after direct scrape result via event`);\n        const statusRequest = new DbUpdateStatusRequest(chatId, finalStatus);\n        await requestDbAndWait(statusRequest);\n    } catch (error) {\n        console.error(`[Orchestrator: handleBackgroundDirectScrapeResult] Error handling direct scrape result for chat ${chatId}:`, error);\n        showError(`Failed to update chat with direct scrape result: ${error.message || error}`);\n        const statusRequest = new DbUpdateStatusRequest(chatId, 'error');\n        requestDbAndWait(statusRequest).catch(e => console.error(\"Failed to set session status on direct scrape processing error:\", e));\n    } finally {\n         isSendingMessage = false; // TODO: Remove later\n    }\n}\n\ndocument.addEventListener(UIEventNames.QUERY_SUBMITTED, (e) => handleQuerySubmit(e.detail));\ndocument.addEventListener(UIEventNames.BACKGROUND_RESPONSE_RECEIVED, (e) => handleBackgroundMsgResponse(e.detail));\ndocument.addEventListener(UIEventNames.BACKGROUND_ERROR_RECEIVED, (e) => handleBackgroundMsgError(e.detail));\ndocument.addEventListener(UIEventNames.BACKGROUND_SCRAPE_STAGE_RESULT, handleBackgroundScrapeStage);\ndocument.addEventListener(UIEventNames.BACKGROUND_SCRAPE_RESULT_RECEIVED, handleBackgroundDirectScrapeResult);\n\nexport function initializeOrchestrator(dependencies) {\n    getActiveSessionIdFunc = dependencies.getActiveSessionIdFunc;\n    onSessionCreatedCallback = dependencies.onSessionCreatedCallback;\n    getCurrentTabIdFunc = dependencies.getCurrentTabIdFunc;\n\n    if (!getActiveSessionIdFunc || !onSessionCreatedCallback || !getCurrentTabIdFunc) {\n        console.error(\"Orchestrator: Missing one or more dependencies during initialization!\");\n        return;\n    }\n\n    console.log(\"[Orchestrator] Initializing and subscribing to application events...\");\n    console.log(\"[Orchestrator] Event subscriptions complete.\");\n}","import {  UIEventNames, DirectDBNames, DBEventNames } from '../events/eventNames.js';\nimport {  clearTemporaryMessages } from './chatRenderer.js';\nimport browser from 'webextension-polyfill';\nimport { dbChannel } from '../Utilities/dbChannels.js';\n\nlet queryInput, sendButton, chatBody, attachButton, fileInput,  loadingIndicatorElement, \n    historyButton, historyPopup, historyList, closeHistoryButton, newChatButton, historySearchInput, \n    sessionListElement, driveButton, driveViewerModal, driveViewerClose, driveViewerBack, driveViewerContent, \n    driveViewerList, driveViewerSearch, driveViewerBreadcrumbs, driveViewerSelectedArea, driveViewerCancel, \n    driveViewerInsert, starredListElement, loadModelButton, modelLoadProgress;\nlet isInitialized = false;\nlet attachFileCallback = null;\nlet currentSessionId = null;\nimport { DbStatusUpdatedNotification } from '../events/dbEvents.js';\n\n// Define available models (can be moved elsewhere later)\nconst AVAILABLE_MODELS = {\n    // Model ID (value) : Display Name\n  //  \"Xenova/Qwen1.5-1.8B-Chat\": \"Qwen 1.8B Chat (Quantized)\",\n   // \"Xenova/Phi-3-mini-4k-instruct\": \"Phi-3 Mini Instruct (Quantized)\",\n    //\"HuggingFaceTB/SmolLM-1.7B-Instruct\": \"SmolLM 1.7B Instruct\",\n    //\"HuggingFaceTB/SmolLM2-1.7B\": \"SmolLM2 1.7B\",\n   // \"google/gemma-3-4b-it-qat-q4_0-gguf\": \"Gemma 3 4B IT Q4 (GGUF)\", \n   // \"bubblspace/Bubbl-P4-multimodal-instruct\": \"Bubbl-P4 Instruct (Multimodal)\", \n    //\"microsoft/Phi-4-multimodal-instruct\": \"Phi-4 Instruct (Multimodal)\", \n   // \"microsoft/Phi-4-mini-instruct\": \"Phi-4 Mini Instruct\",\n    //\"Qwen/Qwen3-4B\": \"Qwen/Qwen3-4B\",\n    //\"google/gemma-3-1b-pt\": \"google/gemma-3-1b-pt\",\n\n    \"HuggingFaceTB/SmolLM2-360M-Instruct\": \"SmolLM2-360M Instruct\",\n    \"onnx-models/all-MiniLM-L6-v2-onnx\": \"MiniLM-L6-v2\",\n    // Add more models here as needed\n};\n\ndocument.addEventListener(DbStatusUpdatedNotification.type, (e) => {\n    console.log('[UIController] Received DbStatusUpdatedNotification: ', e.detail);\n    handleStatusUpdate(e.detail);\n  });\n\n// Add this at the top level to ensure UI progress bar updates\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const type = message?.type;\n    console.log('[UIController] browser.runtime.onMessage Received progress update: ', message.type, message.payload);\n    if (message.type === DbStatusUpdatedNotification.type) {\n        handleStatusUpdate(message.payload);\n    }\n    if (Object.values(DirectDBNames).includes(type)) {\n        return false;\n    }\n    if (Object.values(DBEventNames).includes(type)) {\n        return false;\n    }\n    if (message.type === UIEventNames.MODEL_DOWNLOAD_PROGRESS || message.type === UIEventNames.BACKGROUND_LOADING_STATUS_UPDATE) {\n       \n        handleLoadingProgress(message.payload);\n    }\n});\n\ndbChannel.onmessage = (event) => {\n    const message = event.data;\n    const type = message?.type;\n    console.log('[UIController] dbChannel.onmessage Received progress update: ', message.type, message.payload);\n    if (type === DbStatusUpdatedNotification.type) {\n        handleStatusUpdate(message.payload);\n    }\n    // Add other notification types as needed\n};\n\nfunction selectElements() {\n    queryInput = document.getElementById('query-input');\n    sendButton = document.getElementById('send-button');\n    chatBody = document.getElementById('chat-body');\n    attachButton = document.getElementById('attach-button');\n    fileInput = document.getElementById('file-input');\n    loadingIndicatorElement = document.getElementById('loading-indicator');\n    if (!queryInput || !sendButton || !chatBody || !attachButton || !fileInput /*|| !sessionListElement*/) {\n        console.error(\"UIController: One or more essential elements not found (excluding session list)!\");\n        return false;\n    }\n    return true;\n}\n\nfunction attachListeners() {\n    queryInput?.addEventListener('input', adjustTextareaHeight);\n    queryInput?.addEventListener('keydown', handleEnterKey);\n    sendButton?.addEventListener('click', handleSendButtonClick);\n    attachButton?.addEventListener('click', handleAttachClick);\n}\n\nfunction removeListeners() {\n    queryInput?.removeEventListener('input', adjustTextareaHeight);\n    queryInput?.removeEventListener('keydown', handleEnterKey);\n    sendButton?.removeEventListener('click', handleSendButtonClick);\n    attachButton?.removeEventListener('click', handleAttachClick);\n}\n\nfunction handleEnterKey(event) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        const messageText = getInputValue();\n        if (messageText && !queryInput.disabled) {\n            console.log(\"[UIController] Enter key pressed. Publishing ui:querySubmitted\");\n            document.dispatchEvent(new CustomEvent(UIEventNames.QUERY_SUBMITTED, { detail: { text: messageText } }));\n            clearInput();\n        } else {\n             console.log(\"[UIController] Enter key pressed, but input is empty or disabled.\");\n        }\n    }\n}\n\nfunction handleSendButtonClick() {\n    const messageText = getInputValue();\n    if (messageText && !queryInput.disabled) {\n        console.log(\"[UIController] Send button clicked. Publishing ui:querySubmitted\");\n        document.dispatchEvent(new CustomEvent(UIEventNames.QUERY_SUBMITTED, { detail: { text: messageText } }));\n        clearInput();\n    } else {\n        console.log(\"[UIController] Send button clicked, but input is empty or disabled.\");\n    }\n}\n\nfunction handleAttachClick() {\n    if (attachFileCallback) {\n        attachFileCallback();\n    }\n}\n\nexport function adjustTextareaHeight() {\n    if (!queryInput) return;\n    queryInput.style.height = 'auto';\n    const maxHeight = 150;\n    const scrollHeight = queryInput.scrollHeight;\n    queryInput.style.height = `${Math.min(scrollHeight, maxHeight)}px`;\n    if (sendButton) {\n        sendButton.disabled = queryInput.value.trim() === '' || queryInput.disabled;\n    }\n}\n\nfunction setInputStateInternal(status) {\n    console.log(`[UIController] setInputStateInternal called with status: ${status}`);\n    if (!isInitialized || !queryInput || !sendButton) return;\n    switch (status) {\n        case 'processing':\n            queryInput.disabled = true;\n            sendButton.disabled = true;\n            break;\n        case 'error':\n        case 'idle':\n        case 'complete':\n        default:\n            queryInput.disabled = false;\n            adjustTextareaHeight();\n            break;\n    }\n    console.log(`[UIController] Input disabled state: ${queryInput.disabled}`);\n}\n\nfunction showLoadingIndicatorInternal(message = '', showSpinner = true) {\n    if (!isInitialized || !loadingIndicatorElement) return;\n\n    const textElement = loadingIndicatorElement.querySelector('span');\n    if (textElement) textElement.textContent = message;\n    \n    const spinner = loadingIndicatorElement.querySelector('svg');\n    if (spinner) spinner.classList.toggle('hidden', !showSpinner);\n\n    loadingIndicatorElement.classList.remove('hidden');\n\n    if (message.startsWith('Downloading') || message.startsWith('Loading')) {\n        setLoadButtonState('loading', message); \n    } \n}\n\nfunction hideLoadingIndicatorInternal() {\n    if (!isInitialized || !loadingIndicatorElement) return;\n    loadingIndicatorElement.classList.add('hidden');\n}\n\nfunction handleStatusUpdate(notification) {\n    if (!isInitialized || !notification || !notification.sessionId || !notification.payload) return;\n    if (notification.sessionId === currentSessionId) {\n        setInputStateInternal(notification.payload.status || 'idle');\n    }\n}\n\nfunction handleLoadingProgress(payload) {\n    if (!payload) return;\n    const statusDiv = document.getElementById('model-load-status');\n    const statusText = document.getElementById('model-load-status-text');\n    const progressBar = document.getElementById('model-load-progress-bar');\n    const progressInner = document.getElementById('model-load-progress-inner');\n\n    if (!statusDiv || !statusText || !progressBar || !progressInner) {\n        console.warn('[UIController] Model load progress bar not found.');\n        return;\n    }\n\n    // Always show the status area while loading or on error\n    statusDiv.style.display = 'block';\n    progressBar.style.width = '100%';\n\n    // Handle error\n    if (payload.status === 'error' || payload.error) {\n        statusText.textContent = payload.error || 'Error loading model';\n        progressInner.style.background = '#f44336'; // red\n        progressInner.style.width = '100%';\n        return;\n    }\n\n    // Main progress bar (overall)\n    let percent = payload.progress || payload.percent || 0;\n    percent = Math.max(0, Math.min(100, percent));\n    progressInner.style.width = percent + '%';\n    progressInner.style.background = '#4caf50'; // green\n\n    // Status text\n    let text = '';\n    // Truncate file name for display\n    function truncateFileName(name, maxLen = 32) {\n        if (!name) return '';\n        return name.length > maxLen ? name.slice(0, maxLen - 3) + '...' : name;\n    }\n    if (payload.summary && payload.message) {\n        text = payload.message;\n    } else if (payload.status === 'progress' && payload.file) {\n        const shortFile = truncateFileName(payload.file);\n        text = `Downloading ${shortFile}`;\n        if (payload.chunkIndex && payload.totalChunks) {\n            text += ` (chunk ${payload.chunkIndex} of ${payload.totalChunks})`;\n        }\n        text += `... ${Math.round(percent)}%`;\n    } else if (payload.status === 'done' && payload.file) {\n        const shortFile = truncateFileName(payload.file);\n        text = `${shortFile} downloaded. Preparing pipeline...`;\n    } else {\n        text = 'Loading...';\n    }\n    statusText.textContent = text;\n\n    // Hide when done (but not on error)\n    if ((percent >= 100 || payload.status === 'done' || (payload.summary && percent >= 100)) && !(payload.status === 'error' || payload.error)) {\n        setTimeout(() => { statusDiv.style.display = 'none'; }, 1000);\n    }\n}\n\n\n\n\nexport async function initializeUI(callbacks) {\n    console.log(\"[UIController] Initializing...\");\n    if (isInitialized) {\n        removeListeners();\n    }\n    if (!selectElements()) {\n        isInitialized = false;\n        return null;\n    }\n    attachFileCallback = callbacks?.onAttachFile;\n    \n    attachListeners();\n    \n    const newChatButton = document.getElementById('new-chat-button');\n    if (newChatButton && callbacks?.onNewChat) {\n        newChatButton.addEventListener('click', callbacks.onNewChat);\n    }\n\n    isInitialized = true;\n    setInputStateInternal('idle');\n    adjustTextareaHeight();\n    console.log(\"[UIController] Initialized successfully.\");\n\n    console.log(`[UIController] Returning elements: chatBody is ${chatBody ? 'found' : 'NULL'}, fileInput is ${fileInput ? 'found' : 'NULL'}`);\n\n    clearTemporaryMessages();\n\n    loadModelButton = document.getElementById('load-model-button');\n    if (loadModelButton) {\n        loadModelButton.addEventListener('click', handleLoadModelClick);\n    } else {\n        console.error(\"[UIController] Load Model button not found!\");\n    }\n\n    disableInput(\"Model not loaded. Click 'Load'.\");\n    setLoadButtonState('idle');\n\n    console.log(\"[UIController] Initializing UI elements...\");\n\n    // Populate model selector\n    console.log(\"[UIController] Attempting to find model selector...\");\n    const modelSelector = document.getElementById('model-selector');\n    console.log(modelSelector ? \"[UIController] Model selector found.\" : \"[UIController] WARNING: Model selector NOT found!\");\n    if (modelSelector) {\n        modelSelector.innerHTML = ''; // Clear existing options\n        console.log(\"[UIController] Populating model selector. Available models:\", AVAILABLE_MODELS);\n        for (const [modelId, displayName] of Object.entries(AVAILABLE_MODELS)) {\n            console.log(`[UIController] Adding option: ${displayName} (${modelId})`);\n            const option = document.createElement('option');\n            option.value = modelId;\n            option.textContent = displayName;\n            modelSelector.appendChild(option);\n        }\n\n    } else {\n        console.warn(\"[UIController] Model selector dropdown not found.\");\n    }\n\n    console.log(\"[UIController] UI Initialization complete.\");\n    return { chatBody, queryInput, sendButton, attachButton, fileInput };\n}\n\nexport function setActiveSession(sessionId) {\n    console.log(`[UIController] Setting active session for UI state: ${sessionId}`);\n    currentSessionId = sessionId;\n    if (!sessionId) {\n        setInputStateInternal('idle'); \n    } \n}\n\nexport function checkInitialized() {\n    return isInitialized;\n}\n\nexport function getInputValue() {\n    return queryInput?.value.trim() || '';\n}\n\nexport function clearInput() {\n    console.log(\"[UIController] Entering clearInput function.\");\n    if (queryInput) {\n        queryInput.value = '';\n        adjustTextareaHeight();\n    }\n}\n\nexport function focusInput() {\n    queryInput?.focus();\n}\n\nexport function triggerFileInputClick() {\n    fileInput?.click();\n}\n\nfunction handleLoadModelClick() {\n    if (!isInitialized) return;\n    console.log(\"[UIController] Load Model button clicked.\");\n\n    const modelSelector = document.getElementById('model-selector');\n    const selectedModelId = modelSelector?.value;\n\n    if (!selectedModelId) {\n        console.error(\"[UIController] Cannot load: No model selected or selector not found.\");\n        showNotification(\"Error: Please select a model.\", \"error\");\n        return;\n    }\n\n    console.log(`[UIController] Requesting load for model: ${selectedModelId}`);\n    setLoadButtonState('loading'); \n    disableInput(`Loading ${AVAILABLE_MODELS[selectedModelId] || selectedModelId}...`); \n    document.dispatchEvent(new CustomEvent(UIEventNames.REQUEST_MODEL_LOAD, { detail: { modelId: selectedModelId } }));\n}\n\nfunction setLoadButtonState(state, text = 'Load') {\n    if (!isInitialized || !loadModelButton) return;\n\n    switch (state) {\n        case 'idle':\n            loadModelButton.disabled = false;\n            loadModelButton.textContent = text;\n            loadModelButton.classList.replace('bg-yellow-500', 'bg-green-500');\n            loadModelButton.classList.replace('bg-gray-500', 'bg-green-500');\n            break;\n        case 'loading':\n            loadModelButton.disabled = true;\n            loadModelButton.textContent = text === 'Load' ? 'Loading...' : text;\n            loadModelButton.classList.replace('bg-green-500', 'bg-yellow-500');\n             loadModelButton.classList.replace('bg-gray-500', 'bg-yellow-500');\n            break;\n        case 'loaded':\n            loadModelButton.disabled = true;\n            loadModelButton.textContent = 'Loaded';\n            loadModelButton.classList.replace('bg-green-500', 'bg-gray-500'); \n            loadModelButton.classList.replace('bg-yellow-500', 'bg-gray-500');\n            break;\n        case 'error':\n            loadModelButton.disabled = false;\n            loadModelButton.textContent = 'Load Failed';\n            loadModelButton.classList.replace('bg-yellow-500', 'bg-red-500');\n            loadModelButton.classList.replace('bg-green-500', 'bg-red-500');\n            loadModelButton.classList.replace('bg-gray-500', 'bg-red-500');\n            break;\n    }\n}\n\nfunction disableInput(reason = \"Processing...\") {\n    if (!isInitialized || !queryInput || !sendButton) return;\n    queryInput.disabled = true;\n    queryInput.placeholder = reason;\n    sendButton.disabled = true;\n}\n\nfunction enableInput() {\n    if (!isInitialized || !queryInput || !sendButton) return;\n    queryInput.disabled = false; \n    queryInput.placeholder = \"Ask Tab Agent...\";\n    sendButton.disabled = queryInput.value.trim() === '';\n}\n\ndocument.addEventListener(UIEventNames.WORKER_READY, (e) => {\n    const payload = e.detail;\n    console.log(\"[UIController] Received worker:ready signal\", payload);\n    // Hide progress bar area\n    const statusDiv = document.getElementById('model-load-status');\n    if (statusDiv) statusDiv.style.display = 'none';\n    setLoadButtonState('loaded');\n});\n\ndocument.addEventListener(UIEventNames.WORKER_ERROR, (e) => {\n    const payload = e.detail;\n    console.error(\"[UIController] Received worker:error signal\", payload);\n    // Show error in progress bar area and keep it visible\n    const statusDiv = document.getElementById('model-load-status');\n    const statusText = document.getElementById('model-load-status-text');\n    const progressInner = document.getElementById('model-load-progress-inner');\n    if (statusDiv && statusText && progressInner) {\n        statusDiv.style.display = 'block';\n        statusText.textContent = payload?.error || 'Model load failed.';\n        progressInner.style.background = '#f44336';\n        progressInner.style.width = '100%';\n    }\n    setLoadButtonState('error');\n    disableInput(\"Model load failed. Check logs.\");\n});","export const dbChannel = new BroadcastChannel('tabagent-db');\r\nexport const llmChannel = new BroadcastChannel('tabagent-llm');\r\nexport const logChannel = new BroadcastChannel('tabagent-logs'); ","export const USERS_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS users (\r\n    id TEXT PRIMARY KEY,\r\n    name TEXT,\r\n    email TEXT\r\n);\r\n`;\r\n\r\nexport const CHATS_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS chats (\r\n    id TEXT PRIMARY KEY,\r\n    user_id TEXT,\r\n    tabId INTEGER,\r\n    timestamp INTEGER,\r\n    title TEXT,\r\n    isStarred INTEGER DEFAULT 0,\r\n    status TEXT DEFAULT 'idle',\r\n    metadata TEXT,         -- JSON: {topic, domain, tags, ...}\r\n    summary TEXT,          -- High-level summary of the chat\r\n    embedding BLOB,        -- Vector for the whole chat\r\n    topic TEXT,            -- (optional, for fast lookup)\r\n    domain TEXT,           -- (optional)\r\n    FOREIGN KEY(user_id) REFERENCES users(id)\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_chats_timestamp ON chats(timestamp);\r\nCREATE INDEX IF NOT EXISTS idx_chats_isStarred ON chats(isStarred);\r\nCREATE INDEX IF NOT EXISTS idx_chats_user_id ON chats(user_id);\r\nCREATE INDEX IF NOT EXISTS idx_chats_topic ON chats(topic);\r\nCREATE INDEX IF NOT EXISTS idx_chats_domain ON chats(domain);\r\n`;\r\n\r\nexport const LOG_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS logs (\r\n    id TEXT PRIMARY KEY,\r\n    timestamp INTEGER,\r\n    level TEXT CHECK(level IN ('error', 'warn', 'info', 'debug')),\r\n    message TEXT,\r\n    component TEXT,\r\n    extensionSessionId TEXT,\r\n    chatSessionId TEXT DEFAULT NULL\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_logs_timestamp ON logs(timestamp);\r\nCREATE INDEX IF NOT EXISTS idx_logs_level ON logs(level);\r\nCREATE INDEX IF NOT EXISTS idx_logs_component ON logs(component);\r\nCREATE INDEX IF NOT EXISTS idx_logs_extensionSessionId ON logs(extensionSessionId);\r\nCREATE INDEX IF NOT EXISTS idx_logs_chatSessionId ON logs(chatSessionId);\r\n`;\r\n\r\nexport const MODEL_ASSET_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS model_assets (\r\n    id TEXT PRIMARY KEY,\r\n    folder TEXT,\r\n    fileName TEXT,\r\n    fileType TEXT,\r\n    data BLOB,\r\n    size INTEGER,\r\n    addedAt INTEGER,\r\n    chunkIndex INTEGER DEFAULT 0,\r\n    totalChunks INTEGER DEFAULT 1,\r\n    chunkGroupId TEXT DEFAULT '',\r\n    binarySize INTEGER,\r\n    totalFileSize INTEGER\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_model_assets_folder ON model_assets(folder);\r\nCREATE INDEX IF NOT EXISTS idx_model_assets_fileName ON model_assets(fileName);\r\nCREATE INDEX IF NOT EXISTS idx_model_assets_chunkGroupId ON model_assets(chunkGroupId);\r\nCREATE INDEX IF NOT EXISTS idx_model_assets_chunkGroupId_chunkIndex ON model_assets(chunkGroupId, chunkIndex);\r\n`;\r\n\r\nexport const MESSAGES_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS messages (\r\n    id TEXT PRIMARY KEY,\r\n    chat_id TEXT,\r\n    timestamp INTEGER,\r\n    sender TEXT,\r\n    type TEXT,         -- 'text', 'image', 'file', 'code', 'agent_action', etc.\r\n    content TEXT,      -- main content (text, JSON, or reference)\r\n    metadata TEXT,     -- JSON string for extra fields (language, tool args, etc.)\r\n    embedding BLOB,    -- vector embedding for semantic search (Float32Array, Uint8Array, etc.)\r\n    FOREIGN KEY(chat_id) REFERENCES chats(id) ON DELETE CASCADE\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_messages_chat_id ON messages(chat_id);\r\nCREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp);\r\nCREATE INDEX IF NOT EXISTS idx_messages_type ON messages(type);\r\n`;\r\n\r\nexport const ATTACHMENTS_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS attachments (\r\n    id TEXT PRIMARY KEY,\r\n    message_id TEXT,\r\n    file_name TEXT,\r\n    mime_type TEXT,\r\n    data BLOB,\r\n    FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_attachments_message_id ON attachments(message_id);\r\n`;\r\n\r\nexport const CHAT_SUMMARIES_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS chat_summaries (\r\n    id TEXT PRIMARY KEY,\r\n    chat_id TEXT NOT NULL,\r\n    parent_summary_id TEXT,      -- nullable, for summary-of-summary\r\n    start_message_id TEXT,       -- nullable if summarizing summaries\r\n    end_message_id TEXT,\r\n    start_timestamp INTEGER,\r\n    end_timestamp INTEGER,\r\n    summary TEXT NOT NULL,\r\n    embedding BLOB,              -- vector embedding\r\n    token_count INTEGER,\r\n    metadata TEXT,               -- JSON: {topic, tags, ...}\r\n    created_at INTEGER,\r\n    FOREIGN KEY(chat_id) REFERENCES chats(id),\r\n    FOREIGN KEY(parent_summary_id) REFERENCES chat_summaries(id)\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_chat_summaries_chat_id ON chat_summaries(chat_id);\r\nCREATE INDEX IF NOT EXISTS idx_chat_summaries_parent ON chat_summaries(parent_summary_id);\r\n`;\r\n\r\nexport const KNOWLEDGE_GRAPH_EDGES_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS knowledge_graph_edges (\r\n    id TEXT PRIMARY KEY,\r\n    from_node_id TEXT NOT NULL,   -- can be chat, summary, topic, etc.\r\n    to_node_id TEXT NOT NULL,\r\n    edge_type TEXT,               -- e.g., 'summarizes', 'references', 'is_about'\r\n    metadata TEXT,                -- JSON for edge properties\r\n    created_at INTEGER\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_kg_edges_from ON knowledge_graph_edges(from_node_id);\r\nCREATE INDEX IF NOT EXISTS idx_kg_edges_to ON knowledge_graph_edges(to_node_id);\r\nCREATE INDEX IF NOT EXISTS idx_kg_edges_type ON knowledge_graph_edges(edge_type);\r\n`;\r\n\r\nexport const KNOWLEDGE_GRAPH_NODES_TABLE_SQL = `\r\nCREATE TABLE IF NOT EXISTS knowledge_graph_nodes (\r\n    id TEXT PRIMARY KEY,\r\n    type TEXT,           -- e.g. 'entity', 'concept', 'document', etc.\r\n    label TEXT,          -- Human-readable label\r\n    properties TEXT,     -- JSON string for arbitrary node properties\r\n    embedding BLOB,      -- Optional: vector for semantic search\r\n    created_at INTEGER,\r\n    updated_at INTEGER\r\n);\r\nCREATE INDEX IF NOT EXISTS idx_kg_nodes_type ON knowledge_graph_nodes(type);\r\nCREATE INDEX IF NOT EXISTS idx_kg_nodes_label ON knowledge_graph_nodes(label);\r\n`; \r\n\r\n","import { DbGetSessionRequest } from '../events/dbEvents.js';\r\nimport { formatChatToHtml, downloadHtmlFile } from '../downloadFormatter.js';\r\n\r\n/**\r\n * Fetches, formats, and initiates the download for a chat session.\r\n * @param {string} sessionId - The ID of the session to download.\r\n * @param {Function} requestDbAndWaitFunc - The function to make DB requests.\r\n * @param {Function} showNotificationFunc - The function to display notifications.\r\n */\r\nexport async function initiateChatDownload(sessionId, requestDbAndWaitFunc, showNotificationFunc) {\r\n    if (!sessionId || !requestDbAndWaitFunc || !showNotificationFunc) {\r\n        console.error(\"[initiateChatDownload] Failed: Missing sessionId, requestDbAndWaitFunc, or showNotificationFunc.\");\r\n        if (showNotificationFunc) showNotificationFunc(\"Download failed due to internal error.\", 'error');\r\n        return;\r\n    }\r\n\r\n    console.log(`[initiateChatDownload] Preparing download for: ${sessionId}`);\r\n    showNotificationFunc(\"Preparing download...\", 'info');\r\n\r\n    try {\r\n        const sessionData = await requestDbAndWaitFunc(new DbGetSessionRequest(sessionId));\r\n        if (!sessionData) {\r\n            throw new Error(\"Chat session data not found.\");\r\n        }\r\n\r\n        const htmlContent = formatChatToHtml(sessionData);\r\n        const safeTitle = (sessionData.title || sessionData.name || 'Chat_Session').replace(/[^a-z0-9_\\-\\.]/gi, '_').replace(/_{2,}/g, '_');\r\n        const filename = `${safeTitle}_${sessionId.substring(0, 8)}.html`;\r\n\r\n        downloadHtmlFile(htmlContent, filename, (errorMessage) => {\r\n            showNotificationFunc(errorMessage, 'error');\r\n        });\r\n    } catch (error) {\r\n        console.error(`[initiateChatDownload] Error preparing download for ${sessionId}:`, error);\r\n        showNotificationFunc(`Failed to prepare download: ${error.message}`, 'error');\r\n    }\r\n} ","import browser from 'webextension-polyfill';\r\n\r\nexport function showError(message) {\r\n    console.error(\"UI Error:\", message);\r\n    const errorDiv = document.createElement('div');\r\n    errorDiv.style.position = 'fixed';\r\n    errorDiv.style.bottom = '10px';\r\n    errorDiv.style.left = '10px';\r\n    errorDiv.style.backgroundColor = 'red';\r\n    errorDiv.style.color = 'white';\r\n    errorDiv.style.padding = '10px';\r\n    errorDiv.style.borderRadius = '5px';\r\n    errorDiv.style.zIndex = '1000';\r\n    errorDiv.textContent = message;\r\n    document.body.appendChild(errorDiv);\r\n    setTimeout(() => errorDiv.remove(), 3000);\r\n}\r\n\r\nexport function debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () => {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\r\nexport const URL_REGEX = /^(https?):\\/\\/[^\\s/$.?#].[^\\s]*$/i;\r\n\r\nexport function getActiveTab() {\r\n    if (typeof browser === 'undefined' || !browser.tabs) {\r\n         console.warn(\"Utils: Browser context or tabs API not available. Cannot get active tab.\");\r\n         return Promise.resolve(null);\r\n    }\r\n    return browser.tabs.query({ active: true, currentWindow: true })\r\n        .then(tabs => {\r\n            if (tabs && tabs.length > 0) {\r\n                return tabs[0];\r\n            } else {\r\n                return null;\r\n            }\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Utils: Error querying active tab:\", error.message);\r\n            return null;\r\n        });\r\n}\r\n\r\nexport function getActiveTabUrl() {\r\n    if (typeof browser === 'undefined' || !browser.tabs) {\r\n        console.warn(\"Utils: Browser context or tabs API not available.\");\r\n        return Promise.resolve(null);\r\n    }\r\n    return browser.tabs.query({ active: true, currentWindow: true })\r\n        .then(tabs => {\r\n            if (tabs && tabs.length > 0 && tabs[0].url) {\r\n                return tabs[0].url;\r\n            } else {\r\n                return null;\r\n            }\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Utils: Error querying active tab URL:\", error.message);\r\n            return Promise.reject(error);\r\n        });\r\n} ","import { MessageSenderTypes } from './events/eventNames.js';\n\n/**\n * Formats a chat session object into a self-contained HTML string.\n * @param {object} sessionData - The chat session object from the database.\n * @returns {string} - The generated HTML string.\n */\nexport function formatChatToHtml(sessionData) {\n    if (!sessionData) return '';\n\n    const title = sessionData.title || 'Chat Session';\n    const messagesHtml = (sessionData.messages || []).map(msg => {\n        const senderClass = msg.sender === MessageSenderTypes.USER ? 'user-message' : 'other-message';\n        const senderLabel = msg.sender === MessageSenderTypes.USER ? 'You' : (msg.sender === MessageSenderTypes.AI ? 'Agent' : 'System');\n        // Basic sanitization: escape HTML characters to prevent XSS if message text somehow contains HTML\n        const escapedText = msg.text.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        // Convert newlines to <br> tags for display\n        const formattedText = escapedText.replace(/\\n/g, '<br>');\n\n        return `\n            <div class=\"message-row ${senderClass === 'user-message' ? 'row-user' : 'row-other'}\">\n                <div class=\"message-bubble ${senderClass}\">\n                    <span class=\"sender-label\">${senderLabel}:</span>\n                    <div class=\"message-text\">${formattedText}</div>\n                </div>\n            </div>\n        `;\n    }).join('\\n');\n\n    // Basic CSS for styling the downloaded file\n    const css = `\n        body { font-family: sans-serif; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #212529; }\n        .container { max-width: 800px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        h1 { color: #343a40; border-bottom: 1px solid #dee2e6; padding-bottom: 10px; margin-top: 0; }\n        .chat-body { margin-top: 20px; }\n        .message-row { margin-bottom: 15px; overflow: hidden; /* Clear floats */ }\n        .row-user { text-align: right; }\n        .row-other { text-align: left; }\n        .message-bubble { display: inline-block; padding: 10px 15px; border-radius: 15px; max-width: 75%; word-wrap: break-word; }\n        .user-message { background-color: #007bff; color: white; margin-left: auto; /* Align right */ }\n        .other-message { background-color: #e9ecef; color: #343a40; margin-right: auto; /* Align left */ }\n        .sender-label { font-weight: bold; display: block; margin-bottom: 5px; font-size: 0.9em; color: inherit; }\n        .message-text { margin-top: 5px; }\n    `;\n\n    return `\n        <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <title>${title.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")}</title>\n            <style>${css}</style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <h1>${title.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")}</h1>\n                <div class=\"chat-body\">\n                    ${messagesHtml}\n                </div>\n            </div>\n        </body>\n        </html>\n    `;\n}\n\n/**\n * Initiates the download of the provided HTML content as a file.\n * Requires the \"downloads\" permission in manifest.json.\n * @param {string} htmlContent - The HTML string to download.\n * @param {string} filename - The suggested filename (e.g., \"chat_session.html\").\n * @param {(message: string) => void} [onError] - Optional callback function to handle errors.\n */\nexport function downloadHtmlFile(htmlContent, filename, onError) {\n    try {\n        const blob = new Blob([htmlContent], { type: 'text/html' });\n        const url = URL.createObjectURL(blob);\n\n        console.log(`Initiating download for: ${filename} (prompting user)`);\n        chrome.downloads.download({\n            url: url,\n            filename: filename,\n            saveAs: true\n        }, (downloadId) => {\n            const lastError = chrome.runtime.lastError;\n            // Important: Always revoke the URL\n            setTimeout(() => URL.revokeObjectURL(url), 100);\n\n            if (lastError) {\n                const message = lastError.message;\n                console.error(\"Download API error:\", message);\n                // Don't trigger error callback if the user simply cancelled the dialog\n                if (!message || !message.toLowerCase().includes('cancel')) {\n                    if (onError) {\n                        // Provide a user-friendly message\n                        onError(`Download failed: ${message || 'Unknown error'}`);\n                    } else {\n                        // Fallback if no callback provided (should not happen in our case)\n                        console.error(\"No error handler provided for download failure.\");\n                        alert(`Download failed: ${message || 'Unknown error'}. Ensure extension has permissions.`);\n                    }\n                } else {\n                    console.log(\"Download cancelled by user.\");\n                }\n            } else if (downloadId) {\n                // Successfully initiated (or dialog opened)\n                console.log(`Download initiated (or dialog opened) with ID: ${downloadId}`);\n                // We could call an onSuccess callback here if needed\n            } else {\n                // This case might occur if the user cancels *before* an ID is assigned\n                console.log(\"Download cancelled by user (no downloadId assigned).\");\n            }\n        });\n    } catch (error) {\n        console.error(\"Error creating blob or initiating download:\", error);\n        if (onError) {\n            onError(\"An error occurred while preparing the download.\");\n        } else {\n            console.error(\"No error handler provided for download preparation error.\");\n            alert(\"An error occurred while preparing the download.\");\n        }\n    }\n} ","import { DBEventNames } from './eventNames.js';\n\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n\nexport class DbEventBase {\n  constructor(requestId = null) {\n    this.requestId = requestId || generateUUID();\n    this.timestamp = Date.now();\n  }\n}\n\nexport class DbResponseBase extends DbEventBase {\n  constructor(originalRequestId, success, data = null, error = null) {\n    super(originalRequestId);\n    this.success = success;\n    this.data = data;\n    this.error = error ? (error.message || String(error)) : null;\n  }\n}\n\nclass DbNotificationBase {\n    constructor(sessionId) {\n        this.sessionId = sessionId;\n        this.timestamp = Date.now();\n    }\n}\n\n\n\nexport class DbGetSessionResponse extends DbResponseBase {\n  static type = DBEventNames.DB_GET_SESSION_RESPONSE;\n  constructor(originalRequestId, success, sessionData, error = null) {\n    super(originalRequestId, success, sessionData, error);\n    this.type = DbGetSessionResponse.type;\n  }\n}\n\nexport class DbAddMessageResponse extends DbResponseBase {\n  static type = DBEventNames.DB_ADD_MESSAGE_RESPONSE;\n  constructor(originalRequestId, success, newMessageId, error = null) {\n    super(originalRequestId, success, { newMessageId }, error);\n    this.type = DbAddMessageResponse.type;\n  }\n}\n\nexport class DbUpdateMessageResponse extends DbResponseBase {\n    static type = DBEventNames.DB_UPDATE_MESSAGE_RESPONSE;\n    constructor(originalRequestId, success, error = null) {\n        super(originalRequestId, success, null, error);\n        this.type = DbUpdateMessageResponse.type;\n    }\n}\n\nexport class DbUpdateStatusResponse extends DbResponseBase {\n  static type = DBEventNames.DB_UPDATE_STATUS_RESPONSE;\n  constructor(originalRequestId, success, error = null) {\n    super(originalRequestId, success, null, error);\n    this.type = DbUpdateStatusResponse.type;\n  }\n}\n\nexport class DbDeleteMessageResponse extends DbResponseBase {\n    static type = DBEventNames.DB_DELETE_MESSAGE_RESPONSE;\n    constructor(originalRequestId, success, error = null) {\n        super(originalRequestId, success, null, error);\n        this.type = DbDeleteMessageResponse.type;\n    }\n}\n\nexport class DbToggleStarResponse extends DbResponseBase {\n    static type = DBEventNames.DB_TOGGLE_STAR_RESPONSE;\n    constructor(originalRequestId, success, updatedSessionData, error = null) {\n        super(originalRequestId, success, updatedSessionData, error);\n        this.type = DbToggleStarResponse.type;\n    }\n}\n\nexport class DbCreateSessionResponse extends DbResponseBase {\n    static type = DBEventNames.DB_CREATE_SESSION_RESPONSE;\n    constructor(originalRequestId, success, newSessionId, error = null) {\n        super(originalRequestId, success, { newSessionId }, error);\n        this.type = DbCreateSessionResponse.type;\n        console.log(`[dbEvents] DbCreateSessionResponse constructor: type set to ${this.type}`);\n    }\n\n    get newSessionId() {\n        return this.data?.newSessionId;\n    }\n}\n\nexport class DbDeleteSessionResponse extends DbResponseBase {\n    static type = DBEventNames.DB_DELETE_SESSION_RESPONSE;\n    constructor(originalRequestId, success, error = null) {\n        super(originalRequestId, success, null, error);\n        this.type = DbDeleteSessionResponse.type;\n    }\n}\n\nexport class DbRenameSessionResponse extends DbResponseBase {\n    static type = DBEventNames.DB_RENAME_SESSION_RESPONSE;\n    constructor(originalRequestId, success, error = null) {\n        super(originalRequestId, success, null, error);\n        this.type = DbRenameSessionResponse.type;\n    }\n}\n\nexport class DbGetAllSessionsResponse extends DbResponseBase {\n    static type = DBEventNames.DB_GET_ALL_SESSIONS_RESPONSE;\n    constructor(requestId, success, sessions = null, error = null) {\n        super(requestId, success, sessions, error);\n        this.type = DbGetAllSessionsResponse.type;\n        this.payload = { sessions };\n    }\n}\n\nexport class DbGetStarredSessionsResponse extends DbResponseBase {\n    static type = DBEventNames.DB_GET_STARRED_SESSIONS_RESPONSE;\n    constructor(requestId, success, starredSessions = null, error = null) {\n        super(requestId, success, starredSessions, error); \n        this.type = DbGetStarredSessionsResponse.type;\n    }\n}\n\nexport class DbGetReadyStateResponse extends DbResponseBase {\n    static type = DBEventNames.DB_GET_READY_STATE_RESPONSE;\n    constructor(originalRequestId, success, ready, error = null) {\n        super(originalRequestId, success, { ready }, error);\n        this.type = DbGetReadyStateResponse.type;\n        this.payload = { ready };\n    }\n}\n\n// --- Request Events (Define After Response Events) ---\n\nexport class DbGetSessionRequest extends DbEventBase {\n  static type = DBEventNames.DB_GET_SESSION_REQUEST;\n  static responseEventName = DBEventNames.DB_GET_SESSION_RESPONSE;\n  constructor(sessionId) {\n    super();\n    this.type = DbGetSessionRequest.type;\n    this.payload = { sessionId };\n  }\n}\n\nexport class DbAddMessageRequest extends DbEventBase {\n  static type = DBEventNames.DB_ADD_MESSAGE_REQUEST;\n  static responseEventName = DBEventNames.DB_ADD_MESSAGE_RESPONSE;\n  constructor(sessionId, messageObject) {\n    super();\n    this.type = DbAddMessageRequest.type;\n    this.payload = { sessionId, messageObject };\n  }\n}\n\nexport class DbUpdateMessageRequest extends DbEventBase {\n    static type = DBEventNames.DB_UPDATE_MESSAGE_REQUEST;\n    static responseEventName = DBEventNames.DB_UPDATE_MESSAGE_RESPONSE;\n    constructor(sessionId, messageId, updates) {\n        super();\n        this.type = DbUpdateMessageRequest.type;\n        this.payload = { sessionId, messageId, updates };\n    }\n}\n\nexport class DbUpdateStatusRequest extends DbEventBase {\n  static type = DBEventNames.DB_UPDATE_STATUS_REQUEST;\n  static responseEventName = DBEventNames.DB_UPDATE_STATUS_RESPONSE;\n  constructor(sessionId, status) {\n    super();\n    this.type = DbUpdateStatusRequest.type;\n    this.payload = { sessionId, status };\n  }\n}\n\nexport class DbDeleteMessageRequest extends DbEventBase {\n    static type = DBEventNames.DB_DELETE_MESSAGE_REQUEST;\n    static responseEventName = DBEventNames.DB_DELETE_MESSAGE_RESPONSE;\n    constructor(sessionId, messageId) {\n        super();\n        this.type = DbDeleteMessageRequest.type;\n        this.payload = { sessionId, messageId };\n    }\n}\n\nexport class DbToggleStarRequest extends DbEventBase {\n    static type = DBEventNames.DB_TOGGLE_STAR_REQUEST;\n    static responseEventName = DBEventNames.DB_TOGGLE_STAR_RESPONSE;\n    constructor(sessionId) {\n        super();\n        this.type = DbToggleStarRequest.type;\n        this.payload = { sessionId };\n    }\n}\n\nexport class DbCreateSessionRequest extends DbEventBase {\n    static type = DBEventNames.DB_CREATE_SESSION_REQUEST;\n    static responseEventName = DBEventNames.DB_CREATE_SESSION_RESPONSE;\n    constructor(initialMessage) {\n        super();\n        this.type = DbCreateSessionRequest.type;\n        this.payload = { initialMessage };\n        console.log(`[dbEvents] DbCreateSessionRequest constructor: type set to ${this.type}`);\n    }\n}\n\nexport class DbInitializeRequest extends DbEventBase {\n    static type = DBEventNames.DB_INITIALIZE_REQUEST;\n    constructor() {\n        super();\n        this.type = DbInitializeRequest.type;\n        this.payload = {}; \n    }\n}\n\nexport class DbDeleteSessionRequest extends DbEventBase {\n    static type = DBEventNames.DB_DELETE_SESSION_REQUEST;\n    static responseEventName = DBEventNames.DB_DELETE_SESSION_RESPONSE;\n    constructor(sessionId) {\n        super();\n        this.type = DbDeleteSessionRequest.type;\n        this.payload = { sessionId };\n    }\n}\n\nexport class DbRenameSessionRequest extends DbEventBase {\n    static type = DBEventNames.DB_RENAME_SESSION_REQUEST;\n    static responseEventName = DBEventNames.DB_RENAME_SESSION_RESPONSE;\n    constructor(sessionId, newName) {\n        super();\n        this.type = DbRenameSessionRequest.type;\n        this.payload = { sessionId, newName };\n    }\n}\n\nexport class DbGetAllSessionsRequest extends DbEventBase {\n    static type = DBEventNames.DB_GET_ALL_SESSIONS_REQUEST;\n    static responseEventName = DBEventNames.DB_GET_ALL_SESSIONS_RESPONSE;\n    constructor() {\n        super();\n        this.type = DbGetAllSessionsRequest.type;\n        console.log('[DEBUG][Create] DbGetAllSessionsRequest:', this, this.type);\n    }\n}\n\nexport class DbGetStarredSessionsRequest extends DbEventBase {\n    static type = DBEventNames.DB_GET_STARRED_SESSIONS_REQUEST;\n    static responseEventName = DBEventNames.DB_GET_STARRED_SESSIONS_RESPONSE;\n    constructor() {\n        super();\n        this.type = DbGetStarredSessionsRequest.type;\n    }\n}\n\nexport class DbGetReadyStateRequest extends DbEventBase {\n    static type = DBEventNames.DB_GET_READY_STATE_REQUEST;\n    static responseEventName = DBEventNames.DB_GET_READY_STATE_RESPONSE;\n    constructor() {\n        super();\n        this.type = DbGetReadyStateRequest.type;\n    }\n}\n\n// --- Notification Events ---\n\nexport class DbMessagesUpdatedNotification extends DbNotificationBase {\n    static type = DBEventNames.DB_MESSAGES_UPDATED_NOTIFICATION;\n    constructor(sessionId, messages) {\n        super(sessionId);\n        this.type = DbMessagesUpdatedNotification.type;\n        this.payload = { messages }; \n    }\n}\n\nexport class DbStatusUpdatedNotification extends DbNotificationBase {\n    static type = DBEventNames.DB_STATUS_UPDATED_NOTIFICATION;\n    constructor(sessionId, status) {\n        super(sessionId);\n        this.type = DbStatusUpdatedNotification.type;\n        this.payload = { status };\n    }\n}\n\nexport class DbSessionUpdatedNotification extends DbNotificationBase {\n    static type = DBEventNames.DB_SESSION_UPDATED_NOTIFICATION;\n    constructor(sessionId, updatedSessionData) {\n        super(sessionId);\n        this.type = DbSessionUpdatedNotification.type;\n        this.payload = { session: updatedSessionData }; \n    }\n}\n\nexport class DbInitializationCompleteNotification {\n    static type = DBEventNames.DB_INITIALIZATION_COMPLETE_NOTIFICATION;\n    constructor({ success, error = null }) {\n        this.type = DbInitializationCompleteNotification.type;\n        this.timestamp = Date.now();\n        this.payload = { success, error: error ? (error.message || String(error)) : null };\n    }\n}\n\n// --- Log Response Events ---\n\nexport class DbGetLogsResponse extends DbResponseBase {\n  static type = DBEventNames.DB_GET_LOGS_RESPONSE;\n  constructor(originalRequestId, success, logs, error = null) {\n    super(originalRequestId, success, logs, error); // data = logs array\n    this.type = DbGetLogsResponse.type;\n  }\n}\n\nexport class DbGetUniqueLogValuesResponse extends DbResponseBase {\n  static type = DBEventNames.DB_GET_UNIQUE_LOG_VALUES_RESPONSE;\n  constructor(originalRequestId, success, values, error = null) {\n    super(originalRequestId, success, values, error); // data = values array\n    this.type = DbGetUniqueLogValuesResponse.type;\n  }\n}\n\nexport class DbClearLogsResponse extends DbResponseBase {\n  static type = DBEventNames.DB_CLEAR_LOGS_RESPONSE;\n  constructor(originalRequestId, success, error = null) {\n    super(originalRequestId, success, null, error);\n    this.type = DbClearLogsResponse.type;\n  }\n}\n\nexport class DbGetCurrentAndLastLogSessionIdsResponse extends DbResponseBase {\n    static type = DBEventNames.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE;\n    constructor(originalRequestId, success, ids, error = null) {\n      // data = { currentLogSessionId: '...', previousLogSessionId: '...' | null }\n      super(originalRequestId, success, ids, error);\n      this.type = DbGetCurrentAndLastLogSessionIdsResponse.type;\n    }\n  }\n\nexport class DbAddLogRequest extends DbEventBase {\n  static type = DBEventNames.DB_ADD_LOG_REQUEST;\n  // No responseEventName needed for fire-and-forget\n  constructor(logEntryData) {\n    super(); \n    this.type = DbAddLogRequest.type;\n    this.payload = { logEntryData };\n  }\n}\n\nexport class DbGetLogsRequest extends DbEventBase {\n  static type = DBEventNames.DB_GET_LOGS_REQUEST;\n  static responseEventName = DBEventNames.DB_GET_LOGS_RESPONSE;\n  constructor(filters) {\n    // filters = { extensionSessionId: 'id' | 'current' | 'last' | 'all',\n    //             component: 'name' | 'all',\n    //             level: 'level' | 'all' }\n    super();\n    this.type = DbGetLogsRequest.type;\n    this.payload = { filters };\n  }\n}\n\nexport class DbGetUniqueLogValuesRequest extends DbEventBase {\n  static type = DBEventNames.DB_GET_UNIQUE_LOG_VALUES_REQUEST;\n  static responseEventName = DBEventNames.DB_GET_UNIQUE_LOG_VALUES_RESPONSE;\n  constructor(fieldName) {\n    // fieldName = 'extensionSessionId', 'component', 'level'\n    super();\n    this.type = DbGetUniqueLogValuesRequest.type;\n    this.payload = { fieldName };\n  }\n}\n\nexport class DbClearLogsRequest extends DbEventBase {\n    static type = DBEventNames.DB_CLEAR_LOGS_REQUEST;\n    static responseEventName = DBEventNames.DB_CLEAR_LOGS_RESPONSE;\n    constructor(filter = 'all') { // 'all' or potentially 'last_session' or specific session ID later\n        super();\n        this.type = DbClearLogsRequest.type;\n        this.payload = { filter };\n    }\n}\n\nexport class DbGetCurrentAndLastLogSessionIdsRequest extends DbEventBase {\n    static type = DBEventNames.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST;\n    static responseEventName = DBEventNames.DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE;\n    constructor() {\n        super();\n        this.type = DbGetCurrentAndLastLogSessionIdsRequest.type;\n    }\n}\n\nexport class DbResetDatabaseRequest extends DbEventBase {\n  static type = DBEventNames.DB_RESET_DATABASE_REQUEST;\n  constructor() {\n    super();\n    this.type = DbResetDatabaseRequest.type;\n  }\n}\n\nexport class DbResetDatabaseResponse extends DbResponseBase {\n  static type = DBEventNames.DB_RESET_DATABASE_RESPONSE;\n  constructor(originalRequestId, success, error = null) {\n    super(originalRequestId, success, null, error);\n    this.type = DbResetDatabaseResponse.type;\n  }\n}\n\n// --- Model Asset DB Operations ---\n\nexport class DbAddModelAssetRequest extends DbEventBase {\n  static type = DBEventNames.DB_ADD_MODEL_ASSET_REQUEST;\n  static responseEventName = DBEventNames.DB_ADD_MODEL_ASSET_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbAddModelAssetRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbAddModelAssetResponse extends DbResponseBase {\n  static type = DBEventNames.DB_ADD_MODEL_ASSET_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbAddModelAssetResponse.type;\n  }\n}\n\nexport class DbCountModelAssetChunksRequest extends DbEventBase {\n  static type = DBEventNames.DB_COUNT_MODEL_ASSET_CHUNKS_REQUEST;\n  static responseEventName = DBEventNames.DB_COUNT_MODEL_ASSET_CHUNKS_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbCountModelAssetChunksRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbCountModelAssetChunksResponse extends DbResponseBase {\n  static type = DBEventNames.DB_COUNT_MODEL_ASSET_CHUNKS_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbCountModelAssetChunksResponse.type;\n  }\n}\n\nexport class DbLogAllChunkGroupIdsForModelRequest extends DbEventBase {\n  static type = DBEventNames.DB_LOG_ALL_CHUNK_GROUP_IDS_FOR_MODEL_REQUEST;\n  static responseEventName = DBEventNames.DB_LOG_ALL_CHUNK_GROUP_IDS_FOR_MODEL_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbLogAllChunkGroupIdsForModelRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbLogAllChunkGroupIdsForModelResponse extends DbResponseBase {\n  static type = DBEventNames.DB_LOG_ALL_CHUNK_GROUP_IDS_FOR_MODEL_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbLogAllChunkGroupIdsForModelResponse.type;\n  }\n}\n\nexport class DbListModelFilesRequest extends DbEventBase {\n  static type = DBEventNames.DB_LIST_MODEL_FILES_REQUEST;\n  static responseEventName = DBEventNames.DB_LIST_MODEL_FILES_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbListModelFilesRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbListModelFilesResponse extends DbResponseBase {\n  static type = DBEventNames.DB_LIST_MODEL_FILES_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbListModelFilesResponse.type;\n  }\n}\n\nexport class DbGetModelAssetChunksRequest extends DbEventBase {\n  static type = DBEventNames.DB_GET_MODEL_ASSET_CHUNKS_REQUEST;\n  static responseEventName = DBEventNames.DB_GET_MODEL_ASSET_CHUNKS_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbGetModelAssetChunksRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbGetModelAssetChunksResponse extends DbResponseBase {\n  static type = DBEventNames.DB_GET_MODEL_ASSET_CHUNKS_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbGetModelAssetChunksResponse.type;\n  }\n}\n\nexport class DbGetModelAssetChunkRequest extends DbEventBase {\n  static type = DBEventNames.DB_GET_MODEL_ASSET_CHUNK_REQUEST;\n  static responseEventName = DBEventNames.DB_GET_MODEL_ASSET_CHUNK_RESPONSE;\n  constructor(payload) {\n    super();\n    this.type = DbGetModelAssetChunkRequest.type;\n    this.payload = payload;\n  }\n}\nexport class DbGetModelAssetChunkResponse extends DbResponseBase {\n  static type = DBEventNames.DB_GET_MODEL_ASSET_CHUNK_RESPONSE;\n  constructor(originalRequestId, success, result, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbGetModelAssetChunkResponse.type;\n  }\n}\n\nexport class DbEnsureInitializedRequest extends DbEventBase {\n  static type = DBEventNames.DB_ENSURE_INITIALIZED_REQUEST;\n  static responseEventName = DBEventNames.DB_ENSURE_INITIALIZED_RESPONSE;\n  constructor() {\n    super();\n    this.type = DbEnsureInitializedRequest.type;\n  }\n}\nexport class DbEnsureInitializedResponse extends DbResponseBase {\n  static type = DBEventNames.DB_ENSURE_INITIALIZED_RESPONSE;\n  constructor(originalRequestId, success, result = null, error = null) {\n    super(originalRequestId, success, result, error);\n    this.type = DbEnsureInitializedResponse.type;\n  }\n} ","export const DirectDBNames = Object.freeze({\n  ADD_MODEL_ASSET: 'AddModelAsset',\n  REQUEST_MODEL_ASSET_CHUNK: 'RequestModelAssetChunk',\n  COUNT_MODEL_ASSET_CHUNKS: 'CountModelAssetChunks',\n});\n\nexport const DBEventNames = Object.freeze({\n  DB_GET_SESSION_REQUEST: 'DbGetSessionRequest',\n  DB_GET_SESSION_RESPONSE: 'DbGetSessionResponse',\n  DB_ADD_MESSAGE_REQUEST: 'DbAddMessageRequest',\n  DB_ADD_MESSAGE_RESPONSE: 'DbAddMessageResponse',\n  DB_UPDATE_MESSAGE_REQUEST: 'DbUpdateMessageRequest',\n  DB_UPDATE_MESSAGE_RESPONSE: 'DbUpdateMessageResponse',\n  DB_UPDATE_STATUS_REQUEST: 'DbUpdateStatusRequest',\n  DB_UPDATE_STATUS_RESPONSE: 'DbUpdateStatusResponse',\n  DB_DELETE_MESSAGE_REQUEST: 'DbDeleteMessageRequest',\n  DB_DELETE_MESSAGE_RESPONSE: 'DbDeleteMessageResponse',\n  DB_TOGGLE_STAR_REQUEST: 'DbToggleStarRequest',\n  DB_TOGGLE_STAR_RESPONSE: 'DbToggleStarResponse',\n  DB_CREATE_SESSION_REQUEST: 'DbCreateSessionRequest',\n  DB_CREATE_SESSION_RESPONSE: 'DbCreateSessionResponse',\n  DB_DELETE_SESSION_REQUEST: 'DbDeleteSessionRequest',\n  DB_DELETE_SESSION_RESPONSE: 'DbDeleteSessionResponse',\n  DB_RENAME_SESSION_REQUEST: 'DbRenameSessionRequest',\n  DB_RENAME_SESSION_RESPONSE: 'DbRenameSessionResponse',\n  DB_GET_ALL_SESSIONS_REQUEST: 'DbGetAllSessionsRequest',\n  DB_GET_ALL_SESSIONS_RESPONSE: 'DbGetAllSessionsResponse',\n  DB_GET_STARRED_SESSIONS_REQUEST: 'DbGetStarredSessionsRequest',\n  DB_GET_STARRED_SESSIONS_RESPONSE: 'DbGetStarredSessionsResponse',\n  DB_MESSAGES_UPDATED_NOTIFICATION: 'DbMessagesUpdatedNotification',\n  DB_STATUS_UPDATED_NOTIFICATION: 'DbStatusUpdatedNotification',\n  DB_SESSION_UPDATED_NOTIFICATION: 'DbSessionUpdatedNotification',\n  DB_INITIALIZE_REQUEST: 'DbInitializeRequest',\n  DB_INITIALIZATION_COMPLETE_NOTIFICATION: 'DbInitializationCompleteNotification',\n  DB_GET_LOGS_REQUEST: 'DbGetLogsRequest',\n  DB_GET_LOGS_RESPONSE: 'DbGetLogsResponse',\n  DB_GET_UNIQUE_LOG_VALUES_REQUEST: 'DbGetUniqueLogValuesRequest',\n  DB_GET_UNIQUE_LOG_VALUES_RESPONSE: 'DbGetUniqueLogValuesResponse',\n  DB_CLEAR_LOGS_REQUEST: 'DbClearLogsRequest',\n  DB_CLEAR_LOGS_RESPONSE: 'DbClearLogsResponse',\n  DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST: 'DbGetCurrentAndLastLogSessionIdsRequest',\n  DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE: 'DbGetCurrentAndLastLogSessionIdsResponse',\n  DB_ADD_LOG_REQUEST: 'DbAddLogRequest',\n  DB_ADD_LOG_RESPONSE: 'DbAddLogResponse',\n  DB_GET_READY_STATE_REQUEST: 'DbGetReadyStateRequest',\n  DB_GET_READY_STATE_RESPONSE: 'DbGetReadyStateResponse',\n  DB_RESET_DATABASE_REQUEST: 'DbResetDatabaseRequest',\n  DB_RESET_DATABASE_RESPONSE: 'DbResetDatabaseResponse',\n\n  // Model Asset DB Operations\n  DB_ADD_MODEL_ASSET_REQUEST: 'DbAddModelAssetRequest',\n  DB_ADD_MODEL_ASSET_RESPONSE: 'DbAddModelAssetResponse',\n  DB_COUNT_MODEL_ASSET_CHUNKS_REQUEST: 'DbCountModelAssetChunksRequest',\n  DB_COUNT_MODEL_ASSET_CHUNKS_RESPONSE: 'DbCountModelAssetChunksResponse',\n  DB_LOG_ALL_CHUNK_GROUP_IDS_FOR_MODEL_REQUEST: 'DbLogAllChunkGroupIdsForModelRequest',\n  DB_LOG_ALL_CHUNK_GROUP_IDS_FOR_MODEL_RESPONSE: 'DbLogAllChunkGroupIdsForModelResponse',\n  DB_LIST_MODEL_FILES_REQUEST: 'DbListModelFilesRequest',\n  DB_LIST_MODEL_FILES_RESPONSE: 'DbListModelFilesResponse',\n  DB_GET_MODEL_ASSET_CHUNKS_REQUEST: 'DbGetModelAssetChunksRequest',\n  DB_GET_MODEL_ASSET_CHUNKS_RESPONSE: 'DbGetModelAssetChunksResponse',\n  DB_GET_MODEL_ASSET_CHUNK_REQUEST: 'DbGetModelAssetChunkRequest',\n  DB_GET_MODEL_ASSET_CHUNK_RESPONSE: 'DbGetModelAssetChunkResponse',\n  DB_ENSURE_INITIALIZED_REQUEST: 'DbEnsureInitializedRequest',\n  DB_ENSURE_INITIALIZED_RESPONSE: 'DbEnsureInitializedResponse',\n  DB_INIT_WORKER_REQUEST: 'DbInitWorkerRequest',\n  DB_INIT_WORKER_RESPONSE: 'DbInitWorkerResponse',\n  DB_WORKER_ERROR: 'DbWorkerError',\n  DB_WORKER_RESET: 'DbWorkerReset',\n});\n\nexport const UIEventNames = Object.freeze({\n  QUERY_SUBMITTED: 'querySubmitted',\n  BACKGROUND_RESPONSE_RECEIVED: 'background:responseReceived',\n  BACKGROUND_ERROR_RECEIVED: 'background:errorReceived',\n  BACKGROUND_SCRAPE_STAGE_RESULT: 'background:scrapeStageResult',\n  BACKGROUND_SCRAPE_RESULT_RECEIVED: 'background:scrapeResultReceived',\n  BACKGROUND_LOADING_STATUS_UPDATE: 'ui:loadingStatusUpdate',\n  REQUEST_MODEL_LOAD: 'ui:requestModelLoad',\n  WORKER_READY: 'worker:ready',\n  WORKER_ERROR: 'worker:error',\n  NAVIGATION_PAGE_CHANGED: 'navigation:pageChanged',\n  SCRAPE_PAGE: 'SCRAPE_PAGE',\n  SCRAPE_ACTIVE_TAB: 'SCRAPE_ACTIVE_TAB',\n  DYNAMIC_SCRIPT_MESSAGE_TYPE: 'offscreenIframeResult',\n  MODEL_DOWNLOAD_PROGRESS: 'modelDownloadProgress',\n  // Add more as needed\n});\n\nexport const WorkerEventNames = Object.freeze({\n  WORKER_SCRIPT_READY: 'workerScriptReady',\n  WORKER_READY: 'workerReady',\n  LOADING_STATUS: 'loadingStatus',\n  GENERATION_STATUS: 'generationStatus',\n  GENERATION_UPDATE: 'generationUpdate',\n  GENERATION_COMPLETE: 'generationComplete',\n  GENERATION_ERROR: 'generationError',\n  RESET_COMPLETE: 'resetComplete',\n  ERROR: 'error',\n\n});\n\nexport const ModelWorkerStates = Object.freeze({\n  UNINITIALIZED: 'uninitialized',\n  CREATING_WORKER: 'creating_worker',\n  WORKER_SCRIPT_READY: 'worker_script_ready',\n  LOADING_MODEL: 'loading_model',\n  MODEL_READY: 'model_ready',\n  GENERATING: 'generating',\n  ERROR: 'error',\n  IDLE: 'idle',\n});\n\nexport const RuntimeMessageTypes = Object.freeze({\n  LOAD_MODEL: 'loadModel',\n  SEND_CHAT_MESSAGE: 'sendChatMessage',\n  INTERRUPT_GENERATION: 'interruptGeneration',\n  RESET_WORKER: 'resetWorker',\n  GET_MODEL_WORKER_STATE: 'getModelWorkerState',\n  SCRAPE_REQUEST: 'scrapeRequest',\n  GET_DRIVE_FILE_LIST: 'getDriveFileList',\n  GET_LOG_SESSIONS: 'getLogSessions',\n  GET_LOG_ENTRIES: 'getLogEntries',\n  DETACH_SIDE_PANEL: 'detachSidePanel',\n  GET_DETACHED_STATE: 'getDetachedState',\n  GET_DB_READY_STATE: 'getDbReadyState',\n});\n\nexport const SiteMapperMessageTypes = Object.freeze({\n  OPEN_TAB: 'openTab',\n  MAPPED: 'mapped',\n});\n\nexport const ModelLoaderMessageTypes = Object.freeze({\n  INIT: 'init',\n  GENERATE: 'Generate',\n  INTERRUPT: 'Interrupt',\n  RESET: 'Reset',\n  DOWNLOAD_MODEL_ASSETS: 'DownloadModelAssets',\n  LIST_MODEL_FILES: 'ListModelFiles',\n  LIST_MODEL_FILES_RESULT: 'ListModelFilesResult',\n});\n\nexport const InternalEventBusMessageTypes = Object.freeze({\n  BACKGROUND_EVENT_BROADCAST: 'BackgroundEventBroadcast'\n});\n\nexport const RawDirectMessageTypes = Object.freeze({\n  WORKER_GENERIC_RESPONSE: 'WorkerGenericResponse',\n  WORKER_GENERIC_ERROR: 'WorkerGenericError',\n  WORKER_SCRAPE_STAGE_RESULT: 'WorkerScrapeStageResult',\n  WORKER_DIRECT_SCRAPE_RESULT: 'WorkerDirectScrapeResult',\n  WORKER_UI_LOADING_STATUS_UPDATE: 'UiLoadingStatusUpdate' // This one is used as a direct message type\n});\n\nexport const Contexts = Object.freeze({\n  BACKGROUND: 'Background',\n  MAIN_UI: 'MainUI',\n  POPUP: 'Popup',\n  OTHERS: 'Others',\n  UNKNOWN: 'Unknown',\n});\n\nexport const MessageSenderTypes = Object.freeze({\n  USER: 'user',\n  SYSTEM: 'system',\n  AI: 'ai',\n  AGENT: 'agent',\n  // Add more as needed\n});\n\nexport const MessageContentTypes = Object.freeze({\n  TEXT: 'text',\n  IMAGE: 'image',\n  FILE: 'file',\n  CODE: 'code',\n  AGENT_ACTION: 'agent_action',\n  // Add more as needed\n});\n\nexport const DBPaths = Object.freeze({\n  CHAT: '/sql/chat.db',\n  LOGS: '/sql/logs.db',\n  MODELS: '/sql/models.db',\n  KNOWLEDGE: '/sql/knowledge.db',\n});\n\nexport const TableNames = Object.freeze({\n  CHATS: 'chats',\n  MESSAGES: 'messages',\n  CHAT_SUMMARIES: 'chat_summaries',\n  ATTACHMENTS: 'attachments',\n  USERS: 'users',\n  LOGS: 'logs',\n  MODEL_ASSETS: 'model_assets',\n  KNOWLEDGE_GRAPH_NODES: 'knowledge_graph_nodes',\n  KNOWLEDGE_GRAPH_EDGES: 'knowledge_graph_edges',\n});\n\n","// --- Imports ---\nimport browser from 'webextension-polyfill';\nimport {\n  DbCreateSessionRequest,\n  DbCreateSessionResponse,\n  DbGetSessionRequest,\n  DbGetSessionResponse,\n  DbAddMessageRequest,\n  DbAddMessageResponse,\n  DbUpdateMessageRequest,\n  DbUpdateMessageResponse,\n  DbDeleteMessageRequest,\n  DbDeleteMessageResponse,\n  DbUpdateStatusRequest,\n  DbUpdateStatusResponse,\n  DbToggleStarRequest,\n  DbToggleStarResponse,\n  DbGetAllSessionsRequest,\n  DbGetAllSessionsResponse,\n  DbMessagesUpdatedNotification,\n  DbStatusUpdatedNotification,\n  DbSessionUpdatedNotification,\n  DbInitializeRequest,\n  DbDeleteSessionRequest,\n  DbDeleteSessionResponse,\n  DbRenameSessionRequest,\n  DbRenameSessionResponse,\n  DbGetStarredSessionsRequest,\n  DbGetStarredSessionsResponse,\n  DbGetReadyStateRequest,\n  DbGetReadyStateResponse,\n  DbResetDatabaseRequest,\n  DbResetDatabaseResponse,\n  DbAddModelAssetRequest,\n  DbAddModelAssetResponse,\n  DbCountModelAssetChunksRequest,\n  DbCountModelAssetChunksResponse,\n  DbLogAllChunkGroupIdsForModelRequest,\n  DbLogAllChunkGroupIdsForModelResponse,\n  DbListModelFilesRequest,\n  DbListModelFilesResponse,\n  DbGetModelAssetChunksRequest,\n  DbGetModelAssetChunksResponse,\n  DbGetModelAssetChunkRequest,\n  DbGetModelAssetChunkResponse,\n  DbEnsureInitializedRequest,\n  DbEnsureInitializedResponse,\n  DbAddLogRequest,\n  DbGetLogsRequest,\n  DbGetLogsResponse,\n  DbGetUniqueLogValuesRequest,\n  DbGetUniqueLogValuesResponse,\n  DbClearLogsRequest,\n  DbClearLogsResponse,\n  DbGetCurrentAndLastLogSessionIdsRequest,\n  DbGetCurrentAndLastLogSessionIdsResponse,\n} from './events/dbEvents.js';\nimport { DBEventNames, Contexts } from './events/eventNames.js';\nimport * as dbSchema from './Utilities/dbSchema.js';\nimport { dbChannel } from './Utilities/dbChannels.js';\n\n// --- Constants ---\nconst DB_INIT_TIMEOUT = 15000;\nconst POLL_INTERVAL = 100;\nconst LOG_THROTTLE_MS = 2000;\n\n// --- State ---\nlet SQL = null;\nlet absurdSqlBackendInitialized = false;\nlet chatDB = null;\nlet logDB = null;\nlet modelDB = null;\nlet isDbInitialized = false;\nlet isLogDbInitialized = false;\nlet isModelDbInitialized = false;\nlet isDbReadyFlag = false;\nlet currentExtensionSessionId = null;\nlet previousExtensionSessionId = null;\nlet dbReadyResolve;\nlet dbReadyPromise = new Promise((resolve) => {\n  dbReadyResolve = resolve;\n});\nlet dbInitPromise = null;\nlet isDbInitInProgress = false;\nlet dbWorker = null;\nlet dbWorkerReady = false;\nlet dbWorkerRequestId = 0;\nlet dbWorkerCallbacks = {};\n\n// --- Error Handling ---\nclass AppError extends Error {\n  constructor(code, message, details = {}) {\n    super(message);\n    this.code = code;\n    this.details = details;\n  }\n}\n\nasync function withTimeout(promise, ms, errorMessage = `Operation timed out after ${ms}ms`) {\n  const timeout = new Promise((_, reject) =>\n    setTimeout(() => reject(new AppError('TIMEOUT', errorMessage)), ms)\n  );\n  return Promise.race([promise, timeout]);\n}\n\n// --- Worker Management ---\nfunction getDbWorker() {\n  if (!dbWorker) {\n    const workerUrl = browser.runtime.getURL('js/absurd-sql-backends/sql-worker.js');\n    dbWorker = new Worker(workerUrl, { type: 'module' });\n    dbWorker.onmessage = (event) => {\n      const { requestId, type, result, error, stack } = event.data;\n      if (requestId && dbWorkerCallbacks[requestId]) {\n        if (error) {\n          let errObj = error;\n          if (typeof error === 'string') {\n            errObj = new Error(error);\n            if (stack) errObj.stack = stack;\n          } else if (error instanceof Object && !(error instanceof Error)) {\n            errObj = new Error(error.message || 'Worker error object');\n            Object.assign(errObj, error);\n            if (stack) errObj.stack = stack;\n          }\n          dbWorkerCallbacks[requestId].reject(errObj);\n        } else {\n          dbWorkerCallbacks[requestId].resolve(result);\n        }\n        delete dbWorkerCallbacks[requestId];\n      } else if (type === 'debug') {\n        // console.log(`[DB Worker Debug] ${event.data.message}`);\n      } else if (type === 'fatal') {\n        console.error(`[DB Worker Fatal] ${event.data.error}`, event.data.stack);\n        Object.values(dbWorkerCallbacks).forEach((cb) =>\n          cb.reject(new Error('DB Worker encountered a fatal error'))\n        );\n        dbWorkerCallbacks = {};\n      } else if (type === 'ready') {\n        dbWorkerReady = true;\n        console.log('[DB] SQL Worker signaled script ready.');\n      }\n    };\n    dbWorker.onerror = (errEvent) => {\n      console.error('[DB] Uncaught error in DB Worker:', errEvent.message, errEvent);\n      Object.values(dbWorkerCallbacks).forEach((cb) =>\n        cb.reject(new Error(`DB Worker crashed: ${errEvent.message || 'Unknown worker error'}`))\n      );\n      dbWorkerCallbacks = {};\n      dbWorker = null;\n      dbWorkerReady = false;\n      absurdSqlBackendInitialized = false;\n    };\n  }\n  return dbWorker;\n}\n\nasync function sendDbWorkerRequest(type, payload) {\n  console.log(`[Trace][minimaldb] sendDbWorkerRequest: Called with type=${type}, payload=`, payload);\n  const worker = getDbWorker();\n  if (!dbWorkerReady) {\n    await new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error(\"Worker 'ready' signal timeout\")), 10000);\n      const check = () => {\n        if (dbWorkerReady) {\n          clearTimeout(timeout);\n          resolve();\n        } else {\n          setTimeout(check, 50);\n        }\n      };\n      check();\n    });\n  }\n  console.log('[Trace][minimaldb] sendDbWorkerRequest: Posting to worker', { type, payload });\n  return new Promise((resolve, reject) => {\n    const requestId = (++dbWorkerRequestId).toString();\n    dbWorkerCallbacks[requestId] = { resolve, reject };\n    worker.postMessage({ requestId, type, payload });\n  });\n}\n\n// --- Database Initialization ---\nasync function initializeDatabasesAndBackend(isReset = false) {\n  console.log(`[DB] initializeDatabasesAndBackend called (isReset: ${isReset})`);\n  getDbWorker();\n  const wasmUrl = browser.runtime.getURL('wasm/sql-wasm-debug.wasm');\n  const dbFilesToCreate = [\n    {\n      path: '/sql/chat.db',\n      schema:\n        dbSchema.CHATS_TABLE_SQL +\n        '\\n' +\n        dbSchema.MESSAGES_TABLE_SQL +\n        '\\n' +\n        dbSchema.CHAT_SUMMARIES_TABLE_SQL,\n    },\n    { path: '/sql/logs.db', schema: dbSchema.LOG_TABLE_SQL },\n    { path: '/sql/models.db', schema: dbSchema.MODEL_ASSET_TABLE_SQL },\n    {\n      path: '/sql/knowledge.db',\n      schema: dbSchema.KNOWLEDGE_GRAPH_EDGES_TABLE_SQL + '\\n' + dbSchema.KNOWLEDGE_GRAPH_NODES_TABLE_SQL,\n    },\n  ];\n  const dbFilesAndTables = [\n    { path: '/sql/chat.db', tables: ['chats', 'messages', 'chat_summaries'] },\n    { path: '/sql/logs.db', tables: ['logs'] },\n    { path: '/sql/models.db', tables: ['model_assets'] },\n    { path: '/sql/knowledge.db', tables: ['knowledge_graph_edges', 'knowledge_graph_nodes'] },\n  ];\n  const payload = {\n    wasmUrl,\n    schema: {\n      CHATS_TABLE_SQL: dbSchema.CHATS_TABLE_SQL,\n      LOG_TABLE_SQL: dbSchema.LOG_TABLE_SQL,\n      MODEL_ASSET_TABLE_SQL: dbSchema.MODEL_ASSET_TABLE_SQL,\n      MESSAGES_TABLE_SQL: dbSchema.MESSAGES_TABLE_SQL,\n    },\n    dbFilesToCreate,\n    dbFilesAndTables,\n  };\n  console.log('[DB] Sending worker init/reset with payload:', payload);\n  await sendDbWorkerRequest(\n    isReset ? DBEventNames.DB_WORKER_RESET : DBEventNames.DB_INIT_WORKER_REQUEST,\n    payload\n  );\n  absurdSqlBackendInitialized = true;\n  isDbInitialized = true;\n  isLogDbInitialized = true;\n  isModelDbInitialized = true;\n  isDbReadyFlag = true;\n  if (dbReadyResolve) dbReadyResolve(true);\n  dbReadyPromise = Promise.resolve(true);\n}\n\nasync function handleInitializeRequest(isAutoEnsureCall = false) {\n  console.log('[DB] handleInitializeRequest ENTRY', {\n    isDbReadyFlag,\n    isDbInitialized,\n    isLogDbInitialized,\n    isModelDbInitialized,\n    absurdSqlBackendInitialized,\n    SQL_exists: !!SQL,\n  });\n  if (\n    SQL &&\n    absurdSqlBackendInitialized &&\n    isDbInitialized &&\n    isLogDbInitialized &&\n    isModelDbInitialized &&\n    isDbReadyFlag &&\n    !isAutoEnsureCall\n  ) {\n    return { success: true };\n  }\n  try {\n    const ids = await browser.storage.local.get(['currentLogSessionId', 'previousLogSessionId']);\n    currentExtensionSessionId = ids.currentLogSessionId || null;\n    previousExtensionSessionId = ids.previousLogSessionId || null;\n    if (!currentExtensionSessionId) {\n      const msg = 'CRITICAL: currentLogSessionId not found in storage during DB init!';\n      console.error('[DB] Database:Initialize]', msg);\n      if (dbReadyResolve) dbReadyResolve(false);\n      dbReadyPromise = new Promise((resolve) => {\n        dbReadyResolve = resolve;\n      });\n      return { success: false, error: msg };\n    }\n  } catch (storageError) {\n    console.error('[DB] Failed to retrieve log session IDs from storage', {\n      error: storageError,\n      stack: storageError?.stack,\n    });\n    if (dbReadyResolve) dbReadyResolve(false);\n    dbReadyPromise = new Promise((resolve) => {\n      dbReadyResolve = resolve;\n    });\n    return { success: false, error: storageError.message || String(storageError) };\n  }\n  try {\n    await initializeDatabasesAndBackend(false);\n    console.log('[DB] Databases initialization complete.');\n    return { success: true };\n  } catch (error) {\n    console.error('[DB] CAUGHT ERROR during initializeDatabasesAndBackend:', error, error?.stack);\n    const appError =\n      error instanceof AppError\n        ? error\n        : new AppError('INIT_FAILED', 'Database initialization failed', {\n            originalError: error.message,\n          });\n    isDbInitialized = false;\n    isLogDbInitialized = false;\n    isModelDbInitialized = false;\n    isDbReadyFlag = false;\n    absurdSqlBackendInitialized = false;\n    if (dbReadyResolve) dbReadyResolve(false);\n    dbReadyPromise = new Promise((resolve) => {\n      dbReadyResolve = resolve;\n    });\n    return { success: false, error: appError.message || String(appError) };\n  }\n}\n\nasync function autoEnsureDbInitialized() {\n  if (isDbReadyFlag && absurdSqlBackendInitialized) {\n    return { success: true };\n  }\n  if (isDbInitInProgress) {\n    return dbInitPromise;\n  }\n  isDbInitInProgress = true;\n  dbInitPromise = (async () => {\n    try {\n      const response = await handleInitializeRequest(true);\n      if (response?.success) {\n        return { success: true };\n      }\n      return { success: false, error: response?.error || 'Database failed to initialize (autoEnsure)' };\n    } catch (err) {\n      console.error('[DB] autoEnsureDbInitialized -> Initialization failed:', err);\n      isDbInitInProgress = false;\n      return { success: false, error: err.message || String(err) };\n    } finally {\n      isDbInitInProgress = false;\n    }\n  })();\n  return dbInitPromise;\n}\n\nasync function ensureDbReady(type = 'chat') {\n  const dbInstanceGetter =\n    {\n      chat: () => chatDB,\n      log: () => logDB,\n      model: () => modelDB,\n      modelAssets: () => modelDB,\n    }[type] || (() => { throw new AppError('INVALID_INPUT', `Unknown DB type requested: ${type}`); });\n  const isInitializedFlagGetter =\n    {\n      chat: () => isDbInitialized,\n      log: () => isLogDbInitialized,\n      model: () => isModelDbInitialized,\n      modelAssets: () => isModelDbInitialized,\n    }[type] || (() => false);\n  if (!isDbInitInProgress && !(isDbReadyFlag && absurdSqlBackendInitialized)) {\n    try {\n      await autoEnsureDbInitialized();\n    } catch (initError) {\n      throttledLog(\n        'error',\n        `[DB][ensureDbReady] autoEnsureDbInitialized failed for DB type '${type}'`,\n        null,\n        initError\n      );\n      throw new AppError('DB_INIT_FAILED', `DB auto-init failed for type '${type}': ${initError.message}`);\n    }\n  } else if (isDbInitInProgress) {\n    await dbInitPromise;\n  }\n  const start = Date.now();\n  let waitingLogged = false;\n  while (Date.now() - start < DB_INIT_TIMEOUT) {\n    const dbInstance = dbInstanceGetter();\n    const isInitializedFlag = isInitializedFlagGetter();\n    if (dbInstance && isInitializedFlag && absurdSqlBackendInitialized && isDbReadyFlag) {\n      return dbInstance;\n    }\n    if (!waitingLogged && Date.now() - start > 300) {\n      throttledLog(\n        'log',\n        `[DB][ensureDbReady] Waiting for DB type '${type}'`,\n        null,\n        `(absurdSqlBackendInitialized: ${absurdSqlBackendInitialized}, isDbReadyFlag: ${isDbReadyFlag}, specific init: ${isInitializedFlag})... elapsed: ${Date.now() - start}ms`\n      );\n      waitingLogged = true;\n    }\n    await new Promise((res) => setTimeout(res, POLL_INTERVAL));\n  }\n  const dbInstance = dbInstanceGetter();\n  const isInitializedFlag = isInitializedFlagGetter();\n  if (!dbInstance || !isInitializedFlag || !absurdSqlBackendInitialized || !isDbReadyFlag) {\n    throttledLog(\n      'error',\n      `[DB][ensureDbReady] DB for type '${type}' not initialized after ${DB_INIT_TIMEOUT}ms`,\n      null,\n      `DB: ${!!dbInstance}, InitFlag: ${isInitializedFlag}, AbsurdReady: ${absurdSqlBackendInitialized}, GlobalReady: ${isDbReadyFlag}`\n    );\n    throw new AppError('DB_NOT_READY', `DB for type '${type}' not initialized after ${DB_INIT_TIMEOUT}ms`);\n  }\n  return dbInstance;\n}\n\n// --- Internal DB Operations ---\nasync function createChatSessionInternal(initialMessage) {\n  if (!initialMessage?.text) {\n    return { success: false, error: 'Initial message with text is required' };\n  }\n  const result = await sendDbWorkerRequest(DbCreateSessionRequest.type, { initialMessage });\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to create session' };\n  }\n  await publishSessionUpdate(result.data.id, 'create', result.data);\n  await publishMessagesUpdate(result.data.id, result.data.messages);\n  await publishStatusUpdate(result.data.id, result.data.status);\n  return { success: true, data: result.data };\n}\n\nasync function getChatSessionByIdInternal(sessionId) {\n  if (!sessionId) {\n    return { success: false, error: 'Session ID is required' };\n  }\n  const result = await sendDbWorkerRequest(DbGetSessionRequest.type, { sessionId });\n  if (!result?.success) {\n    return { success: false, error: result?.error || `Session ${sessionId} not found` };\n  }\n  return { success: true, data: result.data };\n}\n\nasync function addMessageToChatInternal(chatId, messageObject) {\n  if (!chatId || !messageObject?.text) {\n    return { success: false, error: 'Chat ID and message with text are required' };\n  }\n  const result = await sendDbWorkerRequest(DbAddMessageRequest.type, { chatId, messageObject });\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to add message' };\n  }\n  await publishSessionUpdate(chatId, 'update', result.data.updatedDoc);\n  await publishMessagesUpdate(chatId, result.data.updatedDoc.messages);\n  return { success: true, data: result.data };\n}\n\nasync function updateMessageInChatInternal(chatId, messageId, updates) {\n  if (!chatId || !messageId || !updates || (!updates.text && typeof updates.isLoading === 'undefined')) {\n    return {\n      success: false,\n      error: 'Chat ID, message ID, and updates (with text or isLoading) are required',\n    };\n  }\n  const result = await sendDbWorkerRequest(DbUpdateMessageRequest.type, {\n    chatId,\n    messageId,\n    updates,\n  });\n  console.log('[minimaldb] updateMessageInChatInternal result:', result);\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to update message' };\n  }\n  await publishSessionUpdate(chatId, 'update', result.data);\n  await publishMessagesUpdate(chatId, result.data.messages);\n  return { success: true, data: result.data };\n}\n\nasync function deleteMessageFromChatInternal(sessionId, messageId) {\n  if (!sessionId || !messageId) {\n    return { success: false, error: 'Session ID and message ID are required' };\n  }\n  const result = await sendDbWorkerRequest(DbDeleteMessageRequest.type, { sessionId, messageId });\n  if (!result?.success) {\n    return {\n      success: false,\n      error: result?.error || `Failed to delete message ${messageId} from session ${sessionId}`,\n    };\n  }\n  await publishSessionUpdate(sessionId, 'update', result.data.updatedDoc);\n  await publishMessagesUpdate(sessionId, result.data.updatedDoc.messages);\n  return { success: true, data: result.data };\n}\n\nasync function updateSessionStatusInternal(sessionId, newStatus) {\n  const validStatuses = ['idle', 'processing', 'complete', 'error'];\n  if (!sessionId || !validStatuses.includes(newStatus)) {\n    return { success: false, error: `Invalid session ID or status: ${newStatus}` };\n  }\n  const result = await sendDbWorkerRequest(DbUpdateStatusRequest.type, { sessionId, status: newStatus });\n  if (!result?.success) {\n    return { success: false, error: result?.error || `Failed to update session status to ${newStatus}` };\n  }\n  await publishSessionUpdate(sessionId, 'update', result.data);\n  await publishStatusUpdate(sessionId, newStatus);\n  return { success: true, data: result.data };\n}\n\nasync function toggleItemStarredInternal(itemId) {\n  if (!itemId) {\n    return { success: false, error: 'Item ID is required' };\n  }\n  const result = await sendDbWorkerRequest(DbToggleStarRequest.type, { sessionId: itemId });\n  if (!result?.success) {\n    return { success: false, error: result?.error || `Failed to toggle starred status for item ${itemId}` };\n  }\n  await publishSessionUpdate(itemId, 'update', result.data);\n  return { success: true, data: result.data };\n}\n\nasync function deleteHistoryItemInternal(itemId) {\n  if (!itemId) {\n    return { success: false, error: 'Item ID is required' };\n  }\n  const result = await sendDbWorkerRequest(DbDeleteSessionRequest.type, { sessionId: itemId });\n  if (!result?.success) {\n    return { success: false, error: result?.error || `Failed to delete item ${itemId}` };\n  }\n  await publishSessionUpdate(itemId, 'delete');\n  return { success: true, data: result.data };\n}\n\nasync function renameHistoryItemInternal(itemId, newTitle) {\n  if (!itemId || !newTitle) {\n    return { success: false, error: 'Item ID and new title are required' };\n  }\n  const result = await sendDbWorkerRequest(DbRenameSessionRequest.type, {\n    sessionId: itemId,\n    newName: newTitle,\n  });\n  if (!result?.success) {\n    return { success: false, error: result?.error || `Failed to rename item ${itemId} to ${newTitle}` };\n  }\n  await publishSessionUpdate(itemId, 'rename', result.data);\n  return { success: true, data: result.data };\n}\n\nasync function getAllSessionsInternal() {\n  const result = await sendDbWorkerRequest(DbGetAllSessionsRequest.type);\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to retrieve all sessions' };\n  }\n  return { success: true, data: result.data };\n}\n\nasync function getStarredSessionsInternal() {\n  const result = await sendDbWorkerRequest(DbGetStarredSessionsRequest.type);\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to retrieve starred sessions' };\n  }\n  return { success: true, data: result.data };\n}\n\nasync function getLogsInternal(filters) {\n  const result = await sendDbWorkerRequest(DbGetLogsRequest.type, { filters });\n  if (!result?.success) return [];\n  return result.data;\n}\n\nasync function getUniqueLogValuesInternal(fieldName) {\n  const result = await sendDbWorkerRequest(DbGetUniqueLogValuesRequest.type, { fieldName });\n  if (!result?.success) return [];\n  return result.data;\n}\n\nasync function clearLogsInternal(sessionIdsToDelete) {\n  const result = await sendDbWorkerRequest(DbClearLogsRequest.type, { sessionIdsToDelete });\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to clear logs', data: { deletedCount: 0 } };\n  }\n  return result;\n}\n\nasync function getAllUniqueLogSessionIdsInternal() {\n  try {\n    const db = await ensureDbReady('log');\n    const rows = await queryAll(db, `SELECT DISTINCT extensionSessionId FROM logs WHERE extensionSessionId IS NOT NULL`);\n    const uniqueIds = new Set(rows.map((r) => r.extensionSessionId));\n    return { success: true, data: uniqueIds };\n  } catch (error) {\n    return { success: false, error: error.message || String(error) };\n  }\n}\n\n// --- Request Handlers ---\nasync function handleRequest(\n  event,\n  internalHandler,\n  ResponseClass,\n  timeout = 5000,\n  successDataExtractor = (result) => result.data,\n  errorDetailsExtractor = () => ({})\n) {\n  const requestId = event?.requestId || crypto.randomUUID();\n  try {\n    await autoEnsureDbInitialized();\n    const result = await withTimeout(internalHandler(event.payload), timeout);\n    console.log('[Trace][minimaldb] handleRequest: result', result);\n    if (!result.success) {\n      throw new AppError('INTERNAL_OPERATION_FAILED', result.error || 'Unknown internal error', errorDetailsExtractor(result));\n    }\n    const responseData = successDataExtractor(result);\n    return new ResponseClass(requestId, true, responseData);\n  } catch (error) {\n    const appError =\n      error instanceof AppError\n        ? error\n        : new AppError('UNKNOWN_HANDLER_ERROR', error.message || 'Failed in request handler', {\n            originalError: error,\n            ...errorDetailsExtractor(error),\n          });\n    return new ResponseClass(requestId, false, null, appError);\n  }\n}\n\nconst dbHandlerMap = {\n  [DbGetReadyStateRequest.type]: handleDbGetReadyStateRequest,\n  [DbCreateSessionRequest.type]: handleDbCreateSessionRequest,\n  [DbGetSessionRequest.type]: handleDbGetSessionRequest,\n  [DbAddMessageRequest.type]: handleDbAddMessageRequest,\n  [DbUpdateMessageRequest.type]: handleDbUpdateMessageRequest,\n  [DbDeleteMessageRequest.type]: handleDbDeleteMessageRequest,\n  [DbUpdateStatusRequest.type]: handleDbUpdateStatusRequest,\n  [DbToggleStarRequest.type]: handleDbToggleStarRequest,\n  [DbGetAllSessionsRequest.type]: handleDbGetAllSessionsRequest,\n  [DbGetStarredSessionsRequest.type]: handleDbGetStarredSessionsRequest,\n  [DbDeleteSessionRequest.type]: handleDbDeleteSessionRequest,\n  [DbRenameSessionRequest.type]: handleDbRenameSessionRequest,\n  [DbAddLogRequest.type]: handleDbAddLogRequest,\n  [DbGetLogsRequest.type]: handleDbGetLogsRequest,\n  [DbGetUniqueLogValuesRequest.type]: handleDbGetUniqueLogValuesRequest,\n  [DbClearLogsRequest.type]: handleDbClearLogsRequest,\n  [DbGetCurrentAndLastLogSessionIdsRequest.type]: handleDbGetCurrentAndLastLogSessionIdsRequest,\n  [DbResetDatabaseRequest.type]: handleDbResetDatabaseRequest,\n  [DbAddModelAssetRequest.type]: handleDbAddModelAssetRequest,\n  [DbCountModelAssetChunksRequest.type]: handleDbCountModelAssetChunksRequest,\n  [DbLogAllChunkGroupIdsForModelRequest.type]: handleDbLogAllChunkGroupIdsForModelRequest,\n  [DbListModelFilesRequest.type]: handleDbListModelFilesRequest,\n  [DbGetModelAssetChunksRequest.type]: handleDbGetModelAssetChunksRequest,\n  [DbGetModelAssetChunkRequest.type]: handleDbGetModelAssetChunkRequest,\n  [DbEnsureInitializedRequest.type]: async (event) => {\n    try {\n      await autoEnsureDbInitialized();\n      return new DbEnsureInitializedResponse(event.requestId, true);\n    } catch (e) {\n      return new DbEnsureInitializedResponse(event.requestId, false, null, e);\n    }\n  },\n};\n\nasync function handleDbGetReadyStateRequest(event) {\n  const requestId = event?.requestId || crypto.randomUUID();\n  return { success: true, data: { ready: isDbReadyFlag && absurdSqlBackendInitialized } };\n}\n\nasync function handleDbCreateSessionRequest(event) {\n  console.log('[Trace][minimaldb] handleDbCreateSessionRequest: called with', event);\n  if (!event?.payload?.initialMessage?.text) {\n    throw new AppError('INVALID_INPUT', 'Missing initialMessage or message text');\n  }\n  return handleRequest(\n    event,\n    (payload) => createChatSessionInternal(payload.initialMessage),\n    DbCreateSessionResponse,\n    5000,\n    (res) => res.data.id\n  );\n}\n\nasync function handleDbGetSessionRequest(event) {\n  if (!event?.payload?.sessionId) {\n    throw new AppError('INVALID_INPUT', 'Session ID is required');\n  }\n  return handleRequest(\n    event,\n    (payload) => getChatSessionByIdInternal(payload.sessionId),\n    DbGetSessionResponse,\n    5000,\n    (res) => (res.data ? res.data : null)\n  );\n}\n\nasync function handleDbAddMessageRequest(event) {\n  if (!event?.payload?.sessionId || !event?.payload?.messageObject?.text) {\n    throw new AppError('INVALID_INPUT', 'Session ID and message with text are required');\n  }\n  return handleRequest(\n    event,\n    (payload) => addMessageToChatInternal(payload.sessionId, payload.messageObject),\n    DbAddMessageResponse,\n    5000,\n    (res) => res.data.newMessageId\n  );\n}\n\nasync function handleDbUpdateMessageRequest(event) {\n  console.log('[minimaldb] handleDbUpdateMessageRequest called with event:', event);\n  if (\n    !event?.payload?.sessionId ||\n    !event?.payload?.messageId ||\n    !event?.payload?.updates ||\n    (!event.payload.updates.text && typeof event.payload.updates.isLoading === 'undefined')\n  ) {\n    throw new AppError(\n      'INVALID_INPUT',\n      'Session ID, message ID, and updates (with text or isLoading) are required'\n    );\n  }\n  return handleRequest(\n    event,\n    (payload) => updateMessageInChatInternal(payload.sessionId, payload.messageId, payload.updates),\n    DbUpdateMessageResponse,\n    5000,\n    () => true\n  );\n}\n\nasync function handleDbDeleteMessageRequest(event) {\n  if (!event?.payload?.sessionId || !event?.payload?.messageId) {\n    throw new AppError('INVALID_INPUT', 'Session ID and message ID are required');\n  }\n  return handleRequest(\n    event,\n    (payload) => deleteMessageFromChatInternal(payload.sessionId, payload.messageId),\n    DbDeleteMessageResponse,\n    5000,\n    () => true\n  );\n}\n\nasync function handleDbUpdateStatusRequest(event) {\n  if (!event?.payload?.sessionId || !event?.payload?.status) {\n    throw new AppError('INVALID_INPUT', 'Session ID and status are required');\n  }\n  const wrappedHandler = async (payload) => {\n    try {\n      return await updateSessionStatusInternal(payload.sessionId, payload.status);\n    } catch (e) {\n      await publishStatusUpdate(payload.sessionId, 'error');\n      throw e;\n    }\n  };\n  return handleRequest(event, wrappedHandler, DbUpdateStatusResponse, 5000, () => true);\n}\n\nasync function handleDbToggleStarRequest(event) {\n  if (!event?.payload?.sessionId) {\n    throw new AppError('INVALID_INPUT', 'Session ID is required');\n  }\n  return handleRequest(\n    event,\n    (payload) => toggleItemStarredInternal(payload.sessionId),\n    DbToggleStarResponse,\n    5000,\n    (res) => res.data\n  );\n}\n\nasync function handleDbGetAllSessionsRequest(event) {\n  console.log('[Trace][minimaldb] handleDbGetAllSessionsRequest: called with', event);\n  return handleRequest(\n    event,\n    getAllSessionsInternal,\n    DbGetAllSessionsResponse,\n    5000,\n    (res) => (res.data || []).sort((a, b) => b.timestamp - a.timestamp)\n  );\n}\n\nasync function handleDbGetStarredSessionsRequest(event) {\n  return handleRequest(\n    event,\n    getStarredSessionsInternal,\n    DbGetStarredSessionsResponse,\n    5000,\n    (res) =>\n      (res.data || [])\n        .map((s) => ({ sessionId: s.id, name: s.title, lastUpdated: s.timestamp, isStarred: s.isStarred }))\n        .sort((a, b) => b.lastUpdatedpls - a.lastUpdated)\n  );\n}\n\nasync function handleDbDeleteSessionRequest(event) {\n  if (!event?.payload?.sessionId) {\n    throw new AppError('INVALID_INPUT', 'Session ID is required');\n  }\n  return handleRequest(\n    event,\n    (payload) => deleteHistoryItemInternal(payload.sessionId),\n    DbDeleteSessionResponse,\n    5000,\n    () => true\n  );\n}\n\nasync function handleDbRenameSessionRequest(event) {\n  if (!event?.payload?.sessionId || !event?.payload?.newName) {\n    throw new AppError('INVALID_INPUT', 'Session ID and new name are required');\n  }\n  return handleRequest(\n    event,\n    (payload) => renameHistoryItemInternal(payload.sessionId, payload.newName),\n    DbRenameSessionResponse,\n    5000,\n    () => true\n  );\n}\n\nasync function handleDbAddLogRequest(event) {\n  const requestId = event?.requestId || crypto.randomUUID();\n  try {\n    await autoEnsureDbInitialized();\n    if (!event?.payload?.logEntryData) {\n      throw new AppError('INVALID_INPUT', 'Missing logEntryData in payload');\n    }\n    const db = await ensureDbReady('log');\n    const entry = event.payload.logEntryData;\n    await runQuery(\n      db,\n      `INSERT INTO logs (id, timestamp, level, message, component, extensionSessionId, chatSessionId)\n       VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      [\n        entry.id,\n        entry.timestamp,\n        entry.level,\n        entry.message,\n        entry.component,\n        entry.extensionSessionId,\n        entry.chatSessionId || null,\n      ]\n    );\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: error.message || String(error) };\n  }\n}\n\nasync function handleDbGetLogsRequest(event) {\n  if (!event?.payload?.filters) {\n    throw new AppError('INVALID_INPUT', 'Missing filters in payload');\n  }\n  return handleRequest(event, (payload) => getLogsInternal(payload.filters), DbGetLogsResponse);\n}\n\nasync function handleDbGetUniqueLogValuesRequest(event) {\n  if (!event?.payload?.fieldName) {\n    throw new AppError('INVALID_INPUT', 'Missing fieldName in payload');\n  }\n  return handleRequest(\n    event,\n    (payload) => getUniqueLogValuesInternal(payload.fieldName),\n    DbGetUniqueLogValuesResponse\n  );\n}\n\nasync function handleDbClearLogsRequest(event) {\n  const requestId = event?.requestId || crypto.randomUUID();\n  try {\n    await autoEnsureDbInitialized();\n    const allLogSessionIdsResult = await getAllUniqueLogSessionIdsInternal();\n    if (!allLogSessionIdsResult.success) {\n      throw new AppError(\n        'FETCH_FAILED',\n        allLogSessionIdsResult.error || 'Failed to get unique log session IDs for clearing.'\n      );\n    }\n    const allLogSessionIds = allLogSessionIdsResult.data;\n    const sessionsToKeep = new Set();\n    if (currentExtensionSessionId) sessionsToKeep.add(currentExtensionSessionId);\n    if (previousExtensionSessionId) sessionsToKeep.add(previousExtensionSessionId);\n    const sessionIdsToDelete = Array.from(allLogSessionIds).filter((id) => !sessionsToKeep.has(id));\n    let deletedCount = 0;\n    if (sessionIdsToDelete.length > 0) {\n      const clearResult = await clearLogsInternal(sessionIdsToDelete);\n      if (clearResult.success) deletedCount = clearResult.data.deletedCount;\n      else throw new AppError('DELETE_FAILED', clearResult.error || 'Failed to delete old logs.');\n    }\n    return new DbClearLogsResponse(requestId, true, { deletedCount });\n  } catch (error) {\n    const appError =\n      error instanceof AppError\n        ? error\n        : new AppError('UNKNOWN', 'Failed to clear logs', { originalError: error });\n    return new DbClearLogsResponse(requestId, false, null, appError);\n  }\n}\n\nasync function handleDbGetCurrentAndLastLogSessionIdsRequest(event) {\n  const requestId = event?.requestId || crypto.randomUUID();\n  try {\n    await autoEnsureDbInitialized();\n    const ids = { currentLogSessionId: currentExtensionSessionId, previousLogSessionId: previousExtensionSessionId };\n    return new DbGetCurrentAndLastLogSessionIdsResponse(requestId, true, ids);\n  } catch (error) {\n    const appError = new AppError('UNKNOWN', 'Failed to get current/last log session IDs', {\n      originalError: error,\n    });\n    return new DbGetCurrentAndLastLogSessionIdsResponse(requestId, false, null, appError);\n  }\n}\n\nasync function handleDbResetDatabaseRequest(event) {\n  return await sendDbWorkerRequest(DBEventNames.DB_WORKER_RESET);\n}\n\n// --- Notification Utilities ---\nfunction smartNotify(notification) {\n  const payloadKeys = notification && notification.payload ? Object.keys(notification.payload) : [];\n  const sessionId = notification.sessionId || (notification.payload && notification.payload.session && notification.payload.session.id) || 'N/A';\n  let deliveryPath = '';\n  if (typeof window === 'undefined') {\n    deliveryPath = 'background (browser.runtime.sendMessage)';\n    console.log(`[minimaldb] smartNotify: type=${notification.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}], path=${deliveryPath}`);\n    browser.runtime.sendMessage(notification);\n  } else if (window.EXTENSION_CONTEXT === Contexts.MAIN_UI) {\n    deliveryPath = 'same-context (document.dispatchEvent)';\n    console.log(`[minimaldb] smartNotify: type=${notification.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}], path=${deliveryPath}`);\n    document.dispatchEvent(new CustomEvent(notification.type, { detail: notification }));\n    deliveryPath = 'cross-context (dbChannel.postMessage)';\n    console.log(`[minimaldb] smartNotify: type=${notification.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}], path=${deliveryPath}`);\n    dbChannel.postMessage(notification);\n  } else {\n    deliveryPath = 'cross-context (dbChannel.postMessage)';\n    console.log(`[minimaldb] smartNotify: type=${notification.type}, sessionId=${sessionId}, payloadKeys=[${payloadKeys.join(', ')}], path=${deliveryPath}`);\n    dbChannel.postMessage(notification);\n  }\n}\n\nasync function publishSessionUpdate(sessionId, updateType = 'update', sessionDataOverride = null) {\n  try {\n    let sessionData = sessionDataOverride;\n    if (!sessionData) {\n      const result = await getChatSessionByIdInternal(sessionId);\n      if (result.success && result.data) {\n        sessionData = result.data;\n      } else if (updateType === 'delete') {\n        sessionData = { id: sessionId };\n      } else {\n        return;\n      }\n    }\n    let plainSession = sessionData;\n    if (sessionData && typeof sessionData.toJSON === 'function') {\n      plainSession = sessionData.toJSON();\n    } else if (sessionData) {\n      try {\n        plainSession = JSON.parse(JSON.stringify(sessionData));\n      } catch (e) {\n        return;\n      }\n    }\n    const notification = {\n      type: DbSessionUpdatedNotification.type,\n      payload: { session: plainSession, updateType },\n    };\n    smartNotify(notification);\n  } catch (e) {\n    // console.error('[DB] Failed to publish session update notification', e, { sessionId, updateType });\n  }\n}\n\n/**\n * Publishes a messages update notification for a session.\n * Always expects messages to be an array of message objects.\n */\nasync function publishMessagesUpdate(sessionId, messages) {\n  try {\n    if (!Array.isArray(messages)) {\n      console.error('[minimaldb] publishMessagesUpdate: messages is not an array! Got:', messages);\n      return;\n    }\n    let plainMessages = messages.map((m) => ({ ...m }));\n    const notification = new DbMessagesUpdatedNotification(sessionId, plainMessages);\n    smartNotify(notification);\n  } catch (e) {\n    console.error('[DB] Failed to publish messages update notification', e, { sessionId });\n  }\n}\n\nasync function publishStatusUpdate(sessionId, status) {\n  try {\n    const notification = new DbStatusUpdatedNotification(sessionId, status);\n    smartNotify(notification);\n  } catch (e) {\n    console.error('[DB] Failed to publish status update notification', e, { sessionId });\n  }\n}\n\n// --- Model Asset Management ---\nasync function ensureModelAssetsReady() {\n  return await ensureDbReady('model');\n}\n\nfunction shouldLogOrSendChunkProgress(chunkIndex, totalChunks) {\n  return chunkIndex === 0 || (totalChunks && chunkIndex === totalChunks - 1) || chunkIndex % 100 === 0;\n}\n\nasync function addModelAsset(\n  folder,\n  fileName,\n  fileType,\n  data,\n  chunkIndex = 0,\n  totalChunks = 1,\n  chunkGroupId = '',\n  binarySize = null,\n  totalFileSize = null\n) {\n  const result = await sendDbWorkerRequest(DbAddModelAssetRequest.type, {\n    folder,\n    fileName,\n    fileType,\n    data,\n    chunkIndex,\n    totalChunks,\n    chunkGroupId,\n    binarySize,\n    totalFileSize,\n  });\n  if (!result?.success) throw new Error(result?.error || 'Failed to add model asset');\n  return result;\n}\n\nasync function getModelAssetChunks(chunkGroupId) {\n  const result = await sendDbWorkerRequest(DbGetModelAssetChunksRequest.type, { chunkGroupId });\n  if (!result?.success) return [];\n  return result.data;\n}\n\nasync function countModelAssetChunks(folder, fileName, expectedSize, expectedChunks) {\n  const result = await sendDbWorkerRequest(DbCountModelAssetChunksRequest.type, {\n    folder,\n    fileName,\n    expectedSize,\n    expectedChunks,\n  });\n  if (!result?.success) {\n    return { success: false, error: result?.error || 'Failed to count model asset chunks' };\n  }\n  return result;\n}\n\nasync function logAllChunkGroupIdsForModel(folder) {\n  const result = await sendDbWorkerRequest(DbLogAllChunkGroupIdsForModelRequest.type, { folder });\n  if (!result?.success) return [];\n  return result.data;\n}\n\nasync function listModelFiles(modelId) {\n  const result = await sendDbWorkerRequest(DbListModelFilesRequest.type, { modelId });\n  if (!result?.success) return [];\n  return result.data;\n}\n\nasync function getModelAssetChunk(folder, fileName, chunkIndex) {\n  const result = await sendDbWorkerRequest(DbGetModelAssetChunkRequest.type, {\n    folder,\n    fileName,\n    chunkIndex,\n  });\n  if (!result?.success) return null;\n  return result.data;\n}\n\nasync function handleDbAddModelAssetRequest(event) {\n  return handleRequest(\n    event,\n    (payload) =>\n      addModelAsset(\n        payload.folder,\n        payload.fileName,\n        payload.fileType,\n        payload.data,\n        payload.chunkIndex,\n        payload.totalChunks,\n        payload.chunkGroupId,\n        payload.binarySize,\n        payload.totalFileSize\n      ),\n    DbAddModelAssetResponse,\n    5000,\n    (res) => res\n  );\n}\n\nasync function handleDbCountModelAssetChunksRequest(event) {\n  return handleRequest(\n    event,\n    (payload) =>\n      countModelAssetChunks(payload.folder, payload.fileName, payload.expectedSize, payload.expectedChunks),\n    DbCountModelAssetChunksResponse,\n    5000,\n    (res) => res\n  );\n}\n\nasync function handleDbLogAllChunkGroupIdsForModelRequest(event) {\n  return handleRequest(\n    event,\n    (payload) => logAllChunkGroupIdsForModel(payload.folder),\n    DbLogAllChunkGroupIdsForModelResponse,\n    5000,\n    (res) => res\n  );\n}\n\nasync function handleDbListModelFilesRequest(event) {\n  return handleRequest(\n    event,\n    (payload) => listModelFiles(payload.modelId),\n    DbListModelFilesResponse\n  );\n}\n\nasync function handleDbGetModelAssetChunksRequest(event) {\n  return handleRequest(\n    event,\n    (payload) => getModelAssetChunks(payload.chunkGroupId),\n    DbGetModelAssetChunksResponse\n  );\n}\n\nasync function handleDbGetModelAssetChunkRequest(event) {\n  return handleRequest(\n    event,\n    (payload) => getModelAssetChunk(payload.folder, payload.fileName, payload.chunkIndex),\n    DbGetModelAssetChunkResponse\n  );\n}\n\n// --- Logging Utilities ---\nconst logThrottleCache = {};\nconst logLastContext = {};\n\nfunction throttledLog(type, staticMsg, contextKey = null, ...args) {\n  const now = Date.now();\n  const cacheKey = contextKey ? `${staticMsg}__${contextKey}` : staticMsg;\n  if (!logThrottleCache[type]) logThrottleCache[type] = {};\n  if (contextKey !== null) {\n    if (logLastContext[staticMsg] === contextKey && now - (logThrottleCache[type][cacheKey] || 0) < LOG_THROTTLE_MS) {\n      return;\n    }\n    logLastContext[staticMsg] = contextKey;\n  }\n  if (!logThrottleCache[type][cacheKey] || now - logThrottleCache[type][cacheKey] > LOG_THROTTLE_MS) {\n    logThrottleCache[type][cacheKey] = now;\n    const fullMessage = contextKey !== null ? [staticMsg, contextKey, ...args] : [staticMsg, ...args];\n    if (type === 'log') console.log(...fullMessage);\n    else if (type === 'warn') console.warn(...fullMessage);\n    else if (type === 'error') console.error(...fullMessage);\n  }\n}\n\n// --- Message Listener ---\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (!message || !message.type || !Object.values(DBEventNames).includes(message.type)) {\n    return false;\n  }\n  forwardDbRequest(message)\n    .then((result) => {\n      console.log('[Trace][minimaldb] onMessage: Handler result', result);\n      sendResponse(result);\n    })\n    .catch((err) => {\n      console.error('[Trace][minimaldb] onMessage: Handler error', err);\n      sendResponse({ success: false, error: err.message || 'Unknown error in handler' });\n    });\n  return true;\n});\n\n// --- Exported Functions ---\nexport async function forwardDbRequest(request) {\n  const handler = dbHandlerMap[request?.type];\n  if (!handler) {\n    throw new Error(`No DB handler for type: ${request?.type}`);\n  }\n  try {\n    const result = await handler(request);\n    return result;\n  } catch (err) {\n    return { success: false, error: err.message || 'Unknown error in handler' };\n  }\n}\n\nexport async function resetDatabase() {\n  try {\n    await initializeDatabasesAndBackend(true);\n    return { success: true };\n  } catch (e) {\n    throw e;\n  }\n}\n\nexport { autoEnsureDbInitialized };","import browser from 'webextension-polyfill';\nimport { UIEventNames } from './events/eventNames.js';\nimport { sendDbRequestSmart } from './sidepanel.js';\nimport { DbAddModelAssetRequest, DbCountModelAssetChunksRequest } from './events/dbEvents.js';\n\nconst prefix = '[Downloader]';\nconst CHUNK_SIZE = 10 * 1024 * 1024;\nconst MAX_RETRIES = 3;\nconst PROGRESS_THROTTLE_MS = 2000;\nconst PROGRESS_THROTTLE_CHUNKS = 200;\n\nfunction logMemory(label) {\n    if (performance && performance.memory) {\n        const usedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);\n        const totalMB = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);\n        console.log(`${prefix} [Memory][${label}] Used: ${usedMB} MB / Total: ${totalMB} MB`);\n    } else {\n        console.log(`${prefix} [Memory][${label}] performance.memory not available`);\n    }\n}\n\nfunction shouldLogOrSendChunkProgress(chunkIndex, totalChunks, lastSent, now) {\n    return chunkIndex === 0 ||\n           (totalChunks && chunkIndex === totalChunks - 1) ||\n           chunkIndex % PROGRESS_THROTTLE_CHUNKS === 0 ||\n           (now - lastSent >= PROGRESS_THROTTLE_MS);\n}\n\nasync function tryStoreChunkInternal(payload, maxRetries = MAX_RETRIES) {\n    let attempt = 0;\n    while (attempt < maxRetries) {\n        const req = new DbAddModelAssetRequest(payload);\n        const addResult = await sendDbRequestSmart(req);\n        if (addResult && addResult.success) return true;\n        attempt++;\n        console.log(`${prefix} Retrying chunk store, attempt ${attempt} for ${payload.fileName} chunk ${payload.chunkIndex}`);\n        await new Promise(res => setTimeout(res, 200 * Math.pow(2, attempt)));\n    }\n    console.error(`${prefix} Failed to store chunk after ${maxRetries} retries:`, payload.fileName, payload.chunkIndex);\n    return false;\n}\n\nasync function countModelAssetChunksViaMessage(folder, fileName, expectedSize, expectedChunks) {\n    const req = new DbCountModelAssetChunksRequest({ folder, fileName, expectedSize, expectedChunks });\n    const result = await sendDbRequestSmart(req);\n    return result && result.success ? result.data : result;\n}\n\nasync function fetchModelMetadataInternal(modelId) {\n    const apiUrl = `https://huggingface.co/api/models/${encodeURIComponent(modelId)}`;\n    console.log(prefix, `Fetching model metadata from: ${apiUrl}`);\n    try {\n        const response = await fetch(apiUrl);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(prefix, `Failed to fetch model file list for ${modelId}: ${response.status} ${response.statusText}`, errorText);\n            throw new Error(`Metadata fetch failed (${response.status}): ${response.statusText}`);\n        }\n        const metadata = await response.json();\n        console.log(prefix, `Model metadata fetched successfully for ${modelId}.`);\n        return metadata;\n    } catch (error) {\n        console.error(prefix, `Error fetching metadata for ${modelId}:`, error);\n        throw error;\n    }\n}\n\nasync function filterAndValidateFilesInternal(metadata, modelId, baseDownloadUrl) {\n    const hfFileEntries = metadata.siblings || [];\n    const neededFileEntries = hfFileEntries.filter(f => f.rfilename.endsWith('.onnx') || f.rfilename.endsWith('.json') || f.rfilename.endsWith('.txt'));\n    const neededFileNames = neededFileEntries.map(f => f.rfilename);\n    console.log(prefix, `Identified ${neededFileNames.length} needed files for ${modelId}:`, neededFileNames);\n\n    if (neededFileEntries.length === 0) {\n        return { neededFileEntries: [], message: \"No .onnx, .json, or .txt files found in model metadata.\" };\n    }\n\n    async function getFileSizeWithHEAD(url) {\n        try {\n            const headResp = await fetch(url, { method: 'HEAD' });\n            if (headResp.ok) {\n                const len = headResp.headers.get('Content-Length');\n                return len ? parseInt(len, 10) : null;\n            }\n        } catch (e) {\n            console.warn(prefix, `HEAD request failed for ${url}:`, e);\n        }\n        return null;\n    }\n\n    const sizePromises = neededFileEntries.map(async (entry) => {\n        if (typeof entry.size !== 'number' || !isFinite(entry.size) || entry.size <= 0) {\n            const url = baseDownloadUrl + entry.rfilename;\n            const size = await getFileSizeWithHEAD(url);\n            if (size && isFinite(size) && size > 0) {\n                entry.size = size;\n                console.log(prefix, `Got file size via HEAD for ${entry.rfilename}: ${size}`);\n            } else {\n                console.error(prefix, `Skipping file ${entry.rfilename}: missing/invalid size (HEAD failed or Content-Length missing)`);\n                entry._skip = true;\n            }\n        }\n    });\n\n    await Promise.all(sizePromises);\n    return { neededFileEntries, message: null };\n}\n\nfunction buildDownloadPlanInternal(neededFileEntries) {\n    const downloadPlan = neededFileEntries.filter(e => !e._skip).map((entry, idx) => ({\n        fileName: entry.rfilename,\n        fileSize: entry.size,\n        totalChunks: Math.ceil(entry.size / CHUNK_SIZE),\n        fileIdx: idx + 1,\n        fileType: entry.rfilename.split('.').pop(),\n    }));\n    const totalBytesToDownload = downloadPlan.reduce((sum, f) => sum + f.fileSize, 0);\n    const totalChunksToDownload = downloadPlan.reduce((sum, f) => sum + f.totalChunks, 0);\n    console.log(prefix, \"Built download plan:\", { downloadPlan, totalBytesToDownload, totalChunksToDownload });\n    return { downloadPlan, totalBytesToDownload, totalChunksToDownload };\n}\n\nasync function getMissingFilesInternal(downloadPlan, modelId) {\n    const missingFiles = [];\n    const presentFiles = {};\n    for (const plan of downloadPlan) {\n        const { fileName, fileSize, totalChunks } = plan;\n        console.log(prefix, '[DB ChunkCount Check] Checking chunk count for:', { modelId, fileName, expectedChunks: totalChunks });\n        const countResult = await countModelAssetChunksViaMessage(modelId, fileName, fileSize, totalChunks);\n        console.log(prefix, '[DB ChunkCount Check] Result:', { modelId, fileName, expectedChunks: totalChunks, countResult });\n        if (countResult && countResult.success && countResult.verified && countResult.count === totalChunks) {\n            presentFiles[fileName] = true;\n        } else {\n            missingFiles.push(plan);\n        }\n    }\n    return { missingFiles, presentFiles };\n}\n\n// Helper to format bytes as human-readable string\nfunction formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\nasync function streamAndStoreFileInternal(plan, modelId, baseDownloadUrl, totalBytesToDownload, totalChunksToDownload, totalBytesDownloaded, totalChunksDownloaded, totalFilesToAttempt) {\n    const { fileName, fileSize, totalChunks, fileIdx, fileType } = plan;\n    const downloadUrl = baseDownloadUrl + fileName;\n    let fileBytesDownloaded = 0;\n    let fileChunksDownloaded = 0;\n    let fileFailed = false;\n    let lastProgressSent = Date.now();\n    let chunkIndex = 0;\n    let allChunksSuccess = true;\n    const chunkGroupId = `${modelId}/${fileName}`;\n    let currentFileSource = \"Download_Attempt\";\n\n    try {\n        if (fileSize > 10 * 1024 * 1024) {\n            logMemory(`Before file ${fileName}`);\n        }\n        console.log(prefix, `Downloading file from: ${downloadUrl}`);\n        const downloadResponse = await fetch(downloadUrl);\n\n        if (!downloadResponse.ok) {\n            const errorText = await downloadResponse.text();\n            console.error(prefix, `Failed to download ${modelId}/${fileName}: ${downloadResponse.status} ${downloadResponse.statusText}`, errorText);\n            await sendUiProgress({\n                modelId,\n                file: fileName,\n                error: `Download failed (${downloadResponse.status})`,\n                downloaded: 0,\n                total: totalFilesToAttempt,\n                currentFileSource,\n                fileIdx,\n                totalFiles: totalFilesToAttempt,\n                fileTotalBytes: fileSize,\n                fileTotalBytesHuman: formatBytes(fileSize)\n            }).catch(e => console.warn(`${prefix} Error sending progress on download fail: ${e.message}`));\n            return { fileFailed: true };\n        }\n        currentFileSource = \"Download_Success_Store_Attempt\";\n\n        const reader = downloadResponse.body.getReader();\n        let buffer = new Uint8Array(CHUNK_SIZE);\n        let bufferOffset = 0;\n\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n\n            if (!(value instanceof Uint8Array)) {\n                console.error(prefix, `Invalid chunk data for ${fileName}, chunk ${chunkIndex}:`, typeof value);\n                fileFailed = true;\n                await sendUiProgress({\n                    modelId,\n                    file: fileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    chunkIndex,\n                    totalChunks,\n                    error: `Invalid chunk data type: ${typeof value}`,\n                    currentFileSource,\n                    failType: 'invalid_chunk',\n                    fileTotalBytes: fileSize,\n                    fileTotalBytesHuman: formatBytes(fileSize)\n                }).catch(e => console.warn(`${prefix} Error sending progress on invalid chunk: ${e.message}`));\n                reader.cancel('Invalid chunk data');\n                break;\n            }\n\n            let valueOffset = 0;\n            while (valueOffset < value.length) {\n                const remainingBuffer = CHUNK_SIZE - bufferOffset;\n                const copyLength = Math.min(remainingBuffer, value.length - valueOffset);\n                buffer.set(value.subarray(valueOffset, valueOffset + copyLength), bufferOffset);\n                bufferOffset += copyLength;\n                valueOffset += copyLength;\n\n                if (bufferOffset === CHUNK_SIZE) {\n                    let chunkToStore = buffer;\n                    buffer = new Uint8Array(CHUNK_SIZE);\n                    bufferOffset = 0;\n\n                    const now = Date.now();\n                    if (shouldLogOrSendChunkProgress(chunkIndex, totalChunks, lastProgressSent, now)) {\n                        console.log(prefix, '[Chunk] About to store chunk:', { fileName, chunkIndex, chunkLength: chunkToStore.length });\n                    }\n\n                    const dbPayload = {\n                        modelId,\n                        fileName,\n                        fileType,\n                        data: chunkToStore,\n                        chunkIndex,\n                        totalChunks,\n                        chunkGroupId,\n                        binarySize: chunkToStore.byteLength,\n                        totalFileSize: fileSize\n                    };\n                    const success = await tryStoreChunkInternal(dbPayload);\n\n                    if (!success) {\n                        allChunksSuccess = false;\n                        fileFailed = true;\n                        await sendUiProgress({\n                            modelId,\n                            file: fileName,\n                            fileIdx,\n                            totalFiles: totalFilesToAttempt,\n                            chunkIndex,\n                            totalChunks,\n                            error: `Failed to store chunk ${chunkIndex + 1} after ${MAX_RETRIES} retries`,\n                            currentFileSource,\n                            failType: 'chunk_write',\n                            fileTotalBytes: fileSize,\n                            fileTotalBytesHuman: formatBytes(fileSize)\n                        }).catch(e => console.warn(`${prefix} Error sending progress on chunk store fail: ${e.message}`));\n                        reader.cancel('Chunk storage failed');\n                        break;\n                    }\n\n                    chunkIndex++;\n                    fileChunksDownloaded++;\n                    totalChunksDownloaded.value++;\n                    fileBytesDownloaded += chunkToStore.byteLength;\n                    totalBytesDownloaded.value += chunkToStore.byteLength;\n\n                    if (chunkIndex === totalChunks || shouldLogOrSendChunkProgress(chunkIndex, totalChunks, lastProgressSent, now)) {\n                        await sendUiProgress({\n                            modelId,\n                            file: fileName,\n                            fileIdx,\n                            totalFiles: totalFilesToAttempt,\n                            chunkIndex,\n                            totalChunks,\n                            fileBytesDownloaded,\n                            fileTotalBytes: fileSize,\n                            fileTotalBytesHuman: formatBytes(fileSize),\n                            totalBytesDownloaded: totalBytesDownloaded.value,\n                            totalBytesToDownload,\n                            totalChunksDownloaded: totalChunksDownloaded.value,\n                            totalChunksToDownload,\n                            percent: (totalBytesDownloaded.value / totalBytesToDownload) * 100,\n                            filePercent: (fileBytesDownloaded / fileSize) * 100,\n                            progress: (totalBytesDownloaded.value / totalBytesToDownload) * 100,\n                            status: 'progress',\n                            currentFileSource\n                        }).catch(e => console.warn(`${prefix} Error sending progress update: ${e.message}`));\n                        lastProgressSent = now;\n                    }\n                    chunkToStore = null;\n                }\n            }\n            if (fileFailed) break;\n        }\n\n        if (allChunksSuccess && !fileFailed && bufferOffset > 0) {\n            let finalChunkToStore = buffer.subarray(0, bufferOffset);\n            buffer = null;\n\n            console.log(prefix, '[Chunk] About to store final chunk:', { fileName, chunkIndex, chunkLength: finalChunkToStore.length });\n\n            const dbPayload = {\n                modelId,\n                fileName,\n                fileType,\n                data: finalChunkToStore,\n                chunkIndex,\n                totalChunks,\n                chunkGroupId,\n                binarySize: finalChunkToStore.byteLength,\n                totalFileSize: fileSize\n            };\n            const success = await tryStoreChunkInternal(dbPayload);\n\n            if (!success) {\n                allChunksSuccess = false;\n                fileFailed = true;\n                await sendUiProgress({\n                    modelId,\n                    file: fileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    chunkIndex,\n                    totalChunks,\n                    error: `Failed to store final chunk ${chunkIndex + 1} after ${MAX_RETRIES} retries`,\n                    currentFileSource,\n                    failType: 'chunk_write',\n                    fileTotalBytes: fileSize,\n                    fileTotalBytesHuman: formatBytes(fileSize)\n                }).catch(e => console.warn(`${prefix} Error sending progress on final chunk store fail: ${e.message}`));\n            } else {\n                chunkIndex++;\n                fileChunksDownloaded++;\n                totalChunksDownloaded.value++;\n                fileBytesDownloaded += finalChunkToStore.byteLength;\n                totalBytesDownloaded.value += finalChunkToStore.byteLength;\n                await sendUiProgress({\n                    modelId,\n                    file: fileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    chunkIndex,\n                    totalChunks,\n                    fileBytesDownloaded,\n                    fileTotalBytes: fileSize,\n                    fileTotalBytesHuman: formatBytes(fileSize),\n                    totalBytesDownloaded: totalBytesDownloaded.value,\n                    totalBytesToDownload,\n                    totalChunksDownloaded: totalChunksDownloaded.value,\n                    totalChunksToDownload,\n                    percent: (totalBytesDownloaded.value / totalBytesToDownload) * 100,\n                    filePercent: 100,\n                    progress: (totalBytesDownloaded.value / totalBytesToDownload) * 100,\n                    status: 'progress',\n                    currentFileSource\n                }).catch(e => console.warn(`${prefix} Error sending progress for final chunk: ${e.message}`));\n            }\n            finalChunkToStore = null;\n        }\n\n        if (allChunksSuccess && !fileFailed) {\n            const countResult = await countModelAssetChunksViaMessage(modelId, fileName, fileSize, totalChunks);\n            if (countResult.success && countResult.verified && countResult.count === totalChunks) {\n                currentFileSource = \"DB_Stored_After_Download\";\n                console.log(prefix, `Successfully downloaded, stored, and verified all chunks for ${modelId}/${fileName} in DB.`);\n            } else {\n                fileFailed = true;\n                await sendUiProgress({\n                    modelId,\n                    file: fileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    error: `Verification failed: ${countResult.error || 'Unknown error'}`,\n                    failType: 'verification',\n                    currentFileSource,\n                    fileTotalBytes: fileSize,\n                    fileTotalBytesHuman: formatBytes(fileSize)\n                }).catch(e => console.warn(`${prefix} Error sending progress on verification fail: ${e.message}`));\n            }\n        } else if (fileFailed || !allChunksSuccess) {\n            console.error(prefix, `Failed to store all chunks for ${modelId}/${fileName} in DB after download.`);\n             await sendUiProgress({\n                modelId,\n                file: fileName,\n                error: `DB store failed after download (chunked)`,\n                fileIdx,\n                totalFiles: totalFilesToAttempt,\n                currentFileSource,\n                failType: 'file_fail_internal',\n                fileTotalBytes: fileSize,\n                fileTotalBytesHuman: formatBytes(fileSize)\n            }).catch(e => console.warn(`${prefix} Error sending progress on internal file fail: ${e.message}`));\n        }\n\n        if (fileSize > 10 * 1024 * 1024) {\n            logMemory(`After file ${fileName}`);\n        }\n    } catch (error) {\n        fileFailed = true;\n        console.error(prefix, `Error downloading ${modelId}/${fileName}:`, error);\n        await sendUiProgress({\n            modelId,\n            file: fileName,\n            fileIdx,\n            totalFiles: totalFilesToAttempt,\n            error: error.message,\n            failType: 'exception',\n            currentFileSource,\n            fileTotalBytes: fileSize,\n            fileTotalBytesHuman: formatBytes(fileSize)\n        }).catch(e => console.warn(`${prefix} Error sending progress on exception: ${e.message}`));\n    }\n\n    return { fileFailed, fileName, fileBytesDownloaded, fileChunksDownloaded };\n}\n\nasync function downloadMissingFilesInternal(missingFiles, modelId, downloadPlan, totalBytesToDownload, totalChunksToDownload, presentFiles, baseDownloadUrl) {\n    let filesSuccessfullyProcessedCount = Object.keys(presentFiles).length;\n    const totalBytesDownloaded = { value: downloadPlan.filter(p => presentFiles[p.fileName]).reduce((sum, p) => sum + p.fileSize, 0) };\n    const totalChunksDownloaded = { value: downloadPlan.filter(p => presentFiles[p.fileName]).reduce((sum, p) => sum + p.totalChunks, 0) };\n    const totalFilesToAttempt = downloadPlan.length;\n    const successfullyProcessedFileMap = { ...presentFiles };\n    const failedFiles = [];\n\n    console.log(prefix, \"Initial download progress state:\", {\n        filesSuccessfullyProcessedCount,\n        totalBytesDownloaded: totalBytesDownloaded.value,\n        totalChunksDownloaded: totalChunksDownloaded.value,\n        totalFilesToAttempt,\n        presentFiles\n    });\n\n    for (const plan of missingFiles) {\n        const result = await streamAndStoreFileInternal(\n            plan,\n            modelId,\n            baseDownloadUrl,\n            totalBytesToDownload,\n            totalChunksToDownload,\n            totalBytesDownloaded,\n            totalChunksDownloaded,\n            totalFilesToAttempt\n        );\n\n        if (!result.fileFailed) {\n            successfullyProcessedFileMap[result.fileName] = true;\n            filesSuccessfullyProcessedCount++;\n        } else {\n            failedFiles.push(result.fileName);\n        }\n    }\n\n    console.log(prefix, \"Final download progress state after processing missing files:\", {\n        filesSuccessfullyProcessedCount,\n        totalBytesDownloaded: totalBytesDownloaded.value,\n        totalChunksDownloaded: totalChunksDownloaded.value,\n        failedFiles\n    });\n    return { successfullyProcessedFileMap, filesSuccessfullyProcessedCount, failedFiles };\n}\n\nfunction sendUiProgress(payload) {\n    return browser.runtime.sendMessage({\n        type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n        payload\n    }).catch(e => console.warn(`${prefix} Error sending MODEL_DOWNLOAD_PROGRESS: ${e.message}`));\n}\n\nexport async function downloadModelAssets(modelId) {\n    console.log(prefix, `Starting downloadModelAssets for modelId: ${modelId}`);\n    const baseDownloadUrl = `https://huggingface.co/${modelId}/resolve/main/`;\n\n    try {\n        const metadata = await fetchModelMetadataInternal(modelId);\n        const { neededFileEntries, message: filterMessage } = await filterAndValidateFilesInternal(metadata, modelId, baseDownloadUrl);\n\n        if (neededFileEntries.length === 0) {\n            console.warn(prefix, filterMessage || \"No needed files after filtering.\");\n            return { success: true, fileMap: {}, message: filterMessage || \"No needed files to download.\" };\n        }\n\n        const { downloadPlan, totalBytesToDownload, totalChunksToDownload } = buildDownloadPlanInternal(neededFileEntries);\n        if (downloadPlan.length === 0) {\n            const msg = `No valid files to download for ${modelId} after validation and plan building.`;\n            console.warn(prefix, msg);\n            return { success: true, fileMap: {}, message: msg };\n        }\n\n        const { missingFiles, presentFiles } = await getMissingFilesInternal(downloadPlan, modelId);\n        console.log(prefix, `Files already present in DB for ${modelId}:`, Object.keys(presentFiles));\n        console.log(prefix, `Files missing and will be downloaded for ${modelId}:`, missingFiles.map(f => f.fileName));\n\n        await sendUiProgress({\n            modelId,\n            initialScanComplete: true,\n            totalFilesToAttempt: downloadPlan.length,\n            filesAlreadyPresent: Object.keys(presentFiles).length,\n            filesToDownload: missingFiles.length,\n            totalBytesToDownload,\n            totalBytesAlreadyPresent: downloadPlan.filter(p => presentFiles[p.fileName]).reduce((sum, p) => sum + p.fileSize, 0),\n            fileTotalBytes: totalBytesToDownload,\n            fileTotalBytesHuman: formatBytes(totalBytesToDownload)\n        }).catch(e => console.warn(`${prefix} Error sending initial scan progress: ${e.message}`));\n\n\n        if (missingFiles.length === 0) {\n            const msg = `All ${downloadPlan.length} assets for ${modelId} are already available in DB.`;\n            console.log(prefix, msg);\n            await sendUiProgress({\n                modelId,\n                summary: true,\n                filesSuccessfullyProcessedCount: Object.keys(presentFiles).length,\n                totalFilesToAttempt: downloadPlan.length,\n                failedFiles: [],\n                success: true,\n                message: msg,\n                fileTotalBytes: totalBytesToDownload,\n                fileTotalBytesHuman: formatBytes(totalBytesToDownload)\n            }).catch(e => console.warn(`${prefix} Error sending progress for 'all files present': ${e.message}`));\n            return { success: true, fileMap: presentFiles, message: msg, fileTotalBytes: totalBytesToDownload, fileTotalBytesHuman: formatBytes(totalBytesToDownload) };\n        }\n\n        const { successfullyProcessedFileMap, filesSuccessfullyProcessedCount, failedFiles } = await downloadMissingFilesInternal(\n            missingFiles,\n            modelId,\n            downloadPlan,\n            totalBytesToDownload,\n            totalChunksToDownload,\n            presentFiles,\n            baseDownloadUrl\n        );\n\n        console.log(prefix, `Finished processing all ${downloadPlan.length} needed files for ${modelId}. Successfully processed ${filesSuccessfullyProcessedCount} files.`);\n        const overallSuccess = filesSuccessfullyProcessedCount === downloadPlan.length;\n        const finalMessage = overallSuccess\n            ? `All ${downloadPlan.length} assets for ${modelId} are now available in DB.`\n            : `Failed to process all assets for ${modelId}. Got ${filesSuccessfullyProcessedCount} of ${downloadPlan.length}. Failed files: ${failedFiles.join(', ')}. Check logs for details.`;\n\n        await sendUiProgress({\n            modelId,\n            summary: true,\n            filesSuccessfullyProcessedCount,\n            totalFilesToAttempt: downloadPlan.length,\n            failedFiles,\n            success: overallSuccess,\n            message: finalMessage,\n            fileTotalBytes: totalBytesToDownload,\n            fileTotalBytesHuman: formatBytes(totalBytesToDownload)\n        }).catch(e => console.warn(`${prefix} Error sending final summary progress: ${e.message}`));\n        console.log(prefix, finalMessage);\n        return { success: overallSuccess, fileMap: successfullyProcessedFileMap, message: finalMessage, failedFiles, fileTotalBytes: totalBytesToDownload, fileTotalBytesHuman: formatBytes(totalBytesToDownload) };\n\n    } catch (error) {\n        console.error(prefix, `Critical error in downloadModelAssets for ${modelId}:`, error);\n        await sendUiProgress({\n            modelId,\n            summary: true,\n            error: `Download process failed: ${error.message}`,\n            success: false,\n            fileTotalBytes: totalBytesToDownload,\n            fileTotalBytesHuman: formatBytes(totalBytesToDownload)\n        }).catch(e => console.warn(`${prefix} Error sending progress on critical error: ${e.message}`));\n        return { success: false, error: `Download process failed for ${modelId}: ${error.message}`, fileTotalBytes: totalBytesToDownload, fileTotalBytesHuman: formatBytes(totalBytesToDownload) };\n    }\n}","import { UIEventNames, Contexts } from './events/eventNames.js';\r\nwindow.EXTENSION_CONTEXT = Contexts.OTHERS;\r\n\r\nlet pageContainers = [];\r\nlet navButtons = [];\r\nlet mainHeaderTitle = null;\r\nconst CONTEXT_PREFIX = '[Navigation]';\r\nconst pageTitles = {\r\n    'page-home': 'Tab Agent', \r\n    'page-spaces': 'Spaces',\r\n    'page-library': 'Library',\r\n    'page-settings': 'Settings'\r\n};\r\n\r\n\r\nasync function navigateTo(pageId) { \r\n    console.log(CONTEXT_PREFIX + `Navigating to ${pageId}`);\r\n   \r\n    pageContainers.forEach(container => {\r\n        container.classList.add('hidden');\r\n        container.classList.remove('active-page');\r\n    });\r\n\r\n    const targetPage = document.getElementById(pageId);\r\n    if (targetPage) {\r\n        targetPage.classList.remove('hidden');\r\n        targetPage.classList.add('active-page');\r\n    } else {\r\n        console.error(CONTEXT_PREFIX + `Navigation error: Page with ID ${pageId} not found. Showing home.`);\r\n        const homePage = document.getElementById('page-home');\r\n        if (homePage) {\r\n             homePage.classList.remove('hidden');\r\n             homePage.classList.add('active-page');\r\n        }\r\n        pageId = 'page-home'; \r\n    }\r\n    \r\n    if (mainHeaderTitle && pageTitles[pageId]) {\r\n         mainHeaderTitle.textContent = pageTitles[pageId];\r\n    } else if (mainHeaderTitle) {\r\n         mainHeaderTitle.textContent = 'Tab Agent'; \r\n    }\r\n\r\n    navButtons.forEach(button => {\r\n        if (button.dataset.page === pageId) {\r\n            button.classList.add('active');\r\n        } else {\r\n            button.classList.remove('active');\r\n        }\r\n    });\r\n\r\n    document.dispatchEvent(new CustomEvent(UIEventNames.NAVIGATION_PAGE_CHANGED, { detail: { pageId } }));\r\n    console.log(CONTEXT_PREFIX + `Published navigation:pageChanged event for ${pageId}`);\r\n\r\n    const queryInput = document.getElementById('query-input');\r\n     if (pageId === 'page-home' && queryInput) {\r\n         queryInput.focus(); \r\n     }\r\n}\r\n\r\nfunction initializeNavigation() {\r\n    console.log(CONTEXT_PREFIX + \"Initializing navigation...\");\r\n\r\n    pageContainers = document.querySelectorAll('.page-container');\r\n    navButtons = document.querySelectorAll('.nav-button');\r\n    mainHeaderTitle = document.querySelector('#header h1');\r\n\r\n\r\n    navButtons.forEach(button => {\r\n        button.addEventListener('click', () => {\r\n            const pageId = button.dataset.page;\r\n            if (pageId) {\r\n                navigateTo(pageId);\r\n            }\r\n        });\r\n    });\r\n\r\n    navigateTo('page-home');\r\n    console.log(CONTEXT_PREFIX + \"Navigation initialized.\");\r\n}\r\n\r\nexport { initializeNavigation, navigateTo }; ","\r\n\r\nlet notificationTimeout;\r\n\r\n/**\r\n * @param {string} message \r\n * @param {'info' | 'success' | 'error'} [type='info'] \r\n * @param {number} [duration=4000] \r\n */\r\nexport function showNotification(message, type = 'info', duration = 3000) {\r\n    console.log(`[Notification] ${type.toUpperCase()}: ${message} (Duration: ${duration}ms)`);\r\n\r\n}\r\n\r\n\r\nexport function hideNotification() {\r\n    const banner = document.getElementById('notification-banner');\r\n    if (banner) {\r\n        banner.classList.remove('visible');\r\n    }\r\n    if (notificationTimeout) {\r\n        clearTimeout(notificationTimeout);\r\n        notificationTimeout = null;\r\n    }\r\n    if (banner) {\r\n        banner.onclick = null;\r\n    }\r\n} ","// --- Imports ---\nimport './minimaldb.js';\nimport './modelAssetDownloader.js';\nimport browser from 'webextension-polyfill';\nimport { initializeNavigation } from './navigation.js';\nimport * as uiController from './Home/uiController.js';\nimport {\n  initializeRenderer,\n  setActiveSessionId as setRendererSessionId,\n  scrollToBottom,\n} from './Home/chatRenderer.js';\nimport { initializeOrchestrator } from './Home/messageOrchestrator.js';\nimport {\n  initializeFileHandling,\n  handleAttachClick,\n  handleFileSelected,\n} from './Home/fileHandler.js';\nimport {\n  initializeUI,\n  clearInput,\n  focusInput,\n  setActiveSession,\n} from './Home/uiController.js';\nimport { getActiveTab, showError as utilShowError, debounce } from './Utilities/generalUtils.js';\nimport { showNotification } from './notifications.js';\nimport { DbGetSessionRequest, DbAddLogRequest } from './events/dbEvents.js';\nimport { autoEnsureDbInitialized, forwardDbRequest } from './minimaldb.js';\nimport { initializeHistoryPopup } from './Controllers/HistoryPopupController.js';\nimport { initializeLibraryController } from './Controllers/LibraryController.js';\nimport { initializeDiscoverController } from './Controllers/DiscoverController.js';\nimport { initializeSettingsController } from './Controllers/SettingsController.js';\nimport { initializeSpacesController } from './Controllers/SpacesController.js';\nimport { initializeDriveController } from './Controllers/DriveController.js';\nimport {\n  UIEventNames,\n  RuntimeMessageTypes,\n  RawDirectMessageTypes,\n  Contexts,\n  DirectDBNames,\n  DBEventNames,\n  InternalEventBusMessageTypes,\n  WorkerEventNames,\n} from './events/eventNames.js';\nimport { dbChannel, llmChannel, logChannel } from './Utilities/dbChannels.js';\n\n// --- Constants ---\nconst LOG_QUEUE_MAX = 1000;\nconst senderId = 'sidepanel-' + Math.random().toString(36).slice(2) + '-' + Date.now();\n\n// --- Global State ---\nlet currentTab = null;\nlet activeSessionId = null;\nlet isPopup = false;\nlet originalTabIdFromPopup = null;\nlet currentTabId = null;\nlet isDbReady = false;\nlet historyPopupController = null;\nlet logQueue = [];\nconst pendingDbRequests = new Map();\n\n// --- Global Setup ---\n// Set EXTENSION_CONTEXT based on URL query string\n(function () {\n  try {\n    const urlParams = new URLSearchParams(window.location.search);\n    const contextParam = urlParams.get('context');\n    const viewParam = urlParams.get('view');\n    window.EXTENSION_CONTEXT =\n      contextParam === 'popup'\n        ? Contexts.POPUP\n        : viewParam === 'logs'\n        ? Contexts.OTHERS\n        : Contexts.MAIN_UI;\n  } catch (e) {\n    window.EXTENSION_CONTEXT = Contexts.UNKNOWN;\n  }\n})();\n\n// Marked.js Setup\nif (window.marked) {\n  window.marked.setOptions({\n    highlight: function (code, lang) {\n      if (lang && window.hljs && window.hljs.getLanguage(lang)) {\n        try {\n          return window.hljs.highlight(code, { language: lang, ignoreIllegals: true }).value;\n        } catch (e) {\n          console.error('hljs error:', e);\n        }\n      } else if (window.hljs) {\n        try {\n          return window.hljs.highlightAuto(code).value;\n        } catch (e) {\n          console.error('hljs auto error:', e);\n        }\n      }\n      const escapeHtml = (htmlStr) =>\n        htmlStr\n          .replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;')\n          .replace(/\"/g, '&quot;')\n          .replace(/'/g, '&#39;');\n      return escapeHtml(code);\n    },\n    langPrefix: 'language-',\n    gfm: true,\n    breaks: true,\n  });\n  console.log('[Sidepanel] Marked.js globally configured to use highlight.js.');\n} else {\n  console.error('[Sidepanel] Marked.js library (window.marked) not found.');\n}\n\n// --- DB and Channel Utilities ---\nfunction isDbRequest(type) {\n  return typeof type === 'string' && type.endsWith('_REQUEST');\n}\n\nfunction isDbLocalContext() {\n  return typeof forwardDbRequest === 'function';\n}\n\nasync function sendDbRequestViaChannel(request) {\n  return new Promise((resolve) => {\n    const responseType = request.type + '_RESPONSE_' + Math.random();\n    const requestId = request.requestId || (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));\n    function onResponse(event) {\n      if (event.data?.type === responseType && event.data.requestId === requestId) {\n        dbChannel.removeEventListener('message', onResponse);\n        resolve(event.data.payload);\n      }\n    }\n    dbChannel.addEventListener('message', onResponse);\n    dbChannel.postMessage({ ...request, responseType, requestId });\n  });\n}\n\nasync function sendDbRequestSmart(request, timeoutMs = 5000) {\n  if (isDbLocalContext()) {\n    return await forwardDbRequest(request);\n  }\n  return await browser.runtime.sendMessage(request);\n}\n\nfunction requestDbAndWait(requestEvent, timeoutMs = 5000) {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const result = await sendDbRequestSmart(requestEvent, timeoutMs);\n      console.log('[Trace][sidepanel] requestDbAndWait: Raw result', result);\n      const response = Array.isArray(result) ? result[0] : result;\n      if (response && (response.success || response.error === undefined)) {\n        resolve(response.data || response.payload);\n      } else {\n        reject(new Error(response?.error || `DB operation ${requestEvent.type} failed`));\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n// --- Logging ---\nfunction bufferOrWriteLog(logPayload) {\n  if (!isDbReady) {\n    if (logQueue.length >= LOG_QUEUE_MAX) {\n      logQueue.shift();\n    }\n    logQueue.push(logPayload);\n  } else {\n    const req = new DbAddLogRequest(logPayload);\n    sendDbRequestViaChannel(req);\n  }\n}\n\nlogChannel.onmessage = (event) => {\n  const { type, payload } = event.data;\n  if (type === 'LOG_TO_DB' && payload) {\n    bufferOrWriteLog(payload);\n  }\n};\n\n// --- UI and Worker Utilities ---\nfunction sendUiEvent(type, payload) {\n  browser.runtime.sendMessage({ type, payload });\n}\n\nfunction sendWorkerError(message) {\n  browser.runtime.sendMessage({ type: UIEventNames.WORKER_ERROR, payload: message });\n}\n\nfunction getActiveChatSessionId() {\n  return activeSessionId;\n}\n\nasync function setActiveChatSessionId(newSessionId) {\n  console.log(`[Sidepanel] Setting active session ID to: ${newSessionId}`);\n  activeSessionId = newSessionId;\n  if (newSessionId) {\n    await browser.storage.local.set({ lastSessionId: newSessionId });\n  } else {\n    await browser.storage.local.remove('lastSessionId');\n  }\n  setRendererSessionId(newSessionId);\n  setActiveSession(newSessionId);\n}\n\n// --- Channel Handlers ---\nif (window.EXTENSION_CONTEXT === Contexts.MAIN_UI) {\n  dbChannel.onmessage = async (event) => {\n    const { type, payload, requestId, senderId: reqSenderId, responseType } = event.data;\n    if (!isDbRequest(type)) return;\n    try {\n      const response = await browser.runtime.sendMessage({\n        type,\n        payload,\n        requestId,\n        senderId: reqSenderId,\n      });\n      const respType = responseType || type + '_RESPONSE';\n      dbChannel.postMessage({ type: respType, payload: response, requestId, senderId });\n    } catch (err) {\n      const respType = responseType || type + '_RESPONSE';\n      dbChannel.postMessage({\n        type: respType,\n        payload: { success: false, error: err.message },\n        requestId,\n        senderId,\n      });\n    }\n  };\n\n  llmChannel.onmessage = async (event) => {\n    const { type, payload, requestId, senderId } = event.data;\n    if (\n      [\n        WorkerEventNames.WORKER_SCRIPT_READY,\n        WorkerEventNames.WORKER_READY,\n        WorkerEventNames.LOADING_STATUS,\n        WorkerEventNames.ERROR,\n        WorkerEventNames.RESET_COMPLETE,\n      ].includes(type)\n    ) {\n      return;\n    }\n    if (type === RuntimeMessageTypes.SEND_CHAT_MESSAGE && typeof window.sendChatMessage === 'function') {\n      const result = await window.sendChatMessage(payload);\n      llmChannel.postMessage({\n        type: RuntimeMessageTypes.SEND_CHAT_MESSAGE + '_RESPONSE',\n        payload: result,\n        requestId,\n        senderId: 'sidepanel',\n        timestamp: Date.now(),\n      });\n    } else if (\n      type === RuntimeMessageTypes.INTERRUPT_GENERATION &&\n      typeof window.interruptGeneration === 'function'\n    ) {\n      const result = await window.interruptGeneration(payload);\n      llmChannel.postMessage({\n        type: RuntimeMessageTypes.INTERRUPT_GENERATION + '_RESPONSE',\n        payload: result,\n        requestId,\n        senderId: 'sidepanel',\n        timestamp: Date.now(),\n      });\n    } else if (type === RuntimeMessageTypes.RESET_WORKER && typeof window.resetWorker === 'function') {\n      const result = await window.resetWorker(payload);\n      llmChannel.postMessage({\n        type: RuntimeMessageTypes.RESET_WORKER + '_RESPONSE',\n        payload: result,\n        requestId,\n        senderId: 'sidepanel',\n        timestamp: Date.now(),\n      });\n    } else if (type === RuntimeMessageTypes.LOAD_MODEL && typeof window.loadModel === 'function') {\n      const result = await window.loadModel(payload);\n      llmChannel.postMessage({\n        type: RuntimeMessageTypes.LOAD_MODEL + '_RESPONSE',\n        payload: result,\n        requestId,\n        senderId: 'sidepanel',\n        timestamp: Date.now(),\n      });\n    } else if (type === RuntimeMessageTypes.GET_MODEL_WORKER_STATE) {\n      const state = window.currentModelWorkerState || 'UNINITIALIZED';\n      const modelId = window.currentModelIdForWorker || null;\n      llmChannel.postMessage({\n        type: RuntimeMessageTypes.GET_MODEL_WORKER_STATE + '_RESPONSE',\n        payload: { state, modelId },\n        requestId,\n        senderId: 'sidepanel',\n        timestamp: Date.now(),\n      });\n    }\n  };\n}\n\n// --- Event Handlers ---\nfunction handleMessage(message, sender, sendResponse) {\n  const { type } = message;\n  if (Object.values(DirectDBNames).includes(type) || Object.values(DBEventNames).includes(type)) {\n    return false;\n  }\n  if (type === RawDirectMessageTypes.WORKER_GENERIC_RESPONSE) {\n    sendUiEvent(UIEventNames.BACKGROUND_RESPONSE_RECEIVED, {\n      chatId: message.chatId,\n      messageId: message.messageId,\n      text: message.text,\n    });\n  } else if (type === RawDirectMessageTypes.WORKER_GENERIC_ERROR) {\n    sendUiEvent(UIEventNames.BACKGROUND_ERROR_RECEIVED, {\n      chatId: message.chatId,\n      messageId: message.messageId,\n      error: message.error,\n    });\n    sendResponse({});\n  } else if (type === RawDirectMessageTypes.WORKER_SCRAPE_STAGE_RESULT) {\n    sendUiEvent(UIEventNames.BACKGROUND_SCRAPE_STAGE_RESULT, message.payload);\n    sendResponse({ status: 'received', type });\n  } else if (type === RawDirectMessageTypes.WORKER_DIRECT_SCRAPE_RESULT) {\n    sendUiEvent(UIEventNames.BACKGROUND_SCRAPE_RESULT_RECEIVED, message.payload);\n    sendResponse({});\n  } else if (type === RawDirectMessageTypes.WORKER_UI_LOADING_STATUS_UPDATE) {\n    sendUiEvent(UIEventNames.BACKGROUND_LOADING_STATUS_UPDATE, message.payload);\n  } else if (\n    type === InternalEventBusMessageTypes.BACKGROUND_EVENT_BROADCAST ||\n    type === UIEventNames.MODEL_DOWNLOAD_PROGRESS\n  ) {\n    // No action needed\n  } else {\n    console.warn('[Sidepanel] Received unknown message type from background:', type, message);\n  }\n}\n\nasync function handleSessionCreated(newSessionId) {\n  console.log(`[Sidepanel] Orchestrator reported new session created: ${newSessionId}`);\n  await setActiveChatSessionId(newSessionId);\n  try {\n    const request = new DbGetSessionRequest(newSessionId);\n    const sessionData = await requestDbAndWait(request);\n    if (!sessionData?.messages) {\n      console.warn(`[Sidepanel] No messages found in session data for new session ${newSessionId}.`, sessionData);\n    }\n  } catch (error) {\n    console.error(`[Sidepanel] Failed to fetch messages for new session ${newSessionId}:`, error);\n    utilShowError(`Failed to load initial messages for new chat: ${error.message}`);\n  }\n}\n\nasync function handleNewChat() {\n  console.log('[Sidepanel] New Chat button clicked.');\n  await setActiveChatSessionId(null);\n  clearInput();\n  focusInput();\n}\n\nasync function handleChatSessionClick(event) {\n  const sessionId = event.currentTarget.dataset.sessionId;\n  if (!sessionId) {\n    console.warn('[Sidepanel] Session list click event missing sessionId:', event.currentTarget);\n    return;\n  }\n  if (sessionId === activeSessionId) {\n    console.log(`[Sidepanel] Clicked already active session: ${sessionId}`);\n    scrollToBottom();\n  } else {\n    console.log(`[Sidepanel] Session list item clicked: ${sessionId}`);\n    await loadAndDisplaySession(sessionId);\n  }\n}\n\nasync function loadAndDisplaySession(sessionId) {\n  if (!sessionId) {\n    console.log('[Sidepanel] No session ID to load, setting renderer to null.');\n    await setActiveChatSessionId(null);\n    return;\n  }\n  console.log(`[Sidepanel] Loading session data for: ${sessionId}`);\n  try {\n    const request = new DbGetSessionRequest(sessionId);\n    const sessionData = await requestDbAndWait(request);\n    console.log(`[Sidepanel] Session data successfully loaded for ${sessionId}.`);\n    await setActiveChatSessionId(sessionId);\n    if (!sessionData?.messages) {\n      console.warn(`[Sidepanel] No messages found in loaded session data for ${sessionId}.`);\n    }\n  } catch (error) {\n    console.error(`[Sidepanel] Failed to load session ${sessionId}:`, error);\n    utilShowError(`Failed to load chat: ${error.message}`);\n    await setActiveChatSessionId(null);\n  }\n}\n\nasync function handleDetach() {\n  if (!currentTabId) {\n    console.error('Cannot detach: Missing tab ID');\n    utilShowError('Cannot detach: Missing tab ID');\n    return;\n  }\n  const currentSessionId = getActiveChatSessionId();\n  try {\n    const response = await browser.runtime.sendMessage({\n      type: 'getPopupForTab',\n      tabId: currentTabId,\n    });\n    if (response?.popupId) {\n      await browser.windows.update(response.popupId, { focused: true });\n      return;\n    }\n    const storageKey = `detachedSessionId_${currentTabId}`;\n    await browser.storage.local.set({ [storageKey]: currentSessionId });\n    console.log(`Sidepanel: Saved session ID ${currentSessionId} for detach key ${storageKey}.`);\n    const popup = await browser.windows.create({\n      url: browser.runtime.getURL(`sidepanel.html?context=popup&originalTabId=${currentTabId}`),\n      type: 'popup',\n      width: 400,\n      height: 600,\n    });\n    if (popup?.id) {\n      await browser.runtime.sendMessage({\n        type: 'popupCreated',\n        tabId: currentTabId,\n        popupId: popup.id,\n      });\n    } else {\n      throw new Error('Failed to create popup window.');\n    }\n  } catch (error) {\n    console.error('Error during detach:', error);\n    utilShowError(`Error detaching chat: ${error.message}`);\n  }\n}\n\nasync function handlePageChange(event) {\n  if (!event?.pageId) return;\n  console.log(`[Sidepanel] Navigation changed to: ${event.pageId}`);\n  if (!isDbReady) {\n    console.log('[Sidepanel] DB not ready yet, skipping session load on initial navigation event.');\n    return;\n  }\n  if (event.pageId === 'page-home') {\n    console.log('[Sidepanel] Navigated to home page, checking for specific session load signal...');\n    try {\n      const { lastSessionId } = await browser.storage.local.get(['lastSessionId']);\n      if (lastSessionId) {\n        console.log(`[Sidepanel] Found load signal: ${lastSessionId}. Loading session and clearing signal.`);\n        await loadAndDisplaySession(lastSessionId);\n        await browser.storage.local.remove('lastSessionId');\n      } else {\n        console.log('[Sidepanel] No load signal found. Resetting to welcome state.');\n        await loadAndDisplaySession(null);\n      }\n    } catch (error) {\n      console.error('[Sidepanel] Error checking/loading session based on signal:', error);\n      utilShowError('Failed to load session state.');\n      await loadAndDisplaySession(null);\n    }\n  }\n}\n\n// --- Worker Status Broadcasting ---\nfunction handleWorkerStatusEvent(event) {\n  const { type, payload } = event.data;\n  if (\n    [\n      WorkerEventNames.WORKER_SCRIPT_READY,\n      WorkerEventNames.WORKER_READY,\n      WorkerEventNames.LOADING_STATUS,\n      WorkerEventNames.ERROR,\n      WorkerEventNames.RESET_COMPLETE,\n    ].includes(type)\n  ) {\n    llmChannel.postMessage({ type, payload, senderId: 'sidepanel', timestamp: Date.now() });\n  }\n}\n\nif (window.modelWorker) {\n  window.modelWorker.onmessage = (event) => {\n    handleWorkerStatusEvent(event);\n  };\n}\n\n// --- Main Initialization ---\ndocument.addEventListener('DOMContentLoaded', async () => {\n  console.log('[Sidepanel] DOM Content Loaded.');\n  const urlParams = new URLSearchParams(window.location.search);\n  const requestedView = urlParams.get('view');\n\n  // Log Viewer Mode\n  if (requestedView === 'logs') {\n    console.log('[Sidepanel] Initializing in Log Viewer Mode.');\n    document.body.classList.add('log-viewer-mode');\n    document.getElementById('header')?.classList.add('hidden');\n    document.getElementById('bottom-nav')?.classList.add('hidden');\n    document\n      .querySelectorAll('#main-content > .page-container:not(#page-log-viewer)')\n      .forEach((el) => el.classList.add('hidden'));\n    const logViewerPage = document.getElementById('page-log-viewer');\n    if (logViewerPage) {\n      logViewerPage.classList.remove('hidden');\n    } else {\n      console.error('CRITICAL: #page-log-viewer element not found!');\n      document.body.innerHTML =\n        \"<p style='color:red; padding: 1em;'>Error: Log viewer UI component failed to load.</p>\";\n      return;\n    }\n    try {\n      const logViewerModule = await import('./Controllers/LogViewerController.js');\n      await logViewerModule.initializeLogViewerController();\n      console.log('[Sidepanel] Log Viewer Controller initialized.');\n    } catch (err) {\n      console.error('Failed to load or initialize LogViewerController:', err);\n      if (logViewerPage) {\n        logViewerPage.innerHTML = `<div style='color:red; padding: 1em;'>Error initializing log viewer: ${err.message}</div>`;\n      }\n    }\n    return;\n  }\n\n  // Standard Mode\n  console.log('[Sidepanel] Initializing in Standard Mode.');\n  document.getElementById('page-log-viewer')?.classList.add('hidden');\n\n  // Initialize DB\n  try {\n    const result = await autoEnsureDbInitialized();\n    if (result?.success) {\n      console.log('[Sidepanel] DB initialized directly.');\n      isDbReady = true;\n      for (const logPayload of logQueue) {\n        const req = new DbAddLogRequest(logPayload);\n        sendDbRequestViaChannel(req);\n      }\n      logQueue = [];\n    } else {\n      throw new Error(`Database initialization failed: ${result?.error || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('[Sidepanel] DB Initialization failed:', error);\n    utilShowError(`Initialization failed: ${error.message}. Please try reloading.`);\n    const chatBody = document.getElementById('chat-body');\n    if (chatBody) {\n      chatBody.innerHTML = `<div class=\"p-4 text-red-500\">Critical Error: ${error.message}. Please reload the extension.</div>`;\n    }\n    return;\n  }\n\n  // Initialize UI and Core Components\n  try {\n    const { chatBody, newChatButton, chatInputElement, sendButton, fileInput } = initializeUI({\n      onNewChat: handleNewChat,\n      onSessionClick: handleChatSessionClick,\n      onAttachFile: handleAttachClick,\n    });\n    console.log('[Sidepanel] UI Controller Initialized.');\n\n    const chatBodyForRenderer = document.getElementById('chat-body');\n    if (!chatBodyForRenderer) {\n      console.error('[Sidepanel] CRITICAL: chatBodyForRenderer is null before initializeRenderer!');\n    }\n    initializeRenderer(chatBodyForRenderer, requestDbAndWait);\n    console.log('[Sidepanel] Chat Renderer Initialized.');\n\n    initializeNavigation();\n    console.log('[Sidepanel] Navigation Initialized.');\n\n    document.addEventListener(UIEventNames.NAVIGATION_PAGE_CHANGED, (e) => handlePageChange(e.detail));\n\n    initializeFileHandling({\n      uiController,\n      getActiveSessionIdFunc: getActiveChatSessionId,\n    });\n    console.log('[Sidepanel] File Handler Initialized.');\n\n    const fileInputForListener = document.getElementById('file-input');\n    if (fileInputForListener) {\n      fileInputForListener.addEventListener('change', handleFileSelected);\n    } else {\n      console.warn('[Sidepanel] File input element not found before adding listener.');\n    }\n\n    const activeTab = await getActiveTab();\n    currentTabId = activeTab?.id;\n    currentTab = activeTab;\n    console.log(`[Sidepanel] Current Tab ID: ${currentTabId}`);\n\n    initializeOrchestrator({\n      getActiveSessionIdFunc: getActiveChatSessionId,\n      onSessionCreatedCallback: handleSessionCreated,\n      getCurrentTabIdFunc: () => currentTabId,\n    });\n    console.log('[Sidepanel] Message Orchestrator Initialized.');\n\n    browser.runtime.onMessage.addListener(handleMessage);\n    console.log('[Sidepanel] Background message listener added.');\n\n    // Initialize Controllers\n    const historyPopupElement = document.getElementById('history-popup');\n    const historyListElement = document.getElementById('history-list');\n    const historySearchElement = document.getElementById('history-search');\n    const closeHistoryButtonElement = document.getElementById('close-history');\n    const historyButton = document.getElementById('history-button');\n    const detachButton = document.getElementById('detach-button');\n\n    if (historyPopupElement && historyListElement && historySearchElement && closeHistoryButtonElement) {\n      historyPopupController = initializeHistoryPopup(\n        {\n          popupContainer: historyPopupElement,\n          listContainer: historyListElement,\n          searchInput: historySearchElement,\n          closeButton: closeHistoryButtonElement,\n        },\n        requestDbAndWait\n      );\n      if (!historyPopupController) {\n        console.error('[Sidepanel] History Popup Controller initialization failed.');\n      }\n    } else {\n      console.warn('[Sidepanel] Could not find all required elements for History Popup Controller.');\n    }\n\n    if (historyButton && historyPopupController) {\n      historyButton.addEventListener('click', () => historyPopupController.show());\n    } else {\n      console.warn('[Sidepanel] History button or controller not available for listener.');\n    }\n\n    if (detachButton) {\n      detachButton.addEventListener('click', handleDetach);\n    } else {\n      console.warn('[Sidepanel] Detach button not found.');\n    }\n\n    const libraryListElement = document.getElementById('starred-list');\n    if (libraryListElement) {\n      initializeLibraryController({ listContainer: libraryListElement }, requestDbAndWait);\n      console.log('[Sidepanel] Library Controller Initialized.');\n    } else {\n      console.warn('[Sidepanel] Could not find #starred-list element for Library Controller.');\n    }\n\n    document.addEventListener(UIEventNames.REQUEST_MODEL_LOAD, (e) => {\n      const { modelId } = e.detail || {};\n      if (!modelId) {\n        sendWorkerError('No model ID specified for loading.');\n        return;\n      }\n      browser.runtime\n        .sendMessage({ type: RuntimeMessageTypes.LOAD_MODEL, payload: { modelId } })\n        .catch((err) => sendWorkerError(`Failed to send load request: ${err.message}`));\n    });\n\n    initializeDiscoverController();\n    console.log('[Sidepanel] Discover Controller Initialized.');\n\n    initializeSettingsController();\n    console.log('[Sidepanel] Settings Controller Initialized.');\n\n    initializeSpacesController();\n    console.log('[Sidepanel] Spaces Controller Initialized.');\n\n    initializeDriveController({\n      requestDbAndWaitFunc: requestDbAndWait,\n      getActiveChatSessionId,\n      setActiveChatSessionId,\n      showNotification,\n      debounce,\n    });\n    console.log('[Sidepanel] Drive Controller Initialized.');\n\n    // Handle Popup Context\n    const popupContext = urlParams.get('context');\n    originalTabIdFromPopup = popupContext === 'popup' ? urlParams.get('originalTabId') : null;\n    isPopup = popupContext === 'popup';\n    console.log(\n      `[Sidepanel] Context: ${isPopup ? 'Popup' : 'Sidepanel'}${\n        isPopup ? ', Original Tab: ' + originalTabIdFromPopup : ''\n      }`\n    );\n\n    if (isPopup && originalTabIdFromPopup) {\n      const storageKey = `detachedSessionId_${originalTabIdFromPopup}`;\n      const result = await browser.storage.local.get(storageKey);\n      const detachedSessionId = result[storageKey];\n      if (detachedSessionId) {\n        console.log(`[Sidepanel-Popup] Found detached session ID: ${detachedSessionId}. Loading...`);\n        await loadAndDisplaySession(detachedSessionId);\n      } else {\n        console.log(`[Sidepanel-Popup] No detached session ID found for key ${storageKey}. Starting fresh.`);\n        await setActiveChatSessionId(null);\n      }\n    } else {\n      console.log('[Sidepanel] Starting fresh. Loading empty/welcome state.');\n      await loadAndDisplaySession(null);\n    }\n\n    console.log('[Sidepanel] Initialization complete.');\n  } catch (error) {\n    console.error('[Sidepanel] Initialization failed:', error);\n    utilShowError(`Initialization failed: ${error.message}. Please try reloading.`);\n    const chatBody = document.getElementById('chat-body');\n    if (chatBody) {\n      chatBody.innerHTML = `<div class=\"p-4 text-red-500\">Critical Error: ${error.message}. Please reload the extension.</div>`;\n    }\n  }\n});\n\n// --- Exports ---\nexport { sendDbRequestSmart };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"assets/\" + chunkId + \"-\" + \"c85e5d206fdb891a6d10\" + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"tabagent:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"sidepanel\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunktabagent\"] = self[\"webpackChunktabagent\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/sidepanel.js\");\n",""],"names":[],"sourceRoot":""}