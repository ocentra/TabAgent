import{A as pe,e as L,I as xe,C as we,B as X}from"./assets/_commonjsHelpers-CcizWAex.js";var Z={exports:{}},be=Z.exports,ie;function he(){return ie||(ie=1,function(e,r){(function(a,l){l(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:be,function(a){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)a.exports=globalThis.browser;else{const l="The message port closed before a response was received.",s=u=>{const B={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(B).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class p extends WeakMap{constructor(o,m=void 0){super(m),this.createItem=o}get(o){return this.has(o)||this.set(o,this.createItem(o)),super.get(o)}}const x=t=>t&&typeof t=="object"&&typeof t.then=="function",h=(t,o)=>(...m)=>{u.runtime.lastError?t.reject(new Error(u.runtime.lastError.message)):o.singleCallbackArg||m.length<=1&&o.singleCallbackArg!==!1?t.resolve(m[0]):t.resolve(m)},T=t=>t==1?"argument":"arguments",f=(t,o)=>function(d,...b){if(b.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${T(o.minArgs)} for ${t}(), got ${b.length}`);if(b.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${T(o.maxArgs)} for ${t}(), got ${b.length}`);return new Promise((C,v)=>{if(o.fallbackToNoCallback)try{d[t](...b,h({resolve:C,reject:v},o))}catch(g){console.warn(`${t} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,g),d[t](...b),o.fallbackToNoCallback=!1,o.noCallback=!0,C()}else o.noCallback?(d[t](...b),C()):d[t](...b,h({resolve:C,reject:v},o))})},y=(t,o,m)=>new Proxy(o,{apply(d,b,C){return m.call(b,t,...C)}});let z=Function.call.bind(Object.prototype.hasOwnProperty);const G=(t,o={},m={})=>{let d=Object.create(null),b={has(v,g){return g in t||g in d},get(v,g,$){if(g in d)return d[g];if(!(g in t))return;let w=t[g];if(typeof w=="function")if(typeof o[g]=="function")w=y(t,t[g],o[g]);else if(z(m,g)){let W=f(g,m[g]);w=y(t,t[g],W)}else w=w.bind(t);else if(typeof w=="object"&&w!==null&&(z(o,g)||z(m,g)))w=G(w,o[g],m[g]);else if(z(m,"*"))w=G(w,o[g],m["*"]);else return Object.defineProperty(d,g,{configurable:!0,enumerable:!0,get(){return t[g]},set(W){t[g]=W}}),w;return d[g]=w,w},set(v,g,$,w){return g in d?d[g]=$:t[g]=$,!0},defineProperty(v,g,$){return Reflect.defineProperty(d,g,$)},deleteProperty(v,g){return Reflect.deleteProperty(d,g)}},C=Object.create(t);return new Proxy(C,b)},Y=t=>({addListener(o,m,...d){o.addListener(t.get(m),...d)},hasListener(o,m){return o.hasListener(t.get(m))},removeListener(o,m){o.removeListener(t.get(m))}}),ue=new p(t=>typeof t!="function"?t:function(m){const d=G(m,{},{getContent:{minArgs:0,maxArgs:0}});t(d)}),ne=new p(t=>typeof t!="function"?t:function(m,d,b){let C=!1,v,g=new Promise(N=>{v=function(S){C=!0,N(S)}}),$;try{$=t(m,d,v)}catch(N){$=Promise.reject(N)}const w=$!==!0&&x($);if($!==!0&&!w&&!C)return!1;const W=N=>{N.then(S=>{b(S)},S=>{let Q;S&&(S instanceof Error||typeof S.message=="string")?Q=S.message:Q="An unexpected error occurred",b({__mozWebExtensionPolyfillReject__:!0,message:Q})}).catch(S=>{console.error("Failed to send onMessage rejected reply",S)})};return W(w?$:g),!0}),Ae=({reject:t,resolve:o},m)=>{u.runtime.lastError?u.runtime.lastError.message===l?o():t(new Error(u.runtime.lastError.message)):m&&m.__mozWebExtensionPolyfillReject__?t(new Error(m.message)):o(m)},oe=(t,o,m,...d)=>{if(d.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${T(o.minArgs)} for ${t}(), got ${d.length}`);if(d.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${T(o.maxArgs)} for ${t}(), got ${d.length}`);return new Promise((b,C)=>{const v=Ae.bind(null,{resolve:b,reject:C});d.push(v),m.sendMessage(...d)})},fe={devtools:{network:{onRequestFinished:Y(ue)}},runtime:{onMessage:Y(ne),onMessageExternal:Y(ne),sendMessage:oe.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:oe.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},J={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return B.privacy={network:{"*":J},services:{"*":J},websites:{"*":J}},G(u,fe,B)};a.exports=s(chrome)}})}(Z)),Z.exports}var ke=he();const c=pe(ke),ye=typeof chrome<"u"&&chrome.runtime;let k="unknown",K=!0,O=!0,ge=!1;const re=[];async function Ce(){if(L)for(;re.length>0;){const e=re.shift();if(e)try{await L.publish(e.type,e)}catch(r){console.error(`LogClient (${k}): Error publishing buffered log. Error: ${r}. Event:`,e)}}}function ve(e,r={}){k=e,K=r.mirrorToConsole!==void 0?r.mirrorToConsole:!0,O=r.sendToDb!==void 0?r.sendToDb:!0,L?L.subscribe(xe.name,s=>{s.payload.success?(console.log(`[LogClient (${k})] Received DB Initialization Complete. Flushing buffer.`),ge=!0,Ce()):console.error(`[LogClient (${k})] Received DB Initialization FAILED notification. Logs will not be sent to DB. Error:`,s.payload.error)}):(console.error(`LogClient (${k}): CRITICAL - eventBus not available during init. DB logging disabled.`),O=!1);let a="unknown";typeof L<"u"?a="sendMessage logging (Standard)":(a="console fallback",console.error(`LogClient (${k}): CRITICAL - No logging mechanism available. Falling back to console.`));const l=`Log client initialized for component: ${k}. (${a}, Console Mirror: ${K}, SendToDB: ${O})`;j("info",l,{mirrorToConsole:K,sendToDb:O,skipInitCheck:!0})}async function j(e,...r){var T;const l=(r.length>0&&typeof r[r.length-1]=="object"&&!Array.isArray(r[r.length-1])?r.pop():{})||{},s=l.mirrorToConsole!==void 0?l.mirrorToConsole:K;let u=l.sendToDb!==void 0?l.sendToDb:O;const B=l.skipInitCheck||!1;if(u&&typeof L>"u"&&(console.warn(`LogClient (${k}): Attempted DB log but eventBus is unavailable. Disabling DB log for this call.`),u=!1),!k&&!B){console.error("LogClient: Attempted to log before init() was called. Message:",e,...r);return}if(s||e.toLowerCase()==="error"){const y=[k?`[${k}]`:"[LogClient]",...r];switch(e.toLowerCase()){case"error":console.error(...y);break;case"warn":s&&console.warn(...y);break;case"debug":s&&console.debug(...y);break;case"info":default:s&&console.log(...y);break}}if(!u)return;const p=r.map(f=>{try{return f instanceof Error?`Error: ${f.message}${f.stack?`
`+f.stack:""}`:typeof f=="object"&&f!==null?"[Object]":String(f)}catch(y){return`[Unstringifiable Object: ${y.message}]`}}).join(" "),x={id:crypto.randomUUID(),timestamp:Date.now(),component:k,level:e.toLowerCase(),message:p};if(ye&&((T=chrome.storage)!=null&&T.local))try{const{currentLogSessionId:f}=await chrome.storage.local.get("currentLogSessionId");f?x.extensionSessionId=f:(console.warn(`LogClient (${k}): Could not retrieve currentLogSessionId from storage.`),x.extensionSessionId="unknown-session")}catch(f){console.error(`LogClient (${k}): Error retrieving session ID from storage:`,f),x.extensionSessionId="storage-error-session"}else x.extensionSessionId="no-storage-session";const h=new we(x);if(ge)try{await L.publish(h.type,h)}catch(f){console.error(`LogClient (${k}): Error during eventBus log submission. Error: ${f}. Original message:`,e,...r)}else re.push(h)}function P(...e){j("debug",...e)}function i(...e){j("info",...e)}function _(...e){j("warn",...e)}function A(...e){j("error",...e)}const te="offscreenWorker.html";ve("Background");let D={},q={};const ae=1,$e=1;let n="uninitialized",E=null,U=null,I=null,R=null,se=null,M=null,H=null,le=null,ee=-10;async function ce(){i("Initializing log session IDs..."),H=Date.now()+"-"+Math.random().toString(36).substring(2,9),i("Current log session ID:",H),await c.storage.local.set({currentLogSessionId:H});const{previousLogSessionId:e}=await c.storage.local.get("previousLogSessionId");le=e||null,i("Previous log session ID found in storage:",le),await c.storage.local.set({previousLogSessionId:H}),i("Stored new previousLogSessionId for next run.")}async function me(){const e=c.runtime.getURL(te);return(await c.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[e]})).length>0}async function de(){if(await me()){i("Model worker offscreen document already exists.");return}i("Creating model worker offscreen document..."),await c.offscreen.createDocument({url:te,reasons:[c.offscreen.Reason.WORKERS],justification:"Run model inference in a separate worker via offscreen document"}),i("Model worker offscreen document created.")}async function V(e){if(e.type!=="init"&&e.type!=="generate"&&e.type!=="interrupt"&&e.type!=="reset")(n==="uninitialized"||!await me())&&(i(`Background: Ensuring model worker offscreen doc potentially exists before sending ${e==null?void 0:e.type}`),await de());else{P(`Background: Ensuring worker script is ready before sending ${e.type}...`);try{await F(),P(`Background: Worker script confirmed ready. Proceeding to send ${e.type}.`)}catch(r){throw A(`Background: Worker script failed to become ready. Cannot send ${e.type}. Error:`,r),n="error",new Error(`Worker script failed to initialize, cannot send ${e.type}.`)}}P(`Background: Sending message type '${e==null?void 0:e.type}' to model worker offscreen doc`);try{if((await c.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[c.runtime.getURL(te)]})).length>0)return c.runtime.sendMessage(e),P(`Background: Message type '${e==null?void 0:e.type}' sent to offscreen.`),{success:!0};throw A(`Background: Could not find target offscreen document context to send ${e==null?void 0:e.type}.`),new Error("Target offscreen document not found.")}catch(r){throw A(`Background: Error sending message type '${e==null?void 0:e.type}' to offscreen:`,r),n="error",e.type==="init"?(M&&M(new Error(`Failed to send init message: ${r.message}`)),R=null):I&&(n==="uninitialized"||n==="creating_worker")&&(I(new Error(`Failed to send message early: ${r.message}`)),E=null),new Error(`Failed to send message to model worker offscreen: ${r.message}`)}}function F(){if(P(`[ensureWorkerScriptIsReady] Current state: ${n}`),n!=="uninitialized"&&n!=="creating_worker")return n==="error"&&!E?Promise.reject(new Error("Worker script initialization previously failed.")):Promise.resolve();if(E)return E;P("[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise."),n="creating_worker",E=new Promise((r,a)=>{U=r,I=a,de().catch(l=>{A("[ensureWorkerScriptIsReady] Error setting up offscreen doc:",l),n="error",I&&I(l),E=null})});const e=3e4;return setTimeout(()=>{n==="creating_worker"&&I&&(A(`[ensureWorkerScriptIsReady] Timeout (${e}ms) waiting for workerScriptReady.`),I(new Error("Timeout waiting for model worker script to load.")),n="error",E=null)},e),E}async function Ee(e){i(`Request to load model: ${e}. Current state: ${n}`);try{await F(),P(`Worker script confirmed ready (state: ${n}). Proceeding with model load.`)}catch(a){throw A("Failed to ensure worker script readiness:",a),new Error(`Failed to ensure worker script readiness: ${a.message}`)}if(n!=="worker_script_ready"&&n!=="idle"&&n!=="error"){const a=`Cannot load model '${e}'. Worker state is '${n}', expected 'worker_script_ready', 'idle', or 'error'.`;throw A("State check failed loading model:",a),new Error(a)}if(!e)return Promise.reject(new Error("Cannot load model: Model ID not provided."));if(n==="model_ready")return i(`Model appears ready. Assuming it's ${e}.`),Promise.resolve();if(n==="loading_model"&&R)return i(`Model is already loading. Assuming it's ${e}.`),R;if(n!=="worker_script_ready")return A("Cannot load model. Worker script is not ready. State:",n),Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${n})`));i(`Worker script ready. Initiating load for model: ${e}.`),n="loading_model",R=new Promise((a,l)=>{se=a,M=l,P(`Attempting to send 'init' message for model: ${e}`),V({type:"init",payload:{modelId:e}}).catch(s=>{A(`Failed to send 'init' message for ${e}:`,s),n="error",M&&M(s),R=null})});const r=3e5;return setTimeout(()=>{n==="loading_model"&&M&&(A(`Timeout (${r}ms) waiting for model ${e} load completion.`),M(new Error(`Timeout waiting for model ${e} to load.`)),n="error",R=null)},r),R}async function Se(){const r=(await c.declarativeNetRequest.getDynamicRules()).map(s=>s.id),a=[{id:ae,priority:$e,action:{type:"modifyHeaders",responseHeaders:[{header:"x-frame-options",operation:"remove"},{header:"X-Frame-Options",operation:"remove"},{header:"content-security-policy",operation:"remove"},{header:"Content-Security-Policy",operation:"remove"}]},condition:{resourceTypes:["main_frame"],urlFilter:"|http*://*/*|"}}],l=r.filter(s=>s===ae);try{await c.declarativeNetRequest.updateDynamicRules({removeRuleIds:l,addRules:a}),i("Declarative Net Request rules updated successfully.")}catch(s){A("Error updating Declarative Net Request rules:",s)}}Se();async function Te(e,r){i(`Attempting to forward message type '${e==null?void 0:e.type}' from worker.`);for(const l in D){const s=D[l];i(`Forwarding message to detached popup ID: ${s} (original tab: ${l})`);try{await c.windows.get(s),c.runtime.sendMessage(e)}catch(u){_(`Error sending to detached popup ID ${s}:`,u.message),u.message.includes("No window with id")&&(delete D[l],delete q[s])}}const a=await c.tabs.query({status:"complete"});for(const l of a)if(!D[l.id])try{await c.tabs.sendMessage(l.id,e)}catch(s){!s.message.includes("Could not establish connection")&&!s.message.includes("Receiving end does not exist")&&_(`Error forwarding message to tab ${l.id}:`,s.message)}}c.runtime.onInstalled.addListener(async e=>{i("onInstalled event fired. Reason:",e.reason),await ce(),c.sidePanel.setPanelBehavior({openPanelOnActionClick:!0}).catch(r=>A("Error setting side panel behavior:",r)),i("Side panel behavior set."),c.storage.local.get(null,r=>{const a=Object.keys(r).filter(l=>l.startsWith("detachedState_"));a.length>0&&c.storage.local.remove(a,()=>{i("Cleaned up old storage keys on install/update.")})}),i("Triggering DB Initialization from onInstalled."),L.publish(X.name,new X),F().catch(r=>{A("Initial worker script readiness check failed after install:",r)})});c.runtime.onStartup.addListener(async()=>{i("onStartup event fired."),await ce(),i("Triggering DB Initialization from onStartup (may be redundant)."),L.publish(X.name,new X),n==="uninitialized"&&F().catch(e=>{A("Worker script readiness check failed on startup:",e)})});c.action.onClicked.addListener(async e=>{if(!e.id){A("Action Clicked: Missing tab ID.");return}const r=e.id;i(`Action clicked for tab ${r}`);const a=D[r];if(a){i(`Popup ${a} exists for tab ${r}. Attempting to close popup.`);try{await c.windows.remove(a),i(`Closed popup window ${a} via action click.`)}catch(l){if(_(`Failed to close popup ${a} via action click, maybe already closed?`,l),q[a]){i(`Force cleaning maps and storage for tab ${r} after failed close.`),delete D[r],delete q[a];try{await c.storage.local.remove(`detachedState_${r}`),await c.sidePanel.setOptions({tabId:r,enabled:!0})}catch(s){A("Error during defensive cleanup:",s)}}}}else i(`No popup exists for tab ${r}. Default side panel opening behavior should trigger.`)});c.windows.onRemoved.addListener(async e=>{i(`Window removed: ${e}`);const r=q[e];if(r){i(`Popup window ${e} for tab ${r} was closed.`),delete D[r],delete q[e];try{await c.storage.local.remove(`detachedState_${r}`),i(`Removed detached state from storage for tab ${r}`),await c.sidePanel.setOptions({tabId:r,enabled:!0}),i(`Re-enabled side panel for tab ${r} after popup closed.`)}catch(a){A(`Error cleaning up storage or re-enabling side panel for tab ${r} on popup close:`,a)}}else i(`Window ${e} closed, but it wasn't a tracked popup.`)});c.runtime.onMessage.addListener((e,r,a)=>{const{type:l,payload:s}=e;let u=!1;if(i(`Received message type '${l}' from`,r.tab?`tab ${r.tab.id}`:r.url||r.id),["workerScriptReady","workerReady","loadingStatus","generationStatus","generationUpdate","generationComplete","generationError","resetComplete","error"].includes(l)){switch(i(`Handling message from worker: ${l}`),l){case"workerScriptReady":i("[Background] Worker SCRIPT is ready!"),n="worker_script_ready",U&&(U(),E=null),c.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"script_ready"}}).catch(()=>{});break;case"workerReady":i("[Background] Worker MODEL is ready! Model:",s==null?void 0:s.model),n="model_ready",se&&(se(),R=null),c.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"model_ready",model:s==null?void 0:s.model}}).catch(()=>{}),U&&(U(),E=null);break;case"loadingStatus":if((s==null?void 0:s.status)==="progress"&&(s!=null&&s.progress)){const x=Math.floor(s.progress);x>=ee+10&&(i("[Background] Worker loading status (progress):",s),ee=x)}else i("[Background] Worker loading status (other):",s),ee=-10;n!=="loading_model"&&(_(`[Background] Received loadingStatus in unexpected state: ${n}`),n="loading_model"),c.runtime.sendMessage({type:"uiLoadingStatusUpdate",payload:s}).catch(x=>{x.message!=="Could not establish connection. Receiving end does not exist."&&_("[Background] Error sending loading status to UI:",x.message)});break;case"generationStatus":i(`[Background] Generation status: ${s==null?void 0:s.status}`),(s==null?void 0:s.status)==="generating"?n="generating":(s==null?void 0:s.status)==="interrupted"&&(n="model_ready");break;case"generationUpdate":n!=="generating"&&_(`[Background] Received generationUpdate in unexpected state: ${n}`),n="generating";break;case"generationComplete":i("[Background] Generation complete."),n="model_ready";break;case"generationError":A("[Background] Generation error from worker:",s),n="error";break;case"resetComplete":i("[Background] Worker reset complete."),n="model_ready";break;case"error":A("[Background] Received generic error from worker/offscreen:",s);const p=n;n="error",p==="creating_worker"&&I?(I(new Error(s||"Generic error during script init")),E=null):p==="loading_model"&&M&&(M(new Error(s||"Generic error during model load")),R=null),c.runtime.sendMessage({type:"uiUpdate",payload:{modelStatus:"error",error:s}}).catch(()=>{});break}return Te(e),!1}if(l==="loadModel"){i("Received 'loadModel' request from sender:",r);const p=s==null?void 0:s.modelId;return i(`Received 'loadModel' request from UI for model: ${p}.`),p?(u=!0,Ee(p).then(()=>{i(`loadModel(${p}) promise resolved successfully.`),a({success:!0,message:`Model loading initiated or already complete for ${p}.`})}).catch(x=>{A(`loadModel(${p}) failed:`,x),a({success:!1,error:x.message})}),u):(A("[Background] 'loadModel' request missing modelId."),a({success:!1,error:"Model ID not provided in request."}),!1)}if(l==="sendChatMessage"){u=!0;const{chatId:p,messages:x,options:h,messageId:T}=s,f=T||p;return n!=="model_ready"?(A(`Cannot send chat message. Model state is ${n}, not 'model_ready'.`),a({success:!1,error:`Model not ready (state: ${n}). Please load a model first.`}),!1):(i(`Model ready, sending generate request for ${f}`),V({type:"generate",payload:{messages:x,max_new_tokens:h==null?void 0:h.max_new_tokens,temperature:h==null?void 0:h.temperature,top_k:h==null?void 0:h.top_k,correlationId:f}}).then(y=>{if(!y.success)throw new Error("Failed to send generate message initially.");i(`Generate request sent for ${f}. Waiting for worker responses.`),a({success:!0,message:"Generation request forwarded to worker."})}).catch(y=>{A(`Error processing sendChatMessage for ${f}:`,y),n==="generating"&&(n="model_ready"),a({success:!1,error:y.message})}),u)}return l==="interruptGeneration"?(i("[Background] Received interrupt request from UI."),F().then(()=>V({type:"interrupt"})).then(()=>a({success:!0})).catch(p=>a({success:!1,error:p.message})),u=!0,u):l==="resetWorker"?(i("[Background] Received reset request from UI."),F().then(()=>V({type:"reset"})).then(()=>a({success:!0})).catch(p=>a({success:!1,error:p.message})),u=!0,u):(u||_(`Unhandled message type: ${l}`),u)});i("[Background-Simple] Script loaded and listening.");
//# sourceMappingURL=background.js.map
