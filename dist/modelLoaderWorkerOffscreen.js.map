{"version":3,"file":"modelLoaderWorkerOffscreen.js","mappings":";;;;;;;;;AAAA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAgC,CAAC,MAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACxD,IAAI,KAAK,YAQN;AACH,CAAC;AACD;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC5I;AACA;AACA,gDAAgD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gCAAgC,MAAM;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC1I;AACA;AACA,8CAA8C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AACzI;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;ACxsCO;AACP;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;UC9ID;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AAC8H;AAClF;;AAE5C;AACA;AACA;;AAEA,gEAAgE,0EAAuB;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,WAAW,MAAM,UAAU,QAAQ,cAAc,SAAS;AACzF,MAAM;AACN,uBAAuB,QAAQ,WAAW,MAAM;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,oEAAe,8BAA8B,gBAAgB;AACzG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;;AAEpC;AACA,yBAAyB,0EAAuB;AAChD,wBAAwB,iCAAiC;AACzD;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,kCAAkC,0EAAuB;AACzD;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA,6CAA6C,oEAAe;AAC5D,8BAA8B,0EAAuB;AACrD,mCAAmC;AACnC,qBAAqB;AACrB;AACA;AACA,kCAAkC,0EAAuB;AACzD;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA8B,0EAAuB;AACrD;AACA,mCAAmC;AACnC,qBAAqB;AACrB;AACA,kBAAkB;AAClB;AACA,8BAA8B,0EAAuB;AACrD;AACA,mCAAmC;AACnC,qBAAqB;AACrB;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA,yBAAyB,mEAAgB;AACzC,gBAAgB,oEAAe;AAC/B,0BAA0B,+DAAY;AACtC;AACA,iBAAiB;AACjB;;AAEA,yBAAyB,mEAAgB;AACzC,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA,6CAA6C,mEAAgB,qCAAqC,uDAAuD,QAAQ,GAAG,SAAS;AAC7K;AACA;AACA,uCAAuC,mEAAgB,sCAAsC,+BAA+B,QAAQ,GAAG,SAAS;;AAEhJ;AACA,iDAAiD,oEAAe,eAAe,MAAM,gEAAa,6BAA6B,qBAAqB;AACpJ;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAA2B;AACvE;AACA;AACA;AACA,gFAAgF,4BAA4B,QAAQ,QAAQ,GAAG,UAAU;AACzI,sDAAsD,+BAA+B;AACrF,0BAA0B;AAC1B,gFAAgF,qBAAqB,QAAQ,QAAQ,GAAG,UAAU;AAClI,sDAAsD,wBAAwB;AAC9E,0BAA0B;AAC1B,gFAAgF,qBAAqB,QAAQ,QAAQ,GAAG,UAAU;AAClI,sDAAsD,+BAA+B;AACrF,0BAA0B;AAC1B,0DAA0D,QAAQ,GAAG,UAAU;AAC/E;AACA,sDAAsD,qBAAqB;AAC3E;AACA,sBAAsB;AACtB,8EAA8E,QAAQ,GAAG,UAAU;AACnG;AACA,kDAAkD,qBAAqB;AACvE;AACA,kBAAkB;AAClB,gGAAgG,QAAQ,GAAG,SAAS;AACpH,8CAA8C,sDAAsD,YAAY,GAAG;AACnH,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,yBAAyB,mEAAgB,+BAA+B,mEAAgB;AACxF,kFAAkF,KAAK;AACvF;;AAEA;AACA,gBAAgB,mEAAgB,sBAAsB,mEAAgB,eAAe,mEAAgB;AACrG,gBAAgB,mEAAgB,iBAAiB,mEAAgB,oBAAoB,mEAAgB;AACrG,gBAAgB,mEAAgB,sBAAsB,mEAAgB,mBAAmB,mEAAgB;AACzG;;AAEA;AACA,6BAA6B,mEAAgB,+BAA+B,mEAAgB;AAC5F,qEAAqE,KAAK;AAC1E;AACA;AACA,0BAA0B,oEAAe,eAAe,eAAe;AACvE,kBAAkB;AAClB,yEAAyE,KAAK;AAC9E;AACA,cAAc;AACd,6BAA6B,0EAAuB;AACpD,0EAA0E,KAAK;AAC/E;AACA;;AAEA,yBAAyB,mEAAgB;AACzC;AACA;AACA;AACA;AACA,yBAAyB,mEAAgB;AACzC,6DAA6D;AAC7D;AACA;AACA,yBAAyB,mEAAgB;AACzC;AACA,0DAA0D;AAC1D;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,cAAc,SAAS,oBAAoB,UAAU,kBAAkB;AAC7H;AACA,YAAY,oEAAe,eAAe,MAAM,mEAAgB,+BAA+B;AAC/F;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA,QAAQ,oEAAe,eAAe,MAAM,mEAAgB,mEAAmE,cAAc,GAAG;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA8E,QAAQ;AACtF,wDAAwD,4BAA4B;AACpF,sDAAsD,QAAQ;;AAE9D;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA,yEAAyE,QAAQ,IAAI,iBAAiB,EAAE,oBAAoB;AAC5H,sDAAsD,gBAAgB,KAAK,oBAAoB;AAC/F;AACA;AACA,uEAAuE,QAAQ;AAC/E,MAAM;AACN,6DAA6D,QAAQ;AACrE,+BAA+B,6CAA6C,SAAS,UAAU,cAAc,GAAG;AAChH;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB,mBAAmB,QAAQ;;AAEzF;AACA,0GAA0G,QAAQ;AAClH,+BAA+B,0BAA0B,sEAAsE;AAC/H;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA,UAAU;AACV,4DAA4D,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB,IAAI,KAAK;AAC3F,cAAc;AACd,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,oEAAe,eAAe,MAAM,gEAAa,2BAA2B;AACjH;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,mCAAmC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;;AAEA;AACA,wFAAwF,sEAAsE;AAC9J,sCAAsC,oEAAe;AACrD,sBAAsB,gEAAa;AACnC,2BAA2B;AAC3B,aAAa;AACb;;AAEA,uCAAuC,oEAAe;AACtD,oBAAoB,gEAAa;AACjC,yBAAyB;AACzB,aAAa;;AAEb;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,gFAAgF,QAAQ,GAAG,iBAAiB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAe;AAC/B,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0BAA0B;AAC1B;;AAEA;AACA,wCAAwC,QAAQ,GAAG,kBAAkB;AACrE;AACA,0DAA0D,YAAY;AACtE;;AAEA;AACA;AACA,4DAA4D,QAAQ,GAAG,iBAAiB,IAAI,yBAAyB,EAAE,4BAA4B;AACnJ,gBAAgB,oEAAe;AAC/B,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ,GAAG,iBAAiB;AAChE;AACA,4CAA4C;AAC5C;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,kBAAkB,QAAQ,WAAW;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAe;AACvC,kCAAkC,+DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB;AAChF;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2CAA2C,gBAAgB,YAAY,MAAM,iBAAiB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAe;AACnC,8BAA8B,+DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG,oBAAoB,oEAAe;AACnC,8BAA8B,+DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAe;AACzD,0BAA0B,gEAAa;AACvC,+BAA+B;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wGAAwG,QAAQ,GAAG,kBAAkB;AACrI,kBAAkB;AAClB;AACA;AACA,oBAAoB,oEAAe;AACnC,8BAA8B,+DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,gEAAgE,mBAAmB,KAAK,iBAAiB;AACzG;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd,wEAAwE,QAAQ,GAAG,kBAAkB;AACrG,gBAAgB,oEAAe;AAC/B,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,YAAY,oEAAe;AAC3B,sBAAsB,+DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,wCAAwC,iBAAiB;AACzD;;AAEA,UAAU;AACV;AACA;AACA,YAAY,oEAAe;AAC3B,sBAAsB,+DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,mDAAmD,qBAAqB,mBAAmB,QAAQ,2BAA2B,iCAAiC;AAC/J;AACA,+BAA+B,sEAAsE,qBAAqB,aAAa,SAAS,2BAA2B;AAC3K,MAAM;AACN,+BAA+B,kGAAkG,QAAQ,QAAQ,iCAAiC,KAAK,oBAAoB,4BAA4B;AACvO;;AAEA;AACA,IAAI,oEAAe;AACnB,cAAc,+DAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB,aAAa,SAAS,kDAAkD,uBAAuB;AAC3K;AACA,KAAK;AACL;;AAEA,oEAAe;AACf;AACA,sBAAsB,gEAAa;AACnC;AACA;AACA,sBAAsB,+DAAY;AAClC;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,sBAAsB;AACtB;;AAEA,mEAAmE,aAAa;AAChF,YAAY,6BAA6B;AACzC;;AAEA,0CAA0C,0EAAuB;AACjE,6DAA6D,YAAY;AACzE,uBAAuB,2FAA2F;AAClH;AACA;;AAEA;AACA,aAAa,0EAAuB;AACpC,4CAA4C,0EAAuB,wBAAwB,aAAa,iBAAiB;AACzH;AACA,yCAAyC,0EAAuB,wBAAwB;AACxF,+BAA+B,8DAA8D;AAC7F;AACA;AACA;AACA,yBAAyB;;AAEzB,aAAa,0EAAuB;AACpC,4CAA4C,0EAAuB,OAAO,qCAAqC,iBAAiB;AAChI;AACA,yDAAyD,0EAAuB,MAAM;AACtF,gCAAgC,uEAAuE;AACvG;AACA;AACA;AACA,yCAAyC,0EAAuB,OAAO;AACvE,+BAA+B,4EAA4E;AAC3G;AACA;;AAEA,6BAA6B,oEAAe;AAC5C,iHAAiH,gBAAgB,eAAe,SAAS;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,kDAAkD,iBAAiB,oCAAoC;AACtI,cAAc;AACd;AACA,+BAA+B,+DAA+D,cAAc,GAAG;AAC/G;AACA;;AAEA,aAAa,0EAAuB;AACpC,aAAa,0EAAuB;AACpC,aAAa,0EAAuB;AACpC,sDAAsD,0EAAuB;AAC7E,wGAAwG,YAAY;AACpH,gCAAgC,2DAA2D,YAAY,kCAAkC;AACzI;AACA;AACA;;AAEA;AACA,aAAa,0EAAuB;AACpC;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA,kCAAkC,0EAAuB;AACzD;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA;AACA,6CAA6C,oEAAe;AAC5D,8BAA8B,0EAAuB;AACrD,mCAAmC;AACnC,qBAAqB;AACrB;AACA;AACA,kCAAkC,0EAAuB;AACzD;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA8B,0EAAuB;AACrD;AACA,mCAAmC;AACnC,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA,8BAA8B,0EAAuB;AACrD;AACA,mCAAmC;AACnC,qBAAqB;AACrB;AACA,aAAa;AACb;;AAEA;AACA,8EAA8E,YAAY;AAC1F,2BAA2B,iDAAiD,aAAa,uBAAuB;AAChH;AACA;AACA,CAAC;;AAED;AACA,wB","sources":["webpack://tabagent/./node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://tabagent/./src/events/eventNames.js","webpack://tabagent/webpack/bootstrap","webpack://tabagent/webpack/runtime/compat get default export","webpack://tabagent/webpack/runtime/define property getters","webpack://tabagent/webpack/runtime/hasOwnProperty shorthand","webpack://tabagent/webpack/runtime/make namespace object","webpack://tabagent/./src/modelLoaderWorkerOffscreen.js"],"sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n  /* vim: set sts=2 sw=2 et tw=80: */\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n  if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\n    // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n          return super.get(key);\n        }\n      }\n\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args);\n\n                // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n        });\n      };\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n            if (!(prop in target)) {\n              return undefined;\n            }\n            let value = target[prop];\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                  return target[prop];\n                },\n                set(value) {\n                  target[prop] = value;\n                }\n              });\n              return value;\n            }\n            cache[prop] = value;\n            return value;\n          },\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n            return true;\n          },\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n        };\n\n        // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n      });\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {} /* wrappers */, {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          const isResultThenable = result !== true && isThenable(result);\n\n          // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          }\n\n          // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          };\n\n          // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          }\n\n          // Let Chrome know that the listener is replying.\n          return true;\n        };\n      });\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    };\n\n    // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","export const DirectDBNames = Object.freeze({\n  ADD_MODEL_ASSET: 'AddModelAsset',\n  GET_MODEL_ASSET: 'GetModelAsset',\n  COUNT_MODEL_ASSET_CHUNKS: 'CountModelAssetChunks',\n  VERIFY_MODEL_ASSET: 'VerifyModelAsset',\n});\n\nexport const DBEventNames = Object.freeze({\n  DB_GET_SESSION_REQUEST: 'DbGetSessionRequest',\n  DB_GET_SESSION_RESPONSE: 'DbGetSessionResponse',\n  DB_ADD_MESSAGE_REQUEST: 'DbAddMessageRequest',\n  DB_ADD_MESSAGE_RESPONSE: 'DbAddMessageResponse',\n  DB_UPDATE_MESSAGE_REQUEST: 'DbUpdateMessageRequest',\n  DB_UPDATE_MESSAGE_RESPONSE: 'DbUpdateMessageResponse',\n  DB_UPDATE_STATUS_REQUEST: 'DbUpdateStatusRequest',\n  DB_UPDATE_STATUS_RESPONSE: 'DbUpdateStatusResponse',\n  DB_DELETE_MESSAGE_REQUEST: 'DbDeleteMessageRequest',\n  DB_DELETE_MESSAGE_RESPONSE: 'DbDeleteMessageResponse',\n  DB_TOGGLE_STAR_REQUEST: 'DbToggleStarRequest',\n  DB_TOGGLE_STAR_RESPONSE: 'DbToggleStarResponse',\n  DB_CREATE_SESSION_REQUEST: 'DbCreateSessionRequest',\n  DB_CREATE_SESSION_RESPONSE: 'DbCreateSessionResponse',\n  DB_DELETE_SESSION_REQUEST: 'DbDeleteSessionRequest',\n  DB_DELETE_SESSION_RESPONSE: 'DbDeleteSessionResponse',\n  DB_RENAME_SESSION_REQUEST: 'DbRenameSessionRequest',\n  DB_RENAME_SESSION_RESPONSE: 'DbRenameSessionResponse',\n  DB_GET_ALL_SESSIONS_REQUEST: 'DbGetAllSessionsRequest',\n  DB_GET_ALL_SESSIONS_RESPONSE: 'DbGetAllSessionsResponse',\n  DB_GET_STARRED_SESSIONS_REQUEST: 'DbGetStarredSessionsRequest',\n  DB_GET_STARRED_SESSIONS_RESPONSE: 'DbGetStarredSessionsResponse',\n  DB_MESSAGES_UPDATED_NOTIFICATION: 'DbMessagesUpdatedNotification',\n  DB_STATUS_UPDATED_NOTIFICATION: 'DbStatusUpdatedNotification',\n  DB_SESSION_UPDATED_NOTIFICATION: 'DbSessionUpdatedNotification',\n  DB_INITIALIZE_REQUEST: 'DbInitializeRequest',\n  DB_INITIALIZATION_COMPLETE_NOTIFICATION: 'DbInitializationCompleteNotification',\n  DB_GET_LOGS_REQUEST: 'DbGetLogsRequest',\n  DB_GET_LOGS_RESPONSE: 'DbGetLogsResponse',\n  DB_GET_UNIQUE_LOG_VALUES_REQUEST: 'DbGetUniqueLogValuesRequest',\n  DB_GET_UNIQUE_LOG_VALUES_RESPONSE: 'DbGetUniqueLogValuesResponse',\n  DB_CLEAR_LOGS_REQUEST: 'DbClearLogsRequest',\n  DB_CLEAR_LOGS_RESPONSE: 'DbClearLogsResponse',\n  DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_REQUEST: 'DbGetCurrentAndLastLogSessionIdsRequest',\n  DB_GET_CURRENT_AND_LAST_LOG_SESSION_IDS_RESPONSE: 'DbGetCurrentAndLastLogSessionIdsResponse',\n  DB_ADD_LOG_REQUEST: 'DbAddLogRequest',\n  DB_ADD_LOG_RESPONSE: 'DbAddLogResponse',\n  DB_GET_READY_STATE_REQUEST: 'DbGetReadyStateRequest',\n  DB_GET_READY_STATE_RESPONSE: 'DbGetReadyStateResponse',\n  DB_RESET_DATABASE_REQUEST: 'DbResetDatabaseRequest',\n  DB_RESET_DATABASE_RESPONSE: 'DbResetDatabaseResponse',\n\n});\n\nexport const UIEventNames = Object.freeze({\n  QUERY_SUBMITTED: 'ui:querySubmitted',\n  BACKGROUND_RESPONSE_RECEIVED: 'background:responseReceived',\n  BACKGROUND_ERROR_RECEIVED: 'background:errorReceived',\n  BACKGROUND_SCRAPE_STAGE_RESULT: 'background:scrapeStageResult',\n  BACKGROUND_SCRAPE_RESULT_RECEIVED: 'background:scrapeResultReceived',\n  BACKGROUND_LOADING_STATUS_UPDATE: 'ui:loadingStatusUpdate',\n  REQUEST_MODEL_LOAD: 'ui:requestModelLoad',\n  WORKER_READY: 'worker:ready',\n  WORKER_ERROR: 'worker:error',\n  NAVIGATION_PAGE_CHANGED: 'navigation:pageChanged',\n  SCRAPE_PAGE: 'SCRAPE_PAGE',\n  SCRAPE_ACTIVE_TAB: 'SCRAPE_ACTIVE_TAB',\n  DYNAMIC_SCRIPT_MESSAGE_TYPE: 'offscreenIframeResult',\n  MODEL_DOWNLOAD_PROGRESS: 'ui:modelDownloadProgress',\n  // Add more as needed\n});\n\nexport const WorkerEventNames = Object.freeze({\n  WORKER_SCRIPT_READY: 'workerScriptReady',\n  WORKER_READY: 'workerReady',\n  LOADING_STATUS: 'loadingStatus',\n  GENERATION_STATUS: 'generationStatus',\n  GENERATION_UPDATE: 'generationUpdate',\n  GENERATION_COMPLETE: 'generationComplete',\n  GENERATION_ERROR: 'generationError',\n  RESET_COMPLETE: 'resetComplete',\n  ERROR: 'error',\n  REQUEST_ASSET_FROM_DB_INTERNAL_TYPE : 'REQUEST_ASSET_FROM_DB_INTERNAL_TYPE',\n});\n\nexport const ModelWorkerStates = Object.freeze({\n  UNINITIALIZED: 'uninitialized',\n  CREATING_WORKER: 'creating_worker',\n  WORKER_SCRIPT_READY: 'worker_script_ready',\n  LOADING_MODEL: 'loading_model',\n  MODEL_READY: 'model_ready',\n  GENERATING: 'generating',\n  ERROR: 'error',\n  IDLE: 'idle',\n});\n\nexport const RuntimeMessageTypes = Object.freeze({\n  LOAD_MODEL: 'loadModel',\n  SEND_CHAT_MESSAGE: 'sendChatMessage',\n  INTERRUPT_GENERATION: 'interruptGeneration',\n  RESET_WORKER: 'resetWorker',\n  GET_MODEL_WORKER_STATE: 'getModelWorkerState',\n  SCRAPE_REQUEST: 'scrapeRequest',\n  GET_DRIVE_FILE_LIST: 'getDriveFileList',\n  GET_LOG_SESSIONS: 'getLogSessions',\n  GET_LOG_ENTRIES: 'getLogEntries',\n  DETACH_SIDE_PANEL: 'detachSidePanel',\n  GET_DETACHED_STATE: 'getDetachedState',\n  GET_DB_READY_STATE: 'getDbReadyState',\n});\n\nexport const SiteMapperMessageTypes = Object.freeze({\n  OPEN_TAB: 'openTab',\n  MAPPED: 'mapped',\n});\n\nexport const ModelLoaderMessageTypes = Object.freeze({\n  INIT: 'init',\n  GENERATE: 'generate',\n  INTERRUPT: 'interrupt',\n  RESET: 'reset',\n  DOWNLOAD_MODEL_ASSETS: 'DOWNLOAD_MODEL_ASSETS',\n  LIST_MODEL_FILES: 'LIST_MODEL_FILES',\n  LIST_MODEL_FILES_RESULT: 'LIST_MODEL_FILES_RESULT',\n});\n\nexport const InternalEventBusMessageTypes = Object.freeze({\n  BACKGROUND_EVENT_BROADCAST: 'InternalEventBus:BackgroundEventBroadcast'\n});\n\nexport const RawDirectMessageTypes = Object.freeze({\n  WORKER_GENERIC_RESPONSE: 'response',\n  WORKER_GENERIC_ERROR: 'error',\n  WORKER_SCRAPE_STAGE_RESULT: 'STAGE_SCRAPE_RESULT',\n  WORKER_DIRECT_SCRAPE_RESULT: 'DIRECT_SCRAPE_RESULT',\n  WORKER_UI_LOADING_STATUS_UPDATE: 'uiLoadingStatusUpdate' // This one is used as a direct message type\n});\n\nexport const Contexts = Object.freeze({\n  BACKGROUND: 'Background',\n  MAIN_UI: 'MainUI',\n  POPUP: 'Popup',\n  OTHERS: 'Others',\n  UNKNOWN: 'Unknown',\n});\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// modelLoaderWorkerOffscreen.js\nimport { WorkerEventNames, ModelLoaderMessageTypes, UIEventNames, DirectDBNames, DBEventNames } from './events/eventNames.js';\nimport browser from 'webextension-polyfill';\n\nlet modelWorker = null;\nlet workerScriptReady = false;\nlet modelWorkerInitializationInProgress = false;\n\nconst allowedMessageTypesFromBackground = new Set(Object.values(ModelLoaderMessageTypes));\nconst prefix = '[Offscreen]';\n\n// Helper: Log memory usage (Chrome only)\nfunction logMemory(label) {\n    if (performance && performance.memory) {\n        const usedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);\n        const totalMB = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);\n        console.log(`${prefix} [Memory][${label}] Used: ${usedMB} MB / Total: ${totalMB} MB`);\n    } else {\n        console.log(`${prefix} [Memory][${label}] performance.memory not available`);\n    }\n}\n\nfunction initializeModelWorker() {\n    if (modelWorker || modelWorkerInitializationInProgress) {\n        if (modelWorker) console.log(prefix, \" model worker instance already exists or is ready.\");\n        if (modelWorkerInitializationInProgress) console.log(prefix, \" model worker initialization is already in progress.\");\n        return modelWorker;\n    }\n\n    console.log(prefix, \"Creating  Model Worker (model-worker.js)...\");\n    modelWorkerInitializationInProgress = true;\n    workerScriptReady = false;\n\n    try {\n        modelWorker = new globalThis.Worker(browser.runtime.getURL('model-worker.js'), { type: 'module' });\n        console.log(prefix, \" Model Worker instance successfully created.\");\n\n        modelWorker.onmessage = async (event) => {\n            if (!event.data || !event.data.type) {\n                // Ignore empty/system messages\n                if (event.data && Object.keys(event.data).length === 0) return;\n                // Log at debug level for unexpected non-empty messages\n                console.debug(prefix, \"Received message from model worker without type or data (likely MessageChannel/system message):\", event.data, event);\n                return;\n            }\n            const { type, payload } = event.data;\n\n            // --- Handle LIST_MODEL_FILES requests from the model worker ---\n            if (type === ModelLoaderMessageTypes.LIST_MODEL_FILES) {\n                const { requestId, payload: reqPayload } = event.data;\n                console.log(prefix, '[Offscreen][modelWorker.onmessage] LIST_MODEL_FILES received from model worker:', reqPayload, 'requestId:', requestId);\n                try {\n                    const { modelId } = reqPayload || {};\n                    if (!modelId) {\n                        modelWorker.postMessage({\n                            type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                            requestId,\n                            payload: { success: false, error: 'No modelId provided' }\n                        });\n                        return;\n                    }\n                    const docsResult = await browser.runtime.sendMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES,\n                        payload: { modelId }\n                    });\n                    if (!docsResult.success) {\n                        modelWorker.postMessage({\n                            type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                            requestId,\n                            payload: { success: false, error: docsResult.error }\n                        });\n                        return;\n                    }\n                    const files = docsResult.files;\n                    modelWorker.postMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                        requestId,\n                        payload: { success: true, files }\n                    });\n                    console.log(prefix, '[Offscreen][modelWorker.onmessage] LIST_MODEL_FILES_RESULT sent to model worker:', files, 'requestId:', requestId);\n                } catch (err) {\n                    modelWorker.postMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                        requestId,\n                        payload: { success: false, error: err.message }\n                    });\n                    console.error(prefix, '[Offscreen][modelWorker.onmessage] Error handling LIST_MODEL_FILES:', err);\n                }\n                return; // Don't process further\n            }\n\n            // Relay pipeline loading progress to UI\n            if (type === WorkerEventNames.LOADING_STATUS) {\n                browser.runtime.sendMessage({\n                    type: UIEventNames.BACKGROUND_LOADING_STATUS_UPDATE,\n                    payload\n                });\n            }\n\n            if (type === WorkerEventNames.REQUEST_ASSET_FROM_DB_INTERNAL_TYPE) {\n                const { modelId, fileName } = payload;\n                const requestPort = event.ports && event.ports[0];\n\n                if (!requestPort) {\n                    console.error(prefix, `${WorkerEventNames.REQUEST_ASSET_FROM_DB_INTERNAL_TYPE}: No MessageChannel port received for asset request: ${modelId}/${fileName}.`);\n                    return;\n                }\n                console.log(prefix, `${WorkerEventNames.REQUEST_ASSET_FROM_DB_INTERNAL_TYPE} from model-worker for asset: ${modelId}/${fileName}`);\n\n                try {\n                    const dbQueryResults = await browser.runtime.sendMessage({ type: DirectDBNames.GET_MODEL_ASSET, payload: { modelId, fileName } });\n                    const dbQueryResult = dbQueryResults && dbQueryResults.length > 0 ? dbQueryResults[0] : null;\n\n                    if (dbQueryResult && dbQueryResult.success && dbQueryResult.data) {\n                        const assetData = dbQueryResult.data.data;\n                        if (typeof assetData === 'string') {\n                            const byteCharacters = atob(assetData);\n                            const byteNumbers = new Array(byteCharacters.length);\n                            for (let i = 0; i < byteCharacters.length; i++) {\n                                byteNumbers[i] = byteCharacters.charCodeAt(i);\n                            }\n                            const byteArray = new Uint8Array(byteNumbers);\n                            console.log(prefix, `Sending ArrayBuffer (length: ${byteArray.buffer.byteLength}) for ${modelId}/${fileName} back to model-worker.`);\n                            requestPort.postMessage({ arrayBuffer: byteArray.buffer }, [byteArray.buffer]);\n                        } else if (assetData instanceof ArrayBuffer) {\n                            console.log(prefix, `Sending ArrayBuffer (length: ${assetData.byteLength}) for ${modelId}/${fileName} back to model-worker (direct ArrayBuffer).`);\n                            requestPort.postMessage({ arrayBuffer: assetData }, [assetData]);\n                        } else if (ArrayBuffer.isView(assetData)) {\n                            console.log(prefix, `Sending ArrayBuffer (length: ${assetData.byteLength}) for ${modelId}/${fileName} back to model-worker (TypedArray).`);\n                            requestPort.postMessage({ arrayBuffer: assetData.buffer }, [assetData.buffer]);\n                        } else {\n                            const errorMessage = `Asset ${modelId}/${fileName} found in DB but data is not a string, ArrayBuffer, or TypedArray.`;\n                            console.error(prefix, errorMessage, \"Full DB result:\", dbQueryResult);\n                            requestPort.postMessage({ error: errorMessage });\n                        }\n                    } else {\n                        const errorMessage = dbQueryResult?.error || `Asset ${modelId}/${fileName} not found in DB or DB response was invalid.`;\n                        console.error(prefix, errorMessage, \"Full DB result:\", dbQueryResult);\n                        requestPort.postMessage({ error: errorMessage });\n                    }\n                } catch (err) {\n                    console.error(prefix, `Error during eventBus.publish for GET_MODEL_ASSET (${modelId}/${fileName}):`, err);\n                    requestPort.postMessage({ error: `EventBus publish error for GET_MODEL_ASSET: ${err.message}` });\n                } finally {\n                    requestPort.close();\n                }\n                return;\n            }\n\n            if (type !== WorkerEventNames.GENERATION_UPDATE && type !== WorkerEventNames.LOADING_STATUS) {\n                console.log(prefix, `Received message from  Model Worker: Type: ${type}, Payload:`, payload);\n            }\n\n            const typesToForwardToBackground = [\n                WorkerEventNames.WORKER_SCRIPT_READY, WorkerEventNames.WORKER_READY, WorkerEventNames.ERROR,\n                WorkerEventNames.LOADING_STATUS, WorkerEventNames.GENERATION_STATUS, WorkerEventNames.GENERATION_UPDATE,\n                WorkerEventNames.GENERATION_COMPLETE, WorkerEventNames.GENERATION_ERROR, WorkerEventNames.RESET_COMPLETE\n            ];\n\n            if (typesToForwardToBackground.includes(type)) {\n                if (type !== WorkerEventNames.GENERATION_UPDATE && type !== WorkerEventNames.LOADING_STATUS) {\n                    console.log(prefix, `Forwarding message type \\`${type}\\` to background.`);\n                }\n                try {\n                    await browser.runtime.sendMessage({ type, payload });\n                } catch (error) {\n                    console.error(prefix, `Error sending message type '${type}' to background:`, error);\n                }\n            } else {\n                if (type !== ModelLoaderMessageTypes.LIST_MODEL_FILES) {\n                    console.warn(prefix, `Not forwarding message type \\`${type}\\` from  worker. (Consider adding to eventNames.js and forward list)`);\n                }\n            }\n\n            if (type === WorkerEventNames.WORKER_SCRIPT_READY) {\n                workerScriptReady = true;\n                modelWorkerInitializationInProgress = false;\n                console.log(prefix, \" Model Worker script (model-worker.js) has signaled readiness.\");\n            }\n            if (type === WorkerEventNames.WORKER_READY) {\n                modelWorkerInitializationInProgress = false; // Model fully loaded and ready\n                console.log(prefix, \" Model Worker has signaled model readiness for:\", payload?.model);\n            }\n            if (type === WorkerEventNames.ERROR) {\n                console.error(prefix, \"Error reported from  model worker:\", payload);\n                if(modelWorkerInitializationInProgress) { // If error during init\n                    modelWorkerInitializationInProgress = false;\n                    workerScriptReady = false; // It didn't fully initialize\n                }\n            }\n        };\n\n        modelWorker.onerror = (errorEvent) => {\n            console.error(prefix, \" Model Worker 'onerror' event triggered:\", errorEvent);\n            const errorMessage = errorEvent.message || 'Unknown error in  model worker';\n            const errorDetails = `Error in  worker: ${errorMessage} (File: ${errorEvent.filename}, Line: ${errorEvent.lineno})`;\n            console.error(prefix, \" Worker onerror details:\", errorDetails);\n            browser.runtime.sendMessage({ type: WorkerEventNames.ERROR, payload: errorDetails })\n                .catch(err => console.error(prefix, \"Error sending  worker's 'onerror' event to background:\", err));\n            \n            modelWorker.terminate(); // Terminate the errored worker\n            modelWorker = null;\n            workerScriptReady = false;\n            modelWorkerInitializationInProgress = false;\n        };\n\n    } catch (error) {\n        console.error(prefix, \"Failed to create  Model Worker instance (new Worker()):\", error);\n        browser.runtime.sendMessage({ type: WorkerEventNames.ERROR, payload: `Offscreen failed to instantiate  model worker: ${error.message}` })\n            .catch(err => console.error(prefix, \"Error sending model worker instantiation error to background:\", err));\n        modelWorker = null;\n        workerScriptReady = false;\n        modelWorkerInitializationInProgress = false;\n    }\n    return modelWorker;\n}\n\nasync function downloadModelAssetsAndReport(modelId, sendResponseCallback) {\n    console.log(prefix, `Starting downloadModelAssetsAndReport for modelId: ${modelId}`);\n    const apiUrl = `https://huggingface.co/api/models/${encodeURIComponent(modelId)}`;\n    const baseDownloadUrl = `https://huggingface.co/${modelId}/resolve/main/`;\n\n    let metadata;\n    try {\n        console.log(prefix, `Fetching model metadata from: ${apiUrl}`);\n        const response = await fetch(apiUrl);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(prefix, `Failed to fetch model file list for ${modelId}: ${response.status} ${response.statusText}`, errorText);\n            throw new Error(`Metadata fetch failed (${response.status}): ${response.statusText}`);\n        }\n        metadata = await response.json();\n        console.log(prefix, `Model metadata fetched successfully for ${modelId}.`);\n    } catch (error) {\n        console.error(prefix, `Error fetching metadata for ${modelId}:`, error);\n        sendResponseCallback({ success: false, error: `Metadata fetch for ${modelId} failed: ${error.message}` });\n        return;\n    }\n\n    const hfFileEntries = metadata.siblings || [];\n    // Only include .onnx, .json, .txt files\n    const neededFileEntries = hfFileEntries.filter(f => f.rfilename.endsWith('.onnx') || f.rfilename.endsWith('.json') || f.rfilename.endsWith('.txt'));\n    const neededFileNames = neededFileEntries.map(f => f.rfilename);\n    console.log(prefix, `Identified ${neededFileNames.length} needed files for ${modelId}:`, neededFileNames);\n\n    if (neededFileNames.length === 0) {\n        console.warn(prefix, `No files matching .onnx, .json, or .txt found in HuggingFace metadata for ${modelId}.`);\n        sendResponseCallback({ success: true, fileMap: {}, message: \"No .onnx, .json, or .txt files found in model metadata.\" });\n        return;\n    }\n\n    // --- Ensure all needed files have a valid size ---\n    async function getFileSizeWithHEAD(url) {\n        try {\n            const headResp = await fetch(url, { method: 'HEAD' });\n            if (headResp.ok) {\n                const len = headResp.headers.get('Content-Length');\n                return len ? parseInt(len, 10) : null;\n            }\n        } catch (e) {\n            console.warn(prefix, `HEAD request failed for ${url}:`, e);\n        }\n        return null;\n    }\n    for (const entry of neededFileEntries) {\n        if (typeof entry.size !== 'number' || !isFinite(entry.size) || entry.size <= 0) {\n            const url = baseDownloadUrl + entry.rfilename;\n            const size = await getFileSizeWithHEAD(url);\n            if (size && isFinite(size) && size > 0) {\n                entry.size = size;\n                console.log(prefix, `Got file size via HEAD for ${entry.rfilename}: ${size}`);\n            } else {\n                console.error(prefix, `Skipping file ${entry.rfilename}: missing/invalid size (HEAD failed or Content-Length missing)`);\n                entry._skip = true;\n            }\n        }\n    }\n    // Build download plan: list of files, sizes, and chunk counts (skip files with _skip)\n    const CHUNK_SIZE = 1024 * 1024; // 1MB\n    const downloadPlan = neededFileEntries.filter(e => !e._skip).map((entry, idx) => ({\n        fileName: entry.rfilename,\n        fileSize: entry.size,\n        totalChunks: Math.ceil(entry.size / CHUNK_SIZE),\n        fileIdx: idx + 1,\n        fileType: entry.rfilename.split('.').pop(),\n    }));\n    const totalBytesToDownload = downloadPlan.reduce((sum, f) => sum + f.fileSize, 0);\n    const totalChunksToDownload = downloadPlan.reduce((sum, f) => sum + f.totalChunks, 0);\n\n    // Helper: Retry chunk write with exponential backoff\n    async function tryStoreChunk(payload, maxRetries = 3) {\n        let attempt = 0;\n        while (attempt < maxRetries) {\n            const addResults = await browser.runtime.sendMessage({ type: DirectDBNames.ADD_MODEL_ASSET, payload });\n            const addResult = addResults && addResults.success !== undefined ? addResults : (addResults && addResults[0] ? addResults[0] : null);\n            if (addResult && addResult.success) return true;\n            attempt++;\n            await new Promise(res => setTimeout(res, 200 * Math.pow(2, attempt))); // Exponential backoff\n        }\n        return false;\n    }\n\n    let filesSuccessfullyProcessedCount = 0;\n    let totalBytesDownloaded = 0;\n    let totalChunksDownloaded = 0;\n    const totalFilesToAttempt = downloadPlan.length;\n    const successfullyProcessedFileMap = {};\n    const failedFiles = [];\n\n    for (let filePlanIdx = 0; filePlanIdx < downloadPlan.length; filePlanIdx++) {\n        const plan = downloadPlan[filePlanIdx];\n        const relativeFileName = plan.fileName;\n        const fileTotalBytes = plan.fileSize;\n        const fileTotalChunks = plan.totalChunks;\n        const fileIdx = plan.fileIdx;\n        let currentFileSource = \"DB_Check\";\n        let fileBytesDownloaded = 0;\n        let fileChunksDownloaded = 0;\n        let fileFailed = false;\n        let lastLoggedPercent = -1;\n        try {\n            // Log memory before big file\n            if (fileTotalBytes > 10 * 1024 * 1024) {\n                logMemory(` Before file ${relativeFileName}`);\n            }\n\n            // --- CHUNK COUNT CHECK BEFORE DOWNLOAD ---\n            console.log('[Offscreen][DB ChunkCount Check] Checking chunk count for:', { modelId, fileName: relativeFileName, expectedChunks: fileTotalChunks });\n            const countResult = await browser.runtime.sendMessage({\n                type: DirectDBNames.COUNT_MODEL_ASSET_CHUNKS,\n                payload: { modelId, fileName: relativeFileName }\n            });\n            console.log('[Offscreen][DB ChunkCount Check] Result:', countResult);\n\n            const verifyResult = await browser.runtime.sendMessage({\n              type: DirectDBNames.VERIFY_MODEL_ASSET,\n              payload: { modelId, fileName: relativeFileName, expectedSize: fileTotalBytes }\n            });\n\n            if (!verifyResult.success) {\n                console.error('[VerifyDownload] Failed to verify file in DB:', modelId, relativeFileName, verifyResult.error);\n                return\n            }\n\n\n\n            if (countResult && countResult.success && countResult.count === fileTotalChunks) {\n                successfullyProcessedFileMap[relativeFileName] = true;\n                filesSuccessfullyProcessedCount++;\n                currentFileSource = \"DB_Found_Chunks\";\n                console.log(prefix, `File already in DB (all chunks present): ${modelId}/${relativeFileName}`);\n                if (fileTotalBytes) {\n                    totalBytesDownloaded += fileTotalBytes;\n                }\n                totalChunksDownloaded += fileTotalChunks;\n                fileBytesDownloaded = fileTotalBytes;\n                fileChunksDownloaded = fileTotalChunks;\n                // Report progress for already-in-DB file\n                browser.runtime.sendMessage({\n                    type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                    payload: {\n                        modelId,\n                        file: relativeFileName,\n                        fileIdx,\n                        totalFiles: totalFilesToAttempt,\n                        chunkIndex: fileTotalChunks,\n                        totalChunks: fileTotalChunks,\n                        fileBytesDownloaded,\n                        fileTotalBytes,\n                        totalBytesDownloaded,\n                        totalBytesToDownload,\n                        totalChunksDownloaded,\n                        totalChunksToDownload,\n                        percent: (totalBytesDownloaded / totalBytesToDownload) * 100,\n                        filePercent: (fileBytesDownloaded / fileTotalBytes) * 100,\n                        currentFileSource\n                    }\n                }).catch(e => console.error(prefix, \"Error sending download progress (already in DB):\", e));\n                continue; // Skip to next file\n            }\n\n            currentFileSource = \"Download_Attempt\";\n            console.log(prefix, `File ${modelId}/${relativeFileName} not in DB or DB query failed. Attempting download. DB Query Result:`, countResult);\n            const downloadUrl = baseDownloadUrl + relativeFileName;\n            console.log(prefix, `Downloading file from: ${downloadUrl}`);\n            const downloadResponse = await fetch(downloadUrl);\n\n            if (!downloadResponse.ok) {\n                const errorText = await downloadResponse.text();\n                console.error(prefix, `Failed to download ${modelId}/${relativeFileName}: ${downloadResponse.status} ${downloadResponse.statusText}`, errorText);\n                browser.runtime.sendMessage({\n                    type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                    payload: {\n                        modelId,\n                        file: relativeFileName,\n                        error: `Download failed (${downloadResponse.status})`,\n                        downloaded: filesSuccessfullyProcessedCount,\n                        total: totalFilesToAttempt,\n                        currentFileSource,\n                        fileIdx,\n                        totalFiles: totalFilesToAttempt\n                    }\n                }).catch(e => console.error(prefix, \"Error sending download progress (failure):\", e));\n                continue;\n            }\n            currentFileSource = \"Download_Success_Store_Attempt\";\n\n            // --- Streams API chunked download and storage with 1MB buffering ---\n            const reader = downloadResponse.body.getReader();\n            let chunkIndex = 0;\n            const chunkGroupId = `${modelId}/${relativeFileName}`;\n            let allChunksSuccess = true;\n            let buffer = new Uint8Array(0); // Buffer for 1MB chunks\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n                let tmp = new Uint8Array(buffer.length + value.length);\n                tmp.set(buffer, 0);\n                tmp.set(value, buffer.length);\n                buffer = tmp;\n                while (buffer.length >= CHUNK_SIZE) {\n                    const chunk = buffer.slice(0, CHUNK_SIZE);\n                    buffer = buffer.slice(CHUNK_SIZE);\n                    // Defensive: Check totalChunks\n                    if (!fileTotalChunks || fileTotalChunks === null || fileTotalChunks === undefined) {\n                        console.warn(`[Offscreen][Defensive] totalChunks is missing or invalid for ${relativeFileName} chunk ${chunkIndex}`);\n                    }\n                    // --- Robust: Retry chunk write ---\n                    const payload = {\n                        modelId,\n                        fileName: relativeFileName,\n                        fileType: plan.fileType,\n                        data: Array.from(chunk),\n                        chunkIndex,\n                        totalChunks: fileTotalChunks,\n                        chunkGroupId,\n                        binarySize: chunk.byteLength,\n                        totalFileSize: fileTotalBytes\n                    };\n                    const success = await tryStoreChunk(payload);\n                    if (!success) {\n                        allChunksSuccess = false;\n                        fileFailed = true;\n                        failedFiles.push(relativeFileName);\n                        browser.runtime.sendMessage({\n                            type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                            payload: {\n                                modelId,\n                                file: relativeFileName,\n                                fileIdx,\n                                totalFiles: totalFilesToAttempt,\n                                chunkIndex,\n                                totalChunks: fileTotalChunks,\n                                error: `Failed to store chunk ${chunkIndex + 1} after retries`,\n                                currentFileSource,\n                                failType: 'chunk_write',\n                            }\n                        }).catch(e => console.error(prefix, \"Error sending download progress (chunk fail):\", e));\n                        break;\n                    }\n                    chunkIndex++;\n                    fileChunksDownloaded++;\n                    totalChunksDownloaded++;\n                    fileBytesDownloaded += chunk.byteLength;\n                    totalBytesDownloaded += chunk.byteLength;\n                    // --- Throttle progress logs/messages: only first and last chunk ---\n                    if (chunkIndex === 1 || chunkIndex === fileTotalChunks) {\n                        console.log(`[Offscreen] ${chunkIndex === 1 ? 'Started' : 'Finished'} storing chunk ${chunkIndex} for ${relativeFileName}`);\n                    }\n                }\n            }\n            // Send any remaining data in buffer\n            if (allChunksSuccess && buffer.length > 0) {\n                const chunk = buffer;\n                buffer = new Uint8Array(0); // Release memory\n                const payload = {\n                    modelId,\n                    fileName: relativeFileName,\n                    fileType: plan.fileType,\n                    data: Array.from(chunk),\n                    chunkIndex,\n                    totalChunks: fileTotalChunks,\n                    chunkGroupId,\n                    binarySize: chunk.byteLength,\n                    totalFileSize: fileTotalBytes\n                };\n                const success = await tryStoreChunk(payload);\n                if (!success) {\n                    allChunksSuccess = false;\n                    fileFailed = true;\n                    failedFiles.push(relativeFileName);\n                    browser.runtime.sendMessage({\n                        type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                        payload: {\n                            modelId,\n                            file: relativeFileName,\n                            fileIdx,\n                            totalFiles: totalFilesToAttempt,\n                            chunkIndex,\n                            totalChunks: fileTotalChunks,\n                            error: `Failed to store final chunk ${chunkIndex + 1} after retries`,\n                            currentFileSource,\n                            failType: 'chunk_write',\n                        }\n                    }).catch(e => console.error(prefix, \"Error sending download progress (final chunk fail):\", e));\n                } else {\n                    chunkIndex++;\n                    fileChunksDownloaded++;\n                    totalChunksDownloaded++;\n                    fileBytesDownloaded += chunk.byteLength;\n                    totalBytesDownloaded += chunk.byteLength;\n                    // Always log/send for last chunk\n                    console.log(`[Offscreen] Finished storing all chunks for ${relativeFileName}`);\n                    browser.runtime.sendMessage({\n                        type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                        payload: {\n                            modelId,\n                            file: relativeFileName,\n                            fileIdx,\n                            totalFiles: totalFilesToAttempt,\n                            chunkIndex,\n                            totalChunks: fileTotalChunks,\n                            fileBytesDownloaded,\n                            fileTotalBytes,\n                            totalBytesDownloaded,\n                            totalBytesToDownload,\n                            totalChunksDownloaded,\n                            totalChunksToDownload,\n                            percent: (totalBytesDownloaded / totalBytesToDownload) * 100,\n                            filePercent: 100,\n                            currentFileSource\n                        }\n                    }).catch(e => console.error(prefix, \"Error sending download progress (final chunk):\", e));\n                }\n            }\n            // --- Efficient: Post-write verification only after last chunk ---\n            if (allChunksSuccess && !fileFailed) {\n                // Only verify after last chunk\n                const countResult = await browser.runtime.sendMessage({\n                    type: DirectDBNames.COUNT_MODEL_ASSET_CHUNKS,\n                    payload: { modelId, fileName: relativeFileName }\n                });\n                if (countResult.success && countResult.count === fileTotalChunks) {\n                    successfullyProcessedFileMap[relativeFileName] = true;\n                    filesSuccessfullyProcessedCount++;\n                    currentFileSource = \"DB_Stored_After_Download\";\n                    console.log(prefix, `Successfully downloaded, stored, and verified all chunks for ${modelId}/${relativeFileName} in DB.`);\n                } else {\n                    fileFailed = true;\n                    failedFiles.push(relativeFileName);\n                    browser.runtime.sendMessage({\n                        type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                        payload: {\n                            modelId,\n                            file: relativeFileName,\n                            fileIdx,\n                            totalFiles: totalFilesToAttempt,\n                            error: `Verification failed: Only ${countResult.count} of ${fileTotalChunks} chunks present in DB after upload`,\n                            failType: 'verification',\n                            currentFileSource\n                        }\n                    }).catch(e => console.error(prefix, \"Error sending download progress (verification fail):\", e));\n                    continue;\n                }\n            } else if (fileFailed || !allChunksSuccess) {\n                console.error(prefix, `Failed to store all chunks for ${modelId}/${relativeFileName} in DB after download.`);\n                browser.runtime.sendMessage({\n                    type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                    payload: {\n                        modelId,\n                        file: relativeFileName,\n                        error: `DB store failed after download (chunked)` ,\n                        downloaded: filesSuccessfullyProcessedCount,\n                        total: totalFilesToAttempt,\n                        currentFileSource,\n                        fileIdx,\n                        totalFiles: totalFilesToAttempt,\n                        failType: 'file_fail',\n                    }\n                }).catch(e => console.error(prefix, \"Error sending download progress (store/verify failure):\", e));\n                continue;\n            }\n\n            // Progress for successfully processed file (either found or downloaded+stored)\n            let percent = (totalBytesDownloaded / totalBytesToDownload) * 100;\n            let filePercent = (fileBytesDownloaded / fileTotalBytes) * 100;\n            browser.runtime.sendMessage({\n                type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                payload: {\n                    modelId,\n                    file: relativeFileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    chunkIndex: fileChunksDownloaded,\n                    totalChunks: fileTotalChunks,\n                    fileBytesDownloaded,\n                    fileTotalBytes,\n                    totalBytesDownloaded,\n                    totalBytesToDownload,\n                    totalChunksDownloaded,\n                    totalChunksToDownload,\n                    percent,\n                    filePercent,\n                    currentFileSource\n                }\n            }).catch(e => console.error(prefix, \"Error sending download progress (success):\", e));\n\n            // Log memory after big file\n            if (fileTotalBytes > 10 * 1024 * 1024) {\n                logMemory(`After file ${relativeFileName}`);\n            }\n\n        } catch (error) {\n            fileFailed = true;\n            failedFiles.push(relativeFileName);\n            browser.runtime.sendMessage({\n                type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n                payload: {\n                    modelId,\n                    file: relativeFileName,\n                    fileIdx,\n                    totalFiles: totalFilesToAttempt,\n                    error: error.message,\n                    failType: 'exception',\n                    currentFileSource\n                }\n            }).catch(e => console.error(prefix, \"Error sending download progress (exception):\", e));\n            // Continue to next file\n        }\n    }\n\n    console.log(prefix, `Finished processing all ${totalFilesToAttempt} needed files for ${modelId}. Successfully processed ${filesSuccessfullyProcessedCount} files.`);\n    if (filesSuccessfullyProcessedCount === totalFilesToAttempt) {\n        sendResponseCallback({ success: true, fileMap: successfullyProcessedFileMap, message: `All ${totalFilesToAttempt} assets for ${modelId} are now available in DB.` });\n    } else {\n        sendResponseCallback({ success: false, fileMap: successfullyProcessedFileMap, error: `Failed to process all assets for ${modelId}. Got ${filesSuccessfullyProcessedCount} of ${totalFilesToAttempt}. Check logs for details.` });\n    }\n\n    // --- Final summary report ---\n    browser.runtime.sendMessage({\n        type: UIEventNames.MODEL_DOWNLOAD_PROGRESS,\n        payload: {\n            modelId,\n            summary: true,\n            filesSuccessfullyProcessedCount,\n            totalFilesToAttempt,\n            failedFiles,\n            success: failedFiles.length === 0,\n            message: failedFiles.length === 0 ? `All ${totalFilesToAttempt} assets for ${modelId} are now available in DB.` : `Some files failed: ${failedFiles.join(', ')}`\n        }\n    }).catch(e => console.error(prefix, \"Error sending download progress (final summary):\", e));\n}\n\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const type = message?.type;\n    if (Object.values(DirectDBNames).includes(type)) {\n        return false;\n    }\n    if (Object.values(DBEventNames).includes(type)) {\n        return false;\n    }\n\n    if (!message || !message.type) {\n        console.warn(prefix, \"Received message from background without type:\", message);\n        return false; // Indicate that sendResponse will not be called\n    }\n\n    if (!allowedMessageTypesFromBackground.has(message.type)) {\n        // This message is not for the model loader part of the offscreen document.\n        return false; // Allow other listeners to handle it.\n    }\n\n    console.log(prefix, `Received message from background: Type: ${message.type}, Payload:`, message.payload);\n    const { type: messageType, payload } = message;\n    const currentWorker = initializeModelWorker();\n\n    if (!currentWorker && messageType !== ModelLoaderMessageTypes.DOWNLOAD_MODEL_ASSETS) {\n        console.error(prefix, `Cannot handle message type '${messageType}'.  model worker (model-worker.js) is not available, and message is not DOWNLOAD_MODEL_ASSETS.`);\n        sendResponse({ success: false, error: \" model worker instance is not available or failed to initialize.\" });\n        return false;\n    }\n\n    switch (messageType) {\n        case ModelLoaderMessageTypes.DOWNLOAD_MODEL_ASSETS:\n            console.log(prefix, `Handling ${ModelLoaderMessageTypes.DOWNLOAD_MODEL_ASSETS} for model: ${payload?.modelId}`);\n            if (!payload || !payload.modelId) {\n                console.error(prefix, `${ModelLoaderMessageTypes.DOWNLOAD_MODEL_ASSETS} request is missing modelId.`);\n                sendResponse({ success: false, error: \"Model ID not provided for download.\" });\n                return false;\n            }\n            downloadModelAssetsAndReport(payload.modelId, sendResponse);\n            return true; // Indicates async response\n\n        case ModelLoaderMessageTypes.INIT:\n            console.log(prefix, `Handling ${ModelLoaderMessageTypes.INIT} (to initialize  worker) for model: ${payload?.modelId}`);\n            if (!currentWorker) {\n                 console.error(prefix, `Cannot forward ${ModelLoaderMessageTypes.INIT}.  model worker instance is null even after initialization attempt.`);\n                 sendResponse({ success: false, error: \" model worker instance is unexpectedly null.\" });\n                 return false;\n            }\n            if (!payload || !payload.modelId) {\n                console.error(prefix, `${ModelLoaderMessageTypes.INIT} request is missing modelId.`);\n                sendResponse({ success: false, error: \"Model ID not provided for  worker initialization.\" });\n                return false;\n            }\n\n            const wasmPath = browser.runtime.getURL('xenova/transformers/dist/');\n            console.log(prefix, `Posting 'init' (internal type for model-worker.js) to  model worker for model ${payload.modelId}. WASM Path: ${wasmPath}`);\n            try {\n                currentWorker.postMessage({\n                    type: 'init', // This 'init' is for model-worker.js\n                    payload: {\n                        modelId: payload.modelId,\n                        wasmPath: wasmPath,\n                    }\n                });\n                sendResponse({ success: true, message: `INIT command for model ${payload.modelId} has been posted to  model worker.` });\n            } catch (error) {\n                console.error(prefix, `Error posting 'init' (internal type) message to  model worker:`, error);\n                sendResponse({ success: false, error: `Error posting INIT to  model worker: ${error.message}` });\n            }\n            return false;\n\n        case ModelLoaderMessageTypes.GENERATE:\n        case ModelLoaderMessageTypes.INTERRUPT:\n        case ModelLoaderMessageTypes.RESET:\n            if (!workerScriptReady && messageType === ModelLoaderMessageTypes.GENERATE) {\n                 console.error(prefix, ` worker script (model-worker.js) is not ready. Cannot forward ${messageType}.`);\n                 sendResponse({ success: false, error: ` worker script not ready. Cannot ${messageType}. Wait for worker ready signal.` });\n                 return false;\n            }\n            break;\n\n        // --- ADDED: Handle listModelFiles for pre-load logging ---\n        case ModelLoaderMessageTypes.LIST_MODEL_FILES:\n            (async () => {\n                try {\n                    const { modelId } = message.payload || {};\n                    const requestId = message.requestId;\n                    if (!modelId) {\n                        currentWorker.postMessage({\n                            type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                            requestId,\n                            payload: { success: false, error: 'No modelId provided' }\n                        });\n                        return;\n                    }\n                    // Request file list from background script\n                    const docsResult = await browser.runtime.sendMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES,\n                        payload: { modelId }\n                    });\n                    if (!docsResult.success) {\n                        currentWorker.postMessage({\n                            type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                            requestId,\n                            payload: { success: false, error: docsResult.error }\n                        });\n                        return;\n                    }\n                    const files = docsResult.files;\n                    currentWorker.postMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                        requestId,\n                        payload: { success: true, files }\n                    });\n                } catch (err) {\n                    const requestId = message.requestId;\n                    currentWorker.postMessage({\n                        type: ModelLoaderMessageTypes.LIST_MODEL_FILES_RESULT,\n                        requestId,\n                        payload: { success: false, error: err.message }\n                    });\n                }\n            })();\n            return true;\n\n        default:\n            console.warn(prefix, `Unhandled allowed message type in switch: ${messageType}`);\n            sendResponse({ success: false, error: `Unhandled message type ${messageType} in offscreen worker.` });\n            return false;\n    }\n});\n\nconsole.log(prefix, \"Offscreen script (modelLoaderWorkerOffscreen.js) loaded. Initializing eventBus listener and attempting to create  worker if not present.\");\ninitializeModelWorker();"],"names":[],"sourceRoot":""}