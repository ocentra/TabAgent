{"version":3,"file":"background.js","sources":["../src/log-client.js","../src/background.js"],"sourcesContent":["import { eventBus } from './eventBus.js';\nimport { DbAddLogRequest, DbInitializationCompleteNotification } from './events/dbEvents.js';\nimport * as EventNames from './events/eventNames.js';\n\nconst hasChromeRuntime = typeof chrome !== 'undefined' && chrome.runtime;\nlet componentName = 'unknown';\nlet mirrorToConsoleDefault = true;\nlet sendToDbDefault = true;\nlet isDbReadyForLogs = false;\nconst logBuffer = [];\n\nasync function flushLogBuffer() {\n    if (!eventBus) return;\n    while (logBuffer.length > 0) {\n        const logEvent = logBuffer.shift();\n        if (logEvent) {\n            try {\n                await eventBus.publish(logEvent.type, logEvent);\n            } catch (error) {\n                console.error(`LogClient (${componentName}): Error publishing buffered log. Error: ${error}. Event:`, logEvent);\n            }\n        }\n    }\n}\n\nfunction init(compName, options = {}) {\n    if (!compName) {\n        console.error(\"LogClient: init() requires a component name.\");\n        return;\n    }\n    componentName = compName;\n    mirrorToConsoleDefault = options.mirrorToConsole !== undefined ? options.mirrorToConsole : true;\n    sendToDbDefault = options.sendToDb !== undefined ? options.sendToDb : true;\n\n    if (eventBus) {\n        eventBus.subscribe(EventNames.DB_INITIALIZATION_COMPLETE_NOTIFICATION, (notification) => {\n            if (notification.payload.success) {\n                console.log(`[LogClient (${componentName})] Received DB Initialization Complete. Flushing buffer.`);\n                isDbReadyForLogs = true;\n                flushLogBuffer();\n            } else {\n                console.error(`[LogClient (${componentName})] Received DB Initialization FAILED notification. Logs will not be sent to DB. Error:`, notification.payload.error);\n            }\n        });\n    } else {\n        console.error(`LogClient (${componentName}): CRITICAL - eventBus not available during init. DB logging disabled.`);\n        sendToDbDefault = false;\n    }\n\n    let logMode = 'unknown';\n    if (typeof eventBus !== 'undefined') {\n        logMode = 'sendMessage logging (Standard)';\n    } else {\n        logMode = 'console fallback';\n        console.error(`LogClient (${componentName}): CRITICAL - No logging mechanism available. Falling back to console.`);\n    }\n\n    const initialLogMessage = `Log client initialized for component: ${componentName}. (${logMode}, Console Mirror: ${mirrorToConsoleDefault}, SendToDB: ${sendToDbDefault})`;\n    _internalLogHelper('info', initialLogMessage, { mirrorToConsole: mirrorToConsoleDefault, sendToDb: sendToDbDefault, skipInitCheck: true });\n}\n\nasync function _internalLogHelper(level, ...args) {\n    const rawOptions = args.length > 0 && typeof args[args.length - 1] === 'object' && !Array.isArray(args[args.length - 1]) ? args.pop() : {};\n    const options = rawOptions || {};\n\n    const mirrorThisCall = options.mirrorToConsole !== undefined ? options.mirrorToConsole : mirrorToConsoleDefault;\n    let sendThisCall = options.sendToDb !== undefined ? options.sendToDb : sendToDbDefault;\n    const skipInitCheck = options.skipInitCheck || false;\n\n    if (sendThisCall && typeof eventBus === 'undefined') {\n        console.warn(`LogClient (${componentName}): Attempted DB log but eventBus is unavailable. Disabling DB log for this call.`);\n        sendThisCall = false;\n    }\n\n    if (!componentName && !skipInitCheck) {\n        console.error(\"LogClient: Attempted to log before init() was called. Message:\", level, ...args);\n        return;\n    }\n\n    if (mirrorThisCall || level.toLowerCase() === 'error') {\n        const consolePrefix = componentName ? `[${componentName}]` : `[LogClient]`;\n        const consoleArgs = [consolePrefix, ...args];\n        switch (level.toLowerCase()) {\n            case 'error': console.error(...consoleArgs); break;\n            case 'warn': if (mirrorThisCall) console.warn(...consoleArgs); break;\n            case 'debug': if (mirrorThisCall) console.debug(...consoleArgs); break;\n            case 'info': default: if (mirrorThisCall) console.log(...consoleArgs); break;\n        }\n    }\n\n    if (!sendThisCall) return;\n\n    const formattedMessage = args.map(arg => {\n        try {\n            if (arg instanceof Error) {\n                return `Error: ${arg.message}${arg.stack ? '\\n' + arg.stack : ''}`;\n            }\n            if (typeof arg === 'object' && arg !== null) {\n                return '[Object]';\n            }\n            return String(arg);\n        } catch (e) {\n            return `[Unstringifiable Object: ${e.message}]`;\n        }\n    }).join(' ');\n\n    const logPayload = {\n        id: crypto.randomUUID(),\n        timestamp: Date.now(),\n        component: componentName,\n        level: level.toLowerCase(),\n        message: formattedMessage,\n    };\n\n    if (hasChromeRuntime && chrome.storage?.local) {\n        try {\n            const { currentLogSessionId } = await chrome.storage.local.get('currentLogSessionId');\n            if (currentLogSessionId) {\n                logPayload.extensionSessionId = currentLogSessionId;\n            } else {\n                console.warn(`LogClient (${componentName}): Could not retrieve currentLogSessionId from storage.`);\n                logPayload.extensionSessionId = 'unknown-session';\n            }\n        } catch (storageError) {\n            console.error(`LogClient (${componentName}): Error retrieving session ID from storage:`, storageError);\n            logPayload.extensionSessionId = 'storage-error-session';\n        }\n    } else {\n        logPayload.extensionSessionId = 'no-storage-session';\n    }\n\n    const logEvent = new DbAddLogRequest(logPayload);\n\n    if (isDbReadyForLogs) {\n        try {\n            await eventBus.publish(logEvent.type, logEvent);\n        } catch (error) {\n            console.error(`LogClient (${componentName}): Error during eventBus log submission. Error: ${error}. Original message:`, level, ...args);\n        }\n    } else {\n        logBuffer.push(logEvent);\n    }\n}\n\nfunction log(level, ...args) {\n    _internalLogHelper(level, ...args);\n}\n\nfunction logDebug(...args) {\n    _internalLogHelper('debug', ...args);\n}\n\nfunction logInfo(...args) {\n    _internalLogHelper('info', ...args);\n}\n\nfunction logWarn(...args) {\n    _internalLogHelper('warn', ...args);\n}\n\nfunction logError(...args) {\n    _internalLogHelper('error', ...args);\n}\n\nexport { init, log, logDebug, logInfo, logWarn, logError };","import browser from 'webextension-polyfill';\n\nconst OFFSCREEN_DOCUMENT_PATH_SCRAPING = 'scrapingOffscreen.html';\nconst MODEL_WORKER_OFFSCREEN_PATH = 'modelLoaderWorkerOffscreen.html';\n\nimport * as logClient from './log-client.js';\nimport { eventBus } from './eventBus.js';\nimport { DbInitializeRequest } from './events/dbEvents.js';\n\nlogClient.init('Background');\n\nlet detachedPopups = {};\nlet popupIdToTabId = {};\n\nconst DNR_RULE_ID_1 = 1;\nconst DNR_RULE_PRIORITY_1 = 1;\n\nlet modelWorkerState = 'uninitialized';\nlet workerScriptReadyPromise = null;\nlet workerScriptReadyResolver = null;\nlet workerScriptReadyRejecter = null;\nlet modelLoadPromise = null;\nlet modelLoadResolver = null;\nlet modelLoadRejecter = null;\n\nlet activeGenerations = {};\n\nlet currentLogSessionId = null;\nlet previousLogSessionId = null;\n\nlet lastLoggedProgress = -10;\n\n// Log Session Management\nasync function initializeSessionIds() {\n    logClient.logInfo('Initializing log session IDs...');\n    currentLogSessionId = Date.now() + '-' + Math.random().toString(36).substring(2, 9);\n    logClient.logInfo('Current log session ID:', currentLogSessionId);\n    await browser.storage.local.set({ currentLogSessionId: currentLogSessionId });\n    const { previousLogSessionId: storedPreviousId } = await browser.storage.local.get('previousLogSessionId');\n    previousLogSessionId = storedPreviousId || null;\n    logClient.logInfo('Previous log session ID found in storage:', previousLogSessionId);\n    await browser.storage.local.set({ previousLogSessionId: currentLogSessionId });\n    logClient.logInfo('Stored new previousLogSessionId for next run.');\n}\n\n// Model Worker Offscreen Communication\nasync function hasModelWorkerOffscreenDocument() {\n    const targetUrl = browser.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH);\n    const existingContexts = await browser.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    return existingContexts.length > 0;\n}\n\nasync function setupModelWorkerOffscreenDocument() {\n    if (await hasModelWorkerOffscreenDocument()) {\n        logClient.logInfo(\"Model worker offscreen document already exists.\");\n        return;\n    }\n    logClient.logInfo(\"Creating model worker offscreen document...\");\n    await browser.offscreen.createDocument({\n        url: MODEL_WORKER_OFFSCREEN_PATH,\n        reasons: [browser.offscreen.Reason.WORKERS],\n        justification: 'Run model inference in a separate worker via offscreen document',\n    });\n    logClient.logInfo(\"Model worker offscreen document created.\");\n}\n\nasync function sendToModelWorkerOffscreen(message) {\n    if (message.type !== 'init' && message.type !== 'generate' && message.type !== 'interrupt' && message.type !== 'reset') {\n        if (modelWorkerState === 'uninitialized' || !(await hasModelWorkerOffscreenDocument())) {\n            logClient.logInfo(`Background: Ensuring model worker offscreen doc potentially exists before sending ${message?.type}`);\n            await setupModelWorkerOffscreenDocument();\n        }\n    } else {\n        logClient.logDebug(`Background: Ensuring worker script is ready before sending ${message.type}...`);\n        try {\n            await ensureWorkerScriptIsReady();\n            logClient.logDebug(`Background: Worker script confirmed ready. Proceeding to send ${message.type}.`);\n        } catch (error) {\n            logClient.logError(`Background: Worker script failed to become ready. Cannot send ${message.type}. Error:`, error);\n            modelWorkerState = 'error';\n            throw new Error(`Worker script failed to initialize, cannot send ${message.type}.`);\n        }\n    }\n\n    logClient.logDebug(`Background: Sending message type '${message?.type}' to model worker offscreen doc`);\n    try {\n        const contexts = await browser.runtime.getContexts({\n            contextTypes: ['OFFSCREEN_DOCUMENT'],\n            documentUrls: [browser.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH)]\n        });\n        if (contexts.length > 0) {\n            browser.runtime.sendMessage(message);\n            logClient.logDebug(`Background: Message type '${message?.type}' sent to offscreen.`);\n            return { success: true };\n        } else {\n            logClient.logError(`Background: Could not find target offscreen document context to send ${message?.type}.`);\n            throw new Error(`Target offscreen document not found.`);\n        }\n    } catch (error) {\n        logClient.logError(`Background: Error sending message type '${message?.type}' to offscreen:`, error);\n        modelWorkerState = 'error';\n        if (message.type === 'init') {\n            if (modelLoadRejecter) modelLoadRejecter(new Error(`Failed to send init message: ${error.message}`));\n            modelLoadPromise = null;\n        } else if (workerScriptReadyRejecter && (modelWorkerState === 'uninitialized' || modelWorkerState === 'creating_worker')) {\n            workerScriptReadyRejecter(new Error(`Failed to send message early: ${error.message}`));\n            workerScriptReadyPromise = null;\n        }\n        throw new Error(`Failed to send message to model worker offscreen: ${error.message}`);\n    }\n}\n\nfunction ensureWorkerScriptIsReady() {\n    logClient.logDebug(`[ensureWorkerScriptIsReady] Current state: ${modelWorkerState}`);\n    if (modelWorkerState !== 'uninitialized' && modelWorkerState !== 'creating_worker') {\n        if (modelWorkerState === 'error' && !workerScriptReadyPromise) {\n            return Promise.reject(new Error(\"Worker script initialization previously failed.\"));\n        }\n        return Promise.resolve();\n    }\n    if (workerScriptReadyPromise) {\n        return workerScriptReadyPromise;\n    }\n\n    logClient.logDebug(\"[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise.\");\n    modelWorkerState = 'creating_worker';\n    workerScriptReadyPromise = new Promise((resolve, reject) => {\n        workerScriptReadyResolver = resolve;\n        workerScriptReadyRejecter = reject;\n\n        setupModelWorkerOffscreenDocument().catch(err => {\n            logClient.logError(\"[ensureWorkerScriptIsReady] Error setting up offscreen doc:\", err);\n            modelWorkerState = 'error';\n            if (workerScriptReadyRejecter) workerScriptReadyRejecter(err);\n            workerScriptReadyPromise = null;\n        });\n    });\n\n    const scriptLoadTimeout = 30000;\n    setTimeout(() => {\n        if (modelWorkerState === 'creating_worker' && workerScriptReadyRejecter) {\n            logClient.logError(`[ensureWorkerScriptIsReady] Timeout (${scriptLoadTimeout}ms) waiting for workerScriptReady.`);\n            workerScriptReadyRejecter(new Error('Timeout waiting for model worker script to load.'));\n            modelWorkerState = 'error';\n            workerScriptReadyPromise = null;\n        }\n    }, scriptLoadTimeout);\n\n    return workerScriptReadyPromise;\n}\n\nasync function loadModel(modelId) {\n    logClient.logInfo(`Request to load model: ${modelId}. Current state: ${modelWorkerState}`);\n    try {\n        await ensureWorkerScriptIsReady();\n        logClient.logDebug(`Worker script confirmed ready (state: ${modelWorkerState}). Proceeding with model load.`);\n    } catch (err) {\n        logClient.logError(\"Failed to ensure worker script readiness:\", err);\n        throw new Error(`Failed to ensure worker script readiness: ${err.message}`);\n    }\n\n    if (modelWorkerState !== 'worker_script_ready' && modelWorkerState !== 'idle' && modelWorkerState !== 'error') {\n        const errorMsg = `Cannot load model '${modelId}'. Worker state is '${modelWorkerState}', expected 'worker_script_ready', 'idle', or 'error'.`;\n        logClient.logError(\"State check failed loading model:\", errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    if (!modelId) {\n        return Promise.reject(new Error(\"Cannot load model: Model ID not provided.\"));\n    }\n\n    if (modelWorkerState === 'model_ready') {\n        logClient.logInfo(`Model appears ready. Assuming it's ${modelId}.`);\n        return Promise.resolve();\n    }\n    if (modelWorkerState === 'loading_model' && modelLoadPromise) {\n        logClient.logInfo(`Model is already loading. Assuming it's ${modelId}.`);\n        return modelLoadPromise;\n    }\n    if (modelWorkerState !== 'worker_script_ready') {\n        logClient.logError(\"Cannot load model. Worker script is not ready. State:\", modelWorkerState);\n        return Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${modelWorkerState})`));\n    }\n\n    logClient.logInfo(`Worker script ready. Initiating load for model: ${modelId}.`);\n    modelWorkerState = 'loading_model';\n    // TODO: Store the modelId being loaded\n    modelLoadPromise = new Promise((resolve, reject) => {\n        modelLoadResolver = resolve;\n        modelLoadRejecter = reject;\n\n        logClient.logDebug(`Attempting to send 'init' message for model: ${modelId}`);\n        sendToModelWorkerOffscreen({ type: 'init', payload: { modelId: modelId } })\n            .catch(err => {\n                logClient.logError(`Failed to send 'init' message for ${modelId}:`, err);\n                modelWorkerState = 'error';\n                if (modelLoadRejecter) modelLoadRejecter(err);\n                modelLoadPromise = null;\n            });\n    });\n\n    const modelLoadTimeout = 300000;\n    setTimeout(() => {\n        if (modelWorkerState === 'loading_model' && modelLoadRejecter) {\n            logClient.logError(`Timeout (${modelLoadTimeout}ms) waiting for model ${modelId} load completion.`);\n            modelLoadRejecter(new Error(`Timeout waiting for model ${modelId} to load.`));\n            modelWorkerState = 'error';\n            modelLoadPromise = null;\n        }\n    }, modelLoadTimeout);\n\n    return modelLoadPromise;\n}\n\n// Declarative Net Request Management\nasync function updateDeclarativeNetRequestRules() {\n    const currentRules = await browser.declarativeNetRequest.getDynamicRules();\n    const currentRuleIds = currentRules.map(rule => rule.id);\n\n    const rulesToAdd = [\n        {\n            id: DNR_RULE_ID_1,\n            priority: DNR_RULE_PRIORITY_1,\n            action: {\n                type: 'modifyHeaders',\n                responseHeaders: [\n                    { header: 'x-frame-options', operation: 'remove' },\n                    { header: 'X-Frame-Options', operation: 'remove' },\n                    { header: 'content-security-policy', operation: 'remove' },\n                    { header: 'Content-Security-Policy', operation: 'remove' }\n                ]\n            },\n            condition: {\n                resourceTypes: ['main_frame'],\n                urlFilter: '|http*://*/*|'\n            }\n        }\n    ];\n\n    const rulesToRemove = currentRuleIds.filter(id => id === DNR_RULE_ID_1);\n\n    try {\n        await browser.declarativeNetRequest.updateDynamicRules({\n            removeRuleIds: rulesToRemove,\n            addRules: rulesToAdd\n        });\n        logClient.logInfo(\"Declarative Net Request rules updated successfully.\");\n    } catch (error) {\n        logClient.logError(\"Error updating Declarative Net Request rules:\", error);\n    }\n}\nupdateDeclarativeNetRequestRules();\n\n// Offscreen Document Management\nasync function hasOffscreenDocument(path) {\n    if (browser.runtime.getContexts) {\n        const contexts = await browser.runtime.getContexts({\n            contextTypes: ['OFFSCREEN_DOCUMENT'],\n            documentUrls: [browser.runtime.getURL(path)] \n        });\n        return contexts.length > 0;\n    }\n    return false;\n}\n\nasync function setupOffscreenDocument(path, reasons, justification) {\n    if (await hasOffscreenDocument(path)) {\n        logClient.logInfo(`Background: Offscreen document at ${path} already exists.`);\n        return;\n    }\n    const filename = path.split('/').pop();\n    logClient.logInfo(`Background: Creating offscreen document using filename: ${filename}...`);\n    await browser.offscreen.createDocument({\n        url: filename,\n        reasons: reasons,\n        justification: justification,\n    });\n    logClient.logInfo(`Background: <<< Offscreen document ${path} CREATED successfully. Script should now load. >>>`);\n    logClient.logInfo(`Background: Offscreen document created successfully using ${filename}.`);\n}\n\n// Scraping Logic\nasync function scrapeUrlWithOffscreenIframe(url) {\n    logClient.logInfo(`[Stage 3] Attempting Offscreen + iframe: ${url}`);\n    const DYNAMIC_SCRIPT_ID_PREFIX = 'offscreen-scrape-';\n    const DYNAMIC_SCRIPT_MESSAGE_TYPE = 'offscreenIframeResult';\n    const IFRAME_LOAD_TIMEOUT = 30000;\n    let dynamicScripterId = null;\n\n    const cleanup = async (scriptIdBase) => {\n        logClient.logInfo(`[Stage 3 Cleanup] Starting cleanup for script ID base: ${scriptIdBase}`);\n        if (scriptIdBase) {\n            try {\n                await browser.scripting.unregisterContentScripts({ ids: [scriptIdBase] });\n                logClient.logInfo(`[Stage 3 Cleanup] Unregistered script: ${scriptIdBase}`);\n            } catch (error) {\n                logClient.logWarn(`[Stage 3 Cleanup] Failed to unregister script ${scriptIdBase}:`, error);\n            }\n        }\n        try {\n            await cleanupOffscreen(OFFSCREEN_DOCUMENT_PATH_SCRAPING);\n            logClient.logInfo('[Stage 3 Cleanup] Sent removeIframe request to offscreen.');\n        } catch (error) {\n            logClient.logWarn('[Stage 3 Cleanup] Failed to send removeIframe request: ', error);\n        }\n    };\n\n    try {\n        await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH_SCRAPING, [browser.offscreen.Reason.DOM_PARSER, browser.offscreen.Reason.IFRAME_SCRIPTING], 'Parse HTML content and manage scraping iframes');\n        logClient.logInfo('[Stage 3] Sending createIframe request to offscreen...');\n        const createResponse = await browser.runtime.sendMessage({\n            type: 'createIframe',\n            target: 'offscreen',\n            url: url\n        });\n        if (!createResponse?.success) {\n            throw new Error(`Failed to create iframe in offscreen: ${createResponse?.error || 'Unknown error'}`);\n        }\n        logClient.logInfo('[Stage 3] Iframe creation request successful. Waiting for load and script...');\n        dynamicScripterId = `${DYNAMIC_SCRIPT_ID_PREFIX}${Date.now()}`;\n        await browser.scripting.registerContentScripts([{\n            id: dynamicScripterId,\n            js: ['pageExtractor.js', 'stage2Helper.js'],\n            matches: [url],\n            runAt: 'document_idle',\n            world: 'ISOLATED',\n            allFrames: true,\n            persistAcrossSessions: false\n        }]);\n        logClient.logInfo(`[Stage 3] Registered dynamic script(s): ${dynamicScripterId} (files: pageExtractor.js, stage2Helper.js)`);\n        let messageListener = null;\n        const scriptResponsePromise = new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                logClient.logWarn(`[Stage 3] Timeout (${IFRAME_LOAD_TIMEOUT / 1000}s) waiting for response from dynamic script.`);\n                if (messageListener) {\n                    browser.runtime.onMessage.removeListener(messageListener);\n                }\n                reject(new Error('Timeout waiting for dynamic script response.'));\n            }, IFRAME_LOAD_TIMEOUT);\n\n            messageListener = (message, sender, sendResponse) => {\n                if (message?.type === DYNAMIC_SCRIPT_MESSAGE_TYPE) {\n                    logClient.logInfo('[Stage 3] Received response from dynamic script:', message.payload);\n                    clearTimeout(timeoutId);\n                    browser.runtime.onMessage.removeListener(messageListener);\n                    if (message.payload?.success) {\n                        resolve(message.payload);\n                    } else {\n                        reject(new Error(message.payload?.error || 'Dynamic script reported failure.'));\n                    }\n                    return false;\n                }\n                return false;\n            };\n            browser.runtime.onMessage.addListener(messageListener);\n            logClient.logInfo('[Stage 3] Listener added for dynamic script response.');\n        });\n        const resultPayload = await scriptResponsePromise;\n        await cleanup(dynamicScripterId);\n        return resultPayload;\n    } catch (error) {\n        logClient.logError(`[Stage 3] Error during Offscreen + iframe process:`, error);\n        await cleanup(dynamicScripterId);\n        throw new Error(`Stage 3 (Offscreen + iframe) failed: ${error.message}`);\n    }\n}\n\nasync function scrapeUrlWithTempTabExecuteScript(url) {\n    logClient.logInfo(`[Stage 1 (ExecuteScript)] Attempting Temp Tab + executeScript: ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg, errorObj = null) => {\n            const finalError = errorObj ? errorObj : new Error(errorMsg);\n            logClient.logWarn(`[Stage 1 (ExecuteScript)] Cleanup & Reject: ${errorMsg}`, errorObj);\n            if (tempTabId) {\n                browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 1 (ExecuteScript)] Error removing tab ${tempTabId}: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(finalError);\n        };\n\n        try {\n            const tab = await browser.tabs.create({ url: url, active: false });\n            tempTabId = tab.id;\n            if (!tempTabId) {\n                cleanupAndReject('[Stage 1 (ExecuteScript)] Failed to get temporary tab ID.');\n                return;\n            }\n            logClient.logInfo(`[Stage 1 (ExecuteScript)] Created temp tab ${tempTabId}.`);\n\n            // Wait for the tab to load\n            let loadTimeoutId = null;\n            const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n                const listener = (tabIdUpdated, changeInfo, updatedTab) => {\n                    if (tabIdUpdated === tempTabId && changeInfo.status === 'complete') {\n                        logClient.logInfo(`[Stage 1 (ExecuteScript)] Tab ${tempTabId} loaded.`);\n                        if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                        browser.tabs.onUpdated.removeListener(listener);\n                        resolveLoad();\n                    }\n                };\n                browser.tabs.onUpdated.addListener(listener);\n                loadTimeoutId = setTimeout(() => {\n                    browser.tabs.onUpdated.removeListener(listener);\n                    rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load in tab ${tempTabId}.`));\n                }, TEMP_TAB_LOAD_TIMEOUT);\n            });\n\n            await loadPromise;\n            logClient.logInfo(`[Stage 1 (ExecuteScript)] Page loaded. Injecting pageExtractor.js module into tab ${tempTabId}...`);\n\n            // 1. Inject the PageExtractor.js script\n            await browser.scripting.executeScript({\n                target: { tabId: tempTabId },\n                files: ['pageExtractor.js'] \n            });\n            logClient.logInfo(`[Stage 1 (ExecuteScript)] pageExtractor.js module INJECTED successfully into tab ${tempTabId}.`);\n\n            // 2. Execute a function that calls the globally exposed extract method\n            logClient.logInfo(`[Stage 1 (ExecuteScript)] Executing function to call window.TabAgentPageExtractor.extract in tab ${tempTabId}...`);\n            const injectionResults = await browser.scripting.executeScript({\n                target: { tabId: tempTabId },\n                func: () => { // Arrow function for lexical this, though not strictly needed here\n                    if (window.TabAgentPageExtractor && typeof window.TabAgentPageExtractor.extract === 'function') {\n                        try {\n                            return window.TabAgentPageExtractor.extract(document);\n                        } catch (e) {\n                            console.error('[In-Tab] Error during execution of PageExtractor.extract:', e);\n                            return { error: `Error in PageExtractor.extract: ${e.message} (Stack: ${e.stack})` };\n                        }\n                    } else {\n                        console.error('[In-Tab] TabAgentPageExtractor or its extract function not found on window.');\n                        return { error: 'TabAgentPageExtractor.extract function not found on window.' };\n                    }\n                }\n            });\n\n            logClient.logInfo('[Stage 1 (ExecuteScript)] Raw results from executeScript func:', injectionResults);\n\n            if (!injectionResults || injectionResults.length === 0 || !injectionResults[0].result) {\n                cleanupAndReject('[Stage 1 (ExecuteScript)] No result returned from executeScript func.', injectionResults && injectionResults[0] ? injectionResults[0].error : null);\n                return;\n            }\n\n            const scriptResult = injectionResults[0].result;\n\n            if (scriptResult && scriptResult.error) {\n                cleanupAndReject(`[Stage 1 (ExecuteScript)] Script execution reported an error: ${scriptResult.error}`, scriptResult);\n                return;\n            }\n            \n            if (scriptResult && typeof scriptResult === 'object') {\n                logClient.logInfo('[Stage 1 (ExecuteScript)] pageExtractor.js module execution succeeded (returned object).');\n                resolve(scriptResult);\n            } else {\n                cleanupAndReject('[Stage 1 (ExecuteScript)] pageExtractor.js module returned unexpected non-object/error type.', scriptResult);\n            }\n\n        } catch (error) {\n            cleanupAndReject(`[Stage 1 (ExecuteScript)] Error: ${error.message}`, error);\n        } finally {\n            if (tempTabId) { // Ensure tab is closed if something went wrong before explicit resolve/reject\n                browser.tabs.remove(tempTabId).catch(err => logClient.logWarn(`[Stage 1 (ExecuteScript)] Error removing tab ${tempTabId} in final catch: ${err.message}`));\n            }\n        }\n    });\n}\n\n\nasync function scrapeUrlMultiStage(url, chatId, messageId) {\n    logClient.logInfo(`Scraping Orchestrator: Starting for ${url}. ChatID: ${chatId}, MessageID: ${messageId}`);\n    const sendStageResult = (stageResult) => {\n        logClient.logInfo(`[Orchestrator] Sending STAGE_SCRAPE_RESULT for Stage ${stageResult.stage}, ChatID: ${chatId}, Success: ${stageResult.success}`);\n        browser.runtime.sendMessage({\n            type: 'STAGE_SCRAPE_RESULT',\n            payload: stageResult\n        }).catch(e => logClient.logWarn(`[Orchestrator] Failed to send result for Stage ${stageResult.stage}:`, e));\n    };\n\n\n    try {\n        try {\n            const executeScriptResult = await scrapeUrlWithTempTabExecuteScript(url);\n            logClient.logInfo(`[Orchestrator Log] Stage 1 (Temp Tab + executeScript) Succeeded for ${url}.`);\n            const stage1SuccessPayload = {\n                stage: 1, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabExecuteScript', url: url,\n                length: executeScriptResult?.text?.length || 0,\n                ...executeScriptResult\n            };\n            sendStageResult(stage1SuccessPayload);\n            return; // Stop after successful Stage 1\n        } catch (stage1Error) {\n            logClient.logWarn(`[Orchestrator Log] Stage 1 (Temp Tab + executeScript) Failed for ${url}: ${stage1Error.message}`);\n            sendStageResult({ stage: 1, success: false, chatId: chatId, messageId: messageId, method: 'tempTabExecuteScript', error: stage1Error.message });\n            // Do not proceed to other stages if Stage 1 fails, as per new plan\n            return; \n        }\n\n        // All other stages (2, 3, 4) have been removed.\n        // If Stage 1 fails, the orchestrator will have already returned.\n        // This part of the code should ideally not be reached if Stage 1 was the only one.\n        // However, to be safe and explicit:\n        logClient.logInfo(\"[Orchestrator Log] No successful scraping stage completed (should have exited after Stage 1 attempt).\");\n\n    } finally {\n        // No specific cleanup for scraping stages needed here anymore.\n        logClient.logInfo(`[Scraping Orchestrator] Finished processing for ${url}.`);\n    }\n}\n\n// Google Drive Integration\nasync function getDriveToken() {\n    return new Promise((resolve, reject) => {\n        browser.identity.getAuthToken({ interactive: true }, (token) => {\n            if (browser.runtime.lastError) {\n                reject(new Error(browser.runtime.lastError.message));\n            } else {\n                resolve(token);\n            }\n        });\n    });\n}\n\nasync function fetchDriveFileList(token, folderId = 'root') {\n    const fields = \"files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)\";\n    const query = `'${folderId}' in parents and trashed=false`;\n    const pageSize = 100;\n    const orderBy = 'folder,modifiedTime desc';\n    const url = `https://www.googleapis.com/drive/v3/files?${new URLSearchParams({\n        pageSize: pageSize.toString(),\n        q: query,\n        fields: fields,\n        orderBy: orderBy\n    })}`;\n    logClient.logInfo(`Background: Fetching Drive list for folder '${folderId}': ${url}`);\n    const response = await fetch(url, {\n        headers: {\n            'Authorization': `Bearer ${token}`,\n            'Accept': 'application/json'\n        }\n    });\n    if (!response.ok) {\n        const errorData = await response.text();\n        logClient.logError(`Background: Drive API files.list error (Folder: ${folderId}):`, response.status, errorData);\n        if (response.status === 404) {\n            throw new Error(`Folder with ID '${folderId}' not found or access denied.`);\n        }\n        throw new Error(`Drive API Error ${response.status} (Folder: ${folderId}): ${errorData || response.statusText}`);\n    }\n    const data = await response.json();\n    logClient.logInfo(`Background: Drive API files.list success (Folder: ${folderId}). Found ${data.files?.length || 0} items.`);\n    return data.files || [];\n}\n\nasync function fetchDriveFileContent(token, fileId) {\n    logClient.logWarn(`Background: fetchDriveFileContent not implemented yet for fileId: ${fileId}`);\n    return `(Content fetch not implemented for ${fileId})`;\n}\n\n// Message Forwarding\nasync function forwardMessageToSidePanelOrPopup(message, originalSender) {\n    logClient.logInfo(`Attempting to forward message type '${message?.type}' from worker.`);\n    for (const tabId in detachedPopups) {\n        const popupId = detachedPopups[tabId];\n        logClient.logInfo(`Forwarding message to detached popup ID: ${popupId} (original tab: ${tabId})`);\n        try {\n            await browser.windows.get(popupId);\n            browser.runtime.sendMessage(message);\n        } catch (error) {\n            logClient.logWarn(`Error sending to detached popup ID ${popupId}:`, error.message);\n            if (error.message.includes(\"No window with id\")) {\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[popupId];\n            }\n        }\n    }\n\n    const tabs = await browser.tabs.query({ status: 'complete' });\n    for (const tab of tabs) {\n        if (detachedPopups[tab.id]) continue;\n        try {\n            await browser.tabs.sendMessage(tab.id, message);\n        } catch (error) {\n            if (!error.message.includes('Could not establish connection') && !error.message.includes('Receiving end does not exist')) {\n                logClient.logWarn(`Error forwarding message to tab ${tab.id}:`, error.message);\n            }\n        }\n    }\n}\n\n// Extension Lifecycle Listeners\nbrowser.runtime.onInstalled.addListener(async (details) => {\n    logClient.logInfo('onInstalled event fired. Reason:', details.reason);\n    await initializeSessionIds();\n\n    browser.sidePanel\n        .setPanelBehavior({ openPanelOnActionClick: true })\n        .catch((error) => logClient.logError('Error setting side panel behavior:', error));\n    logClient.logInfo('Side panel behavior set.');\n\n    browser.storage.local.get().then((items) => {\n        const keysToRemove = Object.keys(items).filter(key => key.startsWith('detachedState_'));\n        if (keysToRemove.length > 0) {\n            browser.storage.local.remove(keysToRemove).then(() => {\n                logClient.logInfo('Cleaned up old storage keys on install/update.');\n            }).catch(err => {\n                logClient.logError('Error removing old storage keys:', err);\n            });\n        }\n    }).catch(err => {\n         logClient.logError('Error getting storage items for cleanup:', err);\n    });\n\n    logClient.logInfo('Triggering DB Initialization from onInstalled.');\n    eventBus.publish(DbInitializeRequest.name, new DbInitializeRequest());\n\n    ensureWorkerScriptIsReady().catch(err => {\n        logClient.logError(\"Initial worker script readiness check failed after install:\", err);\n    });\n});\n\nbrowser.runtime.onStartup.addListener(async () => {\n    logClient.logInfo('onStartup event fired.');\n    await initializeSessionIds();\n\n    logClient.logInfo('Triggering DB Initialization from onStartup (may be redundant).');\n    eventBus.publish(DbInitializeRequest.name, new DbInitializeRequest());\n\n    if (modelWorkerState === 'uninitialized') {\n        ensureWorkerScriptIsReady().catch(err => {\n            logClient.logError(\"Worker script readiness check failed on startup:\", err);\n        });\n    }\n});\n\nbrowser.action.onClicked.addListener(async (tab) => {\n    if (!tab.id) {\n        logClient.logError(\"Action Clicked: Missing tab ID.\");\n        return;\n    }\n    const tabId = tab.id;\n    logClient.logInfo(`Action clicked for tab ${tabId}`);\n    const existingPopupId = detachedPopups[tabId];\n    if (existingPopupId) {\n        logClient.logInfo(`Popup ${existingPopupId} exists for tab ${tabId}. Attempting to close popup.`);\n        try {\n            await browser.windows.remove(existingPopupId);\n            logClient.logInfo(`Closed popup window ${existingPopupId} via action click.`);\n        } catch (error) {\n            logClient.logWarn(`Failed to close popup ${existingPopupId} via action click, maybe already closed?`, error);\n            if (popupIdToTabId[existingPopupId]) {\n                logClient.logInfo(`Force cleaning maps and storage for tab ${tabId} after failed close.`);\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[existingPopupId];\n                try {\n                    await browser.storage.local.remove(`detachedState_${tabId}`);\n                    await browser.sidePanel.setOptions({ tabId: tabId, enabled: true });\n                } catch (cleanupError) {\n                    logClient.logError(\"Error during defensive cleanup:\", cleanupError);\n                }\n            }\n        }\n    } else {\n        logClient.logInfo(`No popup exists for tab ${tabId}. Default side panel opening behavior should trigger.`);\n    }\n});\n\nbrowser.windows.onRemoved.addListener(async (windowId) => {\n    logClient.logInfo(`Window removed: ${windowId}`);\n    const tabId = popupIdToTabId[windowId];\n    if (tabId) {\n        logClient.logInfo(`Popup window ${windowId} for tab ${tabId} was closed.`);\n        delete detachedPopups[tabId];\n        delete popupIdToTabId[windowId];\n        try {\n            await browser.storage.local.remove(`detachedState_${tabId}`);\n            logClient.logInfo(`Removed detached state from storage for tab ${tabId}`);\n            await browser.sidePanel.setOptions({ tabId: tabId, enabled: true });\n            logClient.logInfo(`Re-enabled side panel for tab ${tabId} after popup closed.`);\n        } catch (error) {\n            logClient.logError(`Error cleaning up storage or re-enabling side panel for tab ${tabId} on popup close:`, error);\n        }\n    } else {\n        logClient.logInfo(`Window ${windowId} closed, but it wasn't a tracked popup.`);\n    }\n});\n\n// Message Handling\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const { type, payload } = message;\n    let isResponseAsync = false;\n\n    logClient.logInfo(`Received message type '${type}' from`, sender.tab ? `tab ${sender.tab.id}` : sender.url || sender.id);\n\n    const workerMessageTypes = [\n        'workerScriptReady',\n        'workerReady',\n        'loadingStatus',\n        'generationStatus',\n        'generationUpdate',\n        'generationComplete',\n        'generationError',\n        'resetComplete',\n        'error'\n    ];\n\n    if (workerMessageTypes.includes(type)) {\n        logClient.logInfo(`Handling message from worker: ${type}`);\n        let uiUpdatePayload = null;\n        switch (type) {\n            case 'workerScriptReady':\n                logClient.logInfo(\"[Background] Worker SCRIPT is ready!\");\n                modelWorkerState = 'worker_script_ready';\n                if (workerScriptReadyResolver) {\n                    workerScriptReadyResolver();\n                    workerScriptReadyPromise = null;\n                }\n                uiUpdatePayload = { modelStatus: 'script_ready' };\n                break;\n            case 'workerReady':\n                logClient.logInfo(\"[Background] Worker MODEL is ready! Model:\", payload?.model);\n                modelWorkerState = 'model_ready';\n                if (modelLoadResolver) {\n                    modelLoadResolver();\n                    modelLoadPromise = null;\n                }\n                uiUpdatePayload = { modelStatus: 'model_ready', model: payload?.model };\n                if (workerScriptReadyResolver) {\n                    workerScriptReadyResolver();\n                    workerScriptReadyPromise = null;\n                }\n                break;\n            case 'loadingStatus':\n                if (payload?.status === 'progress' && payload?.progress) {\n                    const currentProgress = Math.floor(payload.progress);\n                    if (currentProgress >= lastLoggedProgress + 10) {\n                        logClient.logInfo(\"[Background] Worker loading status (progress):\", payload);\n                        lastLoggedProgress = currentProgress;\n                    }\n                } else {\n                    logClient.logInfo(\"[Background] Worker loading status (other):\", payload);\n                    lastLoggedProgress = -10;\n                }\n                if (modelWorkerState !== 'loading_model') {\n                    logClient.logWarn(`[Background] Received loadingStatus in unexpected state: ${modelWorkerState}`);\n                    modelWorkerState = 'loading_model';\n                }\n                browser.runtime.sendMessage({ type: 'uiLoadingStatusUpdate', payload: payload }).catch(err => {\n                    if (err.message !== \"Could not establish connection. Receiving end does not exist.\") {\n                        logClient.logWarn(\"[Background] Error sending loading status to UI:\", err.message);\n                    }\n                });\n                break;\n            case 'generationStatus':\n                logClient.logInfo(`[Background] Generation status: ${payload?.status}`);\n                if (payload?.status === 'generating') modelWorkerState = 'generating';\n                else if (payload?.status === 'interrupted') modelWorkerState = 'model_ready';\n                break;\n            case 'generationUpdate':\n                if (modelWorkerState !== 'generating') {\n                    logClient.logWarn(`[Background] Received generationUpdate in unexpected state: ${modelWorkerState}`);\n                }\n                modelWorkerState = 'generating';\n                break;\n            case 'generationComplete':\n                logClient.logInfo(\"[Background] Generation complete.\");\n                modelWorkerState = 'model_ready';\n                break;\n            case 'generationError':\n                logClient.logError(\"[Background] Generation error from worker:\", payload);\n                modelWorkerState = 'error';\n                break;\n            case 'resetComplete':\n                logClient.logInfo(\"[Background] Worker reset complete.\");\n                modelWorkerState = 'model_ready';\n                break;\n            case 'error':\n                logClient.logError(\"[Background] Received generic error from worker/offscreen:\", payload);\n                const previousState = modelWorkerState;\n                modelWorkerState = 'error';\n                if (previousState === 'creating_worker' && workerScriptReadyRejecter) {\n                    workerScriptReadyRejecter(new Error(payload || 'Generic error during script init'));\n                    workerScriptReadyPromise = null;\n                } else if (previousState === 'loading_model' && modelLoadRejecter) {\n                    modelLoadRejecter(new Error(payload || 'Generic error during model load'));\n                    modelLoadPromise = null;\n                }\n                uiUpdatePayload = { modelStatus: 'error', error: payload };\n                break;\n        }\n        \n        if (uiUpdatePayload) {\n            logClient.logInfo(`[Background] Sending uiUpdate to tabs:`, uiUpdatePayload);\n            browser.tabs.query({}).then(tabs => {\n                tabs.forEach(tab => {\n                    if (tab.id) {\n                        browser.tabs.sendMessage(tab.id, { type: 'uiUpdate', payload: uiUpdatePayload })\n                            .catch(err => { \n                                if (!err.message.includes('Could not establish connection') && !err.message.includes('Receiving end does not exist')) {\n                                     logClient.logWarn(`[Background] Error sending uiUpdate to tab ${tab.id}:`, err.message);\n                                }\n                            });\n                    }\n                });\n            }).catch(err => {\n                logClient.logError('[Background] Error querying tabs to send uiUpdate:', err);\n            });\n        }\n        \n        forwardMessageToSidePanelOrPopup(message, sender);\n        return false;\n    }\n\n    if (type === 'loadModel') {\n        logClient.logInfo(`Received 'loadModel' request from sender:`, sender);\n        const modelId = payload?.modelId;\n        logClient.logInfo(`Received 'loadModel' request from UI for model: ${modelId}.`);\n        if (!modelId) {\n            logClient.logError(\"[Background] 'loadModel' request missing modelId.\");\n            sendResponse({ success: false, error: \"Model ID not provided in request.\" });\n            return false;\n        }\n\n        isResponseAsync = true;\n        loadModel(modelId)\n            .then(() => {\n                logClient.logInfo(`loadModel(${modelId}) promise resolved successfully.`);\n                sendResponse({ success: true, message: `Model loading initiated or already complete for ${modelId}.` });\n            })\n            .catch(error => {\n                logClient.logError(`loadModel(${modelId}) failed:`, error);\n                sendResponse({ success: false, error: error.message });\n            });\n        return isResponseAsync;\n    }\n\n    if (type === 'sendChatMessage') {\n        isResponseAsync = true;\n        const { chatId, messages, options, messageId } = payload;\n        const correlationId = messageId || chatId;\n\n        if (modelWorkerState !== 'model_ready') {\n            logClient.logError(`Cannot send chat message. Model state is ${modelWorkerState}, not 'model_ready'.`);\n            sendResponse({ success: false, error: `Model not ready (state: ${modelWorkerState}). Please load a model first.` });\n            return false;\n        }\n\n        logClient.logInfo(`Model ready, sending generate request for ${correlationId}`);\n        sendToModelWorkerOffscreen({\n            type: 'generate',\n            payload: {\n                messages: messages,\n                max_new_tokens: options?.max_new_tokens,\n                temperature: options?.temperature,\n                top_k: options?.top_k,\n                correlationId: correlationId\n            }\n        })\n        .then(sendResult => {\n            if (!sendResult.success) throw new Error(\"Failed to send generate message initially.\");\n            logClient.logInfo(`Generate request sent for ${correlationId}. Waiting for worker responses.`);\n            sendResponse({ success: true, message: \"Generation request forwarded to worker.\"});\n        })\n        .catch(error => {\n            logClient.logError(`Error processing sendChatMessage for ${correlationId}:`, error);\n            if (modelWorkerState === 'generating') modelWorkerState = 'model_ready';\n            sendResponse({ success: false, error: error.message });\n        });\n\n        return isResponseAsync;\n    }\n\n    if (type === 'interruptGeneration') {\n        logClient.logInfo(\"[Background] Received interrupt request from UI.\");\n        ensureWorkerScriptIsReady()\n            .then(() => sendToModelWorkerOffscreen({ type: 'interrupt' }))\n            .then(() => sendResponse({ success: true }))\n            .catch(err => sendResponse({ success: false, error: err.message }));\n        isResponseAsync = true;\n        return isResponseAsync;\n    }\n\n    if (type === 'resetWorker') {\n        logClient.logInfo(\"[Background] Received reset request from UI.\");\n        ensureWorkerScriptIsReady()\n            .then(() => sendToModelWorkerOffscreen({ type: 'reset' }))\n            .then(() => sendResponse({ success: true }))\n            .catch(err => sendResponse({ success: false, error: err.message }));\n        isResponseAsync = true;\n        return isResponseAsync;\n    }\n\n    if (type === 'getModelWorkerState') {\n        logClient.logInfo(`Handling 'getModelWorkerState' request. Current state: ${modelWorkerState}`);\n        sendResponse({ success: true, state: modelWorkerState });\n        return false;\n    }\n\n    if (type === 'scrapeRequest') {\n        logClient.logInfo(`Handling 'scrapeRequest' request. Scraping URL: ${payload?.url}`);\n        isResponseAsync = true;\n        scrapeUrlMultiStage(payload?.url, payload?.chatId, payload?.messageId)\n            .then(() => {\n                logClient.logInfo(`scrapeRequest(${payload?.url}) promise resolved successfully.`);\n                sendResponse({ success: true, message: `Scraping orchestrator started for ${payload?.url}.` });\n            })\n            .catch(error => {\n                logClient.logError(`scrapeRequest(${payload?.url}) failed:`, error);\n                sendResponse({ success: false, error: error.message });\n            });\n        return isResponseAsync;\n    }\n\n    if (type === 'getDriveFileList') {\n        const receivedFolderId = message.folderId;\n        logClient.logInfo(`Handling 'getDriveFileList' for folder: ${receivedFolderId}`);\n        isResponseAsync = true;\n        (async () => {\n            try {\n                const token = await getDriveToken();\n                const files = await fetchDriveFileList(token, receivedFolderId);\n                logClient.logInfo(`Successfully fetched ${files?.length || 0} files/folders.`);\n\n                // Send file list via separate sendMessage\n                logClient.logInfo('[Background] Sending driveFileListData...');\n                browser.runtime.sendMessage({\n                    type: 'driveFileListData',\n                    success: true,\n                    files: files,\n                    folderId: receivedFolderId\n                }).catch(err => {\n                     logClient.logWarn('[Background] Failed to send driveFileListData:', err?.message);\n                     browser.runtime.sendMessage({ type: 'driveFileListData', success: false, error: `Failed to send data: ${err?.message}` , folderId: receivedFolderId });\n                });\n\n                logClient.logInfo('[Background] sendResponse for driveFileListResponse skipped (using separate message).');\n\n            } catch (error) {\n                logClient.logError(\"Error handling getDriveFileList:\", error);\n                // Send error via separate message too\n                browser.runtime.sendMessage({\n                     type: 'driveFileListData',\n                     success: false,\n                     error: error.message,\n                     folderId: receivedFolderId\n                 }).catch(err => {\n                     logClient.logWarn('[Background] Failed to send driveFileListData error message:', err?.message);\n                 });\n                 logClient.logInfo('[Background] sendResponse for driveFileListResponse error skipped (using separate message).');\n            }\n        })();\n        return isResponseAsync;\n    }\n\n    if (type.startsWith('db:')) {\n        logClient.logDebug(`Forwarding DB request of type '${type}' to event bus.`);\n        eventBus.publish(type, message);\n        return false;\n    }\n\n    if (type === 'getLogSessions') {\n        isResponseAsync = true;\n        (async () => {\n            try {\n                const { logSessions: sessions } = await browser.storage.local.get('logSessions');\n                sendResponse({ success: true, sessions: sessions || [] });\n            } catch (err) {\n                logClient.logError(\"Error fetching log sessions:\", err);\n                sendResponse({ success: false, error: err.message });\n            }\n        })();\n        return isResponseAsync;\n    }\n\n    if (type === 'getLogEntries') {\n        isResponseAsync = true;\n        (async () => {\n            const sessionId = payload?.sessionId;\n            if (!sessionId) {\n                sendResponse({ success: false, error: 'Session ID required' });\n                return true;\n            }\n            try {\n                const key = `logs_${sessionId}`;\n                const result = await browser.storage.local.get(key);\n                sendResponse({ success: true, entries: result[key] || [] });\n            } catch (err) {\n                logClient.logError(`Error fetching log entries for ${sessionId}:`, err);\n                sendResponse({ success: false, error: err.message });\n            }\n        })();\n        return isResponseAsync;\n    }\n\n    if (type === 'detachSidePanel') {\n        isResponseAsync = true;\n        handleDetach(sender.tab?.id).then(result => {\n            sendResponse(result);\n        }).catch(error => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return isResponseAsync;\n    }\n\n    if (type === 'getDetachedState') {\n        isResponseAsync = true;\n        (async () => {\n            try {\n                const { [`detachedState_${sender.tab?.id}`]: state } = await browser.storage.local.get(`detachedState_${sender.tab?.id}`);\n                sendResponse({ success: true, state: state });\n            } catch (error) {\n                sendResponse({ success: false, error: error.message });\n            }\n        })();\n        return isResponseAsync;\n    }\n\n    logClient.logWarn(`Unhandled message type: ${type}`);\n    return false;\n});\n\nlogClient.logInfo(\"[Background-Simple] Script loaded and listening.\");"],"names":["EventNames.DB_INITIALIZATION_COMPLETE_NOTIFICATION","currentLogSessionId","logClient.init","logClient.logInfo","logClient.logDebug","logClient.logError","logClient.logWarn","_a"],"mappings":"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"}