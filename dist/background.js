const h="src/offscreen.html";let p={},m={};async function $(){const r=(await chrome.declarativeNetRequest.getDynamicRules()).map(o=>o.id),t=[{id:1,priority:1,action:{type:"modifyHeaders",responseHeaders:[{header:"x-frame-options",operation:"remove"},{header:"X-Frame-Options",operation:"remove"},{header:"content-security-policy",operation:"remove"},{header:"Content-Security-Policy",operation:"remove"}]},condition:{resourceTypes:["main_frame"],urlFilter:"|http*://*/*|"}}],n=r.filter(o=>o===1);try{await chrome.declarativeNetRequest.updateDynamicRules({removeRuleIds:n,addRules:t}),console.log("Declarative Net Request rules updated successfully.")}catch(o){console.error("Error updating Declarative Net Request rules:",o)}}$();async function v(e){return(await chrome.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[chrome.runtime.getURL(e)]})).length>0}async function y(e,r,t){if(await v(e)){console.log(`Background: Offscreen document at ${e} already exists.`);return}const n=e.split("/").pop();console.log(`Background: Creating offscreen document using filename: ${n}...`),await chrome.offscreen.createDocument({url:n,reasons:r,justification:t}),console.log(`Background: Offscreen document created successfully using ${n}.`)}async function T(e){if(console.log(`[Stage 1] Attempting Offscreen Direct: ${e}`),!e||!e.startsWith("http"))throw new Error(`Invalid URL: ${e}`);await y(h,["IFRAME_SCRIPTING"],"Load Google Picker API and handle external scripts/UI");let r;try{const t=await fetch(e);if(!t.ok)throw new Error(`HTTP ${t.status}`);r=await t.text(),console.log(`[Stage 1] Fetched HTML (${r.length} bytes)`)}catch(t){throw new Error(`Failed to fetch URL: ${t.message}`)}console.log("[Stage 1] Sending HTML to offscreen document...");try{const t=await chrome.runtime.sendMessage({type:"parseHTML",target:"offscreen",htmlContent:r});if(console.log("[Stage 1] Received response from offscreen:",t),t!=null&&t.success&&t.article)return t.article;throw t!=null&&t.success&&t.article===null?new Error("Readability found no content (offscreen)."):new Error(`Offscreen parsing error: ${(t==null?void 0:t.error)||"Invalid response format"}`)}catch(t){throw console.error("[Stage 1] Communication/Parsing error with offscreen:",t),new Error(`Offscreen stage failed: ${t.message}`)}}async function E(e){console.log(`[Stage 2] Attempting Offscreen + iframe: ${e}`);const r="offscreen-scrape-",t="offscreenIframeResult",n=3e4;let o=null;const s=async c=>{if(console.log(`[Stage 2 Cleanup] Starting cleanup for script ID base: ${c}`),c)try{await chrome.scripting.unregisterContentScripts({ids:[c]}),console.log(`[Stage 2 Cleanup] Unregistered script: ${c}`)}catch(a){console.warn(`[Stage 2 Cleanup] Failed to unregister script ${c}:`,a)}try{await chrome.runtime.sendMessage({type:"removeIframe",target:"offscreen"}),console.log("[Stage 2 Cleanup] Sent removeIframe request to offscreen.")}catch(a){console.warn("[Stage 2 Cleanup] Failed to send removeIframe request: ",a)}};try{await y(h,["IFRAME_SCRIPTING"],"Load Google Picker API and handle external scripts/UI"),console.log("[Stage 2] Sending createIframe request to offscreen...");const c=await chrome.runtime.sendMessage({type:"createIframe",target:"offscreen",url:e});if(!(c!=null&&c.success))throw new Error(`Failed to create iframe in offscreen: ${(c==null?void 0:c.error)||"Unknown error"}`);console.log("[Stage 2] Iframe creation request successful. Waiting for load and script..."),o=`${r}${Date.now()}`,await chrome.scripting.registerContentScripts([{id:o,js:["Readability.js","webScraper.js","scriptingReadabilityHelper.js"],matches:[e],runAt:"document_idle",world:"ISOLATED",allFrames:!0,persistAcrossSessions:!1}]),console.log(`[Stage 2] Registered dynamic script(s): ${o} (files: Readability.js, webScraper.js, scriptingReadabilityHelper.js)`);let a=null;const i=await new Promise((d,f)=>{const g=setTimeout(()=>{console.warn(`[Stage 2] Timeout (${n/1e3}s) waiting for response from dynamic script.`),a&&chrome.runtime.onMessage.removeListener(a),f(new Error("Timeout waiting for dynamic script response."))},n);a=(u,I,_)=>{var w,b;return(u==null?void 0:u.type)===t&&(console.log("[Stage 2] Received response from dynamic script:",u.payload),clearTimeout(g),chrome.runtime.onMessage.removeListener(a),(w=u.payload)!=null&&w.success?d(u.payload):f(new Error(((b=u.payload)==null?void 0:b.error)||"Dynamic script reported failure."))),!1},chrome.runtime.onMessage.addListener(a),console.log("[Stage 2] Listener added for dynamic script response.")});return await s(o),i}catch(c){throw console.error("[Stage 2] Error during Offscreen + iframe process:",c),await s(o),new Error(`Stage 2 (Offscreen + iframe) failed: ${c.message}`)}}async function R(e){console.log(`[Stage 3] Attempting Temp Tab + executeScript: ${e}`);let r=null;const t=3e4;function n(){if(typeof Readability>"u")return console.error("[Stage 3 ExecuteScript] Readability class is not available."),{success:!1,error:"Readability library not found in tab context."};try{const o=document.cloneNode(!0),s=new Readability(o).parse();return{success:!0,title:s?s.title:"",textContent:s?s.textContent:"",content:s?s.content:"",byline:s?s.byline:"",length:s?s.length:0,excerpt:s?s.excerpt:"",siteName:s?s.siteName:""}}catch(o){return console.error("[Stage 3 ExecuteScript] Error running Readability:",o),{success:!1,error:`Readability execution failed: ${o.message}`}}}return new Promise(async(o,s)=>{const c=i=>{console.warn(`[Stage 3] Cleanup: ${i}`),r&&(chrome.tabs.remove(r).catch(d=>console.warn(`[Stage 3] Error removing tab ${r}: ${d.message}`)),r=null),s(new Error(i))};try{if(r=(await chrome.tabs.create({url:e,active:!1})).id,!r)throw new Error("Failed to get temporary tab ID.");console.log(`[Stage 3] Created temp tab ${r} for executeScript.`)}catch(i){return s(new Error(`Failed to create temp tab: ${i.message}`))}let a=null;const l=new Promise((i,d)=>{const f=(g,u,I)=>{g===r&&u.status==="complete"&&(console.log(`[Stage 3] Tab ${r} loaded.`),a&&clearTimeout(a),chrome.tabs.onUpdated.removeListener(f),i())};chrome.tabs.onUpdated.addListener(f),a=setTimeout(()=>{chrome.tabs.onUpdated.removeListener(f),d(new Error(`Timeout (${t/1e3}s) waiting for page load.`))},t)});try{await l}catch(i){return c(`Load failed or timed out: ${i.message}`)}console.log(`[Stage 3] Executing script in tab ${r}`);try{const i=await chrome.scripting.executeScript({target:{tabId:r},func:n});if(r&&(chrome.tabs.remove(r).catch(d=>console.warn(`[Stage 3] Error removing tab ${r} post-execute: ${d.message}`)),r=null),i&&i.length>0&&i[0].result){const d=i[0].result;d.success?(console.log("[Stage 3] executeScript succeeded."),o(d)):s(new Error(d.error||"executeScript function reported failure."))}else{const d=chrome.runtime.lastError?chrome.runtime.lastError.message:"No result returned";s(new Error(`executeScript failed: ${d}`))}}catch(i){c(`executeScript call failed: ${i.message}`)}})}async function C(e){console.log(`[Stage 4] Attempting Temp Tab + Content Script: ${e}`);let r=null;const t=3e4;return new Promise(async(n,o)=>{const s=l=>{r&&(chrome.tabs.remove(r).catch(i=>{}),r=null),o(new Error(l))};try{if(r=(await chrome.tabs.create({url:e,active:!1})).id,!r)throw new Error("Failed to get temporary tab ID.");console.log(`[Stage 4] Created temp tab ${r}`)}catch(l){return o(new Error(`Failed to create temp tab: ${l.message}`))}let c=null;const a=new Promise((l,i)=>{const d=(f,g,u)=>{f===r&&g.status==="complete"&&(console.log(`[Stage 4] Tab ${r} loaded.`),c&&clearTimeout(c),chrome.tabs.onUpdated.removeListener(d),l())};chrome.tabs.onUpdated.addListener(d),c=setTimeout(()=>{chrome.tabs.onUpdated.removeListener(d),i(new Error("Timeout waiting for page load."))},t)});try{await a}catch(l){return s(l.message)}console.log(`[Stage 4] Sending SCRAPE_PAGE to content script in tab ${r}`);try{const l=await chrome.tabs.sendMessage(r,{type:"SCRAPE_PAGE"});r&&chrome.tabs.remove(r).catch(i=>{}),r=null,l!=null&&l.success?(console.log("[Stage 4] Success from content script."),n(l)):o(new Error((l==null?void 0:l.error)||"Content script failed or gave invalid response."))}catch(l){s(`Messaging content script failed: ${l.message}`)}})}async function k(e,r,t){console.log(`Scraping Orchestrator: Starting for ${e}. ChatID: ${r}, MessageID: ${t}`);let n;try{const o=await T(e);console.log(`Scraping Orchestrator: Stage 1 (Offscreen) Succeeded for ${e}.`),n={chatId:r,messageId:t,success:!0,method:"offscreenDirect",url:e,title:o.title,textContent:o.textContent,content:o.content,byline:o.byline,length:o.length,excerpt:o.excerpt,siteName:o.siteName}}catch(o){console.warn(`Scraping Orchestrator: Stage 1 (Offscreen Direct) Failed for ${e}: ${o.message}`);try{const s=await E(e);console.log(`Scraping Orchestrator: Stage 2 (Offscreen + iframe) Succeeded for ${e}.`),n={chatId:r,messageId:t,success:!0,method:"offscreenIframe",url:e,...s}}catch(s){console.warn(`Scraping Orchestrator: Stage 2 (Offscreen + iframe) Failed for ${e}: ${s.message}`);try{const c=await R(e);console.log(`Scraping Orchestrator: Stage 3 (Temp Tab + executeScript) Succeeded for ${e}.`),n={chatId:r,messageId:t,success:!0,method:"tempTabExecuteScript",url:e,...c}}catch(c){console.warn(`Scraping Orchestrator: Stage 3 (Temp Tab + executeScript) Failed for ${e}: ${c.message}`);try{const a=await C(e);console.log(`Scraping Orchestrator: Stage 4 (Temp Tab + Content Script) Succeeded for ${e}.`),n={chatId:r,messageId:t,success:!0,method:"tempTabContentScript",url:e,...a}}catch(a){console.error(`Scraping Orchestrator: Stage 4 (Temp Tab + Content Script) Failed for ${e}: ${a.message}`),n={chatId:r,messageId:t,success:!1,url:e,error:a.message||"Scraping failed using all available methods."}}}}}return n}chrome.runtime.onInstalled.addListener(()=>{chrome.sidePanel.setPanelBehavior({openPanelOnActionClick:!0}).catch(e=>console.error("Error setting side panel behavior:",e)),console.log("Tab Agent background: Side panel behavior set (default open on click)."),chrome.storage.local.get(null,e=>{const r=Object.keys(e).filter(t=>t.startsWith("detachedState_"));r.length>0&&chrome.storage.local.remove(r,()=>{console.log("Cleaned up old detached states on install/update.")})})});chrome.action.onClicked.addListener(async e=>{if(!e.id){console.error("Action Clicked: Missing tab ID.");return}const r=e.id;console.log(`Action clicked for tab ${r}`);const t=p[r];if(t){console.log(`Popup ${t} exists for tab ${r}. Attempting to close popup.`);try{await chrome.windows.remove(t),console.log(`Closed popup window ${t} via action click.`)}catch(n){if(console.warn(`Failed to close popup ${t} via action click, maybe already closed?`,n),m[t]){console.log(`Force cleaning maps and storage for tab ${r} after failed close.`),delete p[r],delete m[t];try{await chrome.storage.local.remove(`detachedState_${r}`),await chrome.sidePanel.setOptions({tabId:r,enabled:!0})}catch(o){console.error("Error during defensive cleanup:",o)}}}}else console.log(`No popup exists for tab ${r}. Default side panel opening behavior should trigger.`)});chrome.windows.onRemoved.addListener(async e=>{console.log(`Window removed: ${e}`);const r=m[e];if(r){console.log(`Popup window ${e} for tab ${r} was closed.`),delete p[r],delete m[e];try{await chrome.storage.local.remove(`detachedState_${r}`),console.log(`Removed detached state from storage for tab ${r}`),await chrome.sidePanel.setOptions({tabId:r,enabled:!0}),console.log(`Re-enabled side panel for tab ${r} after popup closed.`)}catch(t){console.error(`Error cleaning up storage or re-enabling side panel for tab ${r} on popup close:`,t)}}else console.log(`Window ${e} closed, but it wasn't a tracked popup.`)});chrome.runtime.onMessage.addListener((e,r,t)=>{if(console.log("Background: Received message:",e,"from sender:",r),e.type==="query"){const{text:n,model:o,tabId:s,chatId:c,messageId:a}=e;if(!c||!a)return console.error("Background: Received query without chatId or messageId.",e),a&&chrome.runtime.sendMessage({type:"error",chatId:c||"unknown",messageId:a,error:"Missing chat/message ID in query request"}).catch(i=>console.warn("BG: Error sending missing ID error back:",i)),t({success:!1,error:"Missing chat/message ID in query"}),!1;console.log(`Background: Processing query "${n}" for model "${o}". ChatID: ${c}, MessageID: ${a}`);const l=`(Tab ${s||"N/A"}) Background received: "${n}". Agent logic for ${o} not implemented.`;return setTimeout(()=>{try{chrome.runtime.sendMessage({type:"response",chatId:c,messageId:a,text:l}).catch(i=>console.warn(`BG: Could not send response for ${a}, context likely closed.`,i)),console.log(`Background: Sent placeholder response for ${a}.`)}catch(i){console.warn(`Background: Error sending placeholder response for ${a}`,i),chrome.runtime.sendMessage({type:"error",chatId:c,messageId:a,error:`Failed to send response: ${i.message}`}).catch(d=>console.warn(`BG: Could not send error message for ${a} after initial failure.`,d))}},500),t({success:!0,message:"Query received, processing..."}),!0}else if(e.type==="getTabId")if(r.tab&&r.tab.id){try{t({type:"tabIdResponse",tabId:r.tab.id})}catch{console.warn("BG: Could not send tabId response")}return!1}else return chrome.tabs.query({active:!0,currentWindow:!0},n=>{if(n&&n.length>0)try{t({type:"tabIdResponse",tabId:n[0].id})}catch{console.warn("BG: Could not send tabId response (fallback)")}else{console.warn("Background: 'getTabId' fallback could not find active tab.");try{t({type:"error",error:"Could not determine sender tab ID (no active tab)."})}catch{console.warn("BG: Could not send tabId error response (fallback)")}}}),!0;else{if(e.type==="popupCreated")return e.popupId&&e.tabId?(p[e.tabId]=e.popupId,m[e.popupId]=e.tabId,console.log(`Background: Tracked popup ${e.popupId} for tab ${e.tabId}`)):console.error("Background: Invalid 'popupCreated' message:",e),!1;if(e.type==="getPopupForTab"){const n=p[e.tabId];return t(n?{popupId:n}:{popupId:null}),!1}else if(e.type==="TEMP_SCRAPE_URL"){const n=e.url,{chatId:o,messageId:s}=e;return e.tabId||r.tab&&r.tab.id,!o||!s?(console.error("Background: Received TEMP_SCRAPE_URL without chatId or messageId.",e),!1):(console.log(`Background: Received TEMP_SCRAPE_URL for: ${n}. ChatID: ${o}, MessageID: ${s}. Starting multi-stage scrape.`),(async()=>{const c=await k(n,o,s);console.log("[Background Listener] Sending final scrape result:",c);try{chrome.runtime.sendMessage({type:"TEMP_SCRAPE_RESULT",payload:c}).catch(a=>console.warn("[Background Listener] Failed to send final scrape result:",a))}catch(a){console.warn("[Background Listener] Synchronous error sending final scrape result:",a)}})(),t({success:!0,message:"Scrape request received."}),!1)}else if(e.type==="requestDriveFileList"){const n=e.folderId||"root";return console.log(`Background: Received requestDriveFileList for folder: ${n}`),(async()=>{let o=null,s=null;try{const c=await S();o=await D(c,n)}catch(c){console.error(`Background: Error handling requestDriveFileList (Folder: ${n}):`,c),s=c.message||"Unknown error fetching file list."}chrome.runtime.sendMessage({type:"driveFileListResponse",success:!s,folderId:n,files:o,error:s}).catch(c=>console.warn("Background: Failed to send driveFileListResponse",c))})(),t({success:!0,message:"Request received, fetching file list..."}),!0}else if(e.type==="fetchDriveFileContent"){const{fileId:n,fileName:o}=e;return console.log(`Background: Received fetchDriveFileContent for ID: ${n}`),n?((async()=>{let s=null,c=null;try{const a=await S();s=await P(a,n)}catch(a){console.error(`Background: Error handling fetchDriveFileContent for ${n}:`,a),c=a.message||"Unknown error fetching file content."}chrome.runtime.sendMessage({type:"driveFileContentResponse",success:!c,fileId:n,fileName:o,content:s,error:c}).catch(a=>console.warn("Background: Failed to send driveFileContentResponse",a))})(),t({success:!0,message:"Request received, fetching file content..."}),!0):(console.error("Background: fetchDriveFileContent missing fileId"),!1)}else{if(e.target==="offscreen"&&(e.type==="parseHTML"||e.type==="createIframe"||e.type==="removeIframe"))return console.log(`Background: Forwarding ${e.type} message to parsing offscreen document.`),(async()=>{const n=h;try{await y(n,["DOM_PARSER","IFRAME_SCRIPTING"],"Parse HTML content and manage scraping iframes");const o=await chrome.runtime.sendMessage(e);console.log(`Background: Received response from parsing offscreen for ${e.type}:`,o)}catch(o){console.error(`Background: Error ensuring/communicating with parsing offscreen document for ${e.type}:`,o)}})(),!1;if(e.target==="offscreen_google_drive")return console.warn("Background: Received message explicitly targeted to 'offscreen_google_drive' outside of picker initiation flow. Ignoring."),!1;console.log("Background: Received unknown message type:",e.type);try{t({type:"error",error:"Unknown message type received by background script."})}catch{console.warn("Background: Could not send error response for unknown message type.")}return!1}}});console.log("Tab Agent background script loaded and listening for messages.");async function S(){return new Promise((e,r)=>{chrome.identity.getAuthToken({interactive:!0},t=>{chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):e(t)})})}async function D(e,r="root"){var i;const t="files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)",n=`'${r}' in parents and trashed=false`,o=100,s="folder,modifiedTime desc",c=`https://www.googleapis.com/drive/v3/files?${new URLSearchParams({pageSize:o.toString(),q:n,fields:t,orderBy:s})}`;console.log(`Background: Fetching Drive list for folder '${r}': ${c}`);const a=await fetch(c,{headers:{Authorization:`Bearer ${e}`,Accept:"application/json"}});if(!a.ok){const d=await a.text();throw console.error(`Background: Drive API files.list error (Folder: ${r}):`,a.status,d),a.status===404?new Error(`Folder with ID '${r}' not found or access denied.`):new Error(`Drive API Error ${a.status} (Folder: ${r}): ${d||a.statusText}`)}const l=await a.json();return console.log(`Background: Drive API files.list success (Folder: ${r}). Found ${((i=l.files)==null?void 0:i.length)||0} items.`),l.files||[]}async function P(e,r){return console.warn(`Background: fetchDriveFileContent not implemented yet for fileId: ${r}`),`(Content fetch not implemented for ${r})`}
