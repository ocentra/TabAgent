{"version":3,"file":"background.js","sources":["../src/background.js"],"sourcesContent":["const OFFSCREEN_DOCUMENT_PATH = 'offscreen.html';\nconst MODEL_WORKER_OFFSCREEN_PATH = 'offscreenWorker.html'; // New path for model worker offscreen doc\n\nlet detachedPopups = {};\nlet popupIdToTabId = {};\n\nconst DNR_RULE_ID_1 = 1;\nconst DNR_RULE_PRIORITY_1 = 1;\n\n// ------------ Model Worker Offscreen Communication (New) ------------\n\n// Possible states: 'uninitialized', 'creating_worker', 'worker_script_ready', 'loading_model', 'model_ready', 'generating', 'error'\nlet modelWorkerState = 'uninitialized';\nlet workerScriptReadyPromise = null; // Promise resolved when worker script is loaded\nlet workerScriptReadyResolver = null;\nlet workerScriptReadyRejecter = null;\nlet modelLoadPromise = null; // Promise resolved when model finishes loading\nlet modelLoadResolver = null;\nlet modelLoadRejecter = null;\n\n// Keep track of active generation requests to route back responses\n// Key: correlationId (e.g., messageId or chatId), Value: { sender, resolve, reject, ... }\nlet activeGenerations = {};\n\n// Helper to check if the dedicated model worker offscreen document exists\nasync function hasModelWorkerOffscreenDocument() {\n    const targetUrl = chrome.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH);\n    const existingContexts = await chrome.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    return existingContexts.length > 0;\n}\n\n// Function to create the offscreen document for the model worker if it doesn't exist\nasync function setupModelWorkerOffscreenDocument() {\n    if (await hasModelWorkerOffscreenDocument()) {\n        console.log(\"Background: Model worker offscreen document already exists.\");\n        return;\n    }\n    console.log(\"Background: Creating model worker offscreen document...\");\n    await chrome.offscreen.createDocument({\n        url: MODEL_WORKER_OFFSCREEN_PATH,\n        reasons: [chrome.offscreen.Reason.WORKERS], // Specify reason for worker usage\n        justification: 'Run model inference in a separate worker via offscreen document',\n    });\n    console.log(\"Background: Model worker offscreen document created.\");\n}\n\n// Function to send a message to the model worker via the offscreen document\nasync function sendToModelWorkerOffscreen(message) {\n    // Ensure the worker script is at least ready before sending operational messages like 'init' or 'generate'\n    if (message.type !== 'init' && message.type !== 'generate' && message.type !== 'interrupt' && message.type !== 'reset') {\n        // For other messages, just ensure the doc potentially exists\n         if (modelWorkerState === 'uninitialized' || !(await hasModelWorkerOffscreenDocument())){\n             console.log(`Background: Ensuring model worker offscreen doc potentially exists before sending ${message?.type}`);\n             await setupModelWorkerOffscreenDocument();\n        }\n    } else {\n        // For core operations, wait until the worker script is confirmed running\n        console.log(`Background: Ensuring worker script is ready before sending ${message.type}...`);\n        try {\n            await ensureWorkerScriptIsReady(); // Wait for worker script to load\n            console.log(`Background: Worker script confirmed ready. Proceeding to send ${message.type}.`);\n        } catch (error) {\n             console.error(`Background: Worker script failed to become ready. Cannot send ${message.type}. Error:`, error);\n             modelWorkerState = 'error';\n             throw new Error(`Worker script failed to initialize, cannot send ${message.type}.`);\n        }\n    }\n\n\n    console.log(`Background: Sending message type '${message?.type}' to model worker offscreen doc`);\n    try {\n        // The message goes to the offscreen script, which forwards it to the worker\n        // Use a more robust way to target the specific offscreen document if multiple exist\n        const contexts = await chrome.runtime.getContexts({\n             contextTypes: ['OFFSCREEN_DOCUMENT'],\n             documentUrls: [chrome.runtime.getURL(MODEL_WORKER_OFFSCREEN_PATH)]\n        });\n        if (contexts.length > 0) {\n             // Send the message generally; the listener in the target offscreen document will pick it up.\n            chrome.runtime.sendMessage(message);\n            // Fallback if direct contextId messaging isn't supported:\n            // await chrome.runtime.sendMessage(message); // Original broadcast method\n        console.log(`Background: Message type '${message?.type}' sent to offscreen.`);\n        return { success: true };\n        } else {\n             console.error(`Background: Could not find target offscreen document context to send ${message?.type}.`);\n             throw new Error(`Target offscreen document not found.`);\n        }\n    } catch (error) {\n        console.error(`Background: Error sending message type '${message?.type}' to offscreen:`, error);\n        // Don't close the document here, worker might still be recoverable or state handled via messages\n        modelWorkerState = 'error'; // Mark state as error on send failure\n\n        // Reject relevant promise if send fails\n        if (message.type === 'init') {\n            if(modelLoadRejecter) modelLoadRejecter(new Error(`Failed to send init message: ${error.message}`));\n            modelLoadPromise = null;\n        } else if (workerScriptReadyRejecter && (modelWorkerState === 'uninitialized' || modelWorkerState === 'creating_worker')) {\n            // If sending fails very early, reject script ready promise\n            workerScriptReadyRejecter(new Error(`Failed to send message early: ${error.message}`));\n            workerScriptReadyPromise = null;\n        }\n\n        throw new Error(`Failed to send message to model worker offscreen: ${error.message}`);\n    }\n}\n\n// Function to ensure the worker SCRIPT is ready (doesn't wait for model)\nfunction ensureWorkerScriptIsReady() {\n    console.log(`[ensureWorkerScriptIsReady] Current state: ${modelWorkerState}`);\n    if (modelWorkerState !== 'uninitialized' && modelWorkerState !== 'creating_worker') {\n         // If it's loading_model, model_ready, generating, or error, the script *was* ready\n         if(modelWorkerState === 'error' && !workerScriptReadyPromise) {\n             return Promise.reject(new Error(\"Worker script initialization previously failed.\"));\n         }\n        return Promise.resolve(); // Script is already loaded or beyond that stage\n    }\n    if (workerScriptReadyPromise) {\n        return workerScriptReadyPromise; // Return existing promise\n    }\n\n    console.log(\"[ensureWorkerScriptIsReady] Worker script not ready. Initializing and creating promise.\");\n    modelWorkerState = 'creating_worker'; // New state indicating setup is in progress\n    workerScriptReadyPromise = new Promise((resolve, reject) => {\n        workerScriptReadyResolver = resolve;\n        workerScriptReadyRejecter = reject;\n\n        setupModelWorkerOffscreenDocument().catch(err => {\n             console.error(\"[ensureWorkerScriptIsReady] Error setting up offscreen doc:\", err);\n             modelWorkerState = 'error';\n             if(workerScriptReadyRejecter) workerScriptReadyRejecter(err);\n             workerScriptReadyPromise = null;\n        });\n        // Now we wait for the 'workerScriptReady' message from the worker itself\n    });\n\n    // Optional: Timeout for script loading itself (shorter than model load)\n    const scriptLoadTimeout = 30000; // 30 seconds\n    setTimeout(() => {\n        if (modelWorkerState === 'creating_worker' && workerScriptReadyRejecter) {\n            console.error(`[ensureWorkerScriptIsReady] Timeout (${scriptLoadTimeout}ms) waiting for workerScriptReady.`);\n            workerScriptReadyRejecter(new Error('Timeout waiting for model worker script to load.'));\n            modelWorkerState = 'error';\n            workerScriptReadyPromise = null;\n        }\n    }, scriptLoadTimeout);\n\n\n    return workerScriptReadyPromise;\n}\n\n// Function to initiate and wait for the MODEL to load (called after UI interaction)\nasync function loadModel(modelId) {\n    console.log(`[loadModel] Request to load model: ${modelId}. Current state: ${modelWorkerState}`);\n\n    // Ensure the worker script itself is ready and the offscreen doc exists\n    try {\n        await ensureWorkerScriptIsReady(); // Wait for the worker setup promise\n        console.log(`[loadModel] Worker script confirmed ready (state: ${modelWorkerState}). Proceeding with model load.`);\n    } catch (err) {\n        console.error(\"[loadModel] Failed to ensure worker script readiness:\", err);\n        throw new Error(`Failed to ensure worker script readiness: ${err.message}`);\n    }\n\n    // Now check the state again, it *should* be ready, but double-check\n    if (modelWorkerState !== 'worker_script_ready' && modelWorkerState !== 'idle' && modelWorkerState !== 'error') {\n        const errorMsg = `Cannot load model '${modelId}'. Worker state is '${modelWorkerState}', expected 'worker_script_ready', 'idle', or 'error'.`;\n        console.error(\"[loadModel] State check failed:\", errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    if (!modelId) {\n        return Promise.reject(new Error(\"Cannot load model: Model ID not provided.\"));\n    }\n    console.log(`[loadModel] Request to load model: ${modelId}. Current state: ${modelWorkerState}`);\n\n    // Check if the *correct* model is already loaded or loading\n    // (Requires tracking the currently loaded/loading model ID - TODO)\n    // For now, we assume any 'model_ready' or 'loading_model' state is for the requested model\n    // A more robust implementation would track the specific model ID.\n    if (modelWorkerState === 'model_ready') {\n        console.log(`[loadModel] Model appears ready. Assuming it's ${modelId}.`);\n        return Promise.resolve();\n    }\n    if (modelWorkerState === 'loading_model' && modelLoadPromise) {\n        console.log(`[loadModel] Model is already loading. Assuming it's ${modelId}.`);\n        return modelLoadPromise;\n    }\n    if (modelWorkerState !== 'worker_script_ready') {\n        console.error(\"[loadModel] Cannot load model. Worker script is not ready. State:\", modelWorkerState);\n        return Promise.reject(new Error(`Cannot load model, worker script not ready (state: ${modelWorkerState})`));\n    }\n\n    console.log(`[loadModel] Worker script ready. Initiating load for model: ${modelId}.`);\n    modelWorkerState = 'loading_model';\n    // TODO: Store the modelId being loaded\n    modelLoadPromise = new Promise((resolve, reject) => {\n        modelLoadResolver = resolve;\n        modelLoadRejecter = reject;\n\n        // Send the 'init' message with the specific modelId\n        console.log(`[loadModel] Attempting to send 'init' message for model: ${modelId}`);\n        sendToModelWorkerOffscreen({ type: 'init', payload: { modelId: modelId } })\n            .catch(err => {\n                console.error(`[loadModel] Failed to send 'init' message for ${modelId}:`, err);\n                modelWorkerState = 'error'; // Set state back\n                if (modelLoadRejecter) modelLoadRejecter(err);\n                modelLoadPromise = null;\n            });\n    });\n\n    // Optional: Timeout for the full model load\n    const modelLoadTimeout = 300000; // 5 minutes\n    setTimeout(() => {\n        if (modelWorkerState === 'loading_model' && modelLoadRejecter) {\n            console.error(`[loadModel] Timeout (${modelLoadTimeout}ms) waiting for model ${modelId} load completion.`);\n            modelLoadRejecter(new Error(`Timeout waiting for model ${modelId} to load.`));\n            modelWorkerState = 'error';\n            modelLoadPromise = null;\n        }\n    }, modelLoadTimeout);\n\n    return modelLoadPromise;\n}\n\n// ------------ End Model Worker Comms ------------\n\n// --- DNR Rule Setup (Unchanged) ---\nasync function updateDeclarativeNetRequestRules() {\n    const currentRules = await chrome.declarativeNetRequest.getDynamicRules();\n    const currentRuleIds = currentRules.map(rule => rule.id);\n\n    const rulesToAdd = [\n        {\n            id: DNR_RULE_ID_1,\n            priority: DNR_RULE_PRIORITY_1,\n            action: {\n                type: 'modifyHeaders',\n                responseHeaders: [\n                    { header: 'x-frame-options', operation: 'remove' },\n                    { header: 'X-Frame-Options', operation: 'remove' },\n                    { header: 'content-security-policy', operation: 'remove' },\n                    { header: 'Content-Security-Policy', operation: 'remove' }\n                ]\n            },\n            condition: {\n                resourceTypes: ['main_frame'],\n                urlFilter: '|http*://*/*|'\n            }\n        }\n    ];\n\n    const rulesToRemove = currentRuleIds.filter(id => id === DNR_RULE_ID_1);\n\n    try {\n        await chrome.declarativeNetRequest.updateDynamicRules({\n            removeRuleIds: rulesToRemove,\n            addRules: rulesToAdd\n        });\n        console.log(\"Declarative Net Request rules updated successfully.\");\n    } catch (error) {\n        console.error(\"Error updating Declarative Net Request rules:\", error);\n    }\n}\nupdateDeclarativeNetRequestRules();\n\n// --- Original Offscreen Document Setup (for scraping/parsing, keep if used) ---\n// Make sure this uses OFFSCREEN_DOCUMENT_PATH, not MODEL_WORKER_OFFSCREEN_PATH\nasync function hasOffscreenDocument(path) {\n    const filename = path.split('/').pop();\n    const targetUrl = chrome.runtime.getURL(filename);\n    console.log(`[Debug] hasOffscreenDocument: Checking for URL: ${targetUrl}`);\n    const existingContexts = await chrome.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [targetUrl]\n    });\n    console.log(`[Debug] hasOffscreenDocument: Found ${existingContexts.length} matching contexts.`);\n    return existingContexts.length > 0;\n}\n\nasync function setupOffscreenDocument(path, reasons, justification) {\n    if (await hasOffscreenDocument(path)) {\n        console.log(`Background: Offscreen document at ${path} already exists.`);\n        return;\n    }\n    const filename = path.split('/').pop();\n    console.log(`Background: Creating offscreen document using filename: ${filename}...`);\n    await chrome.offscreen.createDocument({\n        url: filename,\n        reasons: reasons,\n        justification: justification,\n    });\n    console.log(`Background: Offscreen document created successfully using ${filename}.`);\n}\n\n// --- Scraping Logic (Unchanged, uses original offscreen doc if needed) ---\nasync function scrapeUrlWithOffscreenIframe(url) {\n    console.log(`[Stage 2] Attempting Offscreen + iframe: ${url}`);\n    const DYNAMIC_SCRIPT_ID_PREFIX = 'offscreen-scrape-';\n    const DYNAMIC_SCRIPT_MESSAGE_TYPE = 'offscreenIframeResult';\n    const IFRAME_LOAD_TIMEOUT = 30000;\n    let dynamicScripterId = null;\n\n    const cleanup = async (scriptIdBase) => {\n        console.log(`[Stage 2 Cleanup] Starting cleanup for script ID base: ${scriptIdBase}`);\n        if (scriptIdBase) {\n             try {\n                 await chrome.scripting.unregisterContentScripts({ ids: [scriptIdBase] });\n                 console.log(`[Stage 2 Cleanup] Unregistered script: ${scriptIdBase}`);\n             } catch (error) {\n                 console.warn(`[Stage 2 Cleanup] Failed to unregister script ${scriptIdBase}:`, error);\n             }\n        }\n        try {\n            await chrome.runtime.sendMessage({ type: 'removeIframe', target: 'offscreen' });\n            console.log('[Stage 2 Cleanup] Sent removeIframe request to offscreen.');\n        } catch (error) {\n            console.warn('[Stage 2 Cleanup] Failed to send removeIframe request: ', error);\n        }\n    };\n\n    try {\n        await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH, ['DOM_PARSER', 'IFRAME_SCRIPTING'], 'Parse HTML content and manage scraping iframes');\n        console.log('[Stage 2] Sending createIframe request to offscreen...');\n        const createResponse = await chrome.runtime.sendMessage({\n            type: 'createIframe',\n            target: 'offscreen',\n            url: url\n        });\n        if (!createResponse?.success) {\n            throw new Error(`Failed to create iframe in offscreen: ${createResponse?.error || 'Unknown error'}`);\n        }\n        console.log('[Stage 2] Iframe creation request successful. Waiting for load and script...');\n        dynamicScripterId = `${DYNAMIC_SCRIPT_ID_PREFIX}${Date.now()}`;\n        await chrome.scripting.registerContentScripts([{\n            id: dynamicScripterId,\n            js: ['PageExtractor.js', 'stage2-helper.js'],\n            matches: [url],\n            runAt: 'document_idle',\n            world: 'ISOLATED',\n            allFrames: true,\n            persistAcrossSessions: false\n        }]);\n        console.log(`[Stage 2] Registered dynamic script(s): ${dynamicScripterId} (files: PageExtractor.js, stage2-helper.js)`);\n        let messageListener = null;\n        const scriptResponsePromise = new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                console.warn(`[Stage 2] Timeout (${IFRAME_LOAD_TIMEOUT / 1000}s) waiting for response from dynamic script.`);\n                if (messageListener) {\n                    chrome.runtime.onMessage.removeListener(messageListener);\n                }\n                reject(new Error('Timeout waiting for dynamic script response.'));\n            }, IFRAME_LOAD_TIMEOUT);\n\n            messageListener = (message, sender, sendResponse) => {\n                if (message?.type === DYNAMIC_SCRIPT_MESSAGE_TYPE) {\n                    console.log('[Stage 2] Received response from dynamic script:', message.payload);\n                    clearTimeout(timeoutId);\n                    chrome.runtime.onMessage.removeListener(messageListener);\n                    if (message.payload?.success) {\n                        resolve(message.payload);\n                    } else {\n                        reject(new Error(message.payload?.error || 'Dynamic script reported failure.'));\n                    }\n                    return false;\n                }\n                return false;\n            };\n            chrome.runtime.onMessage.addListener(messageListener);\n            console.log('[Stage 2] Listener added for dynamic script response.');\n        });\n        const resultPayload = await scriptResponsePromise;\n        await cleanup(dynamicScripterId);\n        return resultPayload;\n    } catch (error) {\n        console.error(`[Stage 2] Error during Offscreen + iframe process:`, error);\n        await cleanup(dynamicScripterId);\n        throw new Error(`Stage 2 (Offscreen + iframe) failed: ${error.message}`);\n    }\n}\n\nasync function scrapeUrlWithTempTabExecuteScript(url) {\n    console.log(`[Stage 3] Attempting Temp Tab + executeScript (using window.scraper.extract): ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            console.warn(`[Stage 3] Cleanup: ${errorMsg}`);\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 3] Error removing tab ${tempTabId}: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n            const tab = await chrome.tabs.create({ url: url, active: false });\n            tempTabId = tab.id;\n            if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n            console.log(`[Stage 3] Created temp tab ${tempTabId} for executeScript.`);\n        } catch (error) {\n            return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    console.log(`[Stage 3] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    chrome.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            chrome.tabs.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                chrome.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error(`Timeout (${TEMP_TAB_LOAD_TIMEOUT / 1000}s) waiting for page load.`));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch (error) {\n            return cleanupAndReject(`Load failed or timed out: ${error.message}`);\n        }\n        console.log(`[Stage 3] Injecting PageExtractor.js and calling window.scraper.extract() in tab ${tempTabId}`);\n        try {\n            await chrome.scripting.executeScript({\n                target: { tabId: tempTabId },\n                files: ['PageExtractor.js']\n            });\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tempTabId },\n                func: () => window.scraper.extract(),\n            });\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 3] Error removing tab ${tempTabId} post-execute: ${err.message}`));\n                tempTabId = null;\n            }\n            if (results && results.length > 0 && results[0].result) {\n                const scriptResult = results[0].result;\n                if (scriptResult && typeof scriptResult === 'object') {\n                    console.log('[Stage 3] window.scraper.extract() succeeded.');\n                    resolve(scriptResult);\n                } else {\n                    reject(new Error(scriptResult?.error || 'window.scraper.extract() failed or returned null.'));\n                }\n            } else {\n                 const lastError = chrome.runtime.lastError ? chrome.runtime.lastError.message : 'No result returned';\n                 reject(new Error(`executeScript failed: ${lastError}`));\n            }\n        } catch (error) {\n            cleanupAndReject(`executeScript call failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlWithTempTab_ContentScript(url) {\n    console.log(`[Stage 4] Attempting Temp Tab + Content Script: ${url}`);\n    let tempTabId = null;\n    const TEMP_TAB_LOAD_TIMEOUT = 30000;\n\n    return new Promise(async (resolve, reject) => {\n        const cleanupAndReject = (errorMsg) => {\n            if (tempTabId) {\n                chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 4] Error removing tab ${tempTabId} during cleanup: ${err.message}`));\n                tempTabId = null;\n            }\n            reject(new Error(errorMsg));\n        };\n        try {\n             const tab = await chrome.tabs.create({ url: url, active: false });\n             tempTabId = tab.id;\n             if (!tempTabId) throw new Error('Failed to get temporary tab ID.');\n             console.log(`[Stage 4] Created temp tab ${tempTabId}`);\n        } catch(error) {\n             return reject(new Error(`Failed to create temp tab: ${error.message}`));\n        }\n        let loadTimeoutId = null;\n        const loadPromise = new Promise((resolveLoad, rejectLoad) => {\n            const listener = (tabId, changeInfo, updatedTab) => {\n                if (tabId === tempTabId && changeInfo.status === 'complete') {\n                    console.log(`[Stage 4] Tab ${tempTabId} loaded.`);\n                    if (loadTimeoutId) clearTimeout(loadTimeoutId);\n                    chrome.tabs.onUpdated.removeListener(listener);\n                    resolveLoad();\n                }\n            };\n            chrome.tabs.onUpdated.addListener(listener);\n            loadTimeoutId = setTimeout(() => {\n                chrome.tabs.onUpdated.removeListener(listener);\n                rejectLoad(new Error('Timeout waiting for page load.'));\n            }, TEMP_TAB_LOAD_TIMEOUT);\n        });\n        try {\n            await loadPromise;\n        } catch(error) {\n            return cleanupAndReject(error.message);\n        }\n        console.log(`[Stage 4] Sending SCRAPE_PAGE to content script in tab ${tempTabId}`);\n        try {\n            const response = await chrome.tabs.sendMessage(tempTabId, { type: 'SCRAPE_PAGE' });\n            if (tempTabId) chrome.tabs.remove(tempTabId).catch(err => console.warn(`[Stage 4] Error removing tab ${tempTabId} post-message: ${err.message}`));\n            tempTabId = null;\n            if (response?.success) {\n                console.log(`[Stage 4] Success from content script.`);\n                resolve(response);\n            } else {\n                reject(new Error(response?.error || 'Content script failed or gave invalid response.'));\n            }\n        } catch (error) {\n             cleanupAndReject(`Messaging content script failed: ${error.message}`);\n        }\n    });\n}\n\nasync function scrapeUrlMultiStage(url, chatId, messageId) {\n    console.log(`Scraping Orchestrator: Starting for ${url}. ChatID: ${chatId}, MessageID: ${messageId}`);\n    const sendStageResult = (stageResult) => {\n        console.log(`[Orchestrator] Sending STAGE_SCRAPE_RESULT for Stage ${stageResult.stage}, ChatID: ${chatId}, Success: ${stageResult.success}`);\n        chrome.runtime.sendMessage({\n            type: 'STAGE_SCRAPE_RESULT',\n            payload: stageResult\n        }).catch(e => console.warn(`[Orchestrator] Failed to send result for Stage ${stageResult.stage}:`, e));\n    };\n\n    // --- Outer try block to ensure finally always runs --- \n    try { \n        try {\n            const iframeResult = await scrapeUrlWithOffscreenIframe(url);\n            console.log(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Succeeded for ${url}.`);\n            const stage2SuccessPayload = {\n                stage: 2, success: true, chatId: chatId, messageId: messageId,\n                method: 'offscreenIframe', url: url,\n                length: iframeResult?.text?.length || 0,\n                ...iframeResult\n            };\n            sendStageResult(stage2SuccessPayload);\n            return; // <<< Return early on success\n        } catch (stage2Error) {\n            console.warn(`[Orchestrator Log] Stage 2 (Offscreen + iframe) Failed for ${url}: ${stage2Error.message}`);\n            sendStageResult({ stage: 2, success: false, chatId: chatId, messageId: messageId, error: stage2Error.message });\n        }\n\n        // --- If Stage 2 failed, try Stage 3 --- \n        try {\n             const executeScriptResult = await scrapeUrlWithTempTabExecuteScript(url);\n             console.log(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Succeeded for ${url}.`);\n             const stage3SuccessPayload = {\n                stage: 3, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabExecuteScript', url: url,\n                length: executeScriptResult?.text?.length || 0,\n                ...executeScriptResult\n             };\n             sendStageResult(stage3SuccessPayload);\n             return; // <<< Return early on success\n        } catch (stage3Error) {\n             console.warn(`[Orchestrator Log] Stage 3 (Temp Tab + executeScript) Failed for ${url}: ${stage3Error.message}`);\n             sendStageResult({ stage: 3, success: false, chatId: chatId, messageId: messageId, error: stage3Error.message });\n        }\n\n        // --- If Stage 3 failed, try Stage 4 --- \n        try {\n            const tempTabResult = await scrapeUrlWithTempTab_ContentScript(url);\n            console.log(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Succeeded for ${url}.`);\n            const stage4SuccessPayload = {\n                stage: 4, success: true, chatId: chatId, messageId: messageId,\n                method: 'tempTabContentScript', url: url,\n                length: tempTabResult?.text?.length || 0,\n                ...tempTabResult\n            };\n            console.log(\"[Orchestrator Log] Stage 4 Payload being sent:\", stage4SuccessPayload);\n            sendStageResult(stage4SuccessPayload);\n            return; // <<< Return early on success\n        } catch (stage4Error) {\n             console.warn(`[Orchestrator Log] Stage 4 (Temp Tab + Content Script) Failed for ${url}: ${stage4Error.message}`);\n             sendStageResult({ stage: 4, success: false, chatId: chatId, messageId: messageId, error: stage4Error.message });\n        }\n\n        // --- If we reach here, all stages failed --- \n        console.log(\"[Orchestrator Log] All stages failed.\");\n\n    // --- ADDED Finally block for cleanup --- \n    } finally { \n        console.log(\"[Orchestrator Cleanup] Attempting to close offscreen document after multi-stage scrape.\");\n        try {\n            if (await hasOffscreenDocument(OFFSCREEN_DOCUMENT_PATH)) {\n                await chrome.offscreen.closeDocument();\n                console.log(\"[Orchestrator Cleanup] Offscreen document closed successfully.\");\n            } else {\n                 console.log(\"[Orchestrator Cleanup] No offscreen document found to close.\");\n            }\n        } catch (error) {\n            console.warn(\"[Orchestrator Cleanup] Error closing offscreen document:\", error);\n        }\n    }\n    // --- END Finally block ---\n}\n\n// --- Lifecycle Listeners ---\nchrome.runtime.onInstalled.addListener((details) => {\n    console.log(\"Extension installed or updated:\", details.reason);\n    // Setup side panel\n    chrome.sidePanel\n        .setPanelBehavior({ openPanelOnActionClick: true })\n        .catch((error) => console.error('Error setting side panel behavior:', error));\n    console.log(\"Tab Agent background: Side panel behavior set (default open on click).\");\n    // Cleanup old storage\n    chrome.storage.local.get(null, (items) => {\n        const keysToRemove = Object.keys(items).filter(key => key.startsWith('detachedState_'));\n        if (keysToRemove.length > 0) {\n            chrome.storage.local.remove(keysToRemove, () => {\n                console.log(\"Cleaned up old detached states on install/update.\");\n            });\n        }\n    });\n\n    // Trigger initial worker SCRIPT readiness check (don't wait for model)\n    ensureWorkerScriptIsReady().catch(err => {\n        console.error(\"Initial worker script readiness check failed:\", err);\n    });\n});\n\nchrome.runtime.onStartup.addListener(() => {\n    console.log(\"Extension startup.\");\n    // Check worker script readiness on startup\n    if (modelWorkerState === 'uninitialized') {\n         ensureWorkerScriptIsReady().catch(err => {\n             console.error(\"Initial worker script readiness check failed on startup:\", err);\n         });\n    }\n});\n\n// --- Action/Window Listeners (Unchanged) ---\nchrome.action.onClicked.addListener(async (tab) => {\n    if (!tab.id) {\n        console.error(\"Action Clicked: Missing tab ID.\");\n        return;\n    }\n    const tabId = tab.id;\n    console.log(`Action clicked for tab ${tabId}`);\n    const existingPopupId = detachedPopups[tabId];\n    if (existingPopupId) {\n        console.log(`Popup ${existingPopupId} exists for tab ${tabId}. Attempting to close popup.`);\n        try {\n            await chrome.windows.remove(existingPopupId);\n            console.log(`Closed popup window ${existingPopupId} via action click.`);\n        } catch (error) {\n            console.warn(`Failed to close popup ${existingPopupId} via action click, maybe already closed?`, error);\n            if (popupIdToTabId[existingPopupId]) {\n                 console.log(`Force cleaning maps and storage for tab ${tabId} after failed close.`);\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[existingPopupId];\n                try {\n                     await chrome.storage.local.remove(`detachedState_${tabId}`);\n                     await chrome.sidePanel.setOptions({ tabId: tabId, enabled: true });\n                } catch (cleanupError) {\n                     console.error(\"Error during defensive cleanup:\", cleanupError);\n                }\n            }\n        }\n    } else {\n        console.log(`No popup exists for tab ${tabId}. Default side panel opening behavior should trigger.`);\n    }\n});\n\nchrome.windows.onRemoved.addListener(async (windowId) => {\n    console.log(`Window removed: ${windowId}`);\n    const tabId = popupIdToTabId[windowId];\n    if (tabId) {\n        console.log(`Popup window ${windowId} for tab ${tabId} was closed.`);\n        delete detachedPopups[tabId];\n        delete popupIdToTabId[windowId];\n        try {\n            await chrome.storage.local.remove(`detachedState_${tabId}`);\n            console.log(`Removed detached state from storage for tab ${tabId}`);\n            await chrome.sidePanel.setOptions({ tabId: tabId, enabled: true });\n            console.log(`Re-enabled side panel for tab ${tabId} after popup closed.`);\n        } catch (error) {\n             console.error(`Error cleaning up storage or re-enabling side panel for tab ${tabId} on popup close:`, error);\n        }\n    } else {\n         console.log(`Window ${windowId} closed, but it wasn't a tracked popup.`);\n    }\n});\n\n// Variable to track progress logging\nlet lastLoggedProgress = -10; // Initialize to ensure the first 0-10% update gets logged\n\n// --- Main Message Listener ---\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    const { type, payload } = message;\n    let isResponseAsync = false;\n\n    // Debugging: Log all incoming messages\n    // console.log(`[DEBUG Background Listener] Raw message: `, message, ` from: `, sender);\n\n    console.log(`[Background Listener] Received message type '${type}' from`, sender.tab ? `tab ${sender.tab.id}` : sender.url || sender.id);\n\n    // --- Handle Messages FROM Model Worker (via Offscreen) ---\n    // Identify messages likely from our offscreen worker\n    const workerMessageTypes = [\n        'workerScriptReady', // NEW: Worker script loaded, before model download\n        'workerReady',       // OLD name, now means MODEL is loaded\n        'loadingStatus',\n        'generationStatus',\n        'generationUpdate',\n        'generationComplete',\n        'generationError',\n        'resetComplete',\n        'error'\n    ];\n\n    if (workerMessageTypes.includes(type)) {\n        console.log(`[Background Listener] Handling message from worker: ${type}`);\n        switch (type) {\n             case 'workerScriptReady': // Worker script is loaded, ready for 'init'\n                 console.log(\"[Background] Worker SCRIPT is ready!\");\n                 modelWorkerState = 'worker_script_ready';\n                 if (workerScriptReadyResolver) {\n                     workerScriptReadyResolver();\n                     workerScriptReadyPromise = null;\n                 }\n                 // Optional: Notify UI that the worker script is up, but model needs loading\n                 chrome.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'script_ready' } }).catch(()=>{/*ignore*/});\n                break;\n\n            case 'workerReady': // Model finished loading successfully\n                console.log(\"[Background] Worker MODEL is ready! Model:\", payload?.model);\n                modelWorkerState = 'model_ready'; // Final ready state\n                if (modelLoadResolver) {\n                    modelLoadResolver(); // Resolve the promise waiting for model load\n                    modelLoadPromise = null; // Clear promise\n                }\n                 // Notify UI that the model is ready\n                chrome.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'model_ready', model: payload?.model } }).catch(()=>{/*ignore*/});\n                // Ensure script ready promise is also resolved if somehow missed\n                 if (workerScriptReadyResolver) {\n                    workerScriptReadyResolver();\n                    workerScriptReadyPromise = null;\n                 }\n                 break;\n            case 'loadingStatus':\n                // Throttle progress logging\n                if (payload?.status === 'progress' && payload?.progress) {\n                    const currentProgress = Math.floor(payload.progress);\n                    if (currentProgress >= lastLoggedProgress + 10) {\n                        console.log(\"[Background] Worker loading status (progress):\", payload);\n                        lastLoggedProgress = currentProgress;\n                    } // Else: Skip logging frequent progress updates\n                } else {\n                    // Log non-progress statuses or if progress data is missing\n                    console.log(\"[Background] Worker loading status (other):\", payload);\n                    lastLoggedProgress = -10; // Reset for next progress sequence\n                }\n\n                // State should already be 'loading_model' if this message is received\n                if (modelWorkerState !== 'loading_model') {\n                     console.warn(`[Background] Received loadingStatus in unexpected state: ${modelWorkerState}`);\n                     modelWorkerState = 'loading_model'; // Correct the state\n                }\n                // Forward to UI\n                chrome.runtime.sendMessage({ type: 'uiLoadingStatusUpdate', payload: payload }).catch(err => {\n                    if (err.message !== \"Could not establish connection. Receiving end does not exist.\") {\n                         console.warn(\"[Background] Error sending loading status to UI:\", err.message);\n                    }\n                });\n                break;\n             case 'generationStatus':\n                 console.log(`[Background] Generation status: ${payload?.status}`);\n                 if (payload?.status === 'generating') modelWorkerState = 'generating';\n                 else if (payload?.status === 'interrupted') modelWorkerState = 'model_ready'; // Ready for next command\n                 // Forward to UI\n                 // forwardToSidePanel(payload.correlationId, { type: 'generationStatus', payload });\n                 break;\n            case 'generationUpdate':\n                 // console.log(\"[Background] Generation update chunk received.\"); // Too noisy\n                 if (modelWorkerState !== 'generating') {\n                      console.warn(`[Background] Received generationUpdate in unexpected state: ${modelWorkerState}`);\n                 }\n                 modelWorkerState = 'generating'; // Ensure state is correct\n                 // Forward chunk to specific chat in UI\n                 // forwardToSidePanel(payload.correlationId, { type: 'generationUpdate', payload });\n                 break;\n            case 'generationComplete':\n                 console.log(\"[Background] Generation complete.\");\n                 modelWorkerState = 'model_ready'; // Back to ready state\n                 // Forward final result to UI\n                 // forwardToSidePanel(payload.correlationId, { type: 'generationComplete', payload });\n                 break;\n            case 'generationError':\n                 console.error(\"[Background] Generation error from worker:\", payload);\n                 modelWorkerState = 'error'; // Generation failed, go to error state\n                 // Forward error to UI\n                 // forwardToSidePanel(payload.correlationId, { type: 'generationError', payload });\n                 break;\n             case 'resetComplete':\n                 console.log(\"[Background] Worker reset complete.\");\n                 // Reset should bring it back to a known good state\n                 // If model was loaded, it should still be loaded unless reset clears it. Assume ready.\n                 modelWorkerState = 'model_ready'; // Or 'worker_script_ready' if reset clears model? Assume 'model_ready'.\n                 // Notify UI?\n                 break;\n             case 'error': // Generic error from worker/offscreen\n                 console.error(\"[Background] Received generic error from worker/offscreen:\", payload);\n                 const previousState = modelWorkerState;\n                 modelWorkerState = 'error'; // Go to error state\n                 // Reject any pending promises based on when the error occurred\n                 if (previousState === 'creating_worker' && workerScriptReadyRejecter) {\n                     workerScriptReadyRejecter(new Error(payload || 'Generic error during script init'));\n                     workerScriptReadyPromise = null;\n                 } else if (previousState === 'loading_model' && modelLoadRejecter) {\n                      modelLoadRejecter(new Error(payload || 'Generic error during model load'));\n                      modelLoadPromise = null;\n                 }\n                 // Notify UI\n                 chrome.runtime.sendMessage({ type: 'uiUpdate', payload: { modelStatus: 'error', error: payload } }).catch(()=>{/*ignore*/});\n                 break;\n        }\n        // Ensure ALL messages identified as from the worker get forwarded\n        forwardMessageToSidePanelOrPopup(message, sender);\n        return false; // These are informational, background doesn't directly respond to worker\n    }\n\n    // --- Handle Messages FROM Side Panel / UI ---\n\n    // NEW: Handle 'loadModel' request from UI\n    if (type === 'loadModel') {\n        console.log(`[Background Listener] Received 'loadModel' request from sender:`, sender);\n        const modelId = payload?.modelId;\n        console.log(`[Background] Received 'loadModel' request from UI for model: ${modelId}.`);\n        if (!modelId) {\n            console.error(\"[Background] 'loadModel' request missing modelId.\");\n            sendResponse({ success: false, error: \"Model ID not provided in request.\" });\n            return false; // Synchronous response\n        }\n\n        isResponseAsync = true; // Will respond after attempting load\n        loadModel(modelId) // Pass the modelId here\n           .then(() => {\n                console.log(`[Background] loadModel(${modelId}) promise resolved successfully.`);\n                sendResponse({ success: true, message: `Model loading initiated or already complete for ${modelId}.` });\n                    })\n                    .catch(error => {\n                console.error(`[Background] loadModel(${modelId}) failed:`, error);\n                        sendResponse({ success: false, error: error.message });\n                    });\n        return isResponseAsync;\n    }\n\n    // Example: Assuming side panel sends a message like { type: 'sendChatMessage', payload: { chatId: '...', messages: [...], options: {...} } }\n    if (type === 'sendChatMessage') { // Replace with your actual message type from UI\n        isResponseAsync = true;\n        const { chatId, messages, options, messageId } = payload;\n        const correlationId = messageId || chatId;\n\n        // Ensure MODEL is ready before generating\n        // **Important**: We need to know which model the UI *thinks* is loaded.\n        // For now, assume the last requested model via loadModel() is the target.\n        // A more robust solution might pass the expected modelId with the chat message.\n        if (modelWorkerState !== 'model_ready') {\n             console.error(`[Background] Cannot send chat message. Model state is ${modelWorkerState}, not 'model_ready'.`);\n              sendResponse({ success: false, error: `Model not ready (state: ${modelWorkerState}). Please load a model first.` });\n              return false; // Synchronous response\n        }\n\n        // Proceed only if model is ready\n        console.log(`[Background] Model ready, sending generate request for ${correlationId}`);\n        sendToModelWorkerOffscreen({\n            type: 'generate',\n            payload: {\n                messages: messages,\n                max_new_tokens: options?.max_new_tokens,\n                temperature: options?.temperature,\n                top_k: options?.top_k,\n                correlationId: correlationId\n            }\n        })\n        .then(sendResult => {\n            if (!sendResult.success) throw new Error(\"Failed to send generate message initially.\");\n            console.log(`[Background] Generate request sent for ${correlationId}. Waiting for worker responses.`);\n            sendResponse({ success: true, message: \"Generation request forwarded to worker.\"});\n        })\n        .catch(error => {\n            console.error(`[Background] Error processing sendChatMessage for ${correlationId}:`, error);\n            if (modelWorkerState === 'generating') modelWorkerState = 'model_ready';\n            sendResponse({ success: false, error: error.message });\n        });\n\n        return isResponseAsync;\n    }\n\n    // Example: Handle interrupt request from UI\n    if (type === 'interruptGeneration') { // Replace with your actual message type\n         console.log(\"[Background] Received interrupt request from UI.\");\n         // Should only require script to be ready, not necessarily the model (can interrupt loading? No, only generation)\n         ensureWorkerScriptIsReady() // Check if worker script is running\n            .then(() => sendToModelWorkerOffscreen({ type: 'interrupt' }))\n                    .then(() => sendResponse({ success: true }))\n                    .catch(err => sendResponse({ success: false, error: err.message }));\n         isResponseAsync = true;\n         return isResponseAsync;\n    }\n\n    // Example: Handle reset request from UI\n     if (type === 'resetWorker') { // Replace with your actual message type\n         console.log(\"[Background] Received reset request from UI.\");\n          ensureWorkerScriptIsReady() // Check if worker script is running\n             .then(() => sendToModelWorkerOffscreen({ type: 'reset' }))\n                    .then(() => sendResponse({ success: true }))\n                    .catch(err => sendResponse({ success: false, error: err.message }));\n         isResponseAsync = true;\n         return isResponseAsync;\n     }\n\n    // --- Handle other message types (e.g., scraping, detach, etc.) ---\n    // ... (existing logic) ...\n\n    // If we haven't handled the message and aren't responding asynchronously, log it.\n    if (!isResponseAsync) {\n         console.warn(`[Background Listener] Unhandled message type: ${type}`);\n    }\n    return isResponseAsync; // Return true if any handler uses sendResponse asynchronously\n});\n\n// --- Google Drive Functions (Unchanged) ---\nasync function getDriveToken() {\n    return new Promise((resolve, reject) => {\n        chrome.identity.getAuthToken({ interactive: true }, (token) => {\n            if (chrome.runtime.lastError) {\n                reject(new Error(chrome.runtime.lastError.message));\n            } else {\n                resolve(token);\n            }\n        });\n    });\n}\n\nasync function fetchDriveFileList(token, folderId = 'root') {\n    const fields = \"files(id, name, mimeType, iconLink, webViewLink, size, createdTime, modifiedTime)\";\n    const query = `'${folderId}' in parents and trashed=false`;\n    const pageSize = 100;\n    const orderBy = 'folder,modifiedTime desc';\n    const url = `https://www.googleapis.com/drive/v3/files?${new URLSearchParams({\n        pageSize: pageSize.toString(),\n        q: query,\n        fields: fields,\n        orderBy: orderBy\n    })}`;\n    console.log(`Background: Fetching Drive list for folder '${folderId}': ${url}`);\n    const response = await fetch(url, {\n        headers: {\n            'Authorization': `Bearer ${token}`,\n            'Accept': 'application/json'\n        }\n    });\n    if (!response.ok) {\n        const errorData = await response.text();\n        console.error(`Background: Drive API files.list error (Folder: ${folderId}):`, response.status, errorData);\n        if (response.status === 404) {\n            throw new Error(`Folder with ID '${folderId}' not found or access denied.`);\n        }\n        throw new Error(`Drive API Error ${response.status} (Folder: ${folderId}): ${errorData || response.statusText}`);\n    }\n    const data = await response.json();\n    console.log(`Background: Drive API files.list success (Folder: ${folderId}). Found ${data.files?.length || 0} items.`);\n    return data.files || [];\n}\n\nasync function fetchDriveFileContent(token, fileId) {\n    console.warn(`Background: fetchDriveFileContent not implemented yet for fileId: ${fileId}`);\n    return `(Content fetch not implemented for ${fileId})`;\n}\n\n// --- Detach/Reattach Functions (Unchanged) ---\nasync function handleDetach(tabId) { /* ... existing code ... */ }\nasync function handleReattach(windowId) { /* ... existing code ... */ }\n\n// Helper to forward worker messages (like progress) to the correct UI context\nasync function forwardMessageToSidePanelOrPopup(message, originalSender) { // Renamed sender param to avoid conflict\n    console.log(`[Forwarder] Attempting to forward message type '${message?.type}' from worker.`);\n    // Forward to any detached popups associated with the original tab if applicable\n    // Note: The 'sender' here is the offscreen worker, which doesn't have a tab ID.\n    // We need a way to know which UI instance initiated the load if multiple are open.\n    // For now, broadcasting to all potential UIs (side panels/popups).\n\n    // Option 1: Broadcast to all detached popups\n    for (const tabId in detachedPopups) {\n        const popupId = detachedPopups[tabId];\n        console.log(`[Forwarder] Forwarding message to detached popup ID: ${popupId} (original tab: ${tabId})`); // Added log\n        try {\n            await chrome.windows.get(popupId); // Check if window still exists\n            // Attempt to send directly to the popup context ID if possible\n            // If not, sending to the popup window might work if it has a listener\n            // chrome.runtime.sendMessage({ targetPopupId: popupId, ...message }); // Need a specific handler\n            // Let's stick to a general broadcast for now if direct context messaging fails\n            chrome.runtime.sendMessage(message); // Send generally, hoping popup listener catches it\n\n        } catch (error) {\n            console.warn(`[Forwarder] Error sending to detached popup ID ${popupId}:`, error.message);\n            if (error.message.includes(\"No window with id\")) {\n                // Clean up stale entry\n                delete detachedPopups[tabId];\n                delete popupIdToTabId[popupId];\n            }\n        }\n    }\n\n    // Option 2: Try sending to the side panel of the tab that *might* have originated the request\n    // This is less reliable if the message doesn't contain original context info.\n    // Let's find *all* active side panels/tabs and send to them? Might be overkill.\n    // For now, let's try sending to *all* tabs where the extension might be active.\n    // This is broad, but necessary if we don't track the originator precisely.\n    const tabs = await chrome.tabs.query({ status: 'complete' }); // Query only complete tabs\n    for (const tab of tabs) {\n        if (detachedPopups[tab.id]) continue; // Skip tabs with detached popups already handled\n        try {\n            // Check if side panel is enabled/open for this tab? chrome.sidePanel API needed.\n            // For now, just try sending. Errors will be caught.\n            await chrome.tabs.sendMessage(tab.id, message);\n        } catch (error) {\n            // Ignore errors like \"Could not establish connection...\" if the side panel isn't open\n            if (!error.message.includes('Could not establish connection') && !error.message.includes('Receiving end does not exist')) {\n                console.warn(`[Forwarder] Error forwarding message to tab ${tab.id}:`, error.message);\n            }\n        }\n    }\n}\n\nconsole.log(\"[Background-Simple] Script loaded and listening.\");"],"names":["MODEL_WORKER_OFFSCREEN_PATH","detachedPopups","popupIdToTabId","modelWorkerState","workerScriptReadyPromise","workerScriptReadyResolver","workerScriptReadyRejecter","modelLoadPromise","modelLoadResolver","modelLoadRejecter","hasModelWorkerOffscreenDocument","targetUrl","setupModelWorkerOffscreenDocument","sendToModelWorkerOffscreen","message","ensureWorkerScriptIsReady","error","resolve","reject","err","scriptLoadTimeout","loadModel","modelId","errorMsg","modelLoadTimeout","updateDeclarativeNetRequestRules","currentRuleIds","rule","rulesToAdd","rulesToRemove","id","details","items","keysToRemove","key","tab","tabId","existingPopupId","cleanupError","windowId","lastLoggedProgress","sender","sendResponse","type","payload","isResponseAsync","currentProgress","previousState","forwardMessageToSidePanelOrPopup","chatId","messages","options","messageId","correlationId","sendResult","originalSender","popupId","tabs"],"mappings":"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"}